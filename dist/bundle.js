(()=>{var __webpack_modules__={9179:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.AddNode = AddNode;\nvar _litegraph = __webpack_require__(8463);\n//your node constructor class\nfunction AddNode() {\n  //add some input slots\n  this.addInput("A", "number");\n  this.addInput("B", "number");\n  //add some output slots\n  this.addOutput("A+B", "number");\n  //add some properties\n  this.properties = {\n    precision: 1\n  };\n}\n\n//name to show on the canvas\nAddNode.title = "Sum";\n\n//function to call when the node is executed\nAddNode.prototype.onExecute = function () {\n  //retrieve data from inputs\n  var A = this.getInputData(0);\n  if (A === undefined) A = 0;\n  var B = this.getInputData(1);\n  if (B === undefined) B = 0;\n  //assing data to outputs\n  this.setOutputData(0, A + B);\n};\n\n//register in the system\n_litegraph.LiteGraph.registerNodeType("basic/sum", AddNode);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTE3OS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxJQUFBQSxVQUFBLEdBQUFDLG1CQUFBO0FBRUE7QUFDTyxTQUFTQyxPQUFPQSxDQUFBLEVBQ3ZCO0VBQ0U7RUFDQSxJQUFJLENBQUNDLFFBQVEsQ0FBQyxHQUFHLEVBQUMsUUFBUSxDQUFDO0VBQzNCLElBQUksQ0FBQ0EsUUFBUSxDQUFDLEdBQUcsRUFBQyxRQUFRLENBQUM7RUFDM0I7RUFDQSxJQUFJLENBQUNDLFNBQVMsQ0FBQyxLQUFLLEVBQUMsUUFBUSxDQUFDO0VBQzlCO0VBQ0EsSUFBSSxDQUFDQyxVQUFVLEdBQUc7SUFBRUMsU0FBUyxFQUFFO0VBQUUsQ0FBQztBQUNwQzs7QUFFQTtBQUNBSixPQUFPLENBQUNLLEtBQUssR0FBRyxLQUFLOztBQUVyQjtBQUNBTCxPQUFPLENBQUNNLFNBQVMsQ0FBQ0MsU0FBUyxHQUFHLFlBQzlCO0VBQ0U7RUFDQSxJQUFJQyxDQUFDLEdBQUcsSUFBSSxDQUFDQyxZQUFZLENBQUMsQ0FBQyxDQUFDO0VBQzVCLElBQUlELENBQUMsS0FBS0UsU0FBUyxFQUNqQkYsQ0FBQyxHQUFHLENBQUM7RUFDUCxJQUFJRyxDQUFDLEdBQUcsSUFBSSxDQUFDRixZQUFZLENBQUMsQ0FBQyxDQUFDO0VBQzVCLElBQUlFLENBQUMsS0FBS0QsU0FBUyxFQUNqQkMsQ0FBQyxHQUFHLENBQUM7RUFDUDtFQUNBLElBQUksQ0FBQ0MsYUFBYSxDQUFFLENBQUMsRUFBRUosQ0FBQyxHQUFHRyxDQUFFLENBQUM7QUFDaEMsQ0FBQzs7QUFFRDtBQUNBRSxvQkFBUyxDQUFDQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUVkLE9BQU8sQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9zcmMvY3VzdG9tL25vZGVzL2FkZE5vZGUuanM/NGU1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMaXRlR3JhcGggfSBmcm9tIFwibGl0ZWdyYXBoLmpzXCI7XG5cbi8veW91ciBub2RlIGNvbnN0cnVjdG9yIGNsYXNzXG5leHBvcnQgZnVuY3Rpb24gQWRkTm9kZSgpXG57XG4gIC8vYWRkIHNvbWUgaW5wdXQgc2xvdHNcbiAgdGhpcy5hZGRJbnB1dChcIkFcIixcIm51bWJlclwiKTtcbiAgdGhpcy5hZGRJbnB1dChcIkJcIixcIm51bWJlclwiKTtcbiAgLy9hZGQgc29tZSBvdXRwdXQgc2xvdHNcbiAgdGhpcy5hZGRPdXRwdXQoXCJBK0JcIixcIm51bWJlclwiKTtcbiAgLy9hZGQgc29tZSBwcm9wZXJ0aWVzXG4gIHRoaXMucHJvcGVydGllcyA9IHsgcHJlY2lzaW9uOiAxIH07XG59XG5cbi8vbmFtZSB0byBzaG93IG9uIHRoZSBjYW52YXNcbkFkZE5vZGUudGl0bGUgPSBcIlN1bVwiO1xuXG4vL2Z1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgbm9kZSBpcyBleGVjdXRlZFxuQWRkTm9kZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKVxue1xuICAvL3JldHJpZXZlIGRhdGEgZnJvbSBpbnB1dHNcbiAgdmFyIEEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgaWYoIEEgPT09IHVuZGVmaW5lZCApXG4gICAgQSA9IDA7XG4gIHZhciBCID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG4gIGlmKCBCID09PSB1bmRlZmluZWQgKVxuICAgIEIgPSAwO1xuICAvL2Fzc2luZyBkYXRhIHRvIG91dHB1dHNcbiAgdGhpcy5zZXRPdXRwdXREYXRhKCAwLCBBICsgQiApO1xufVxuXG4vL3JlZ2lzdGVyIGluIHRoZSBzeXN0ZW1cbkxpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvc3VtXCIsIEFkZE5vZGUpOyJdLCJuYW1lcyI6WyJfbGl0ZWdyYXBoIiwicmVxdWlyZSIsIkFkZE5vZGUiLCJhZGRJbnB1dCIsImFkZE91dHB1dCIsInByb3BlcnRpZXMiLCJwcmVjaXNpb24iLCJ0aXRsZSIsInByb3RvdHlwZSIsIm9uRXhlY3V0ZSIsIkEiLCJnZXRJbnB1dERhdGEiLCJ1bmRlZmluZWQiLCJCIiwic2V0T3V0cHV0RGF0YSIsIkxpdGVHcmFwaCIsInJlZ2lzdGVyTm9kZVR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9179\n')},2980:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('var __webpack_unused_export__;\n\n\nfunction _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }\n__webpack_unused_export__ = ({\n  value: true\n});\n__webpack_unused_export__ = void 0;\nvar LG = _interopRequireWildcard(__webpack_require__(8463));\nvar _addNode = __webpack_require__(9179);\nfunction _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }\nif (window) {\n  window.LiteGraph = LG.LiteGraph;\n  window.LGraph = LG.LGraph;\n  window.LLink = LG.LLink;\n  window.LGraphNode = LG.LGraphNode;\n  window.LGraphGroup = LG.LGraphGroup;\n  window.DragAndScale = LG.DragAndScale;\n  window.LGraphCanvas = LG.LGraphCanvas;\n  window.ContextMenu = LG.ContextMenu;\n}\nvar _default = __webpack_unused_export__ = LG; // (function(global){\n//   console.log(\'.lllll\', global, LG)\n//   global.LiteGraph = LG.LiteGraph;\n//   global.LGraph = LG.LGraph;\n//   global.LLink = LG.LLink;\n//   global.LGraphNode = LG.LGraphNode;\n//   global.LGraphGroup = LG.LGraphGroup;\n//   global.DragAndScale = LG.DragAndScale;\n//   global.LGraphCanvas = LG.LGraphCanvas;\n//   global.ContextMenu = LG.ContextMenu;\n// })(this)\n// if (typeof exports != "undefined") {\n//   exports.LiteGraph = this.LiteGraph;\n//   exports.LGraph = this.LGraph;\n//   exports.LLink = this.LLink;\n//   exports.LGraphNode = this.LGraphNode;\n//   exports.LGraphGroup = this.LGraphGroup;\n//   exports.DragAndScale = this.DragAndScale;\n//   exports.LGraphCanvas = this.LGraphCanvas;\n//   exports.ContextMenu = this.ContextMenu;\n// }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk4MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLElBQUFBLEVBQUEsR0FBQUMsdUJBQUEsQ0FBQUMsbUJBQUE7QUFDQSxJQUFBQyxRQUFBLEdBQUFELG1CQUFBO0FBQWdELFNBQUFFLHlCQUFBQyxDQUFBLDZCQUFBQyxPQUFBLG1CQUFBQyxDQUFBLE9BQUFELE9BQUEsSUFBQUUsQ0FBQSxPQUFBRixPQUFBLFlBQUFGLHdCQUFBLFlBQUFBLHlCQUFBQyxDQUFBLFdBQUFBLENBQUEsR0FBQUcsQ0FBQSxHQUFBRCxDQUFBLEtBQUFGLENBQUE7QUFBQSxTQUFBSix3QkFBQUksQ0FBQSxFQUFBRSxDQUFBLFNBQUFBLENBQUEsSUFBQUYsQ0FBQSxJQUFBQSxDQUFBLENBQUFJLFVBQUEsU0FBQUosQ0FBQSxlQUFBQSxDQUFBLGdCQUFBSyxPQUFBLENBQUFMLENBQUEsMEJBQUFBLENBQUEsc0JBQUFBLENBQUEsUUFBQUcsQ0FBQSxHQUFBSix3QkFBQSxDQUFBRyxDQUFBLE9BQUFDLENBQUEsSUFBQUEsQ0FBQSxDQUFBRyxHQUFBLENBQUFOLENBQUEsVUFBQUcsQ0FBQSxDQUFBSSxHQUFBLENBQUFQLENBQUEsT0FBQVEsQ0FBQSxLQUFBQyxTQUFBLFVBQUFDLENBQUEsR0FBQUMsTUFBQSxDQUFBQyxjQUFBLElBQUFELE1BQUEsQ0FBQUUsd0JBQUEsV0FBQUMsQ0FBQSxJQUFBZCxDQUFBLG9CQUFBYyxDQUFBLE9BQUFDLGNBQUEsQ0FBQUMsSUFBQSxDQUFBaEIsQ0FBQSxFQUFBYyxDQUFBLFNBQUFHLENBQUEsR0FBQVAsQ0FBQSxHQUFBQyxNQUFBLENBQUFFLHdCQUFBLENBQUFiLENBQUEsRUFBQWMsQ0FBQSxVQUFBRyxDQUFBLEtBQUFBLENBQUEsQ0FBQVYsR0FBQSxJQUFBVSxDQUFBLENBQUFDLEdBQUEsSUFBQVAsTUFBQSxDQUFBQyxjQUFBLENBQUFKLENBQUEsRUFBQU0sQ0FBQSxFQUFBRyxDQUFBLElBQUFULENBQUEsQ0FBQU0sQ0FBQSxJQUFBZCxDQUFBLENBQUFjLENBQUEsWUFBQU4sQ0FBQSxjQUFBUixDQUFBLEVBQUFHLENBQUEsSUFBQUEsQ0FBQSxDQUFBZSxHQUFBLENBQUFsQixDQUFBLEVBQUFRLENBQUEsR0FBQUEsQ0FBQTtBQUloRCxJQUFJVyxNQUFNLEVBQUU7RUFDVkEsTUFBTSxDQUFDQyxTQUFTLEdBQUd6QixFQUFFLENBQUN5QixTQUFTO0VBQy9CRCxNQUFNLENBQUNFLE1BQU0sR0FBRzFCLEVBQUUsQ0FBQzBCLE1BQU07RUFDekJGLE1BQU0sQ0FBQ0csS0FBSyxHQUFHM0IsRUFBRSxDQUFDMkIsS0FBSztFQUN2QkgsTUFBTSxDQUFDSSxVQUFVLEdBQUc1QixFQUFFLENBQUM0QixVQUFVO0VBQ2pDSixNQUFNLENBQUNLLFdBQVcsR0FBRzdCLEVBQUUsQ0FBQzZCLFdBQVc7RUFDbkNMLE1BQU0sQ0FBQ00sWUFBWSxHQUFHOUIsRUFBRSxDQUFDOEIsWUFBWTtFQUNyQ04sTUFBTSxDQUFDTyxZQUFZLEdBQUcvQixFQUFFLENBQUMrQixZQUFZO0VBQ3JDUCxNQUFNLENBQUNRLFdBQVcsR0FBR2hDLEVBQUUsQ0FBQ2dDLFdBQVc7QUFDckM7QUFBQyxJQUFBQyxRQUFBLEdBQUFDLHlCQUFBLEdBQ2NsQyxFQUFFLEVBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBMRyBmcm9tIFwibGl0ZWdyYXBoLmpzXCI7XG5pbXBvcnQgeyBBZGROb2RlIH0gZnJvbSAnLi9jdXN0b20vbm9kZXMvYWRkTm9kZScgXG5cblxuXG5pZiAod2luZG93KSB7XG4gIHdpbmRvdy5MaXRlR3JhcGggPSBMRy5MaXRlR3JhcGg7XG4gIHdpbmRvdy5MR3JhcGggPSBMRy5MR3JhcGg7XG4gIHdpbmRvdy5MTGluayA9IExHLkxMaW5rO1xuICB3aW5kb3cuTEdyYXBoTm9kZSA9IExHLkxHcmFwaE5vZGU7XG4gIHdpbmRvdy5MR3JhcGhHcm91cCA9IExHLkxHcmFwaEdyb3VwO1xuICB3aW5kb3cuRHJhZ0FuZFNjYWxlID0gTEcuRHJhZ0FuZFNjYWxlO1xuICB3aW5kb3cuTEdyYXBoQ2FudmFzID0gTEcuTEdyYXBoQ2FudmFzO1xuICB3aW5kb3cuQ29udGV4dE1lbnUgPSBMRy5Db250ZXh0TWVudTtcbn1cbmV4cG9ydCBkZWZhdWx0IExHXG4vLyAoZnVuY3Rpb24oZ2xvYmFsKXtcbi8vICAgY29uc29sZS5sb2coJy5sbGxsbCcsIGdsb2JhbCwgTEcpXG4vLyAgIGdsb2JhbC5MaXRlR3JhcGggPSBMRy5MaXRlR3JhcGg7XG4vLyAgIGdsb2JhbC5MR3JhcGggPSBMRy5MR3JhcGg7XG4vLyAgIGdsb2JhbC5MTGluayA9IExHLkxMaW5rO1xuLy8gICBnbG9iYWwuTEdyYXBoTm9kZSA9IExHLkxHcmFwaE5vZGU7XG4vLyAgIGdsb2JhbC5MR3JhcGhHcm91cCA9IExHLkxHcmFwaEdyb3VwO1xuLy8gICBnbG9iYWwuRHJhZ0FuZFNjYWxlID0gTEcuRHJhZ0FuZFNjYWxlO1xuLy8gICBnbG9iYWwuTEdyYXBoQ2FudmFzID0gTEcuTEdyYXBoQ2FudmFzO1xuLy8gICBnbG9iYWwuQ29udGV4dE1lbnUgPSBMRy5Db250ZXh0TWVudTtcbi8vIH0pKHRoaXMpXG5cblxuXG4vLyBpZiAodHlwZW9mIGV4cG9ydHMgIT0gXCJ1bmRlZmluZWRcIikge1xuLy8gICBleHBvcnRzLkxpdGVHcmFwaCA9IHRoaXMuTGl0ZUdyYXBoO1xuLy8gICBleHBvcnRzLkxHcmFwaCA9IHRoaXMuTEdyYXBoO1xuLy8gICBleHBvcnRzLkxMaW5rID0gdGhpcy5MTGluaztcbi8vICAgZXhwb3J0cy5MR3JhcGhOb2RlID0gdGhpcy5MR3JhcGhOb2RlO1xuLy8gICBleHBvcnRzLkxHcmFwaEdyb3VwID0gdGhpcy5MR3JhcGhHcm91cDtcbi8vICAgZXhwb3J0cy5EcmFnQW5kU2NhbGUgPSB0aGlzLkRyYWdBbmRTY2FsZTtcbi8vICAgZXhwb3J0cy5MR3JhcGhDYW52YXMgPSB0aGlzLkxHcmFwaENhbnZhcztcbi8vICAgZXhwb3J0cy5Db250ZXh0TWVudSA9IHRoaXMuQ29udGV4dE1lbnU7XG4vLyB9XG5cblxuIl0sIm5hbWVzIjpbIkxHIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX2FkZE5vZGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX19lc01vZHVsZSIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJ3aW5kb3ciLCJMaXRlR3JhcGgiLCJMR3JhcGgiLCJMTGluayIsIkxHcmFwaE5vZGUiLCJMR3JhcGhHcm91cCIsIkRyYWdBbmRTY2FsZSIsIkxHcmFwaENhbnZhcyIsIkNvbnRleHRNZW51IiwiX2RlZmF1bHQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2980\n')},9653:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\n__webpack_require__(6813);\n\n__webpack_require__(5780);\n\n__webpack_require__(8262);\n\nif (__webpack_require__.g._babelPolyfill) {\n  throw new Error("only one instance of babel-polyfill is allowed");\n}\n__webpack_require__.g._babelPolyfill = true;\n\nvar DEFINE_PROPERTY = "defineProperty";\nfunction define(O, key, value) {\n  O[key] || Object[DEFINE_PROPERTY](O, key, {\n    writable: true,\n    configurable: true,\n    value: value\n  });\n}\n\ndefine(String.prototype, "padLeft", "".padStart);\ndefine(String.prototype, "padRight", "".padEnd);\n\n"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {\n  [][key] && define(Array, key, Function.call.bind([][key]));\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY1My5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBTyxDQUFDLElBQWM7O0FBRXRCLG1CQUFPLENBQUMsSUFBNkI7O0FBRXJDLG1CQUFPLENBQUMsSUFBMEI7O0FBRWxDLElBQUkscUJBQU07QUFDVjtBQUNBO0FBQ0EscUJBQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXBvbHlmaWxsL2xpYi9pbmRleC5qcz9kYjRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9zaGltXCIpO1xuXG5yZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlXCIpO1xuXG5pZiAoZ2xvYmFsLl9iYWJlbFBvbHlmaWxsKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIm9ubHkgb25lIGluc3RhbmNlIG9mIGJhYmVsLXBvbHlmaWxsIGlzIGFsbG93ZWRcIik7XG59XG5nbG9iYWwuX2JhYmVsUG9seWZpbGwgPSB0cnVlO1xuXG52YXIgREVGSU5FX1BST1BFUlRZID0gXCJkZWZpbmVQcm9wZXJ0eVwiO1xuZnVuY3Rpb24gZGVmaW5lKE8sIGtleSwgdmFsdWUpIHtcbiAgT1trZXldIHx8IE9iamVjdFtERUZJTkVfUFJPUEVSVFldKE8sIGtleSwge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG59XG5cbmRlZmluZShTdHJpbmcucHJvdG90eXBlLCBcInBhZExlZnRcIiwgXCJcIi5wYWRTdGFydCk7XG5kZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgXCJwYWRSaWdodFwiLCBcIlwiLnBhZEVuZCk7XG5cblwicG9wLHJldmVyc2Usc2hpZnQsa2V5cyx2YWx1ZXMsZW50cmllcyxpbmRleE9mLGV2ZXJ5LHNvbWUsZm9yRWFjaCxtYXAsZmlsdGVyLGZpbmQsZmluZEluZGV4LGluY2x1ZGVzLGpvaW4sc2xpY2UsY29uY2F0LHB1c2gsc3BsaWNlLHVuc2hpZnQsc29ydCxsYXN0SW5kZXhPZixyZWR1Y2UscmVkdWNlUmlnaHQsY29weVdpdGhpbixmaWxsXCIuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBbXVtrZXldICYmIGRlZmluZShBcnJheSwga2V5LCBGdW5jdGlvbi5jYWxsLmJpbmQoW11ba2V5XSkpO1xufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9653\n')},5780:function(module,__unused_webpack_exports,__webpack_require__){eval('/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  "use strict";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === "function" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || "@@iterator";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";\n  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";\n\n  var inModule = "object" === "object";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we\'re in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don\'t bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we\'re in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there\'s no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don\'t have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: "normal", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: "throw", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = "suspendedStart";\n  var GenStateSuspendedYield = "suspendedYield";\n  var GenStateExecuting = "executing";\n  var GenStateCompleted = "completed";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don\'t natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = "GeneratorFunction";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    ["next", "throw", "return"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === "function" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === "GeneratorFunction"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = "GeneratorFunction";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, "__await")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === "throw") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === "object" &&\n            hasOwn.call(value, "__await")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke("next", value, resolve, reject);\n          }, function(err) {\n            invoke("throw", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof global.process === "object" && global.process.domain) {\n      invoke = global.process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error("Generator is already running");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === "throw") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === "next") {\n          // Setting context._sent for legacy support of Babel\'s\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === "throw") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === "return") {\n          context.abrupt("return", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === "normal") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === "throw") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = "throw";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === "throw") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = "return";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === "throw") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // "return" to "throw", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = "throw";\n        context.arg = new TypeError(\n          "The iterator does not provide a \'throw\' method");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === "throw") {\n      context.method = "throw";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = "throw";\n      context.arg = new TypeError("iterator result is not an object");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was "throw" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was "next", forget context.arg since it has been\n      // "consumed" by the delegate iterator. If context.method was\n      // "return", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== "return") {\n        context.method = "next";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = "Generator";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers\' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn\'t happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return "[object Generator]";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = "normal";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: "root" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === "function") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel\'s\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = "next";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === "t" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === "throw") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = "throw";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = "next";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === "root") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle("end");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, "catchLoc");\n          var hasFinally = hasOwn.call(entry, "finallyLoc");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error("try statement without catch or finally");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, "finallyLoc") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === "break" ||\n           type === "continue") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = "next";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === "throw") {\n        throw record.arg;\n      }\n\n      if (record.type === "break" ||\n          record.type === "continue") {\n        this.next = record.arg;\n      } else if (record.type === "return") {\n        this.rval = this.arg = record.arg;\n        this.method = "return";\n        this.next = "end";\n      } else if (record.type === "normal" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    "catch": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === "throw") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error("illegal catch attempt");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === "next") {\n        // Deliberately forget the last sent value so that we don\'t\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof __webpack_require__.g === "object" ? __webpack_require__.g :\n  typeof window === "object" ? window :\n  typeof self === "object" ? self : this\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc4MC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixRQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxQkFBTSxnQkFBZ0IscUJBQU07QUFDckM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9iYWJlbC1wb2x5ZmlsbC9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzP2YzYTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwucHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBnbG9iYWwucHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IGdsb2JhbC5wcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4gIC8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuICAvLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXNcbik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5780\n')},8262:(module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(6289);\nmodule.exports = __webpack_require__(6094).RegExp.escape;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI2Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBTyxDQUFDLElBQWtDO0FBQzFDLHdEQUE2RCIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlLmpzP2ZkNWEiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlJlZ0V4cC5lc2NhcGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8262\n")},3387:module=>{eval("module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM4Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzP2Q4ZTgiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3387\n")},5122:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var cof = __webpack_require__(5089);\nmodule.exports = function (it, msg) {\n  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);\n  return +it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEyMi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLW51bWJlci12YWx1ZS5qcz9iZWY5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnbnVtYmVyJyAmJiBjb2YoaXQpICE9ICdOdW1iZXInKSB0aHJvdyBUeXBlRXJyb3IobXNnKTtcbiAgcmV0dXJuICtpdDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5122\n")},8184:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = __webpack_require__(7574)('unscopables');\nvar ArrayProto = Array.prototype;\nif (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(3341)(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function (key) {\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE4NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLElBQVE7QUFDbEM7QUFDQSwwQ0FBMEMsbUJBQU8sQ0FBQyxJQUFTLDZCQUE2QjtBQUN4RjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzPzljNmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbmlmIChBcnJheVByb3RvW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHJlcXVpcmUoJy4vX2hpZGUnKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8184\n")},8828:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar at = __webpack_require__(1212)(true);\n\n // `AdvanceStringIndex` abstract operation\n// https://tc39.github.io/ecma262/#sec-advancestringindex\nmodule.exports = function (S, index, unicode) {\n  return index + (unicode ? at(S, index).length : 1);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODgyOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFNBQVMsbUJBQU8sQ0FBQyxJQUFjOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkdmFuY2Utc3RyaW5nLWluZGV4LmpzPzAzOTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbiAvLyBgQWR2YW5jZVN0cmluZ0luZGV4YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFkdmFuY2VzdHJpbmdpbmRleFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUywgaW5kZXgsIHVuaWNvZGUpIHtcbiAgcmV0dXJuIGluZGV4ICsgKHVuaWNvZGUgPyBhdChTLCBpbmRleCkubGVuZ3RoIDogMSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8828\n")},6440:module=>{eval("module.exports = function (it, Constructor, name, forbiddenField) {\n  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQ0MC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanM/ZjYwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6440\n")},4228:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isObject = __webpack_require__(3305);\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIyOC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanM/Y2I3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4228\n")},4438:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\n\nvar toObject = __webpack_require__(8270);\nvar toAbsoluteIndex = __webpack_require__(157);\nvar toLength = __webpack_require__(1485);\n\nmodule.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {\n  var O = toObject(this);\n  var len = toLength(O.length);\n  var to = toAbsoluteIndex(target, len);\n  var from = toAbsoluteIndex(start, len);\n  var end = arguments.length > 2 ? arguments[2] : undefined;\n  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);\n  var inc = 1;\n  if (from < to && to < from + count) {\n    inc = -1;\n    from += count - 1;\n    to += count - 1;\n  }\n  while (count-- > 0) {\n    if (from in O) O[to] = O[from];\n    else delete O[to];\n    to += inc;\n    from += inc;\n  } return O;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQzOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhO0FBQ2IsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsR0FBc0I7QUFDcEQsZUFBZSxtQkFBTyxDQUFDLElBQWM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qcz9iYTkyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQgLyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIHRvID0gdG9BYnNvbHV0ZUluZGV4KHRhcmdldCwgbGVuKTtcbiAgdmFyIGZyb20gPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKSkgLSBmcm9tLCBsZW4gLSB0byk7XG4gIHZhciBpbmMgPSAxO1xuICBpZiAoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KSB7XG4gICAgaW5jID0gLTE7XG4gICAgZnJvbSArPSBjb3VudCAtIDE7XG4gICAgdG8gKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byArPSBpbmM7XG4gICAgZnJvbSArPSBpbmM7XG4gIH0gcmV0dXJuIE87XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4438\n")},5564:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\n\nvar toObject = __webpack_require__(8270);\nvar toAbsoluteIndex = __webpack_require__(157);\nvar toLength = __webpack_require__(1485);\nmodule.exports = function fill(value /* , start = 0, end = @length */) {\n  var O = toObject(this);\n  var length = toLength(O.length);\n  var aLen = arguments.length;\n  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);\n  var end = aLen > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);\n  while (endPos > index) O[index++] = value;\n  return O;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTU2NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhO0FBQ2IsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsR0FBc0I7QUFDcEQsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZmlsbC5qcz8zNmJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuICB2YXIgZW5kID0gYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCk7XG4gIHdoaWxlIChlbmRQb3MgPiBpbmRleCkgT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5564\n")},956:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var forOf = __webpack_require__(8790);\n\nmodule.exports = function (iter, ITERATOR) {\n  var result = [];\n  forOf(iter, false, result.push, result, ITERATOR);\n  return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTU2LmpzIiwibWFwcGluZ3MiOiJBQUFBLFlBQVksbUJBQU8sQ0FBQyxJQUFXOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanM/NDM3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlciwgSVRFUkFUT1IpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3JPZihpdGVyLCBmYWxzZSwgcmVzdWx0LnB1c2gsIHJlc3VsdCwgSVRFUkFUT1IpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///956\n")},1464:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __webpack_require__(7221);\nvar toLength = __webpack_require__(1485);\nvar toAbsoluteIndex = __webpack_require__(157);\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ2NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsSUFBZTtBQUN2QyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxzQkFBc0IsbUJBQU8sQ0FBQyxHQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sV0FBVyxnQkFBZ0I7QUFDakM7QUFDQSxNQUFNO0FBQ047QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcz9jMzY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1464\n")},6179:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// 0 -> Array#forEach\n// 1 -> Array#map\n// 2 -> Array#filter\n// 3 -> Array#some\n// 4 -> Array#every\n// 5 -> Array#find\n// 6 -> Array#findIndex\nvar ctx = __webpack_require__(5052);\nvar IObject = __webpack_require__(1249);\nvar toObject = __webpack_require__(8270);\nvar toLength = __webpack_require__(1485);\nvar asc = __webpack_require__(3191);\nmodule.exports = function (TYPE, $create) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  var create = $create || asc;\n  return function ($this, callbackfn, that) {\n    var O = toObject($this);\n    var self = IObject(O);\n    var f = ctx(callbackfn, that, 3);\n    var length = toLength(self.length);\n    var index = 0;\n    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n    var val, res;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      val = self[index];\n      res = f(val, index, O);\n      if (TYPE) {\n        if (IS_MAP) result[index] = res;   // map\n        else if (res) switch (TYPE) {\n          case 3: return true;             // some\n          case 5: return val;              // find\n          case 6: return index;            // findIndex\n          case 2: result.push(val);        // filter\n        } else if (IS_EVERY) return false; // every\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjE3OS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxJQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxJQUFZO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLFVBQVUsbUJBQU8sQ0FBQyxJQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQyxVQUFVLGlDQUFpQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanM/MGE0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYXNjID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsICRjcmVhdGUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICB2YXIgY3JlYXRlID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWwsIHJlcztcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHJlc3VsdFtpbmRleF0gPSByZXM7ICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlcykgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmIChJU19FVkVSWSkgcmV0dXJuIGZhbHNlOyAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6179\n")},6543:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var aFunction = __webpack_require__(3387);\nvar toObject = __webpack_require__(8270);\nvar IObject = __webpack_require__(1249);\nvar toLength = __webpack_require__(1485);\n\nmodule.exports = function (that, callbackfn, aLen, memo, isRight) {\n  aFunction(callbackfn);\n  var O = toObject(that);\n  var self = IObject(O);\n  var length = toLength(O.length);\n  var index = isRight ? length - 1 : 0;\n  var i = isRight ? -1 : 1;\n  if (aLen < 2) for (;;) {\n    if (index in self) {\n      memo = self[index];\n      index += i;\n      break;\n    }\n    index += i;\n    if (isRight ? index < 0 : length <= index) {\n      throw TypeError('Reduce of empty array with no initial value');\n    }\n  }\n  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {\n    memo = callbackfn(memo, self[index], index, O);\n  }\n  return memo;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU0My5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFlO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxJQUFZO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUNBQXVDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXJlZHVjZS5qcz83YjIzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFMZW4sIG1lbW8sIGlzUmlnaHQpIHtcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBpbmRleCA9IGlzUmlnaHQgPyBsZW5ndGggLSAxIDogMDtcbiAgdmFyIGkgPSBpc1JpZ2h0ID8gLTEgOiAxO1xuICBpZiAoYUxlbiA8IDIpIGZvciAoOzspIHtcbiAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCArPSBpO1xuICAgIGlmIChpc1JpZ2h0ID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgZm9yICg7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICB9XG4gIHJldHVybiBtZW1vO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6543\n")},3606:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isObject = __webpack_require__(3305);\nvar isArray = __webpack_require__(7981);\nvar SPECIES = __webpack_require__(7574)('species');\n\nmodule.exports = function (original) {\n  var C;\n  if (isArray(original)) {\n    C = original.constructor;\n    // cross-realm fallback\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n    if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? Array : C;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYwNi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxjQUFjLG1CQUFPLENBQUMsSUFBYTtBQUNuQyxjQUFjLG1CQUFPLENBQUMsSUFBUTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcz9lODUzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWwpKSB7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3606\n")},3191:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\nvar speciesConstructor = __webpack_require__(3606);\n\nmodule.exports = function (original, length) {\n  return new (speciesConstructor(original))(length);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE5MS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHlCQUF5QixtQkFBTyxDQUFDLElBQThCOztBQUUvRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanM/Y2QxYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3191\n")},5538:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar aFunction = __webpack_require__(3387);\nvar isObject = __webpack_require__(3305);\nvar invoke = __webpack_require__(4877);\nvar arraySlice = [].slice;\nvar factories = {};\n\nvar construct = function (F, len, args) {\n  if (!(len in factories)) {\n    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';\n    // eslint-disable-next-line no-new-func\n    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');\n  } return factories[len](F, args);\n};\n\nmodule.exports = Function.bind || function bind(that /* , ...args */) {\n  var fn = aFunction(this);\n  var partArgs = arraySlice.call(arguments, 1);\n  var bound = function (/* args... */) {\n    var args = partArgs.concat(arraySlice.call(arguments));\n    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);\n  };\n  if (isObject(fn.prototype)) bound.prototype = fn.prototype;\n  return bound;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUzOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsYUFBYSxtQkFBTyxDQUFDLElBQVc7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzP2YwYzEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xudmFyIGFycmF5U2xpY2UgPSBbXS5zbGljZTtcbnZhciBmYWN0b3JpZXMgPSB7fTtcblxudmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIChGLCBsZW4sIGFyZ3MpIHtcbiAgaWYgKCEobGVuIGluIGZhY3RvcmllcykpIHtcbiAgICBmb3IgKHZhciBuID0gW10sIGkgPSAwOyBpIDwgbGVuOyBpKyspIG5baV0gPSAnYVsnICsgaSArICddJztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICBmYWN0b3JpZXNbbGVuXSA9IEZ1bmN0aW9uKCdGLGEnLCAncmV0dXJuIG5ldyBGKCcgKyBuLmpvaW4oJywnKSArICcpJyk7XG4gIH0gcmV0dXJuIGZhY3Rvcmllc1tsZW5dKEYsIGFyZ3MpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5iaW5kIHx8IGZ1bmN0aW9uIGJpbmQodGhhdCAvKiAsIC4uLmFyZ3MgKi8pIHtcbiAgdmFyIGZuID0gYUZ1bmN0aW9uKHRoaXMpO1xuICB2YXIgcGFydEFyZ3MgPSBhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGJvdW5kID0gZnVuY3Rpb24gKC8qIGFyZ3MuLi4gKi8pIHtcbiAgICB2YXIgYXJncyA9IHBhcnRBcmdzLmNvbmNhdChhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZCA/IGNvbnN0cnVjdChmbiwgYXJncy5sZW5ndGgsIGFyZ3MpIDogaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbiAgaWYgKGlzT2JqZWN0KGZuLnByb3RvdHlwZSkpIGJvdW5kLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5538\n")},4848:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = __webpack_require__(5089);\nvar TAG = __webpack_require__(7574)('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg0OC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxJQUFRO0FBQzFCLFVBQVUsbUJBQU8sQ0FBQyxJQUFRO0FBQzFCO0FBQ0EsNEJBQTRCLG1CQUFtQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFlBQVk7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcz8yM2M2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4848\n")},5089:module=>{eval("var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA4OS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanM/MmQ5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5089\n")},6197:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar dP = (__webpack_require__(7967).f);\nvar create = __webpack_require__(4719);\nvar redefineAll = __webpack_require__(6065);\nvar ctx = __webpack_require__(5052);\nvar anInstance = __webpack_require__(6440);\nvar forOf = __webpack_require__(8790);\nvar $iterDefine = __webpack_require__(8175);\nvar step = __webpack_require__(4970);\nvar setSpecies = __webpack_require__(5762);\nvar DESCRIPTORS = __webpack_require__(1763);\nvar fastKey = (__webpack_require__(2988).fastKey);\nvar validate = __webpack_require__(2888);\nvar SIZE = DESCRIPTORS ? '_s' : 'size';\n\nvar getEntry = function (that, key) {\n  // fast case\n  var index = fastKey(key);\n  var entry;\n  if (index !== 'F') return that._i[index];\n  // frozen object case\n  for (entry = that._f; entry; entry = entry.n) {\n    if (entry.k == key) return entry;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, NAME, '_i');\n      that._t = NAME;         // collection type\n      that._i = create(null); // index\n      that._f = undefined;    // first entry\n      that._l = undefined;    // last entry\n      that[SIZE] = 0;         // size\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear() {\n        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {\n          entry.r = true;\n          if (entry.p) entry.p = entry.p.n = undefined;\n          delete data[entry.i];\n        }\n        that._f = that._l = undefined;\n        that[SIZE] = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function (key) {\n        var that = validate(this, NAME);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next = entry.n;\n          var prev = entry.p;\n          delete that._i[entry.i];\n          entry.r = true;\n          if (prev) prev.n = next;\n          if (next) next.p = prev;\n          if (that._f == entry) that._f = next;\n          if (that._l == entry) that._l = prev;\n          that[SIZE]--;\n        } return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn /* , that = undefined */) {\n        validate(this, NAME);\n        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n        var entry;\n        while (entry = entry ? entry.n : this._f) {\n          f(entry.v, entry.k, this);\n          // revert to the last existing entry\n          while (entry && entry.r) entry = entry.p;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key) {\n        return !!getEntry(validate(this, NAME), key);\n      }\n    });\n    if (DESCRIPTORS) dP(C.prototype, 'size', {\n      get: function () {\n        return validate(this, NAME)[SIZE];\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var entry = getEntry(that, key);\n    var prev, index;\n    // change existing entry\n    if (entry) {\n      entry.v = value;\n    // create new entry\n    } else {\n      that._l = entry = {\n        i: index = fastKey(key, true), // <- index\n        k: key,                        // <- key\n        v: value,                      // <- value\n        p: prev = that._l,             // <- previous entry\n        n: undefined,                  // <- next entry\n        r: false                       // <- removed\n      };\n      if (!that._f) that._f = entry;\n      if (prev) prev.n = entry;\n      that[SIZE]++;\n      // add to index\n      if (index !== 'F') that._i[index] = entry;\n    } return that;\n  },\n  getEntry: getEntry,\n  setStrong: function (C, NAME, IS_MAP) {\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    $iterDefine(C, NAME, function (iterated, kind) {\n      this._t = validate(iterated, NAME); // target\n      this._k = kind;                     // kind\n      this._l = undefined;                // previous\n    }, function () {\n      var that = this;\n      var kind = that._k;\n      var entry = that._l;\n      // revert to the last existing entry\n      while (entry && entry.r) entry = entry.p;\n      // get next entry\n      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {\n        // or finish the iteration\n        that._t = undefined;\n        return step(1);\n      }\n      // return step by kind\n      if (kind == 'keys') return step(0, entry.k);\n      if (kind == 'values') return step(0, entry.v);\n      return step(0, [entry.k, entry.v]);\n    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);\n\n    // add [@@species], 23.1.2.2, 23.2.2.2\n    setSpecies(NAME);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjE5Ny5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFNBQVMsNkJBQXlCO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxJQUFrQjtBQUN2QyxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFpQjtBQUMzQyxVQUFVLG1CQUFPLENBQUMsSUFBUTtBQUMxQixpQkFBaUIsbUJBQU8sQ0FBQyxJQUFnQjtBQUN6QyxZQUFZLG1CQUFPLENBQUMsSUFBVztBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyxJQUFnQjtBQUMxQyxXQUFXLG1CQUFPLENBQUMsSUFBYztBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFnQjtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFnQjtBQUMxQyxjQUFjLG1DQUEwQjtBQUN4QyxlQUFlLG1CQUFPLENBQUMsSUFBd0I7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxPQUFPO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzP2MyNmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIGZhc3RLZXkgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTSVpFID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gIHZhciBlbnRyeTtcbiAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvciAoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgaWYgKGVudHJ5LmsgPT0ga2V5KSByZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgZm9yICh2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnApIGVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uO1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZiAodGhhdC5fZiA9PSBlbnRyeSkgdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYgKHRoYXQuX2wgPT0gZW50cnkpIHRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgICAgICB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpO1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2YpIHtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUodGhpcywgTkFNRSlbU0laRV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgIHZhciBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmICghdGhhdC5fZikgdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYgKHByZXYpIHByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKEMsIE5BTUUsIElTX01BUCkge1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgICAgIHRoaXMuX3QgPSB2YWxpZGF0ZShpdGVyYXRlZCwgTkFNRSk7IC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgICAgICAgICAgICAgICAgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIga2luZCA9IHRoYXQuX2s7XG4gICAgICB2YXIgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmICghdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKSB7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6197\n")},4490:(module,__unused_webpack_exports,__webpack_require__)=>{eval('// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar classof = __webpack_require__(4848);\nvar from = __webpack_require__(956);\nmodule.exports = function (NAME) {\n  return function toJSON() {\n    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn\'t generic");\n    return from(this);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ5MC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFZO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyxHQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzPzQ0YjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgZnJvbSA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICBpZiAoY2xhc3NvZih0aGlzKSAhPSBOQU1FKSB0aHJvdyBUeXBlRXJyb3IoTkFNRSArIFwiI3RvSlNPTiBpc24ndCBnZW5lcmljXCIpO1xuICAgIHJldHVybiBmcm9tKHRoaXMpO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4490\n')},9882:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar redefineAll = __webpack_require__(6065);\nvar getWeak = (__webpack_require__(2988).getWeak);\nvar anObject = __webpack_require__(4228);\nvar isObject = __webpack_require__(3305);\nvar anInstance = __webpack_require__(6440);\nvar forOf = __webpack_require__(8790);\nvar createArrayMethod = __webpack_require__(6179);\nvar $has = __webpack_require__(7917);\nvar validate = __webpack_require__(2888);\nvar arrayFind = createArrayMethod(5);\nvar arrayFindIndex = createArrayMethod(6);\nvar id = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function (that) {\n  return that._l || (that._l = new UncaughtFrozenStore());\n};\nvar UncaughtFrozenStore = function () {\n  this.a = [];\n};\nvar findUncaughtFrozen = function (store, key) {\n  return arrayFind(store.a, function (it) {\n    return it[0] === key;\n  });\n};\nUncaughtFrozenStore.prototype = {\n  get: function (key) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) return entry[1];\n  },\n  has: function (key) {\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function (key, value) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) entry[1] = value;\n    else this.a.push([key, value]);\n  },\n  'delete': function (key) {\n    var index = arrayFindIndex(this.a, function (it) {\n      return it[0] === key;\n    });\n    if (~index) this.a.splice(index, 1);\n    return !!~index;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, NAME, '_i');\n      that._t = NAME;      // collection type\n      that._i = id++;      // collection id\n      that._l = undefined; // leak store for uncaught frozen objects\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.3.3.2 WeakMap.prototype.delete(key)\n      // 23.4.3.3 WeakSet.prototype.delete(value)\n      'delete': function (key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);\n        return data && $has(data, this._i) && delete data[this._i];\n      },\n      // 23.3.3.4 WeakMap.prototype.has(key)\n      // 23.4.3.4 WeakSet.prototype.has(value)\n      has: function has(key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);\n        return data && $has(data, this._i);\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var data = getWeak(anObject(key), true);\n    if (data === true) uncaughtFrozenStore(that).set(key, value);\n    else data[that._i] = value;\n    return that;\n  },\n  ufstore: uncaughtFrozenStore\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg4Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGtCQUFrQixtQkFBTyxDQUFDLElBQWlCO0FBQzNDLGNBQWMsbUNBQTBCO0FBQ3hDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGlCQUFpQixtQkFBTyxDQUFDLElBQWdCO0FBQ3pDLFlBQVksbUJBQU8sQ0FBQyxJQUFXO0FBQy9CLHdCQUF3QixtQkFBTyxDQUFDLElBQWtCO0FBQ2xELFdBQVcsbUJBQU8sQ0FBQyxJQUFRO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxJQUF3QjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi13ZWFrLmpzPzY0M2UiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZ2V0V2VhayA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xudmFyICRoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbnZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xudmFyIGlkID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYSA9IFtdO1xufTtcbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYgKH5pbmRleCkgdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGlkKys7ICAgICAgLy8gY29sbGVjdGlvbiBpZFxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgZWxzZSBkYXRhW3RoYXQuX2ldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIHVmc3RvcmU6IHVuY2F1Z2h0RnJvemVuU3RvcmVcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9882\n")},8933:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar global = __webpack_require__(7526);\nvar $export = __webpack_require__(2127);\nvar redefine = __webpack_require__(8859);\nvar redefineAll = __webpack_require__(6065);\nvar meta = __webpack_require__(2988);\nvar forOf = __webpack_require__(8790);\nvar anInstance = __webpack_require__(6440);\nvar isObject = __webpack_require__(3305);\nvar fails = __webpack_require__(9448);\nvar $iterDetect = __webpack_require__(8931);\nvar setToStringTag = __webpack_require__(3844);\nvar inheritIfRequired = __webpack_require__(8880);\n\nmodule.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {\n  var Base = global[NAME];\n  var C = Base;\n  var ADDER = IS_MAP ? 'set' : 'add';\n  var proto = C && C.prototype;\n  var O = {};\n  var fixMethod = function (KEY) {\n    var fn = proto[KEY];\n    redefine(proto, KEY,\n      KEY == 'delete' ? function (a) {\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'has' ? function has(a) {\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'get' ? function get(a) {\n        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }\n        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }\n    );\n  };\n  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {\n    new C().entries().next();\n  }))) {\n    // create collection constructor\n    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\n    redefineAll(C.prototype, methods);\n    meta.NEED = true;\n  } else {\n    var instance = new C();\n    // early implementations not supports chaining\n    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;\n    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false\n    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });\n    // most early implementations doesn't supports iterables, most modern - not close it correctly\n    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new\n    // for early implementations -0 and +0 not the same\n    var BUGGY_ZERO = !IS_WEAK && fails(function () {\n      // V8 ~ Chromium 42- fails only with 5+ elements\n      var $instance = new C();\n      var index = 5;\n      while (index--) $instance[ADDER](index, index);\n      return !$instance.has(-0);\n    });\n    if (!ACCEPT_ITERABLES) {\n      C = wrapper(function (target, iterable) {\n        anInstance(target, C, NAME);\n        var that = inheritIfRequired(new Base(), target, C);\n        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n        return that;\n      });\n      C.prototype = proto;\n      proto.constructor = C;\n    }\n    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\n      fixMethod('delete');\n      fixMethod('has');\n      IS_MAP && fixMethod('get');\n    }\n    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);\n    // weak collections should not contains .clear method\n    if (IS_WEAK && proto.clear) delete proto.clear;\n  }\n\n  setToStringTag(C, NAME);\n\n  O[NAME] = C;\n  $export($export.G + $export.W + $export.F * (C != Base), O);\n\n  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);\n\n  return C;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODkzMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxJQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFhO0FBQ3BDLGtCQUFrQixtQkFBTyxDQUFDLElBQWlCO0FBQzNDLFdBQVcsbUJBQU8sQ0FBQyxJQUFTO0FBQzVCLFlBQVksbUJBQU8sQ0FBQyxJQUFXO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLElBQWdCO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyxJQUFVO0FBQzlCLGtCQUFrQixtQkFBTyxDQUFDLElBQWdCO0FBQzFDLHFCQUFxQixtQkFBTyxDQUFDLElBQXNCO0FBQ25ELHdCQUF3QixtQkFBTyxDQUFDLElBQXdCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUSxtQ0FBbUMsZ0NBQWdDO0FBQzNFLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLG1EQUFtRCxrQkFBa0I7QUFDckU7QUFDQSx5REFBeUQsY0FBYyxHQUFHO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24uanM/ZTBiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIEMgPSBCYXNlO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlO1xuICB2YXIgTyA9IHt9O1xuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVkZWZpbmUocHJvdG8sIEtFWSxcbiAgICAgIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSkgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpOyByZXR1cm4gdGhpczsgfVxuICAgICk7XG4gIH07XG4gIGlmICh0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcbiAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG4gICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHsgbmV3IEMoaXRlcik7IH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAgIHZhciBpbmRleCA9IDU7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICB9KTtcbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSgpLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZiAoSVNfV0VBSyAmJiBwcm90by5jbGVhcikgZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8933\n")},6094:module=>{eval("var core = module.exports = { version: '2.6.12' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA5NC5qcyIsIm1hcHBpbmdzIjoiQUFBQSw4QkFBOEI7QUFDOUIsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanM/ODM3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi42LjEyJyB9O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6094\n")},7227:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $defineProperty = __webpack_require__(7967);\nvar createDesc = __webpack_require__(1996);\n\nmodule.exports = function (object, index, value) {\n  if (index in object) $defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIyNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHNCQUFzQixtQkFBTyxDQUFDLElBQWM7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsSUFBa0I7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcz9mMWFlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGluZGV4LCB2YWx1ZSkge1xuICBpZiAoaW5kZXggaW4gb2JqZWN0KSAkZGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGluZGV4LCBjcmVhdGVEZXNjKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7227\n")},5052:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// optional / simple context binding\nvar aFunction = __webpack_require__(3387);\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA1Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcz85YjQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5052\n")},5385:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()\nvar fails = __webpack_require__(9448);\nvar getTime = Date.prototype.getTime;\nvar $toISOString = Date.prototype.toISOString;\n\nvar lz = function (num) {\n  return num > 9 ? num : '0' + num;\n};\n\n// PhantomJS / old WebKit has a broken implementations\nmodule.exports = (fails(function () {\n  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';\n}) || !fails(function () {\n  $toISOString.call(new Date(NaN));\n})) ? function toISOString() {\n  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');\n  var d = this;\n  var y = d.getUTCFullYear();\n  var m = d.getUTCMilliseconds();\n  var s = y < 0 ? '-' : y > 9999 ? '+' : '';\n  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +\n    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +\n    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +\n    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';\n} : $toISOString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM4NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLElBQVU7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1pc28tc3RyaW5nLmpzPzhlZDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gMjAuMy40LjM2IC8gMTUuOS41LjQzIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKClcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZ2V0VGltZSA9IERhdGUucHJvdG90eXBlLmdldFRpbWU7XG52YXIgJHRvSVNPU3RyaW5nID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmc7XG5cbnZhciBseiA9IGZ1bmN0aW9uIChudW0pIHtcbiAgcmV0dXJuIG51bSA+IDkgPyBudW0gOiAnMCcgKyBudW07XG59O1xuXG4vLyBQaGFudG9tSlMgLyBvbGQgV2ViS2l0IGhhcyBhIGJyb2tlbiBpbXBsZW1lbnRhdGlvbnNcbm1vZHVsZS5leHBvcnRzID0gKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICR0b0lTT1N0cmluZy5jYWxsKG5ldyBEYXRlKC01ZTEzIC0gMSkpICE9ICcwMzg1LTA3LTI1VDA3OjA2OjM5Ljk5OVonO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgJHRvSVNPU3RyaW5nLmNhbGwobmV3IERhdGUoTmFOKSk7XG59KSkgPyBmdW5jdGlvbiB0b0lTT1N0cmluZygpIHtcbiAgaWYgKCFpc0Zpbml0ZShnZXRUaW1lLmNhbGwodGhpcykpKSB0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIHRpbWUgdmFsdWUnKTtcbiAgdmFyIGQgPSB0aGlzO1xuICB2YXIgeSA9IGQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgdmFyIG0gPSBkLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICB2YXIgcyA9IHkgPCAwID8gJy0nIDogeSA+IDk5OTkgPyAnKycgOiAnJztcbiAgcmV0dXJuIHMgKyAoJzAwMDAwJyArIE1hdGguYWJzKHkpKS5zbGljZShzID8gLTYgOiAtNCkgK1xuICAgICctJyArIGx6KGQuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICsgbHooZC5nZXRVVENEYXRlKCkpICtcbiAgICAnVCcgKyBseihkLmdldFVUQ0hvdXJzKCkpICsgJzonICsgbHooZC5nZXRVVENNaW51dGVzKCkpICtcbiAgICAnOicgKyBseihkLmdldFVUQ1NlY29uZHMoKSkgKyAnLicgKyAobSA+IDk5ID8gbSA6ICcwJyArIGx6KG0pKSArICdaJztcbn0gOiAkdG9JU09TdHJpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5385\n")},107:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar anObject = __webpack_require__(4228);\nvar toPrimitive = __webpack_require__(3048);\nvar NUMBER = 'number';\n\nmodule.exports = function (hint) {\n  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');\n  return toPrimitive(anObject(this), hint != NUMBER);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA3LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsa0JBQWtCLG1CQUFPLENBQUMsSUFBaUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1wcmltaXRpdmUuanM/ODM4MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIE5VTUJFUiA9ICdudW1iZXInO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoaW50KSB7XG4gIGlmIChoaW50ICE9PSAnc3RyaW5nJyAmJiBoaW50ICE9PSBOVU1CRVIgJiYgaGludCAhPT0gJ2RlZmF1bHQnKSB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBoaW50Jyk7XG4gIHJldHVybiB0b1ByaW1pdGl2ZShhbk9iamVjdCh0aGlzKSwgaGludCAhPSBOVU1CRVIpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///107\n")},3344:module=>{eval('// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError("Can\'t call method on  " + it);\n  return it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM0NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanM/YmUxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3344\n')},1763:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(9448)(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc2My5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLElBQVU7QUFDcEMsaUNBQWlDLFNBQVMsbUJBQW1CLGFBQWE7QUFDMUUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcz85ZTFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1763\n")},6034:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isObject = __webpack_require__(3305);\nvar document = (__webpack_require__(7526).document);\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAzNC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxlQUFlLG9DQUE2QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanM/MjMwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6034\n")},6140:module=>{eval("// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjE0MC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzP2UxMWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6140\n")},5969:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// all enumerable object keys, includes symbols\nvar getKeys = __webpack_require__(1311);\nvar gOPS = __webpack_require__(1060);\nvar pIE = __webpack_require__(8449);\nmodule.exports = function (it) {\n  var result = getKeys(it);\n  var getSymbols = gOPS.f;\n  if (getSymbols) {\n    var symbols = getSymbols(it);\n    var isEnum = pIE.f;\n    var i = 0;\n    var key;\n    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);\n  } return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTk2OS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFnQjtBQUN0QyxXQUFXLG1CQUFPLENBQUMsSUFBZ0I7QUFDbkMsVUFBVSxtQkFBTyxDQUFDLElBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qcz9kNGMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5969\n")},2127:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var global = __webpack_require__(7526);\nvar core = __webpack_require__(6094);\nvar hide = __webpack_require__(3341);\nvar redefine = __webpack_require__(8859);\nvar ctx = __webpack_require__(5052);\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if (target) redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEyNy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBVztBQUNoQyxXQUFXLG1CQUFPLENBQUMsSUFBUztBQUM1QixXQUFXLG1CQUFPLENBQUMsSUFBUztBQUM1QixlQUFlLG1CQUFPLENBQUMsSUFBYTtBQUNwQyxVQUFVLG1CQUFPLENBQUMsSUFBUTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsdUJBQXVCO0FBQ3pHLGlFQUFpRTtBQUNqRSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanM/NWNhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2127\n")},5203:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var MATCH = __webpack_require__(7574)('match');\nmodule.exports = function (KEY) {\n  var re = /./;\n  try {\n    '/./'[KEY](re);\n  } catch (e) {\n    try {\n      re[MATCH] = false;\n      return !'/./'[KEY](re);\n    } catch (f) { /* empty */ }\n  } return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIwMy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsSUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNLFlBQVk7QUFDbEIsSUFBSTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qcz81MTQ3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciByZSA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tLRVldKHJlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICByZVtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAhJy8uLydbS0VZXShyZSk7XG4gICAgfSBjYXRjaCAoZikgeyAvKiBlbXB0eSAqLyB9XG4gIH0gcmV0dXJuIHRydWU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5203\n")},9448:module=>{eval("module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQ0OC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzPzc5ZTUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9448\n")},9228:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n__webpack_require__(4116);\nvar redefine = __webpack_require__(8859);\nvar hide = __webpack_require__(3341);\nvar fails = __webpack_require__(9448);\nvar defined = __webpack_require__(3344);\nvar wks = __webpack_require__(7574);\nvar regexpExec = __webpack_require__(9600);\n\nvar SPECIES = wks('species');\n\nvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\n  // #replace needs built-in support for named groups.\n  // #match works fine because it just return the exec results, even if it has\n  // a \"grops\" property.\n  var re = /./;\n  re.exec = function () {\n    var result = [];\n    result.groups = { a: '7' };\n    return result;\n  };\n  return ''.replace(re, '$<a>') !== '7';\n});\n\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {\n  // Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n  var re = /(?:)/;\n  var originalExec = re.exec;\n  re.exec = function () { return originalExec.apply(this, arguments); };\n  var result = 'ab'.split(re);\n  return result.length === 2 && result[0] === 'a' && result[1] === 'b';\n})();\n\nmodule.exports = function (KEY, length, exec) {\n  var SYMBOL = wks(KEY);\n\n  var DELEGATES_TO_SYMBOL = !fails(function () {\n    // String methods call symbol-named RegEp methods\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  });\n\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {\n    // Symbol-named RegExp methods call .exec\n    var execCalled = false;\n    var re = /a/;\n    re.exec = function () { execCalled = true; return null; };\n    if (KEY === 'split') {\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\n      // a new one. We need to return the patched regex when creating the new one.\n      re.constructor = {};\n      re.constructor[SPECIES] = function () { return re; };\n    }\n    re[SYMBOL]('');\n    return !execCalled;\n  }) : undefined;\n\n  if (\n    !DELEGATES_TO_SYMBOL ||\n    !DELEGATES_TO_EXEC ||\n    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||\n    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)\n  ) {\n    var nativeRegExpMethod = /./[SYMBOL];\n    var fns = exec(\n      defined,\n      SYMBOL,\n      ''[KEY],\n      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {\n        if (regexp.exec === regexpExec) {\n          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n            // The native String method already delegates to @@method (this\n            // polyfilled function), leasing to infinite recursion.\n            // We avoid it by directly calling the native @@method method.\n            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };\n          }\n          return { done: true, value: nativeMethod.call(str, regexp, arg2) };\n        }\n        return { done: false };\n      }\n    );\n    var strfn = fns[0];\n    var rxfn = fns[1];\n\n    redefine(String.prototype, KEY, strfn);\n    hide(RegExp.prototype, SYMBOL, length == 2\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function (string, arg) { return rxfn.call(string, this, arg); }\n      // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function (string) { return rxfn.call(string, this); }\n    );\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIyOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLG1CQUFPLENBQUMsSUFBbUI7QUFDM0IsZUFBZSxtQkFBTyxDQUFDLElBQWE7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLElBQVM7QUFDNUIsWUFBWSxtQkFBTyxDQUFDLElBQVU7QUFDOUIsY0FBYyxtQkFBTyxDQUFDLElBQVk7QUFDbEMsVUFBVSxtQkFBTyxDQUFDLElBQVE7QUFDMUIsaUJBQWlCLG1CQUFPLENBQUMsSUFBZ0I7O0FBRXpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcz8yMTRmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5leGVjJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjJyk7XG5cbnZhciBTUEVDSUVTID0gd2tzKCdzcGVjaWVzJyk7XG5cbnZhciBSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vICNyZXBsYWNlIG5lZWRzIGJ1aWx0LWluIHN1cHBvcnQgZm9yIG5hbWVkIGdyb3Vwcy5cbiAgLy8gI21hdGNoIHdvcmtzIGZpbmUgYmVjYXVzZSBpdCBqdXN0IHJldHVybiB0aGUgZXhlYyByZXN1bHRzLCBldmVuIGlmIGl0IGhhc1xuICAvLyBhIFwiZ3JvcHNcIiBwcm9wZXJ0eS5cbiAgdmFyIHJlID0gLy4vO1xuICByZS5leGVjID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICByZXN1bHQuZ3JvdXBzID0geyBhOiAnNycgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4gJycucmVwbGFjZShyZSwgJyQ8YT4nKSAhPT0gJzcnO1xufSk7XG5cbnZhciBTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBDaHJvbWUgNTEgaGFzIGEgYnVnZ3kgXCJzcGxpdFwiIGltcGxlbWVudGF0aW9uIHdoZW4gUmVnRXhwI2V4ZWMgIT09IG5hdGl2ZUV4ZWNcbiAgdmFyIHJlID0gLyg/OikvO1xuICB2YXIgb3JpZ2luYWxFeGVjID0gcmUuZXhlYztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yaWdpbmFsRXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICB2YXIgcmVzdWx0ID0gJ2FiJy5zcGxpdChyZSk7XG4gIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAyICYmIHJlc3VsdFswXSA9PT0gJ2EnICYmIHJlc3VsdFsxXSA9PT0gJ2InO1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBsZW5ndGgsIGV4ZWMpIHtcbiAgdmFyIFNZTUJPTCA9IHdrcyhLRVkpO1xuXG4gIHZhciBERUxFR0FURVNfVE9fU1lNQk9MID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTdHJpbmcgbWV0aG9kcyBjYWxsIHN5bWJvbC1uYW1lZCBSZWdFcCBtZXRob2RzXG4gICAgdmFyIE8gPSB7fTtcbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pO1xuXG4gIHZhciBERUxFR0FURVNfVE9fRVhFQyA9IERFTEVHQVRFU19UT19TWU1CT0wgPyAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kcyBjYWxsIC5leGVjXG4gICAgdmFyIGV4ZWNDYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmUgPSAvYS87XG4gICAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgZXhlY0NhbGxlZCA9IHRydWU7IHJldHVybiBudWxsOyB9O1xuICAgIGlmIChLRVkgPT09ICdzcGxpdCcpIHtcbiAgICAgIC8vIFJlZ0V4cFtAQHNwbGl0XSBkb2Vzbid0IGNhbGwgdGhlIHJlZ2V4J3MgZXhlYyBtZXRob2QsIGJ1dCBmaXJzdCBjcmVhdGVzXG4gICAgICAvLyBhIG5ldyBvbmUuIFdlIG5lZWQgdG8gcmV0dXJuIHRoZSBwYXRjaGVkIHJlZ2V4IHdoZW4gY3JlYXRpbmcgdGhlIG5ldyBvbmUuXG4gICAgICByZS5jb25zdHJ1Y3RvciA9IHt9O1xuICAgICAgcmUuY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZTsgfTtcbiAgICB9XG4gICAgcmVbU1lNQk9MXSgnJyk7XG4gICAgcmV0dXJuICFleGVjQ2FsbGVkO1xuICB9KSA6IHVuZGVmaW5lZDtcblxuICBpZiAoXG4gICAgIURFTEVHQVRFU19UT19TWU1CT0wgfHxcbiAgICAhREVMRUdBVEVTX1RPX0VYRUMgfHxcbiAgICAoS0VZID09PSAncmVwbGFjZScgJiYgIVJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTKSB8fFxuICAgIChLRVkgPT09ICdzcGxpdCcgJiYgIVNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQylcbiAgKSB7XG4gICAgdmFyIG5hdGl2ZVJlZ0V4cE1ldGhvZCA9IC8uL1tTWU1CT0xdO1xuICAgIHZhciBmbnMgPSBleGVjKFxuICAgICAgZGVmaW5lZCxcbiAgICAgIFNZTUJPTCxcbiAgICAgICcnW0tFWV0sXG4gICAgICBmdW5jdGlvbiBtYXliZUNhbGxOYXRpdmUobmF0aXZlTWV0aG9kLCByZWdleHAsIHN0ciwgYXJnMiwgZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgICAgaWYgKHJlZ2V4cC5leGVjID09PSByZWdleHBFeGVjKSB7XG4gICAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcbiAgICAgICAgICAgIC8vIHBvbHlmaWxsZWQgZnVuY3Rpb24pLCBsZWFzaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlUmVnRXhwTWV0aG9kLmNhbGwocmVnZXhwLCBzdHIsIGFyZzIpIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBuYXRpdmVNZXRob2QuY2FsbChzdHIsIHJlZ2V4cCwgYXJnMikgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICk7XG4gICAgdmFyIHN0cmZuID0gZm5zWzBdO1xuICAgIHZhciByeGZuID0gZm5zWzFdO1xuXG4gICAgcmVkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBzdHJmbik7XG4gICAgaGlkZShSZWdFeHAucHJvdG90eXBlLCBTWU1CT0wsIGxlbmd0aCA9PSAyXG4gICAgICAvLyAyMS4yLjUuOCBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV0oc3RyaW5nLCByZXBsYWNlVmFsdWUpXG4gICAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxuICAgICAgPyBmdW5jdGlvbiAoc3RyaW5nLCBhcmcpIHsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9228\n")},1158:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// 21.2.5.3 get RegExp.prototype.flags\nvar anObject = __webpack_require__(4228);\nmodule.exports = function () {\n  var that = anObject(this);\n  var result = '';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.unicode) result += 'u';\n  if (that.sticky) result += 'y';\n  return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE1OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanM/MGJmYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1158\n")},2322:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray\nvar isArray = __webpack_require__(7981);\nvar isObject = __webpack_require__(3305);\nvar toLength = __webpack_require__(1485);\nvar ctx = __webpack_require__(5052);\nvar IS_CONCAT_SPREADABLE = __webpack_require__(7574)('isConcatSpreadable');\n\nfunction flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {\n  var targetIndex = start;\n  var sourceIndex = 0;\n  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;\n  var element, spreadable;\n\n  while (sourceIndex < sourceLen) {\n    if (sourceIndex in source) {\n      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];\n\n      spreadable = false;\n      if (isObject(element)) {\n        spreadable = element[IS_CONCAT_SPREADABLE];\n        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);\n      }\n\n      if (spreadable && depth > 0) {\n        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;\n      } else {\n        if (targetIndex >= 0x1fffffffffffff) throw TypeError();\n        target[targetIndex] = element;\n      }\n\n      targetIndex++;\n    }\n    sourceIndex++;\n  }\n  return targetIndex;\n}\n\nmodule.exports = flattenIntoArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMyMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQWE7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsVUFBVSxtQkFBTyxDQUFDLElBQVE7QUFDMUIsMkJBQTJCLG1CQUFPLENBQUMsSUFBUTs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhdHRlbi1pbnRvLWFycmF5LmpzP2M0NWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtRmxhdHRlbkludG9BcnJheVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRSA9IHJlcXVpcmUoJy4vX3drcycpKCdpc0NvbmNhdFNwcmVhZGFibGUnKTtcblxuZnVuY3Rpb24gZmxhdHRlbkludG9BcnJheSh0YXJnZXQsIG9yaWdpbmFsLCBzb3VyY2UsIHNvdXJjZUxlbiwgc3RhcnQsIGRlcHRoLCBtYXBwZXIsIHRoaXNBcmcpIHtcbiAgdmFyIHRhcmdldEluZGV4ID0gc3RhcnQ7XG4gIHZhciBzb3VyY2VJbmRleCA9IDA7XG4gIHZhciBtYXBGbiA9IG1hcHBlciA/IGN0eChtYXBwZXIsIHRoaXNBcmcsIDMpIDogZmFsc2U7XG4gIHZhciBlbGVtZW50LCBzcHJlYWRhYmxlO1xuXG4gIHdoaWxlIChzb3VyY2VJbmRleCA8IHNvdXJjZUxlbikge1xuICAgIGlmIChzb3VyY2VJbmRleCBpbiBzb3VyY2UpIHtcbiAgICAgIGVsZW1lbnQgPSBtYXBGbiA/IG1hcEZuKHNvdXJjZVtzb3VyY2VJbmRleF0sIHNvdXJjZUluZGV4LCBvcmlnaW5hbCkgOiBzb3VyY2Vbc291cmNlSW5kZXhdO1xuXG4gICAgICBzcHJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoaXNPYmplY3QoZWxlbWVudCkpIHtcbiAgICAgICAgc3ByZWFkYWJsZSA9IGVsZW1lbnRbSVNfQ09OQ0FUX1NQUkVBREFCTEVdO1xuICAgICAgICBzcHJlYWRhYmxlID0gc3ByZWFkYWJsZSAhPT0gdW5kZWZpbmVkID8gISFzcHJlYWRhYmxlIDogaXNBcnJheShlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNwcmVhZGFibGUgJiYgZGVwdGggPiAwKSB7XG4gICAgICAgIHRhcmdldEluZGV4ID0gZmxhdHRlbkludG9BcnJheSh0YXJnZXQsIG9yaWdpbmFsLCBlbGVtZW50LCB0b0xlbmd0aChlbGVtZW50Lmxlbmd0aCksIHRhcmdldEluZGV4LCBkZXB0aCAtIDEpIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0YXJnZXRJbmRleCA+PSAweDFmZmZmZmZmZmZmZmZmKSB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgdGFyZ2V0W3RhcmdldEluZGV4XSA9IGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldEluZGV4Kys7XG4gICAgfVxuICAgIHNvdXJjZUluZGV4Kys7XG4gIH1cbiAgcmV0dXJuIHRhcmdldEluZGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW5JbnRvQXJyYXk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2322\n")},8790:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var ctx = __webpack_require__(5052);\nvar call = __webpack_require__(7368);\nvar isArrayIter = __webpack_require__(1508);\nvar anObject = __webpack_require__(4228);\nvar toLength = __webpack_require__(1485);\nvar getIterFn = __webpack_require__(762);\nvar BREAK = {};\nvar RETURN = {};\nvar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);\n  var f = ctx(fn, that, entries ? 2 : 1);\n  var index = 0;\n  var length, step, iterator, result;\n  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if (result === BREAK || result === RETURN) return result;\n  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n    result = call(iterator, f, step.value, entries);\n    if (result === BREAK || result === RETURN) return result;\n  }\n};\nexports.BREAK = BREAK;\nexports.RETURN = RETURN;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODc5MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBUTtBQUMxQixXQUFXLG1CQUFPLENBQUMsSUFBYztBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFrQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxHQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsbUJBQW1CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsZ0JBQWdCO0FBQ3BGO0FBQ0E7QUFDQSxJQUFJLDRDQUE0QywrQkFBK0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qcz80YTU5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8790\n")},9461:(module,__unused_webpack_exports,__webpack_require__)=>{eval("module.exports = __webpack_require__(4556)('native-function-to-string', Function.toString);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQ2MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Z1bmN0aW9uLXRvLXN0cmluZy5qcz9mYTViIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ25hdGl2ZS1mdW5jdGlvbi10by1zdHJpbmcnLCBGdW5jdGlvbi50b1N0cmluZyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9461\n")},7526:module=>{eval("// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUyNi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcz83NzI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7526\n")},7917:module=>{eval("var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzkxNy5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcz82OWE4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7917\n")},3341:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var dP = __webpack_require__(7967);\nvar createDesc = __webpack_require__(1996);\nmodule.exports = __webpack_require__(1763) ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM0MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTLG1CQUFPLENBQUMsSUFBYztBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyxJQUFrQjtBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFnQjtBQUN6QztBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcz8zMmU5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3341\n")},1308:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var document = (__webpack_require__(7526).document);\nmodule.exports = document && document.documentElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMwOC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG9DQUE2QjtBQUM1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19odG1sLmpzP2ZhYjIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1308\n")},2956:(module,__unused_webpack_exports,__webpack_require__)=>{eval("module.exports = !__webpack_require__(1763) && !__webpack_require__(9448)(function () {\n  return Object.defineProperty(__webpack_require__(6034)('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk1Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFnQixNQUFNLG1CQUFPLENBQUMsSUFBVTtBQUNsRSwrQkFBK0IsbUJBQU8sQ0FBQyxJQUFlLGlCQUFpQixtQkFBbUIsYUFBYTtBQUN2RyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzP2M2OWEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2956\n")},8880:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isObject = __webpack_require__(3305);\nvar setPrototypeOf = (__webpack_require__(5170).set);\nmodule.exports = function (that, target, C) {\n  var S = target.constructor;\n  var P;\n  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {\n    setPrototypeOf(that, P);\n  } return that;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODg4MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxxQkFBcUIsK0JBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcz81ZGJjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgdGFyZ2V0LCBDKSB7XG4gIHZhciBTID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICB2YXIgUDtcbiAgaWYgKFMgIT09IEMgJiYgdHlwZW9mIFMgPT0gJ2Z1bmN0aW9uJyAmJiAoUCA9IFMucHJvdG90eXBlKSAhPT0gQy5wcm90b3R5cGUgJiYgaXNPYmplY3QoUCkgJiYgc2V0UHJvdG90eXBlT2YpIHtcbiAgICBzZXRQcm90b3R5cGVPZih0aGF0LCBQKTtcbiAgfSByZXR1cm4gdGhhdDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8880\n")},4877:module=>{eval("// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function (fn, args, that) {\n  var un = that === undefined;\n  switch (args.length) {\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return fn.apply(that, args);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg3Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qcz8zMWY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4877\n")},1249:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(5089);\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI0OS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxJQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanM/NjI2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1249\n")},1508:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// check on default Array iterator\nvar Iterators = __webpack_require__(906);\nvar ITERATOR = __webpack_require__(7574)('iterator');\nvar ArrayProto = Array.prototype;\n\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUwOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLEdBQWM7QUFDdEMsZUFBZSxtQkFBTyxDQUFDLElBQVE7QUFDL0I7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanM/MzNhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1508\n")},7981:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// 7.2.2 IsArray(argument)\nvar cof = __webpack_require__(5089);\nmodule.exports = Array.isArray || function isArray(arg) {\n  return cof(arg) == 'Array';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk4MS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxJQUFRO0FBQzFCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qcz8xMTY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7981\n")},3842:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.1.2.3 Number.isInteger(number)\nvar isObject = __webpack_require__(3305);\nvar floor = Math.floor;\nmodule.exports = function isInteger(it) {\n  return !isObject(it) && isFinite(it) && floor(it) === it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg0Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWludGVnZXIuanM/OWMxMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KSB7XG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3842\n")},3305:module=>{eval("module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMwNS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzP2QzZjQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3305\n")},5411:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// 7.2.8 IsRegExp(argument)\nvar isObject = __webpack_require__(3305);\nvar cof = __webpack_require__(5089);\nvar MATCH = __webpack_require__(7574)('match');\nmodule.exports = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQxMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLFVBQVUsbUJBQU8sQ0FBQyxJQUFRO0FBQzFCLFlBQVksbUJBQU8sQ0FBQyxJQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcz9hYWUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDcuMi44IElzUmVnRXhwKGFyZ3VtZW50KVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNvZihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5411\n")},7368:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// call something on iterator step with safe closing on error\nvar anObject = __webpack_require__(4228);\nmodule.exports = function (iterator, fn, value, entries) {\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) anObject(ret.call(iterator));\n    throw e;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM2OC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzPzFmYTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7368\n")},6032:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar create = __webpack_require__(4719);\nvar descriptor = __webpack_require__(1996);\nvar setToStringTag = __webpack_require__(3844);\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n__webpack_require__(3341)(IteratorPrototype, __webpack_require__(7574)('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAzMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxJQUFrQjtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFrQjtBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQyxJQUFzQjtBQUNuRDs7QUFFQTtBQUNBLG1CQUFPLENBQUMsSUFBUyxxQkFBcUIsbUJBQU8sQ0FBQyxJQUFRLDZCQUE2QixjQUFjOztBQUVqRztBQUNBLHNEQUFzRCwyQkFBMkI7QUFDakY7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcz80MWEwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6032\n")},8175:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar LIBRARY = __webpack_require__(2750);\nvar $export = __webpack_require__(2127);\nvar redefine = __webpack_require__(8859);\nvar hide = __webpack_require__(3341);\nvar Iterators = __webpack_require__(906);\nvar $iterCreate = __webpack_require__(6032);\nvar setToStringTag = __webpack_require__(3844);\nvar getPrototypeOf = __webpack_require__(627);\nvar ITERATOR = __webpack_require__(7574)('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE3NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFZO0FBQ2xDLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFhO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxJQUFTO0FBQzVCLGdCQUFnQixtQkFBTyxDQUFDLEdBQWM7QUFDdEMsa0JBQWtCLG1CQUFPLENBQUMsSUFBZ0I7QUFDMUMscUJBQXFCLG1CQUFPLENBQUMsSUFBc0I7QUFDbkQscUJBQXFCLG1CQUFPLENBQUMsR0FBZTtBQUM1QyxlQUFlLG1CQUFPLENBQUMsSUFBUTtBQUMvQiwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBOztBQUVBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyw4Q0FBOEM7QUFDOUMsTUFBTSw0QkFBNEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanM/MDFmOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgJGl0ZXJDcmVhdGUgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTO1xuICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlO1xuICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcbiAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07XG4gIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpO1xuICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkO1xuICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7XG4gIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmICgkYW55TmF0aXZlKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYgKCFMSUJSQVJZICYmIHR5cGVvZiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0gIT0gJ2Z1bmN0aW9uJykgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKSB7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7XG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8175\n")},8931:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var ITERATOR = __webpack_require__(7574)('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function () { SAFE_CLOSING = true; };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(riter, function () { throw 2; });\n} catch (e) { /* empty */ }\n\nmodule.exports = function (exec, skipClosing) {\n  if (!skipClosing && !SAFE_CLOSING) return false;\n  var safe = false;\n  try {\n    var arr = [7];\n    var iter = arr[ITERATOR]();\n    iter.next = function () { return { done: safe = true }; };\n    arr[ITERATOR] = function () { return iter; };\n    exec(arr);\n  } catch (e) { /* empty */ }\n  return safe;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODkzMS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBUTtBQUMvQjs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUMsRUFBRSxZQUFZOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDLGtDQUFrQztBQUNsQztBQUNBLElBQUksWUFBWTtBQUNoQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzPzVjYzUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24gKCkgeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIHNraXBDbG9zaW5nKSB7XG4gIGlmICghc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBbN107XG4gICAgdmFyIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geyBkb25lOiBzYWZlID0gdHJ1ZSB9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8931\n")},4970:module=>{eval("module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk3MC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFdBQVc7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanM/ZDUzYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4970\n")},906:module=>{eval("module.exports = {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA2LmpzIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcz84NGYyIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge307XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///906\n")},2750:module=>{eval("module.exports = false;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc1MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzPzJkMDAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2750\n")},5551:module=>{eval("// 20.2.2.14 Math.expm1(x)\nvar $expm1 = Math.expm1;\nmodule.exports = (!$expm1\n  // Old FF bug\n  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168\n  // Tor Browser bug\n  || $expm1(-2e-17) != -2e-17\n) ? function expm1(x) {\n  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;\n} : $expm1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTU1MS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanM/MmQ1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBtMSA9IE1hdGguZXhwbTE7XG5tb2R1bGUuZXhwb3J0cyA9ICghJGV4cG0xXG4gIC8vIE9sZCBGRiBidWdcbiAgfHwgJGV4cG0xKDEwKSA+IDIyMDI1LjQ2NTc5NDgwNjcxOSB8fCAkZXhwbTEoMTApIDwgMjIwMjUuNDY1Nzk0ODA2NzE2NTE2OFxuICAvLyBUb3IgQnJvd3NlciBidWdcbiAgfHwgJGV4cG0xKC0yZS0xNykgIT0gLTJlLTE3XG4pID8gZnVuY3Rpb24gZXhwbTEoeCkge1xuICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiB4ID4gLTFlLTYgJiYgeCA8IDFlLTYgPyB4ICsgeCAqIHggLyAyIDogTWF0aC5leHAoeCkgLSAxO1xufSA6ICRleHBtMTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5551\n")},2122:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.16 Math.fround(x)\nvar sign = __webpack_require__(3733);\nvar pow = Math.pow;\nvar EPSILON = pow(2, -52);\nvar EPSILON32 = pow(2, -23);\nvar MAX32 = pow(2, 127) * (2 - EPSILON32);\nvar MIN32 = pow(2, -126);\n\nvar roundTiesToEven = function (n) {\n  return n + 1 / EPSILON - 1 / EPSILON;\n};\n\nmodule.exports = Math.fround || function fround(x) {\n  var $abs = Math.abs(x);\n  var $sign = sign(x);\n  var a, result;\n  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;\n  a = (1 + EPSILON32 / EPSILON) * $abs;\n  result = a - (a - $abs);\n  // eslint-disable-next-line no-self-compare\n  if (result > MAX32 || result != result) return $sign * Infinity;\n  return $sign * result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEyMi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxJQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1mcm91bmQuanM/OTFjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciBzaWduID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJyk7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgRVBTSUxPTiA9IHBvdygyLCAtNTIpO1xudmFyIEVQU0lMT04zMiA9IHBvdygyLCAtMjMpO1xudmFyIE1BWDMyID0gcG93KDIsIDEyNykgKiAoMiAtIEVQU0lMT04zMik7XG52YXIgTUlOMzIgPSBwb3coMiwgLTEyNik7XG5cbnZhciByb3VuZFRpZXNUb0V2ZW4gPSBmdW5jdGlvbiAobikge1xuICByZXR1cm4gbiArIDEgLyBFUFNJTE9OIC0gMSAvIEVQU0lMT047XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguZnJvdW5kIHx8IGZ1bmN0aW9uIGZyb3VuZCh4KSB7XG4gIHZhciAkYWJzID0gTWF0aC5hYnMoeCk7XG4gIHZhciAkc2lnbiA9IHNpZ24oeCk7XG4gIHZhciBhLCByZXN1bHQ7XG4gIGlmICgkYWJzIDwgTUlOMzIpIHJldHVybiAkc2lnbiAqIHJvdW5kVGllc1RvRXZlbigkYWJzIC8gTUlOMzIgLyBFUFNJTE9OMzIpICogTUlOMzIgKiBFUFNJTE9OMzI7XG4gIGEgPSAoMSArIEVQU0lMT04zMiAvIEVQU0lMT04pICogJGFicztcbiAgcmVzdWx0ID0gYSAtIChhIC0gJGFicyk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgaWYgKHJlc3VsdCA+IE1BWDMyIHx8IHJlc3VsdCAhPSByZXN1bHQpIHJldHVybiAkc2lnbiAqIEluZmluaXR5O1xuICByZXR1cm4gJHNpZ24gKiByZXN1bHQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2122\n")},1473:module=>{eval("// 20.2.2.20 Math.log1p(x)\nmodule.exports = Math.log1p || function log1p(x) {\n  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ3My5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzP2Q2YzYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5sb2cxcCB8fCBmdW5jdGlvbiBsb2cxcCh4KSB7XG4gIHJldHVybiAoeCA9ICt4KSA+IC0xZS04ICYmIHggPCAxZS04ID8geCAtIHggKiB4IC8gMiA6IE1hdGgubG9nKDEgKyB4KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1473\n")},7836:module=>{eval("// https://rwaldron.github.io/proposal-math-extensions/\nmodule.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {\n  if (\n    arguments.length === 0\n      // eslint-disable-next-line no-self-compare\n      || x != x\n      // eslint-disable-next-line no-self-compare\n      || inLow != inLow\n      // eslint-disable-next-line no-self-compare\n      || inHigh != inHigh\n      // eslint-disable-next-line no-self-compare\n      || outLow != outLow\n      // eslint-disable-next-line no-self-compare\n      || outHigh != outHigh\n  ) return NaN;\n  if (x === Infinity || x === -Infinity) return x;\n  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzgzNi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zY2FsZS5qcz9lOWQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5zY2FsZSB8fCBmdW5jdGlvbiBzY2FsZSh4LCBpbkxvdywgaW5IaWdoLCBvdXRMb3csIG91dEhpZ2gpIHtcbiAgaWYgKFxuICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDBcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IHggIT0geFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgaW5Mb3cgIT0gaW5Mb3dcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IGluSGlnaCAhPSBpbkhpZ2hcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IG91dExvdyAhPSBvdXRMb3dcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IG91dEhpZ2ggIT0gb3V0SGlnaFxuICApIHJldHVybiBOYU47XG4gIGlmICh4ID09PSBJbmZpbml0eSB8fCB4ID09PSAtSW5maW5pdHkpIHJldHVybiB4O1xuICByZXR1cm4gKHggLSBpbkxvdykgKiAob3V0SGlnaCAtIG91dExvdykgLyAoaW5IaWdoIC0gaW5Mb3cpICsgb3V0TG93O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7836\n")},3733:module=>{eval("// 20.2.2.28 Math.sign(x)\nmodule.exports = Math.sign || function sign(x) {\n  // eslint-disable-next-line no-self-compare\n  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzczMy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2lnbi5qcz85NmZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uIHNpZ24oeCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiAoeCA9ICt4KSA9PSAwIHx8IHggIT0geCA/IHggOiB4IDwgMCA/IC0xIDogMTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3733\n")},2988:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var META = __webpack_require__(4415)('meta');\nvar isObject = __webpack_require__(3305);\nvar has = __webpack_require__(7917);\nvar setDesc = (__webpack_require__(7967).f);\nvar id = 0;\nvar isExtensible = Object.isExtensible || function () {\n  return true;\n};\nvar FREEZE = !__webpack_require__(9448)(function () {\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function (it) {\n  setDesc(it, META, { value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  } });\n};\nvar fastKey = function (it, create) {\n  // return primitive with prefix\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function (it, create) {\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY: META,\n  NEED: false,\n  fastKey: fastKey,\n  getWeak: getWeak,\n  onFreeze: onFreeze\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk4OC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsSUFBUTtBQUMzQixlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxVQUFVLG1CQUFPLENBQUMsSUFBUTtBQUMxQixjQUFjLDZCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFVO0FBQ2hDLGlEQUFpRDtBQUNqRCxDQUFDO0FBQ0Q7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzPzY3YWIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2988\n")},7380:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var Map = __webpack_require__(3386);\nvar $export = __webpack_require__(2127);\nvar shared = __webpack_require__(4556)('metadata');\nvar store = shared.store || (shared.store = new (__webpack_require__(9397))());\n\nvar getOrCreateMetadataMap = function (target, targetKey, create) {\n  var targetMetadata = store.get(target);\n  if (!targetMetadata) {\n    if (!create) return undefined;\n    store.set(target, targetMetadata = new Map());\n  }\n  var keyMetadata = targetMetadata.get(targetKey);\n  if (!keyMetadata) {\n    if (!create) return undefined;\n    targetMetadata.set(targetKey, keyMetadata = new Map());\n  } return keyMetadata;\n};\nvar ordinaryHasOwnMetadata = function (MetadataKey, O, P) {\n  var metadataMap = getOrCreateMetadataMap(O, P, false);\n  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);\n};\nvar ordinaryGetOwnMetadata = function (MetadataKey, O, P) {\n  var metadataMap = getOrCreateMetadataMap(O, P, false);\n  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);\n};\nvar ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {\n  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);\n};\nvar ordinaryOwnMetadataKeys = function (target, targetKey) {\n  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);\n  var keys = [];\n  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });\n  return keys;\n};\nvar toMetaKey = function (it) {\n  return it === undefined || typeof it == 'symbol' ? it : String(it);\n};\nvar exp = function (O) {\n  $export($export.S, 'Reflect', O);\n};\n\nmodule.exports = {\n  store: store,\n  map: getOrCreateMetadataMap,\n  has: ordinaryHasOwnMetadata,\n  get: ordinaryGetOwnMetadata,\n  set: ordinaryDefineOwnMetadata,\n  keys: ordinaryOwnMetadataKeys,\n  key: toMetaKey,\n  exp: exp\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM4MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBVztBQUM3QixjQUFjLG1CQUFPLENBQUMsSUFBVztBQUNqQyxhQUFhLG1CQUFPLENBQUMsSUFBVztBQUNoQyxpREFBaUQsbUJBQU8sQ0FBQyxJQUFnQjs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGlCQUFpQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGFkYXRhLmpzPzM3YTciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIE1hcCA9IHJlcXVpcmUoJy4vZXM2Lm1hcCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnbWV0YWRhdGEnKTtcbnZhciBzdG9yZSA9IHNoYXJlZC5zdG9yZSB8fCAoc2hhcmVkLnN0b3JlID0gbmV3IChyZXF1aXJlKCcuL2VzNi53ZWFrLW1hcCcpKSgpKTtcblxudmFyIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRLZXksIGNyZWF0ZSkge1xuICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcbiAgaWYgKCF0YXJnZXRNZXRhZGF0YSkge1xuICAgIGlmICghY3JlYXRlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHN0b3JlLnNldCh0YXJnZXQsIHRhcmdldE1ldGFkYXRhID0gbmV3IE1hcCgpKTtcbiAgfVxuICB2YXIga2V5TWV0YWRhdGEgPSB0YXJnZXRNZXRhZGF0YS5nZXQodGFyZ2V0S2V5KTtcbiAgaWYgKCFrZXlNZXRhZGF0YSkge1xuICAgIGlmICghY3JlYXRlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHRhcmdldE1ldGFkYXRhLnNldCh0YXJnZXRLZXksIGtleU1ldGFkYXRhID0gbmV3IE1hcCgpKTtcbiAgfSByZXR1cm4ga2V5TWV0YWRhdGE7XG59O1xudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBtZXRhZGF0YU1hcC5oYXMoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICByZXR1cm4gbWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG1ldGFkYXRhTWFwLmdldChNZXRhZGF0YUtleSk7XG59O1xudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApIHtcbiAgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCB0cnVlKS5zZXQoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUpO1xufTtcbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldEtleSkge1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKHRhcmdldCwgdGFyZ2V0S2V5LCBmYWxzZSk7XG4gIHZhciBrZXlzID0gW107XG4gIGlmIChtZXRhZGF0YU1hcCkgbWV0YWRhdGFNYXAuZm9yRWFjaChmdW5jdGlvbiAoXywga2V5KSB7IGtleXMucHVzaChrZXkpOyB9KTtcbiAgcmV0dXJuIGtleXM7XG59O1xudmFyIHRvTWV0YUtleSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6IFN0cmluZyhpdCk7XG59O1xudmFyIGV4cCA9IGZ1bmN0aW9uIChPKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIE8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0b3JlOiBzdG9yZSxcbiAgbWFwOiBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwLFxuICBoYXM6IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEsXG4gIGdldDogb3JkaW5hcnlHZXRPd25NZXRhZGF0YSxcbiAgc2V0OiBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhLFxuICBrZXlzOiBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyxcbiAga2V5OiB0b01ldGFLZXksXG4gIGV4cDogZXhwXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7380\n")},1384:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var global = __webpack_require__(7526);\nvar macrotask = (__webpack_require__(2780).set);\nvar Observer = global.MutationObserver || global.WebKitMutationObserver;\nvar process = global.process;\nvar Promise = global.Promise;\nvar isNode = __webpack_require__(5089)(process) == 'process';\n\nmodule.exports = function () {\n  var head, last, notify;\n\n  var flush = function () {\n    var parent, fn;\n    if (isNode && (parent = process.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (e) {\n        if (head) notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // Node.js\n  if (isNode) {\n    notify = function () {\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339\n  } else if (Observer && !(global.navigator && global.navigator.standalone)) {\n    var toggle = true;\n    var node = document.createTextNode('');\n    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new\n    notify = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (Promise && Promise.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    var promise = Promise.resolve(undefined);\n    notify = function () {\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function () {\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function (fn) {\n    var task = { fn: fn, next: undefined };\n    if (last) last.next = task;\n    if (!head) {\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM4NC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBVztBQUNoQyxnQkFBZ0IsK0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxJQUFROztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUIsR0FBRztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19taWNyb3Rhc2suanM/ODA3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBPYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYgKGlzTm9kZSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyBTYWZhcmkgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG4gIH0gZWxzZSBpZiAoT2JzZXJ2ZXIgJiYgIShnbG9iYWwubmF2aWdhdG9yICYmIGdsb2JhbC5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSkpIHtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmIChQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSkge1xuICAgIC8vIFByb21pc2UucmVzb2x2ZSB3aXRob3V0IGFuIGFyZ3VtZW50IHRocm93cyBhbiBlcnJvciBpbiBMRyBXZWJPUyAyXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmICghaGVhZCkge1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1384\n")},4258:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// 25.4.1.5 NewPromiseCapability(C)\nvar aFunction = __webpack_require__(3387);\n\nfunction PromiseCapability(C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject = aFunction(reject);\n}\n\nmodule.exports.f = function (C) {\n  return new PromiseCapability(C);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI1OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsSUFBZTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzP2E1YjgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbmZ1bmN0aW9uIFByb21pc2VDYXBhYmlsaXR5KEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4258\n")},8206:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// 19.1.2.1 Object.assign(target, source, ...)\nvar DESCRIPTORS = __webpack_require__(1763);\nvar getKeys = __webpack_require__(1311);\nvar gOPS = __webpack_require__(1060);\nvar pIE = __webpack_require__(8449);\nvar toObject = __webpack_require__(8270);\nvar IObject = __webpack_require__(1249);\nvar $assign = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || __webpack_require__(9448)(function () {\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line no-undef\n  var S = Symbol();\n  var K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function (k) { B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n  var T = toObject(target);\n  var aLen = arguments.length;\n  var index = 1;\n  var getSymbols = gOPS.f;\n  var isEnum = pIE.f;\n  while (aLen > index) {\n    var S = IObject(arguments[index++]);\n    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODIwNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsSUFBZ0I7QUFDMUMsY0FBYyxtQkFBTyxDQUFDLElBQWdCO0FBQ3RDLFdBQVcsbUJBQU8sQ0FBQyxJQUFnQjtBQUNuQyxVQUFVLG1CQUFPLENBQUMsSUFBZTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxjQUFjLG1CQUFPLENBQUMsSUFBWTtBQUNsQzs7QUFFQTtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLElBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVc7QUFDaEQsbUJBQW1CLHNDQUFzQztBQUN6RCxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzPzczMzMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBpc0VudW0uY2FsbChTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG4gICAgfVxuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8206\n")},4719:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = __webpack_require__(4228);\nvar dPs = __webpack_require__(1626);\nvar enumBugKeys = __webpack_require__(6140);\nvar IE_PROTO = __webpack_require__(766)('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = __webpack_require__(6034)('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  (__webpack_require__(1308).appendChild)(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcxOS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLFVBQVUsbUJBQU8sQ0FBQyxJQUFlO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLElBQWtCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQyxHQUFlO0FBQ3RDLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsSUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSx1Q0FBOEI7QUFDaEMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzPzJhZWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4719\n")},7967:(__unused_webpack_module,exports,__webpack_require__)=>{eval("var anObject = __webpack_require__(4228);\nvar IE8_DOM_DEFINE = __webpack_require__(2956);\nvar toPrimitive = __webpack_require__(3048);\nvar dP = Object.defineProperty;\n\nexports.f = __webpack_require__(1763) ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk2Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyxJQUFtQjtBQUNoRCxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFpQjtBQUMzQzs7QUFFQSxTQUFTLEdBQUcsbUJBQU8sQ0FBQyxJQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxZQUFZO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcz84NmNjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7967\n")},1626:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var dP = __webpack_require__(7967);\nvar anObject = __webpack_require__(4228);\nvar getKeys = __webpack_require__(1311);\n\nmodule.exports = __webpack_require__(1763) ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYyNi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTLG1CQUFPLENBQUMsSUFBYztBQUMvQixlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxjQUFjLG1CQUFPLENBQUMsSUFBZ0I7O0FBRXRDLGlCQUFpQixtQkFBTyxDQUFDLElBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcz8xNDk1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1626\n")},1913:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// Forced replacement prototype accessors methods\nmodule.exports = __webpack_require__(2750) || !__webpack_require__(9448)(function () {\n  var K = Math.random();\n  // In FF throws only define methods\n  // eslint-disable-next-line no-undef, no-useless-call\n  __defineSetter__.call(null, K, function () { /* empty */ });\n  delete __webpack_require__(7526)[K];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkxMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsSUFBWSxNQUFNLG1CQUFPLENBQUMsSUFBVTtBQUM3RDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsYUFBYTtBQUM1RCxTQUFTLG1CQUFPLENBQUMsSUFBVztBQUM1QixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1mb3JjZWQtcGFtLmpzP2M1YjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gRm9yY2VkIHJlcGxhY2VtZW50IHByb3RvdHlwZSBhY2Nlc3NvcnMgbWV0aG9kc1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19saWJyYXJ5JykgfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgSyA9IE1hdGgucmFuZG9tKCk7XG4gIC8vIEluIEZGIHRocm93cyBvbmx5IGRlZmluZSBtZXRob2RzXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZiwgbm8tdXNlbGVzcy1jYWxsXG4gIF9fZGVmaW5lU2V0dGVyX18uY2FsbChudWxsLCBLLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xuICBkZWxldGUgcmVxdWlyZSgnLi9fZ2xvYmFsJylbS107XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1913\n")},8641:(__unused_webpack_module,exports,__webpack_require__)=>{eval("var pIE = __webpack_require__(8449);\nvar createDesc = __webpack_require__(1996);\nvar toIObject = __webpack_require__(7221);\nvar toPrimitive = __webpack_require__(3048);\nvar has = __webpack_require__(7917);\nvar IE8_DOM_DEFINE = __webpack_require__(2956);\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = __webpack_require__(1763) ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODY0MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBZTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFrQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFlO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLElBQWlCO0FBQzNDLFVBQVUsbUJBQU8sQ0FBQyxJQUFRO0FBQzFCLHFCQUFxQixtQkFBTyxDQUFDLElBQW1CO0FBQ2hEOztBQUVBLFNBQVMsR0FBRyxtQkFBTyxDQUFDLElBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxZQUFZO0FBQ2hCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanM/MTFlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8641\n")},4765:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = __webpack_require__(7221);\nvar gOPN = (__webpack_require__(9415).f);\nvar toString = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return gOPN(it);\n  } catch (e) {\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc2NS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkMsV0FBVyw2QkFBMkI7QUFDdEMsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzPzdiYmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4765\n")},9415:(__unused_webpack_module,exports,__webpack_require__)=>{eval("// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys = __webpack_require__(4561);\nvar hiddenKeys = (__webpack_require__(6140).concat)('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return $keys(O, hiddenKeys);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQxNS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFlBQVksbUJBQU8sQ0FBQyxJQUF5QjtBQUM3QyxpQkFBaUIsa0NBQWtDOztBQUVuRCxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qcz85MDkzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9415\n")},1060:(__unused_webpack_module,exports)=>{eval("exports.f = Object.getOwnPropertySymbols;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA2MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzPzI2MjEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1060\n")},627:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = __webpack_require__(7917);\nvar toObject = __webpack_require__(8270);\nvar IE_PROTO = __webpack_require__(766)('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLElBQVE7QUFDMUIsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsZUFBZSxtQkFBTyxDQUFDLEdBQWU7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzPzM4ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///627\n")},4561:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var has = __webpack_require__(7917);\nvar toIObject = __webpack_require__(7221);\nvar arrayIndexOf = __webpack_require__(1464)(false);\nvar IE_PROTO = __webpack_require__(766)('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU2MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBUTtBQUMxQixnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFlO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLElBQW1CO0FBQzlDLGVBQWUsbUJBQU8sQ0FBQyxHQUFlOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanM/Y2UxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4561\n")},1311:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = __webpack_require__(4561);\nvar enumBugKeys = __webpack_require__(6140);\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMxMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFlBQVksbUJBQU8sQ0FBQyxJQUF5QjtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFrQjs7QUFFNUM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzPzBkNTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1311\n")},8449:(__unused_webpack_module,exports)=>{eval("exports.f = {}.propertyIsEnumerable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQ0OS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcz81MmE3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8449\n")},923:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// most Object methods by ES6 should accept primitives\nvar $export = __webpack_require__(2127);\nvar core = __webpack_require__(6094);\nvar fails = __webpack_require__(9448);\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsV0FBVyxtQkFBTyxDQUFDLElBQVM7QUFDNUIsWUFBWSxtQkFBTyxDQUFDLElBQVU7QUFDOUI7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHNEQUFzRCxRQUFRO0FBQzlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanM/NWVkYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///923\n")},3854:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var DESCRIPTORS = __webpack_require__(1763);\nvar getKeys = __webpack_require__(1311);\nvar toIObject = __webpack_require__(7221);\nvar isEnum = (__webpack_require__(8449).f);\nmodule.exports = function (isEntries) {\n  return function (it) {\n    var O = toIObject(it);\n    var keys = getKeys(O);\n    var length = keys.length;\n    var i = 0;\n    var result = [];\n    var key;\n    while (length > i) {\n      key = keys[i++];\n      if (!DESCRIPTORS || isEnum.call(O, key)) {\n        result.push(isEntries ? [key, O[key]] : O[key]);\n      }\n    }\n    return result;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg1NC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFnQjtBQUMxQyxjQUFjLG1CQUFPLENBQUMsSUFBZ0I7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMsSUFBZTtBQUN2QyxhQUFhLDZCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC10by1hcnJheS5qcz81MDRjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGlzRW51bSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXNFbnRyaWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdChpdCk7XG4gICAgdmFyIGtleXMgPSBnZXRLZXlzKE8pO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGkpIHtcbiAgICAgIGtleSA9IGtleXNbaSsrXTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMgfHwgaXNFbnVtLmNhbGwoTywga2V5KSkge1xuICAgICAgICByZXN1bHQucHVzaChpc0VudHJpZXMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3854\n")},6222:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// all object keys, includes non-enumerable and symbols\nvar gOPN = __webpack_require__(9415);\nvar gOPS = __webpack_require__(1060);\nvar anObject = __webpack_require__(4228);\nvar Reflect = (__webpack_require__(7526).Reflect);\nmodule.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {\n  var keys = gOPN.f(anObject(it));\n  var getSymbols = gOPS.f;\n  return getSymbols ? keys.concat(getSymbols(it)) : keys;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIyMi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxJQUFnQjtBQUNuQyxXQUFXLG1CQUFPLENBQUMsSUFBZ0I7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsY0FBYyxtQ0FBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vd24ta2V5cy5qcz85OTBiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIFJlZmxlY3QgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0ICYmIFJlZmxlY3Qub3duS2V5cyB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ09QTi5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICByZXR1cm4gZ2V0U3ltYm9scyA/IGtleXMuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6222\n")},3589:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var $parseFloat = (__webpack_require__(7526).parseFloat);\nvar $trim = (__webpack_require__(629).trim);\n\nmodule.exports = 1 / $parseFloat(__webpack_require__(832) + '-0') !== -Infinity ? function parseFloat(str) {\n  var string = $trim(String(str), 3);\n  var result = $parseFloat(string);\n  return result === 0 && string.charAt(0) == '-' ? -0 : result;\n} : $parseFloat;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU4OS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0Isc0NBQStCO0FBQ2pELFlBQVksK0JBQThCOztBQUUxQyxpQ0FBaUMsbUJBQU8sQ0FBQyxHQUFjO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtZmxvYXQuanM/ZDc1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUZsb2F0O1xudmFyICR0cmltID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xuXG5tb2R1bGUuZXhwb3J0cyA9IDEgLyAkcGFyc2VGbG9hdChyZXF1aXJlKCcuL19zdHJpbmctd3MnKSArICctMCcpICE9PSAtSW5maW5pdHkgPyBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cikge1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpO1xuICB2YXIgcmVzdWx0ID0gJHBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiBzdHJpbmcuY2hhckF0KDApID09ICctJyA/IC0wIDogcmVzdWx0O1xufSA6ICRwYXJzZUZsb2F0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3589\n")},2738:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var $parseInt = (__webpack_require__(7526).parseInt);\nvar $trim = (__webpack_require__(629).trim);\nvar ws = __webpack_require__(832);\nvar hex = /^[-+]?0[xX]/;\n\nmodule.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {\n  var string = $trim(String(str), 3);\n  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));\n} : $parseInt;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjczOC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0Isb0NBQTZCO0FBQzdDLFlBQVksK0JBQThCO0FBQzFDLFNBQVMsbUJBQU8sQ0FBQyxHQUFjO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtaW50LmpzPzNjYTUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlSW50O1xudmFyICR0cmltID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xudmFyIHdzID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJyk7XG52YXIgaGV4ID0gL15bLStdPzBbeFhdLztcblxubW9kdWxlLmV4cG9ydHMgPSAkcGFyc2VJbnQod3MgKyAnMDgnKSAhPT0gOCB8fCAkcGFyc2VJbnQod3MgKyAnMHgxNicpICE9PSAyMiA/IGZ1bmN0aW9uIHBhcnNlSW50KHN0ciwgcmFkaXgpIHtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKTtcbiAgcmV0dXJuICRwYXJzZUludChzdHJpbmcsIChyYWRpeCA+Pj4gMCkgfHwgKGhleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG59IDogJHBhcnNlSW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2738\n")},128:module=>{eval("module.exports = function (exec) {\n  try {\n    return { e: false, v: exec() };\n  } catch (e) {\n    return { e: true, v: e };\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKLGFBQWE7QUFDYjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BlcmZvcm0uanM/OWM4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZTogZmFsc2UsIHY6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgZTogdHJ1ZSwgdjogZSB9O1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///128\n")},5957:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var anObject = __webpack_require__(4228);\nvar isObject = __webpack_require__(3305);\nvar newPromiseCapability = __webpack_require__(4258);\n\nmodule.exports = function (C, x) {\n  anObject(C);\n  if (isObject(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTk1Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQywyQkFBMkIsbUJBQU8sQ0FBQyxJQUEyQjs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9taXNlLXJlc29sdmUuanM/YmNhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5957\n")},1996:module=>{eval("module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk5Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanM/NDYzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1996\n")},6065:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var redefine = __webpack_require__(8859);\nmodule.exports = function (target, src, safe) {\n  for (var key in src) redefine(target, key, src[key], safe);\n  return target;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA2NS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS1hbGwuanM/ZGNiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBzYWZlKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6065\n")},8859:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var global = __webpack_require__(7526);\nvar hide = __webpack_require__(3341);\nvar has = __webpack_require__(7917);\nvar SRC = __webpack_require__(4415)('src');\nvar $toString = __webpack_require__(9461);\nvar TO_STRING = 'toString';\nvar TPL = ('' + $toString).split(TO_STRING);\n\n(__webpack_require__(6094).inspectSource) = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODg1OS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBVztBQUNoQyxXQUFXLG1CQUFPLENBQUMsSUFBUztBQUM1QixVQUFVLG1CQUFPLENBQUMsSUFBUTtBQUMxQixVQUFVLG1CQUFPLENBQUMsSUFBUTtBQUMxQixnQkFBZ0IsbUJBQU8sQ0FBQyxJQUF1QjtBQUMvQztBQUNBOztBQUVBLHlDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcz8yYWJhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFNSQyA9IHJlcXVpcmUoJy4vX3VpZCcpKCdzcmMnKTtcbnZhciAkdG9TdHJpbmcgPSByZXF1aXJlKCcuL19mdW5jdGlvbi10by1zdHJpbmcnKTtcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyIFRQTCA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcbn07XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbCwgc2FmZSkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYgKE9ba2V5XSA9PT0gdmFsKSByZXR1cm47XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIGlmICghc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH0gZWxzZSBpZiAoT1trZXldKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8859\n")},2535:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar classof = __webpack_require__(4848);\nvar builtinExec = RegExp.prototype.exec;\n\n // `RegExpExec` abstract operation\n// https://tc39.github.io/ecma262/#sec-regexpexec\nmodule.exports = function (R, S) {\n  var exec = R.exec;\n  if (typeof exec === 'function') {\n    var result = exec.call(R, S);\n    if (typeof result !== 'object') {\n      throw new TypeError('RegExp exec method returned something other than an Object or null');\n    }\n    return result;\n  }\n  if (classof(R) !== 'RegExp') {\n    throw new TypeError('RegExp#exec called on incompatible receiver');\n  }\n  return builtinExec.call(R, S);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUzNS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsSUFBWTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy1hYnN0cmFjdC5qcz81ZjFiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgYnVpbHRpbkV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG5cbiAvLyBgUmVnRXhwRXhlY2AgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHBleGVjXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChSLCBTKSB7XG4gIHZhciBleGVjID0gUi5leGVjO1xuICBpZiAodHlwZW9mIGV4ZWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVzdWx0ID0gZXhlYy5jYWxsKFIsIFMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVnRXhwIGV4ZWMgbWV0aG9kIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIE9iamVjdCBvciBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNsYXNzb2YoUikgIT09ICdSZWdFeHAnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xuICB9XG4gIHJldHVybiBidWlsdGluRXhlYy5jYWxsKFIsIFMpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2535\n")},9600:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar regexpFlags = __webpack_require__(1158);\n\nvar nativeExec = RegExp.prototype.exec;\n// This always refers to the native implementation, because the\n// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,\n// which loads this file before patching the method.\nvar nativeReplace = String.prototype.replace;\n\nvar patchedExec = nativeExec;\n\nvar LAST_INDEX = 'lastIndex';\n\nvar UPDATES_LAST_INDEX_WRONG = (function () {\n  var re1 = /a/,\n      re2 = /b*/g;\n  nativeExec.call(re1, 'a');\n  nativeExec.call(re2, 'a');\n  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;\n})();\n\n// nonparticipating capturing group, copied from es5-shim's String#split patch.\nvar NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\n\nvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;\n\nif (PATCH) {\n  patchedExec = function exec(str) {\n    var re = this;\n    var lastIndex, reCopy, match, i;\n\n    if (NPCG_INCLUDED) {\n      reCopy = new RegExp('^' + re.source + '$(?!\\\\s)', regexpFlags.call(re));\n    }\n    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];\n\n    match = nativeExec.call(re, str);\n\n    if (UPDATES_LAST_INDEX_WRONG && match) {\n      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;\n    }\n    if (NPCG_INCLUDED && match && match.length > 1) {\n      // Fix browsers whose `exec` methods don't consistently return `undefined`\n      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n      // eslint-disable-next-line no-loop-func\n      nativeReplace.call(match[0], reCopy, function () {\n        for (i = 1; i < arguments.length - 2; i++) {\n          if (arguments[i] === undefined) match[i] = undefined;\n        }\n      });\n    }\n\n    return match;\n  };\n}\n\nmodule.exports = patchedExec;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYwMC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyxJQUFVOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy5qcz81MjBhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHJlZ2V4cEZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcblxudmFyIG5hdGl2ZUV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG4vLyBUaGlzIGFsd2F5cyByZWZlcnMgdG8gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgYmVjYXVzZSB0aGVcbi8vIFN0cmluZyNyZXBsYWNlIHBvbHlmaWxsIHVzZXMgLi9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljLmpzLFxuLy8gd2hpY2ggbG9hZHMgdGhpcyBmaWxlIGJlZm9yZSBwYXRjaGluZyB0aGUgbWV0aG9kLlxudmFyIG5hdGl2ZVJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG5cbnZhciBwYXRjaGVkRXhlYyA9IG5hdGl2ZUV4ZWM7XG5cbnZhciBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG5cbnZhciBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUxID0gL2EvLFxuICAgICAgcmUyID0gL2IqL2c7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTEsICdhJyk7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTIsICdhJyk7XG4gIHJldHVybiByZTFbTEFTVF9JTkRFWF0gIT09IDAgfHwgcmUyW0xBU1RfSU5ERVhdICE9PSAwO1xufSkoKTtcblxuLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXAsIGNvcGllZCBmcm9tIGVzNS1zaGltJ3MgU3RyaW5nI3NwbGl0IHBhdGNoLlxudmFyIE5QQ0dfSU5DTFVERUQgPSAvKCk/Py8uZXhlYygnJylbMV0gIT09IHVuZGVmaW5lZDtcblxudmFyIFBBVENIID0gVVBEQVRFU19MQVNUX0lOREVYX1dST05HIHx8IE5QQ0dfSU5DTFVERUQ7XG5cbmlmIChQQVRDSCkge1xuICBwYXRjaGVkRXhlYyA9IGZ1bmN0aW9uIGV4ZWMoc3RyKSB7XG4gICAgdmFyIHJlID0gdGhpcztcbiAgICB2YXIgbGFzdEluZGV4LCByZUNvcHksIG1hdGNoLCBpO1xuXG4gICAgaWYgKE5QQ0dfSU5DTFVERUQpIHtcbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14nICsgcmUuc291cmNlICsgJyQoPyFcXFxccyknLCByZWdleHBGbGFncy5jYWxsKHJlKSk7XG4gICAgfVxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcpIGxhc3RJbmRleCA9IHJlW0xBU1RfSU5ERVhdO1xuXG4gICAgbWF0Y2ggPSBuYXRpdmVFeGVjLmNhbGwocmUsIHN0cik7XG5cbiAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HICYmIG1hdGNoKSB7XG4gICAgICByZVtMQVNUX0lOREVYXSA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICBuYXRpdmVSZXBsYWNlLmNhbGwobWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaGVkRXhlYztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9600\n")},7963:module=>{eval("module.exports = function (regExp, replace) {\n  var replacer = replace === Object(replace) ? function (part) {\n    return replace[part];\n  } : replace;\n  return function (it) {\n    return String(it).replace(regExp, replacer);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk2My5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVwbGFjZXIuanM/YWJkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyZWdFeHAsIHJlcGxhY2UpIHtcbiAgdmFyIHJlcGxhY2VyID0gcmVwbGFjZSA9PT0gT2JqZWN0KHJlcGxhY2UpID8gZnVuY3Rpb24gKHBhcnQpIHtcbiAgICByZXR1cm4gcmVwbGFjZVtwYXJ0XTtcbiAgfSA6IHJlcGxhY2U7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gU3RyaW5nKGl0KS5yZXBsYWNlKHJlZ0V4cCwgcmVwbGFjZXIpO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7963\n")},7359:module=>{eval("// 7.2.9 SameValue(x, y)\nmodule.exports = Object.is || function is(x, y) {\n  // eslint-disable-next-line no-self-compare\n  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM1OS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NhbWUtdmFsdWUuanM/ODNhMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjIuOSBTYW1lVmFsdWUoeCwgeSlcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7359\n")},9307:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// https://tc39.github.io/proposal-setmap-offrom/\nvar $export = __webpack_require__(2127);\nvar aFunction = __webpack_require__(3387);\nvar ctx = __webpack_require__(5052);\nvar forOf = __webpack_require__(8790);\n\nmodule.exports = function (COLLECTION) {\n  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {\n    var mapFn = arguments[1];\n    var mapping, A, n, cb;\n    aFunction(this);\n    mapping = mapFn !== undefined;\n    if (mapping) aFunction(mapFn);\n    if (source == undefined) return new this();\n    A = [];\n    if (mapping) {\n      n = 0;\n      cb = ctx(mapFn, arguments[2], 2);\n      forOf(source, false, function (nextItem) {\n        A.push(cb(nextItem, n++));\n      });\n    } else {\n      forOf(source, false, A.push, A);\n    }\n    return new this(A);\n  } });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTMwNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsSUFBZTtBQUN2QyxVQUFVLG1CQUFPLENBQUMsSUFBUTtBQUMxQixZQUFZLG1CQUFPLENBQUMsSUFBVzs7QUFFL0I7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tZnJvbS5qcz8yOGU0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTExFQ1RJT04pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsIENPTExFQ1RJT04sIHsgZnJvbTogZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBGbiwgdGhpc0FyZyAqLykge1xuICAgIHZhciBtYXBGbiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbWFwcGluZywgQSwgbiwgY2I7XG4gICAgYUZ1bmN0aW9uKHRoaXMpO1xuICAgIG1hcHBpbmcgPSBtYXBGbiAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChtYXBwaW5nKSBhRnVuY3Rpb24obWFwRm4pO1xuICAgIGlmIChzb3VyY2UgPT0gdW5kZWZpbmVkKSByZXR1cm4gbmV3IHRoaXMoKTtcbiAgICBBID0gW107XG4gICAgaWYgKG1hcHBpbmcpIHtcbiAgICAgIG4gPSAwO1xuICAgICAgY2IgPSBjdHgobWFwRm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBmdW5jdGlvbiAobmV4dEl0ZW0pIHtcbiAgICAgICAgQS5wdXNoKGNiKG5leHRJdGVtLCBuKyspKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBBLnB1c2gsIEEpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gIH0gfSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9307\n")},8966:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// https://tc39.github.io/proposal-setmap-offrom/\nvar $export = __webpack_require__(2127);\n\nmodule.exports = function (COLLECTION) {\n  $export($export.S, COLLECTION, { of: function of() {\n    var length = arguments.length;\n    var A = new Array(length);\n    while (length--) A[length] = arguments[length];\n    return new this(A);\n  } });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk2Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7O0FBRWpDO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLW9mLmpzP2M2YTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBvZjogZnVuY3Rpb24gb2YoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIEEgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIEFbbGVuZ3RoXSA9IGFyZ3VtZW50c1tsZW5ndGhdO1xuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8966\n")},5170:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = __webpack_require__(3305);\nvar anObject = __webpack_require__(4228);\nvar check = function (O, proto) {\n  anObject(O);\n  if (!isObject(proto) && proto !== null) throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function (test, buggy, set) {\n      try {\n        set = __webpack_require__(5052)(Function.call, (__webpack_require__(8641).f)(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch (e) { buggy = true; }\n      return function setPrototypeOf(O, proto) {\n        check(O, proto);\n        if (buggy) O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTE3MC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVEsaUJBQWlCLDZCQUEyQjtBQUMxRTtBQUNBO0FBQ0EsUUFBUSxZQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzPzhiOTciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5170\n")},5762:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar global = __webpack_require__(7526);\nvar dP = __webpack_require__(7967);\nvar DESCRIPTORS = __webpack_require__(1763);\nvar SPECIES = __webpack_require__(7574)('species');\n\nmodule.exports = function (KEY) {\n  var C = global[KEY];\n  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\n    configurable: true,\n    get: function () { return this; }\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc2Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxJQUFXO0FBQ2hDLFNBQVMsbUJBQU8sQ0FBQyxJQUFjO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLElBQWdCO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyxJQUFROztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanM/N2E1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgQyA9IGdsb2JhbFtLRVldO1xuICBpZiAoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkgZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5762\n")},3844:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var def = (__webpack_require__(7967).f);\nvar has = __webpack_require__(7917);\nvar TAG = __webpack_require__(7574)('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg0NC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLDZCQUF5QjtBQUNuQyxVQUFVLG1CQUFPLENBQUMsSUFBUTtBQUMxQixVQUFVLG1CQUFPLENBQUMsSUFBUTs7QUFFMUI7QUFDQSxxRUFBcUUsZ0NBQWdDO0FBQ3JHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzPzdmMjAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3844\n")},766:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var shared = __webpack_require__(4556)('keys');\nvar uid = __webpack_require__(4415);\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzY2LmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyxJQUFXO0FBQ2hDLFVBQVUsbUJBQU8sQ0FBQyxJQUFRO0FBQzFCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzPzYxM2IiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///766\n")},4556:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var core = __webpack_require__(6094);\nvar global = __webpack_require__(7526);\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: __webpack_require__(2750) ? 'pure' : 'global',\n  copyright: '© 2020 Denis Pushkarev (zloirock.ru)'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU1Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsSUFBUztBQUM1QixhQUFhLG1CQUFPLENBQUMsSUFBVztBQUNoQztBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQSxxRUFBcUU7QUFDckUsQ0FBQztBQUNEO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLElBQVk7QUFDNUI7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcz81NTM3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiByZXF1aXJlKCcuL19saWJyYXJ5JykgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAyMCBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4556\n")},9190:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject = __webpack_require__(4228);\nvar aFunction = __webpack_require__(3387);\nvar SPECIES = __webpack_require__(7574)('species');\nmodule.exports = function (O, D) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTE5MC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLElBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzP2ViZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9190\n")},6884:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar fails = __webpack_require__(9448);\n\nmodule.exports = function (method, arg) {\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call\n    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjg4NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFlBQVksbUJBQU8sQ0FBQyxJQUFVOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaWN0LW1ldGhvZC5qcz8yZjIxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbFxuICAgIGFyZyA/IG1ldGhvZC5jYWxsKG51bGwsIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgMSkgOiBtZXRob2QuY2FsbChudWxsKTtcbiAgfSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6884\n")},1212:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var toInteger = __webpack_require__(7087);\nvar defined = __webpack_require__(3344);\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIxMi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFlO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyxJQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanM/MDJmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1212\n")},8942:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// helper for String#{startsWith, endsWith, includes}\nvar isRegExp = __webpack_require__(5411);\nvar defined = __webpack_require__(3344);\n\nmodule.exports = function (that, searchString, NAME) {\n  if (isRegExp(searchString)) throw TypeError('String#' + NAME + \" doesn't accept regex!\");\n  return String(defined(that));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk0Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQkFBc0I7QUFDdEIsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsY0FBYyxtQkFBTyxDQUFDLElBQVk7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzP2QyYzgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaGVscGVyIGZvciBTdHJpbmcje3N0YXJ0c1dpdGgsIGVuZHNXaXRoLCBpbmNsdWRlc31cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSkge1xuICBpZiAoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSkgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcIiBkb2Vzbid0IGFjY2VwdCByZWdleCFcIik7XG4gIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8942\n")},2468:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var $export = __webpack_require__(2127);\nvar fails = __webpack_require__(9448);\nvar defined = __webpack_require__(3344);\nvar quot = /\"/g;\n// B.2.3.2.1 CreateHTML(string, tag, attribute, value)\nvar createHTML = function (string, tag, attribute, value) {\n  var S = String(defined(string));\n  var p1 = '<' + tag;\n  if (attribute !== '') p1 += ' ' + attribute + '=\"' + String(value).replace(quot, '&quot;') + '\"';\n  return p1 + '>' + S + '</' + tag + '>';\n};\nmodule.exports = function (NAME, exec) {\n  var O = {};\n  O[NAME] = exec(createHTML);\n  $export($export.P + $export.F * fails(function () {\n    var test = ''[NAME]('\"');\n    return test !== test.toLowerCase() || test.split('\"').length > 3;\n  }), 'String', O);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ2OC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsSUFBVztBQUNqQyxZQUFZLG1CQUFPLENBQUMsSUFBVTtBQUM5QixjQUFjLG1CQUFPLENBQUMsSUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanM/Mzg2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIHF1b3QgPSAvXCIvZztcbi8vIEIuMi4zLjIuMSBDcmVhdGVIVE1MKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKVxudmFyIGNyZWF0ZUhUTUwgPSBmdW5jdGlvbiAoc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgdmFyIFMgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTtcbiAgdmFyIHAxID0gJzwnICsgdGFnO1xuICBpZiAoYXR0cmlidXRlICE9PSAnJykgcDEgKz0gJyAnICsgYXR0cmlidXRlICsgJz1cIicgKyBTdHJpbmcodmFsdWUpLnJlcGxhY2UocXVvdCwgJyZxdW90OycpICsgJ1wiJztcbiAgcmV0dXJuIHAxICsgJz4nICsgUyArICc8LycgKyB0YWcgKyAnPic7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSwgZXhlYykge1xuICB2YXIgTyA9IHt9O1xuICBPW05BTUVdID0gZXhlYyhjcmVhdGVIVE1MKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRlc3QgPSAnJ1tOQU1FXSgnXCInKTtcbiAgICByZXR1cm4gdGVzdCAhPT0gdGVzdC50b0xvd2VyQ2FzZSgpIHx8IHRlc3Quc3BsaXQoJ1wiJykubGVuZ3RoID4gMztcbiAgfSksICdTdHJpbmcnLCBPKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2468\n")},4472:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://github.com/tc39/proposal-string-pad-start-end\nvar toLength = __webpack_require__(1485);\nvar repeat = __webpack_require__(7926);\nvar defined = __webpack_require__(3344);\n\nmodule.exports = function (that, maxLength, fillString, left) {\n  var S = String(defined(that));\n  var stringLength = S.length;\n  var fillStr = fillString === undefined ? ' ' : String(fillString);\n  var intMaxLength = toLength(maxLength);\n  if (intMaxLength <= stringLength || fillStr == '') return S;\n  var fillLen = intMaxLength - stringLength;\n  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));\n  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);\n  return left ? stringFiller + S : S + stringFiller;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ3Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxJQUFrQjtBQUN2QyxjQUFjLG1CQUFPLENBQUMsSUFBWTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcGFkLmpzPzJlMDgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBtYXhMZW5ndGgsIGZpbGxTdHJpbmcsIGxlZnQpIHtcbiAgdmFyIFMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gIHZhciBzdHJpbmdMZW5ndGggPSBTLmxlbmd0aDtcbiAgdmFyIGZpbGxTdHIgPSBmaWxsU3RyaW5nID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbFN0cmluZyk7XG4gIHZhciBpbnRNYXhMZW5ndGggPSB0b0xlbmd0aChtYXhMZW5ndGgpO1xuICBpZiAoaW50TWF4TGVuZ3RoIDw9IHN0cmluZ0xlbmd0aCB8fCBmaWxsU3RyID09ICcnKSByZXR1cm4gUztcbiAgdmFyIGZpbGxMZW4gPSBpbnRNYXhMZW5ndGggLSBzdHJpbmdMZW5ndGg7XG4gIHZhciBzdHJpbmdGaWxsZXIgPSByZXBlYXQuY2FsbChmaWxsU3RyLCBNYXRoLmNlaWwoZmlsbExlbiAvIGZpbGxTdHIubGVuZ3RoKSk7XG4gIGlmIChzdHJpbmdGaWxsZXIubGVuZ3RoID4gZmlsbExlbikgc3RyaW5nRmlsbGVyID0gc3RyaW5nRmlsbGVyLnNsaWNlKDAsIGZpbGxMZW4pO1xuICByZXR1cm4gbGVmdCA/IHN0cmluZ0ZpbGxlciArIFMgOiBTICsgc3RyaW5nRmlsbGVyO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4472\n")},7926:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar toInteger = __webpack_require__(7087);\nvar defined = __webpack_require__(3344);\n\nmodule.exports = function repeat(count) {\n  var str = String(defined(this));\n  var res = '';\n  var n = toInteger(count);\n  if (n < 0 || n == Infinity) throw RangeError(\"Count can't be negative\");\n  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;\n  return res;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzkyNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLElBQVk7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLE9BQU87QUFDZjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanM/OTc0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwZWF0KGNvdW50KSB7XG4gIHZhciBzdHIgPSBTdHJpbmcoZGVmaW5lZCh0aGlzKSk7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIG4gPSB0b0ludGVnZXIoY291bnQpO1xuICBpZiAobiA8IDAgfHwgbiA9PSBJbmZpbml0eSkgdGhyb3cgUmFuZ2VFcnJvcihcIkNvdW50IGNhbid0IGJlIG5lZ2F0aXZlXCIpO1xuICBmb3IgKDtuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpIGlmIChuICYgMSkgcmVzICs9IHN0cjtcbiAgcmV0dXJuIHJlcztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7926\n")},629:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var $export = __webpack_require__(2127);\nvar defined = __webpack_require__(3344);\nvar fails = __webpack_require__(9448);\nvar spaces = __webpack_require__(832);\nvar space = '[' + spaces + ']';\nvar non = '\\u200b\\u0085';\nvar ltrim = RegExp('^' + space + space + '*');\nvar rtrim = RegExp(space + space + '*$');\n\nvar exporter = function (KEY, exec, ALIAS) {\n  var exp = {};\n  var FORCE = fails(function () {\n    return !!spaces[KEY]() || non[KEY]() != non;\n  });\n  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];\n  if (ALIAS) exp[ALIAS] = fn;\n  $export($export.P + $export.F * FORCE, 'String', exp);\n};\n\n// 1 -> String#trimLeft\n// 2 -> String#trimRight\n// 3 -> String#trim\nvar trim = exporter.trim = function (string, TYPE) {\n  string = String(defined(string));\n  if (TYPE & 1) string = string.replace(ltrim, '');\n  if (TYPE & 2) string = string.replace(rtrim, '');\n  return string;\n};\n\nmodule.exports = exporter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI5LmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyxJQUFZO0FBQ2xDLFlBQVksbUJBQU8sQ0FBQyxJQUFVO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyxHQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctdHJpbS5qcz9hYTc3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc3BhY2VzID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJyk7XG52YXIgc3BhY2UgPSAnWycgKyBzcGFjZXMgKyAnXSc7XG52YXIgbm9uID0gJ1xcdTIwMGJcXHUwMDg1JztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyBzcGFjZSArIHNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cChzcGFjZSArIHNwYWNlICsgJyokJyk7XG5cbnZhciBleHBvcnRlciA9IGZ1bmN0aW9uIChLRVksIGV4ZWMsIEFMSUFTKSB7XG4gIHZhciBleHAgPSB7fTtcbiAgdmFyIEZPUkNFID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXNwYWNlc1tLRVldKCkgfHwgbm9uW0tFWV0oKSAhPSBub247XG4gIH0pO1xuICB2YXIgZm4gPSBleHBbS0VZXSA9IEZPUkNFID8gZXhlYyh0cmltKSA6IHNwYWNlc1tLRVldO1xuICBpZiAoQUxJQVMpIGV4cFtBTElBU10gPSBmbjtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRSwgJ1N0cmluZycsIGV4cCk7XG59O1xuXG4vLyAxIC0+IFN0cmluZyN0cmltTGVmdFxuLy8gMiAtPiBTdHJpbmcjdHJpbVJpZ2h0XG4vLyAzIC0+IFN0cmluZyN0cmltXG52YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbiAoc3RyaW5nLCBUWVBFKSB7XG4gIHN0cmluZyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpO1xuICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gIGlmIChUWVBFICYgMikgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///629\n")},832:module=>{eval("module.exports = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' +\n  '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODMyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXdzLmpzP2ZkZWYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICtcbiAgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///832\n")},2780:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var ctx = __webpack_require__(5052);\nvar invoke = __webpack_require__(4877);\nvar html = __webpack_require__(1308);\nvar cel = __webpack_require__(6034);\nvar global = __webpack_require__(7526);\nvar process = global.process;\nvar setTask = global.setImmediate;\nvar clearTask = global.clearImmediate;\nvar MessageChannel = global.MessageChannel;\nvar Dispatch = global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer, channel, port;\nvar run = function () {\n  var id = +this;\n  // eslint-disable-next-line no-prototype-builtins\n  if (queue.hasOwnProperty(id)) {\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function (event) {\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!setTask || !clearTask) {\n  setTask = function setImmediate(fn) {\n    var args = [];\n    var i = 1;\n    while (arguments.length > i) args.push(arguments[i++]);\n    queue[++counter] = function () {\n      // eslint-disable-next-line no-new-func\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id) {\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if (__webpack_require__(5089)(process) == 'process') {\n    defer = function (id) {\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if (MessageChannel) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {\n    defer = function (id) {\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in cel('script')) {\n    defer = function (id) {\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set: setTask,\n  clear: clearTask\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc4MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBUTtBQUMxQixhQUFhLG1CQUFPLENBQUMsSUFBVztBQUNoQyxXQUFXLG1CQUFPLENBQUMsSUFBUztBQUM1QixVQUFVLG1CQUFPLENBQUMsSUFBZTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsSUFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtQkFBTyxDQUFDLElBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanM/MTk5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcbnZhciBjZWwgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHNldFRhc2sgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyVGFzayA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spIHtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGkgPSAxO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2780\n")},157:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var toInteger = __webpack_require__(7087);\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU3LmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzPzc3ZjEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///157\n")},3133:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://tc39.github.io/ecma262/#sec-toindex\nvar toInteger = __webpack_require__(7087);\nvar toLength = __webpack_require__(1485);\nmodule.exports = function (it) {\n  if (it === undefined) return 0;\n  var number = toInteger(it);\n  var length = toLength(number);\n  if (number !== length) throw RangeError('Wrong length!');\n  return length;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEzMy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW5kZXguanM/MDlmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2luZGV4XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIHZhciBudW1iZXIgPSB0b0ludGVnZXIoaXQpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgobnVtYmVyKTtcbiAgaWYgKG51bWJlciAhPT0gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBsZW5ndGghJyk7XG4gIHJldHVybiBsZW5ndGg7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3133\n")},7087:module=>{eval("// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA4Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcz80NTg4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7087\n")},7221:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(1249);\nvar defined = __webpack_require__(3344);\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIyMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFZO0FBQ2xDLGNBQWMsbUJBQU8sQ0FBQyxJQUFZO0FBQ2xDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzPzY4MjEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7221\n")},1485:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// 7.1.15 ToLength\nvar toInteger = __webpack_require__(7087);\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ4NS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkM7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanM/OWRlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1485\n")},8270:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// 7.1.13 ToObject(argument)\nvar defined = __webpack_require__(3344);\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI3MC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFZO0FBQ2xDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanM/NGJmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8270\n")},3048:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(3305);\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA0OC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcz82YTk5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3048\n")},7209:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nif (__webpack_require__(1763)) {\n  var LIBRARY = __webpack_require__(2750);\n  var global = __webpack_require__(7526);\n  var fails = __webpack_require__(9448);\n  var $export = __webpack_require__(2127);\n  var $typed = __webpack_require__(237);\n  var $buffer = __webpack_require__(8032);\n  var ctx = __webpack_require__(5052);\n  var anInstance = __webpack_require__(6440);\n  var propertyDesc = __webpack_require__(1996);\n  var hide = __webpack_require__(3341);\n  var redefineAll = __webpack_require__(6065);\n  var toInteger = __webpack_require__(7087);\n  var toLength = __webpack_require__(1485);\n  var toIndex = __webpack_require__(3133);\n  var toAbsoluteIndex = __webpack_require__(157);\n  var toPrimitive = __webpack_require__(3048);\n  var has = __webpack_require__(7917);\n  var classof = __webpack_require__(4848);\n  var isObject = __webpack_require__(3305);\n  var toObject = __webpack_require__(8270);\n  var isArrayIter = __webpack_require__(1508);\n  var create = __webpack_require__(4719);\n  var getPrototypeOf = __webpack_require__(627);\n  var gOPN = (__webpack_require__(9415).f);\n  var getIterFn = __webpack_require__(762);\n  var uid = __webpack_require__(4415);\n  var wks = __webpack_require__(7574);\n  var createArrayMethod = __webpack_require__(6179);\n  var createArrayIncludes = __webpack_require__(1464);\n  var speciesConstructor = __webpack_require__(9190);\n  var ArrayIterators = __webpack_require__(5165);\n  var Iterators = __webpack_require__(906);\n  var $iterDetect = __webpack_require__(8931);\n  var setSpecies = __webpack_require__(5762);\n  var arrayFill = __webpack_require__(5564);\n  var arrayCopyWithin = __webpack_require__(4438);\n  var $DP = __webpack_require__(7967);\n  var $GOPD = __webpack_require__(8641);\n  var dP = $DP.f;\n  var gOPD = $GOPD.f;\n  var RangeError = global.RangeError;\n  var TypeError = global.TypeError;\n  var Uint8Array = global.Uint8Array;\n  var ARRAY_BUFFER = 'ArrayBuffer';\n  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;\n  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';\n  var PROTOTYPE = 'prototype';\n  var ArrayProto = Array[PROTOTYPE];\n  var $ArrayBuffer = $buffer.ArrayBuffer;\n  var $DataView = $buffer.DataView;\n  var arrayForEach = createArrayMethod(0);\n  var arrayFilter = createArrayMethod(2);\n  var arraySome = createArrayMethod(3);\n  var arrayEvery = createArrayMethod(4);\n  var arrayFind = createArrayMethod(5);\n  var arrayFindIndex = createArrayMethod(6);\n  var arrayIncludes = createArrayIncludes(true);\n  var arrayIndexOf = createArrayIncludes(false);\n  var arrayValues = ArrayIterators.values;\n  var arrayKeys = ArrayIterators.keys;\n  var arrayEntries = ArrayIterators.entries;\n  var arrayLastIndexOf = ArrayProto.lastIndexOf;\n  var arrayReduce = ArrayProto.reduce;\n  var arrayReduceRight = ArrayProto.reduceRight;\n  var arrayJoin = ArrayProto.join;\n  var arraySort = ArrayProto.sort;\n  var arraySlice = ArrayProto.slice;\n  var arrayToString = ArrayProto.toString;\n  var arrayToLocaleString = ArrayProto.toLocaleString;\n  var ITERATOR = wks('iterator');\n  var TAG = wks('toStringTag');\n  var TYPED_CONSTRUCTOR = uid('typed_constructor');\n  var DEF_CONSTRUCTOR = uid('def_constructor');\n  var ALL_CONSTRUCTORS = $typed.CONSTR;\n  var TYPED_ARRAY = $typed.TYPED;\n  var VIEW = $typed.VIEW;\n  var WRONG_LENGTH = 'Wrong length!';\n\n  var $map = createArrayMethod(1, function (O, length) {\n    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);\n  });\n\n  var LITTLE_ENDIAN = fails(function () {\n    // eslint-disable-next-line no-undef\n    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;\n  });\n\n  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {\n    new Uint8Array(1).set({});\n  });\n\n  var toOffset = function (it, BYTES) {\n    var offset = toInteger(it);\n    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');\n    return offset;\n  };\n\n  var validate = function (it) {\n    if (isObject(it) && TYPED_ARRAY in it) return it;\n    throw TypeError(it + ' is not a typed array!');\n  };\n\n  var allocate = function (C, length) {\n    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {\n      throw TypeError('It is not a typed array constructor!');\n    } return new C(length);\n  };\n\n  var speciesFromList = function (O, list) {\n    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);\n  };\n\n  var fromList = function (C, list) {\n    var index = 0;\n    var length = list.length;\n    var result = allocate(C, length);\n    while (length > index) result[index] = list[index++];\n    return result;\n  };\n\n  var addGetter = function (it, key, internal) {\n    dP(it, key, { get: function () { return this._d[internal]; } });\n  };\n\n  var $from = function from(source /* , mapfn, thisArg */) {\n    var O = toObject(source);\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var iterFn = getIterFn(O);\n    var i, length, values, result, step, iterator;\n    if (iterFn != undefined && !isArrayIter(iterFn)) {\n      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {\n        values.push(step.value);\n      } O = values;\n    }\n    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);\n    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {\n      result[i] = mapping ? mapfn(O[i], i) : O[i];\n    }\n    return result;\n  };\n\n  var $of = function of(/* ...items */) {\n    var index = 0;\n    var length = arguments.length;\n    var result = allocate(this, length);\n    while (length > index) result[index] = arguments[index++];\n    return result;\n  };\n\n  // iOS Safari 6.x fails here\n  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });\n\n  var $toLocaleString = function toLocaleString() {\n    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);\n  };\n\n  var proto = {\n    copyWithin: function copyWithin(target, start /* , end */) {\n      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    every: function every(callbackfn /* , thisArg */) {\n      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars\n      return arrayFill.apply(validate(this), arguments);\n    },\n    filter: function filter(callbackfn /* , thisArg */) {\n      return speciesFromList(this, arrayFilter(validate(this), callbackfn,\n        arguments.length > 1 ? arguments[1] : undefined));\n    },\n    find: function find(predicate /* , thisArg */) {\n      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    findIndex: function findIndex(predicate /* , thisArg */) {\n      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    forEach: function forEach(callbackfn /* , thisArg */) {\n      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    indexOf: function indexOf(searchElement /* , fromIndex */) {\n      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    includes: function includes(searchElement /* , fromIndex */) {\n      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    join: function join(separator) { // eslint-disable-line no-unused-vars\n      return arrayJoin.apply(validate(this), arguments);\n    },\n    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars\n      return arrayLastIndexOf.apply(validate(this), arguments);\n    },\n    map: function map(mapfn /* , thisArg */) {\n      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars\n      return arrayReduce.apply(validate(this), arguments);\n    },\n    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars\n      return arrayReduceRight.apply(validate(this), arguments);\n    },\n    reverse: function reverse() {\n      var that = this;\n      var length = validate(that).length;\n      var middle = Math.floor(length / 2);\n      var index = 0;\n      var value;\n      while (index < middle) {\n        value = that[index];\n        that[index++] = that[--length];\n        that[length] = value;\n      } return that;\n    },\n    some: function some(callbackfn /* , thisArg */) {\n      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    sort: function sort(comparefn) {\n      return arraySort.call(validate(this), comparefn);\n    },\n    subarray: function subarray(begin, end) {\n      var O = validate(this);\n      var length = O.length;\n      var $begin = toAbsoluteIndex(begin, length);\n      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(\n        O.buffer,\n        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,\n        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)\n      );\n    }\n  };\n\n  var $slice = function slice(start, end) {\n    return speciesFromList(this, arraySlice.call(validate(this), start, end));\n  };\n\n  var $set = function set(arrayLike /* , offset */) {\n    validate(this);\n    var offset = toOffset(arguments[1], 1);\n    var length = this.length;\n    var src = toObject(arrayLike);\n    var len = toLength(src.length);\n    var index = 0;\n    if (len + offset > length) throw RangeError(WRONG_LENGTH);\n    while (index < len) this[offset + index] = src[index++];\n  };\n\n  var $iterators = {\n    entries: function entries() {\n      return arrayEntries.call(validate(this));\n    },\n    keys: function keys() {\n      return arrayKeys.call(validate(this));\n    },\n    values: function values() {\n      return arrayValues.call(validate(this));\n    }\n  };\n\n  var isTAIndex = function (target, key) {\n    return isObject(target)\n      && target[TYPED_ARRAY]\n      && typeof key != 'symbol'\n      && key in target\n      && String(+key) == String(key);\n  };\n  var $getDesc = function getOwnPropertyDescriptor(target, key) {\n    return isTAIndex(target, key = toPrimitive(key, true))\n      ? propertyDesc(2, target[key])\n      : gOPD(target, key);\n  };\n  var $setDesc = function defineProperty(target, key, desc) {\n    if (isTAIndex(target, key = toPrimitive(key, true))\n      && isObject(desc)\n      && has(desc, 'value')\n      && !has(desc, 'get')\n      && !has(desc, 'set')\n      // TODO: add validation descriptor w/o calling accessors\n      && !desc.configurable\n      && (!has(desc, 'writable') || desc.writable)\n      && (!has(desc, 'enumerable') || desc.enumerable)\n    ) {\n      target[key] = desc.value;\n      return target;\n    } return dP(target, key, desc);\n  };\n\n  if (!ALL_CONSTRUCTORS) {\n    $GOPD.f = $getDesc;\n    $DP.f = $setDesc;\n  }\n\n  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {\n    getOwnPropertyDescriptor: $getDesc,\n    defineProperty: $setDesc\n  });\n\n  if (fails(function () { arrayToString.call({}); })) {\n    arrayToString = arrayToLocaleString = function toString() {\n      return arrayJoin.call(this);\n    };\n  }\n\n  var $TypedArrayPrototype$ = redefineAll({}, proto);\n  redefineAll($TypedArrayPrototype$, $iterators);\n  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);\n  redefineAll($TypedArrayPrototype$, {\n    slice: $slice,\n    set: $set,\n    constructor: function () { /* noop */ },\n    toString: arrayToString,\n    toLocaleString: $toLocaleString\n  });\n  addGetter($TypedArrayPrototype$, 'buffer', 'b');\n  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');\n  addGetter($TypedArrayPrototype$, 'byteLength', 'l');\n  addGetter($TypedArrayPrototype$, 'length', 'e');\n  dP($TypedArrayPrototype$, TAG, {\n    get: function () { return this[TYPED_ARRAY]; }\n  });\n\n  // eslint-disable-next-line max-statements\n  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {\n    CLAMPED = !!CLAMPED;\n    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';\n    var GETTER = 'get' + KEY;\n    var SETTER = 'set' + KEY;\n    var TypedArray = global[NAME];\n    var Base = TypedArray || {};\n    var TAC = TypedArray && getPrototypeOf(TypedArray);\n    var FORCED = !TypedArray || !$typed.ABV;\n    var O = {};\n    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];\n    var getter = function (that, index) {\n      var data = that._d;\n      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);\n    };\n    var setter = function (that, index, value) {\n      var data = that._d;\n      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;\n      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);\n    };\n    var addElement = function (that, index) {\n      dP(that, index, {\n        get: function () {\n          return getter(this, index);\n        },\n        set: function (value) {\n          return setter(this, index, value);\n        },\n        enumerable: true\n      });\n    };\n    if (FORCED) {\n      TypedArray = wrapper(function (that, data, $offset, $length) {\n        anInstance(that, TypedArray, NAME, '_d');\n        var index = 0;\n        var offset = 0;\n        var buffer, byteLength, length, klass;\n        if (!isObject(data)) {\n          length = toIndex(data);\n          byteLength = length * BYTES;\n          buffer = new $ArrayBuffer(byteLength);\n        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {\n          buffer = data;\n          offset = toOffset($offset, BYTES);\n          var $len = data.byteLength;\n          if ($length === undefined) {\n            if ($len % BYTES) throw RangeError(WRONG_LENGTH);\n            byteLength = $len - offset;\n            if (byteLength < 0) throw RangeError(WRONG_LENGTH);\n          } else {\n            byteLength = toLength($length) * BYTES;\n            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);\n          }\n          length = byteLength / BYTES;\n        } else if (TYPED_ARRAY in data) {\n          return fromList(TypedArray, data);\n        } else {\n          return $from.call(TypedArray, data);\n        }\n        hide(that, '_d', {\n          b: buffer,\n          o: offset,\n          l: byteLength,\n          e: length,\n          v: new $DataView(buffer)\n        });\n        while (index < length) addElement(that, index++);\n      });\n      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);\n      hide(TypedArrayPrototype, 'constructor', TypedArray);\n    } else if (!fails(function () {\n      TypedArray(1);\n    }) || !fails(function () {\n      new TypedArray(-1); // eslint-disable-line no-new\n    }) || !$iterDetect(function (iter) {\n      new TypedArray(); // eslint-disable-line no-new\n      new TypedArray(null); // eslint-disable-line no-new\n      new TypedArray(1.5); // eslint-disable-line no-new\n      new TypedArray(iter); // eslint-disable-line no-new\n    }, true)) {\n      TypedArray = wrapper(function (that, data, $offset, $length) {\n        anInstance(that, TypedArray, NAME);\n        var klass;\n        // `ws` module bug, temporarily remove validation length for Uint8Array\n        // https://github.com/websockets/ws/pull/645\n        if (!isObject(data)) return new Base(toIndex(data));\n        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {\n          return $length !== undefined\n            ? new Base(data, toOffset($offset, BYTES), $length)\n            : $offset !== undefined\n              ? new Base(data, toOffset($offset, BYTES))\n              : new Base(data);\n        }\n        if (TYPED_ARRAY in data) return fromList(TypedArray, data);\n        return $from.call(TypedArray, data);\n      });\n      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {\n        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);\n      });\n      TypedArray[PROTOTYPE] = TypedArrayPrototype;\n      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;\n    }\n    var $nativeIterator = TypedArrayPrototype[ITERATOR];\n    var CORRECT_ITER_NAME = !!$nativeIterator\n      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);\n    var $iterator = $iterators.values;\n    hide(TypedArray, TYPED_CONSTRUCTOR, true);\n    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);\n    hide(TypedArrayPrototype, VIEW, true);\n    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);\n\n    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {\n      dP(TypedArrayPrototype, TAG, {\n        get: function () { return NAME; }\n      });\n    }\n\n    O[NAME] = TypedArray;\n\n    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);\n\n    $export($export.S, NAME, {\n      BYTES_PER_ELEMENT: BYTES\n    });\n\n    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {\n      from: $from,\n      of: $of\n    });\n\n    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);\n\n    $export($export.P, NAME, proto);\n\n    setSpecies(NAME);\n\n    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });\n\n    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);\n\n    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;\n\n    $export($export.P + $export.F * fails(function () {\n      new TypedArray(1).slice();\n    }), NAME, { slice: $slice });\n\n    $export($export.P + $export.F * (fails(function () {\n      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();\n    }) || !fails(function () {\n      TypedArrayPrototype.toLocaleString.call([1, 2]);\n    })), NAME, { toLocaleString: $toLocaleString });\n\n    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;\n    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);\n  };\n} else module.exports = function () { /* empty */ };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUF3RCxXQUFXOztBQUVuRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSyxXQUFXLGVBQWU7O0FBRS9CO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLLFlBQVksaUNBQWlDOztBQUVsRDtBQUNBO0FBQ0E7QUFDQSxFQUFFLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qcz9lYzMwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpKSB7XG4gIHZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xuICB2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG4gIHZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG4gIHZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4gIHZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xuICB2YXIgJGJ1ZmZlciA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpO1xuICB2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG4gIHZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbiAgdmFyIHByb3BlcnR5RGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbiAgdmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG4gIHZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xuICB2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xuICB2YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbiAgdmFyIHRvSW5kZXggPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xuICB2YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbiAgdmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG4gIHZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbiAgdmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG4gIHZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuICB2YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbiAgdmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xuICB2YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xuICB2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG4gIHZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xuICB2YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbiAgdmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xuICB2YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG4gIHZhciBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKTtcbiAgdmFyIGNyZWF0ZUFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpO1xuICB2YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuICB2YXIgQXJyYXlJdGVyYXRvcnMgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xuICB2YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG4gIHZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG4gIHZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbiAgdmFyIGFycmF5RmlsbCA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKTtcbiAgdmFyIGFycmF5Q29weVdpdGhpbiA9IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJyk7XG4gIHZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbiAgdmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbiAgdmFyIGRQID0gJERQLmY7XG4gIHZhciBnT1BEID0gJEdPUEQuZjtcbiAgdmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcbiAgdmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG4gIHZhciBVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXk7XG4gIHZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuICB2YXIgU0hBUkVEX0JVRkZFUiA9ICdTaGFyZWQnICsgQVJSQVlfQlVGRkVSO1xuICB2YXIgQllURVNfUEVSX0VMRU1FTlQgPSAnQllURVNfUEVSX0VMRU1FTlQnO1xuICB2YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXlbUFJPVE9UWVBFXTtcbiAgdmFyICRBcnJheUJ1ZmZlciA9ICRidWZmZXIuQXJyYXlCdWZmZXI7XG4gIHZhciAkRGF0YVZpZXcgPSAkYnVmZmVyLkRhdGFWaWV3O1xuICB2YXIgYXJyYXlGb3JFYWNoID0gY3JlYXRlQXJyYXlNZXRob2QoMCk7XG4gIHZhciBhcnJheUZpbHRlciA9IGNyZWF0ZUFycmF5TWV0aG9kKDIpO1xuICB2YXIgYXJyYXlTb21lID0gY3JlYXRlQXJyYXlNZXRob2QoMyk7XG4gIHZhciBhcnJheUV2ZXJ5ID0gY3JlYXRlQXJyYXlNZXRob2QoNCk7XG4gIHZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbiAgdmFyIGFycmF5RmluZEluZGV4ID0gY3JlYXRlQXJyYXlNZXRob2QoNik7XG4gIHZhciBhcnJheUluY2x1ZGVzID0gY3JlYXRlQXJyYXlJbmNsdWRlcyh0cnVlKTtcbiAgdmFyIGFycmF5SW5kZXhPZiA9IGNyZWF0ZUFycmF5SW5jbHVkZXMoZmFsc2UpO1xuICB2YXIgYXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9ycy52YWx1ZXM7XG4gIHZhciBhcnJheUtleXMgPSBBcnJheUl0ZXJhdG9ycy5rZXlzO1xuICB2YXIgYXJyYXlFbnRyaWVzID0gQXJyYXlJdGVyYXRvcnMuZW50cmllcztcbiAgdmFyIGFycmF5TGFzdEluZGV4T2YgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mO1xuICB2YXIgYXJyYXlSZWR1Y2UgPSBBcnJheVByb3RvLnJlZHVjZTtcbiAgdmFyIGFycmF5UmVkdWNlUmlnaHQgPSBBcnJheVByb3RvLnJlZHVjZVJpZ2h0O1xuICB2YXIgYXJyYXlKb2luID0gQXJyYXlQcm90by5qb2luO1xuICB2YXIgYXJyYXlTb3J0ID0gQXJyYXlQcm90by5zb3J0O1xuICB2YXIgYXJyYXlTbGljZSA9IEFycmF5UHJvdG8uc2xpY2U7XG4gIHZhciBhcnJheVRvU3RyaW5nID0gQXJyYXlQcm90by50b1N0cmluZztcbiAgdmFyIGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBBcnJheVByb3RvLnRvTG9jYWxlU3RyaW5nO1xuICB2YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG4gIHZhciBUQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJyk7XG4gIHZhciBUWVBFRF9DT05TVFJVQ1RPUiA9IHVpZCgndHlwZWRfY29uc3RydWN0b3InKTtcbiAgdmFyIERFRl9DT05TVFJVQ1RPUiA9IHVpZCgnZGVmX2NvbnN0cnVjdG9yJyk7XG4gIHZhciBBTExfQ09OU1RSVUNUT1JTID0gJHR5cGVkLkNPTlNUUjtcbiAgdmFyIFRZUEVEX0FSUkFZID0gJHR5cGVkLlRZUEVEO1xuICB2YXIgVklFVyA9ICR0eXBlZC5WSUVXO1xuICB2YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCEnO1xuXG4gIHZhciAkbWFwID0gY3JlYXRlQXJyYXlNZXRob2QoMSwgZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xuICAgIHJldHVybiBhbGxvY2F0ZShzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGVuZ3RoKTtcbiAgfSk7XG5cbiAgdmFyIExJVFRMRV9FTkRJQU4gPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBVaW50MTZBcnJheShbMV0pLmJ1ZmZlcilbMF0gPT09IDE7XG4gIH0pO1xuXG4gIHZhciBGT1JDRURfU0VUID0gISFVaW50OEFycmF5ICYmICEhVWludDhBcnJheVtQUk9UT1RZUEVdLnNldCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IFVpbnQ4QXJyYXkoMSkuc2V0KHt9KTtcbiAgfSk7XG5cbiAgdmFyIHRvT2Zmc2V0ID0gZnVuY3Rpb24gKGl0LCBCWVRFUykge1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoaXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICBpZiAoaXNPYmplY3QoaXQpICYmIFRZUEVEX0FSUkFZIGluIGl0KSByZXR1cm4gaXQ7XG4gICAgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSEnKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbiAoQywgbGVuZ3RoKSB7XG4gICAgaWYgKCEoaXNPYmplY3QoQykgJiYgVFlQRURfQ09OU1RSVUNUT1IgaW4gQykpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSXQgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IhJyk7XG4gICAgfSByZXR1cm4gbmV3IEMobGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgc3BlY2llc0Zyb21MaXN0ID0gZnVuY3Rpb24gKE8sIGxpc3QpIHtcbiAgICByZXR1cm4gZnJvbUxpc3Qoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxpc3QpO1xuICB9O1xuXG4gIHZhciBmcm9tTGlzdCA9IGZ1bmN0aW9uIChDLCBsaXN0KSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IGFsbG9jYXRlKEMsIGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbiAoaXQsIGtleSwgaW50ZXJuYWwpIHtcbiAgICBkUChpdCwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZFtpbnRlcm5hbF07IH0gfSk7XG4gIH07XG5cbiAgdmFyICRmcm9tID0gZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBmbiwgdGhpc0FyZyAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3Qoc291cmNlKTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGksIGxlbmd0aCwgdmFsdWVzLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICFpc0FycmF5SXRlcihpdGVyRm4pKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHZhbHVlcyA9IFtdLCBpID0gMDsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpKyspIHtcbiAgICAgICAgdmFsdWVzLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICB9IE8gPSB2YWx1ZXM7XG4gICAgfVxuICAgIGlmIChtYXBwaW5nICYmIGFMZW4gPiAyKSBtYXBmbiA9IGN0eChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCksIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7IGxlbmd0aCA+IGk7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gbWFwcGluZyA/IG1hcGZuKE9baV0sIGkpIDogT1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgJG9mID0gZnVuY3Rpb24gb2YoLyogLi4uaXRlbXMgKi8pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIGlPUyBTYWZhcmkgNi54IGZhaWxzIGhlcmVcbiAgdmFyIFRPX0xPQ0FMRV9CVUcgPSAhIVVpbnQ4QXJyYXkgJiYgZmFpbHMoZnVuY3Rpb24gKCkgeyBhcnJheVRvTG9jYWxlU3RyaW5nLmNhbGwobmV3IFVpbnQ4QXJyYXkoMSkpOyB9KTtcblxuICB2YXIgJHRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoKSB7XG4gICAgcmV0dXJuIGFycmF5VG9Mb2NhbGVTdHJpbmcuYXBwbHkoVE9fTE9DQUxFX0JVRyA/IGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSkgOiB2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgcHJvdG8gPSB7XG4gICAgY29weVdpdGhpbjogZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0IC8qICwgZW5kICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlDb3B5V2l0aGluLmNhbGwodmFsaWRhdGUodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5RXZlcnkodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCwgZW5kICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUZpbGwuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheUZpbHRlcih2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbixcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKTtcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5RmluZCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChwcmVkaWNhdGUgLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kSW5kZXgodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgYXJyYXlGb3JFYWNoKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUluZGV4T2YodmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlJbmNsdWRlcyh2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUxhc3RJbmRleE9mLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiBtYXAobWFwZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gJG1hcCh2YWxpZGF0ZSh0aGlzKSwgbWFwZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlUmlnaHQuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGxlbmd0aCA9IHZhbGlkYXRlKHRoYXQpLmxlbmd0aDtcbiAgICAgIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKGxlbmd0aCAvIDIpO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHdoaWxlIChpbmRleCA8IG1pZGRsZSkge1xuICAgICAgICB2YWx1ZSA9IHRoYXRbaW5kZXhdO1xuICAgICAgICB0aGF0W2luZGV4KytdID0gdGhhdFstLWxlbmd0aF07XG4gICAgICAgIHRoYXRbbGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgfSByZXR1cm4gdGhhdDtcbiAgICB9LFxuICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheVNvbWUodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgICByZXR1cm4gYXJyYXlTb3J0LmNhbGwodmFsaWRhdGUodGhpcyksIGNvbXBhcmVmbik7XG4gICAgfSxcbiAgICBzdWJhcnJheTogZnVuY3Rpb24gc3ViYXJyYXkoYmVnaW4sIGVuZCkge1xuICAgICAgdmFyIE8gPSB2YWxpZGF0ZSh0aGlzKTtcbiAgICAgIHZhciBsZW5ndGggPSBPLmxlbmd0aDtcbiAgICAgIHZhciAkYmVnaW4gPSB0b0Fic29sdXRlSW5kZXgoYmVnaW4sIGxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSkoXG4gICAgICAgIE8uYnVmZmVyLFxuICAgICAgICBPLmJ5dGVPZmZzZXQgKyAkYmVnaW4gKiBPLkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICB0b0xlbmd0aCgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpKSAtICRiZWdpbilcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIHZhciAkc2xpY2UgPSBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcyksIHN0YXJ0LCBlbmQpKTtcbiAgfTtcblxuICB2YXIgJHNldCA9IGZ1bmN0aW9uIHNldChhcnJheUxpa2UgLyogLCBvZmZzZXQgKi8pIHtcbiAgICB2YWxpZGF0ZSh0aGlzKTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9PZmZzZXQoYXJndW1lbnRzWzFdLCAxKTtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgdmFyIHNyYyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHNyYy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgaWYgKGxlbiArIG9mZnNldCA+IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbikgdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG4gIH07XG5cbiAgdmFyICRpdGVyYXRvcnMgPSB7XG4gICAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgIHJldHVybiBhcnJheUVudHJpZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgcmV0dXJuIGFycmF5S2V5cy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIGFycmF5VmFsdWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNUQUluZGV4ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHRhcmdldClcbiAgICAgICYmIHRhcmdldFtUWVBFRF9BUlJBWV1cbiAgICAgICYmIHR5cGVvZiBrZXkgIT0gJ3N5bWJvbCdcbiAgICAgICYmIGtleSBpbiB0YXJnZXRcbiAgICAgICYmIFN0cmluZygra2V5KSA9PSBTdHJpbmcoa2V5KTtcbiAgfTtcbiAgdmFyICRnZXREZXNjID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICA/IHByb3BlcnR5RGVzYygyLCB0YXJnZXRba2V5XSlcbiAgICAgIDogZ09QRCh0YXJnZXQsIGtleSk7XG4gIH07XG4gIHZhciAkc2V0RGVzYyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgaWYgKGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICAmJiBpc09iamVjdChkZXNjKVxuICAgICAgJiYgaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgICAmJiAhaGFzKGRlc2MsICdnZXQnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnc2V0JylcbiAgICAgIC8vIFRPRE86IGFkZCB2YWxpZGF0aW9uIGRlc2NyaXB0b3Igdy9vIGNhbGxpbmcgYWNjZXNzb3JzXG4gICAgICAmJiAhZGVzYy5jb25maWd1cmFibGVcbiAgICAgICYmICghaGFzKGRlc2MsICd3cml0YWJsZScpIHx8IGRlc2Mud3JpdGFibGUpXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnZW51bWVyYWJsZScpIHx8IGRlc2MuZW51bWVyYWJsZSlcbiAgICApIHtcbiAgICAgIHRhcmdldFtrZXldID0gZGVzYy52YWx1ZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSByZXR1cm4gZFAodGFyZ2V0LCBrZXksIGRlc2MpO1xuICB9O1xuXG4gIGlmICghQUxMX0NPTlNUUlVDVE9SUykge1xuICAgICRHT1BELmYgPSAkZ2V0RGVzYztcbiAgICAkRFAuZiA9ICRzZXREZXNjO1xuICB9XG5cbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhQUxMX0NPTlNUUlVDVE9SUywgJ09iamVjdCcsIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXREZXNjLFxuICAgIGRlZmluZVByb3BlcnR5OiAkc2V0RGVzY1xuICB9KTtcblxuICBpZiAoZmFpbHMoZnVuY3Rpb24gKCkgeyBhcnJheVRvU3RyaW5nLmNhbGwoe30pOyB9KSkge1xuICAgIGFycmF5VG9TdHJpbmcgPSBhcnJheVRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciAkVHlwZWRBcnJheVByb3RvdHlwZSQgPSByZWRlZmluZUFsbCh7fSwgcHJvdG8pO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsICRpdGVyYXRvcnMpO1xuICBoaWRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgSVRFUkFUT1IsICRpdGVyYXRvcnMudmFsdWVzKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCB7XG4gICAgc2xpY2U6ICRzbGljZSxcbiAgICBzZXQ6ICRzZXQsXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHsgLyogbm9vcCAqLyB9LFxuICAgIHRvU3RyaW5nOiBhcnJheVRvU3RyaW5nLFxuICAgIHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmdcbiAgfSk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdidWZmZXInLCAnYicpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZU9mZnNldCcsICdvJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlTGVuZ3RoJywgJ2wnKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2xlbmd0aCcsICdlJyk7XG4gIGRQKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgVEFHLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW1RZUEVEX0FSUkFZXTsgfVxuICB9KTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBCWVRFUywgd3JhcHBlciwgQ0xBTVBFRCkge1xuICAgIENMQU1QRUQgPSAhIUNMQU1QRUQ7XG4gICAgdmFyIE5BTUUgPSBLRVkgKyAoQ0xBTVBFRCA/ICdDbGFtcGVkJyA6ICcnKSArICdBcnJheSc7XG4gICAgdmFyIEdFVFRFUiA9ICdnZXQnICsgS0VZO1xuICAgIHZhciBTRVRURVIgPSAnc2V0JyArIEtFWTtcbiAgICB2YXIgVHlwZWRBcnJheSA9IGdsb2JhbFtOQU1FXTtcbiAgICB2YXIgQmFzZSA9IFR5cGVkQXJyYXkgfHwge307XG4gICAgdmFyIFRBQyA9IFR5cGVkQXJyYXkgJiYgZ2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheSk7XG4gICAgdmFyIEZPUkNFRCA9ICFUeXBlZEFycmF5IHx8ICEkdHlwZWQuQUJWO1xuICAgIHZhciBPID0ge307XG4gICAgdmFyIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5ICYmIFR5cGVkQXJyYXlbUFJPVE9UWVBFXTtcbiAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICByZXR1cm4gZGF0YS52W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgaWYgKENMQU1QRUQpIHZhbHVlID0gKHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSkpIDwgMCA/IDAgOiB2YWx1ZSA+IDB4ZmYgPyAweGZmIDogdmFsdWUgJiAweGZmO1xuICAgICAgZGF0YS52W1NFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgdmFsdWUsIExJVFRMRV9FTkRJQU4pO1xuICAgIH07XG4gICAgdmFyIGFkZEVsZW1lbnQgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIGRQKHRoYXQsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBnZXR0ZXIodGhpcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzZXR0ZXIodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSB7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUsICdfZCcpO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGJ1ZmZlciwgYnl0ZUxlbmd0aCwgbGVuZ3RoLCBrbGFzcztcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgICAgIGxlbmd0aCA9IHRvSW5kZXgoZGF0YSk7XG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IGxlbmd0aCAqIEJZVEVTO1xuICAgICAgICAgIGJ1ZmZlciA9IG5ldyAkQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUikge1xuICAgICAgICAgIGJ1ZmZlciA9IGRhdGE7XG4gICAgICAgICAgb2Zmc2V0ID0gdG9PZmZzZXQoJG9mZnNldCwgQllURVMpO1xuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmICgkbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgkbGVuICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPCAwKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCgkbGVuZ3RoKSAqIEJZVEVTO1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggKyBvZmZzZXQgPiAkbGVuKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCA9IGJ5dGVMZW5ndGggLyBCWVRFUztcbiAgICAgICAgfSBlbHNlIGlmIChUWVBFRF9BUlJBWSBpbiBkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGhpZGUodGhhdCwgJ19kJywge1xuICAgICAgICAgIGI6IGJ1ZmZlcixcbiAgICAgICAgICBvOiBvZmZzZXQsXG4gICAgICAgICAgbDogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBlOiBsZW5ndGgsXG4gICAgICAgICAgdjogbmV3ICREYXRhVmlldyhidWZmZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIGFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBjcmVhdGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkKTtcbiAgICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheSk7XG4gICAgfSBlbHNlIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgVHlwZWRBcnJheSgxKTtcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0pIHx8ICEkaXRlckRldGVjdChmdW5jdGlvbiAoaXRlcikge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KG51bGwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KGl0ZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0sIHRydWUpKSB7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUpO1xuICAgICAgICB2YXIga2xhc3M7XG4gICAgICAgIC8vIGB3c2AgbW9kdWxlIGJ1ZywgdGVtcG9yYXJpbHkgcmVtb3ZlIHZhbGlkYXRpb24gbGVuZ3RoIGZvciBVaW50OEFycmF5XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL3B1bGwvNjQ1XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHJldHVybiBuZXcgQmFzZSh0b0luZGV4KGRhdGEpKTtcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpIHtcbiAgICAgICAgICByZXR1cm4gJGxlbmd0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSwgJGxlbmd0aClcbiAgICAgICAgICAgIDogJG9mZnNldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpKVxuICAgICAgICAgICAgICA6IG5ldyBCYXNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChUWVBFRF9BUlJBWSBpbiBkYXRhKSByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBhcnJheUZvckVhY2goVEFDICE9PSBGdW5jdGlvbi5wcm90b3R5cGUgPyBnT1BOKEJhc2UpLmNvbmNhdChnT1BOKFRBQykpIDogZ09QTihCYXNlKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gVHlwZWRBcnJheSkpIGhpZGUoVHlwZWRBcnJheSwga2V5LCBCYXNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBUeXBlZEFycmF5UHJvdG90eXBlO1xuICAgICAgaWYgKCFMSUJSQVJZKSBUeXBlZEFycmF5UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHlwZWRBcnJheTtcbiAgICB9XG4gICAgdmFyICRuYXRpdmVJdGVyYXRvciA9IFR5cGVkQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdO1xuICAgIHZhciBDT1JSRUNUX0lURVJfTkFNRSA9ICEhJG5hdGl2ZUl0ZXJhdG9yXG4gICAgICAmJiAoJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gJ3ZhbHVlcycgfHwgJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gdW5kZWZpbmVkKTtcbiAgICB2YXIgJGl0ZXJhdG9yID0gJGl0ZXJhdG9ycy52YWx1ZXM7XG4gICAgaGlkZShUeXBlZEFycmF5LCBUWVBFRF9DT05TVFJVQ1RPUiwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBUWVBFRF9BUlJBWSwgTkFNRSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIERFRl9DT05TVFJVQ1RPUiwgVHlwZWRBcnJheSk7XG5cbiAgICBpZiAoQ0xBTVBFRCA/IG5ldyBUeXBlZEFycmF5KDEpW1RBR10gIT0gTkFNRSA6ICEoVEFHIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKSB7XG4gICAgICBkUChUeXBlZEFycmF5UHJvdG90eXBlLCBUQUcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBOQU1FOyB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBPW05BTUVdID0gVHlwZWRBcnJheTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXkgIT0gQmFzZSksIE8pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMsIE5BTUUsIHtcbiAgICAgIEJZVEVTX1BFUl9FTEVNRU5UOiBCWVRFU1xuICAgIH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IEJhc2Uub2YuY2FsbChUeXBlZEFycmF5LCAxKTsgfSksIE5BTUUsIHtcbiAgICAgIGZyb206ICRmcm9tLFxuICAgICAgb2Y6ICRvZlxuICAgIH0pO1xuXG4gICAgaWYgKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgQllURVNfUEVSX0VMRU1FTlQsIEJZVEVTKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QLCBOQU1FLCBwcm90byk7XG5cbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRURfU0VULCBOQU1FLCB7IHNldDogJHNldCB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIUNPUlJFQ1RfSVRFUl9OQU1FLCBOQU1FLCAkaXRlcmF0b3JzKTtcblxuICAgIGlmICghTElCUkFSWSAmJiBUeXBlZEFycmF5UHJvdG90eXBlLnRvU3RyaW5nICE9IGFycmF5VG9TdHJpbmcpIFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgPSBhcnJheVRvU3RyaW5nO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgxKS5zbGljZSgpO1xuICAgIH0pLCBOQU1FLCB7IHNsaWNlOiAkc2xpY2UgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IFR5cGVkQXJyYXkoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpO1xuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsIDJdKTtcbiAgICB9KSksIE5BTUUsIHsgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZyB9KTtcblxuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IENPUlJFQ1RfSVRFUl9OQU1FID8gJG5hdGl2ZUl0ZXJhdG9yIDogJGl0ZXJhdG9yO1xuICAgIGlmICghTElCUkFSWSAmJiAhQ09SUkVDVF9JVEVSX05BTUUpIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgSVRFUkFUT1IsICRpdGVyYXRvcik7XG4gIH07XG59IGVsc2UgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7209\n")},8032:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nvar global = __webpack_require__(7526);\nvar DESCRIPTORS = __webpack_require__(1763);\nvar LIBRARY = __webpack_require__(2750);\nvar $typed = __webpack_require__(237);\nvar hide = __webpack_require__(3341);\nvar redefineAll = __webpack_require__(6065);\nvar fails = __webpack_require__(9448);\nvar anInstance = __webpack_require__(6440);\nvar toInteger = __webpack_require__(7087);\nvar toLength = __webpack_require__(1485);\nvar toIndex = __webpack_require__(3133);\nvar gOPN = (__webpack_require__(9415).f);\nvar dP = (__webpack_require__(7967).f);\nvar arrayFill = __webpack_require__(5564);\nvar setToStringTag = __webpack_require__(3844);\nvar ARRAY_BUFFER = 'ArrayBuffer';\nvar DATA_VIEW = 'DataView';\nvar PROTOTYPE = 'prototype';\nvar WRONG_LENGTH = 'Wrong length!';\nvar WRONG_INDEX = 'Wrong index!';\nvar $ArrayBuffer = global[ARRAY_BUFFER];\nvar $DataView = global[DATA_VIEW];\nvar Math = global.Math;\nvar RangeError = global.RangeError;\n// eslint-disable-next-line no-shadow-restricted-names\nvar Infinity = global.Infinity;\nvar BaseBuffer = $ArrayBuffer;\nvar abs = Math.abs;\nvar pow = Math.pow;\nvar floor = Math.floor;\nvar log = Math.log;\nvar LN2 = Math.LN2;\nvar BUFFER = 'buffer';\nvar BYTE_LENGTH = 'byteLength';\nvar BYTE_OFFSET = 'byteOffset';\nvar $BUFFER = DESCRIPTORS ? '_b' : BUFFER;\nvar $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;\nvar $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;\n\n// IEEE754 conversions based on https://github.com/feross/ieee754\nfunction packIEEE754(value, mLen, nBytes) {\n  var buffer = new Array(nBytes);\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;\n  var i = 0;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n  var e, m, c;\n  value = abs(value);\n  // eslint-disable-next-line no-self-compare\n  if (value != value || value === Infinity) {\n    // eslint-disable-next-line no-self-compare\n    m = value != value ? 1 : 0;\n    e = eMax;\n  } else {\n    e = floor(log(value) / LN2);\n    if (value * (c = pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * pow(2, eBias - 1) * pow(2, mLen);\n      e = 0;\n    }\n  }\n  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);\n  e = e << mLen | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);\n  buffer[--i] |= s * 128;\n  return buffer;\n}\nfunction unpackIEEE754(buffer, mLen, nBytes) {\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = eLen - 7;\n  var i = nBytes - 1;\n  var s = buffer[i--];\n  var e = s & 127;\n  var m;\n  s >>= 7;\n  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : s ? -Infinity : Infinity;\n  } else {\n    m = m + pow(2, mLen);\n    e = e - eBias;\n  } return (s ? -1 : 1) * m * pow(2, e - mLen);\n}\n\nfunction unpackI32(bytes) {\n  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];\n}\nfunction packI8(it) {\n  return [it & 0xff];\n}\nfunction packI16(it) {\n  return [it & 0xff, it >> 8 & 0xff];\n}\nfunction packI32(it) {\n  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];\n}\nfunction packF64(it) {\n  return packIEEE754(it, 52, 8);\n}\nfunction packF32(it) {\n  return packIEEE754(it, 23, 4);\n}\n\nfunction addGetter(C, key, internal) {\n  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });\n}\n\nfunction get(view, bytes, index, isLittleEndian) {\n  var numIndex = +index;\n  var intIndex = toIndex(numIndex);\n  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b;\n  var start = intIndex + view[$OFFSET];\n  var pack = store.slice(start, start + bytes);\n  return isLittleEndian ? pack : pack.reverse();\n}\nfunction set(view, bytes, index, conversion, value, isLittleEndian) {\n  var numIndex = +index;\n  var intIndex = toIndex(numIndex);\n  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b;\n  var start = intIndex + view[$OFFSET];\n  var pack = conversion(+value);\n  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];\n}\n\nif (!$typed.ABV) {\n  $ArrayBuffer = function ArrayBuffer(length) {\n    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);\n    var byteLength = toIndex(length);\n    this._b = arrayFill.call(new Array(byteLength), 0);\n    this[$LENGTH] = byteLength;\n  };\n\n  $DataView = function DataView(buffer, byteOffset, byteLength) {\n    anInstance(this, $DataView, DATA_VIEW);\n    anInstance(buffer, $ArrayBuffer, DATA_VIEW);\n    var bufferLength = buffer[$LENGTH];\n    var offset = toInteger(byteOffset);\n    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');\n    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);\n    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);\n    this[$BUFFER] = buffer;\n    this[$OFFSET] = offset;\n    this[$LENGTH] = byteLength;\n  };\n\n  if (DESCRIPTORS) {\n    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');\n    addGetter($DataView, BUFFER, '_b');\n    addGetter($DataView, BYTE_LENGTH, '_l');\n    addGetter($DataView, BYTE_OFFSET, '_o');\n  }\n\n  redefineAll($DataView[PROTOTYPE], {\n    getInt8: function getInt8(byteOffset) {\n      return get(this, 1, byteOffset)[0] << 24 >> 24;\n    },\n    getUint8: function getUint8(byteOffset) {\n      return get(this, 1, byteOffset)[0];\n    },\n    getInt16: function getInt16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n    },\n    getUint16: function getUint16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return bytes[1] << 8 | bytes[0];\n    },\n    getInt32: function getInt32(byteOffset /* , littleEndian */) {\n      return unpackI32(get(this, 4, byteOffset, arguments[1]));\n    },\n    getUint32: function getUint32(byteOffset /* , littleEndian */) {\n      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;\n    },\n    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);\n    },\n    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);\n    },\n    setInt8: function setInt8(byteOffset, value) {\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packF32, value, arguments[2]);\n    },\n    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {\n      set(this, 8, byteOffset, packF64, value, arguments[2]);\n    }\n  });\n} else {\n  if (!fails(function () {\n    $ArrayBuffer(1);\n  }) || !fails(function () {\n    new $ArrayBuffer(-1); // eslint-disable-line no-new\n  }) || fails(function () {\n    new $ArrayBuffer(); // eslint-disable-line no-new\n    new $ArrayBuffer(1.5); // eslint-disable-line no-new\n    new $ArrayBuffer(NaN); // eslint-disable-line no-new\n    return $ArrayBuffer.name != ARRAY_BUFFER;\n  })) {\n    $ArrayBuffer = function ArrayBuffer(length) {\n      anInstance(this, $ArrayBuffer);\n      return new BaseBuffer(toIndex(length));\n    };\n    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];\n    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {\n      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);\n    }\n    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;\n  }\n  // iOS Safari 7.x bug\n  var view = new $DataView(new $ArrayBuffer(2));\n  var $setInt8 = $DataView[PROTOTYPE].setInt8;\n  view.setInt8(0, 2147483648);\n  view.setInt8(1, 2147483649);\n  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {\n    setInt8: function setInt8(byteOffset, value) {\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    }\n  }, true);\n}\nsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\nsetToStringTag($DataView, DATA_VIEW);\nhide($DataView[PROTOTYPE], $typed.VIEW, true);\nexports[ARRAY_BUFFER] = $ArrayBuffer;\nexports[DATA_VIEW] = $DataView;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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MkI7QUFDM0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzP2VkMGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0luZGV4ID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBhcnJheUZpbGwgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG52YXIgREFUQV9WSUVXID0gJ0RhdGFWaWV3JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG52YXIgV1JPTkdfSU5ERVggPSAnV3JvbmcgaW5kZXghJztcbnZhciAkQXJyYXlCdWZmZXIgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXTtcbnZhciAkRGF0YVZpZXcgPSBnbG9iYWxbREFUQV9WSUVXXTtcbnZhciBNYXRoID0gZ2xvYmFsLk1hdGg7XG52YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvdy1yZXN0cmljdGVkLW5hbWVzXG52YXIgSW5maW5pdHkgPSBnbG9iYWwuSW5maW5pdHk7XG52YXIgQmFzZUJ1ZmZlciA9ICRBcnJheUJ1ZmZlcjtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG52YXIgQlVGRkVSID0gJ2J1ZmZlcic7XG52YXIgQllURV9MRU5HVEggPSAnYnl0ZUxlbmd0aCc7XG52YXIgQllURV9PRkZTRVQgPSAnYnl0ZU9mZnNldCc7XG52YXIgJEJVRkZFUiA9IERFU0NSSVBUT1JTID8gJ19iJyA6IEJVRkZFUjtcbnZhciAkTEVOR1RIID0gREVTQ1JJUFRPUlMgPyAnX2wnIDogQllURV9MRU5HVEg7XG52YXIgJE9GRlNFVCA9IERFU0NSSVBUT1JTID8gJ19vJyA6IEJZVEVfT0ZGU0VUO1xuXG4vLyBJRUVFNzU0IGNvbnZlcnNpb25zIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxuZnVuY3Rpb24gcGFja0lFRUU3NTQodmFsdWUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KG5CeXRlcyk7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSBtTGVuID09PSAyMyA/IHBvdygyLCAtMjQpIC0gcG93KDIsIC03NykgOiAwO1xuICB2YXIgaSA9IDA7XG4gIHZhciBzID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAxIDogMDtcbiAgdmFyIGUsIG0sIGM7XG4gIHZhbHVlID0gYWJzKHZhbHVlKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICBpZiAodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIG0gPSB2YWx1ZSAhPSB2YWx1ZSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBmbG9vcihsb2codmFsdWUpIC8gTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IHBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBwb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW2krK10gPSBtICYgMjU1LCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcbiAgZSA9IGUgPDwgbUxlbiB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbaSsrXSA9IGUgJiAyNTUsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuICBidWZmZXJbLS1pXSB8PSBzICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufVxuZnVuY3Rpb24gdW5wYWNrSUVFRTc1NChidWZmZXIsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIG5CaXRzID0gZUxlbiAtIDc7XG4gIHZhciBpID0gbkJ5dGVzIC0gMTtcbiAgdmFyIHMgPSBidWZmZXJbaS0tXTtcbiAgdmFyIGUgPSBzICYgMTI3O1xuICB2YXIgbTtcbiAgcyA+Pj0gNztcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGUgPj49IC1uQml0cztcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiBzID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBwb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfSByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIHBvdygyLCBlIC0gbUxlbik7XG59XG5cbmZ1bmN0aW9uIHVucGFja0kzMihieXRlcykge1xuICByZXR1cm4gYnl0ZXNbM10gPDwgMjQgfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbn1cbmZ1bmN0aW9uIHBhY2tJOChpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrSTE2KGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrSTMyKGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZiwgaXQgPj4gMTYgJiAweGZmLCBpdCA+PiAyNCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0Y2NChpdCkge1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDUyLCA4KTtcbn1cbmZ1bmN0aW9uIHBhY2tGMzIoaXQpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCAyMywgNCk7XG59XG5cbmZ1bmN0aW9uIGFkZEdldHRlcihDLCBrZXksIGludGVybmFsKSB7XG4gIGRQKENbUFJPVE9UWVBFXSwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tpbnRlcm5hbF07IH0gfSk7XG59XG5cbmZ1bmN0aW9uIGdldCh2aWV3LCBieXRlcywgaW5kZXgsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChudW1JbmRleCk7XG4gIGlmIChpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2I7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXTtcbiAgdmFyIHBhY2sgPSBzdG9yZS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcyk7XG4gIHJldHVybiBpc0xpdHRsZUVuZGlhbiA/IHBhY2sgOiBwYWNrLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIHNldCh2aWV3LCBieXRlcywgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICBpZiAoaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF07XG4gIHZhciBwYWNrID0gY29udmVyc2lvbigrdmFsdWUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHN0b3JlW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGJ5dGVzIC0gaSAtIDFdO1xufVxuXG5pZiAoISR0eXBlZC5BQlYpIHtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0b0luZGV4KGxlbmd0aCk7XG4gICAgdGhpcy5fYiA9IGFycmF5RmlsbC5jYWxsKG5ldyBBcnJheShieXRlTGVuZ3RoKSwgMCk7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgJERhdGFWaWV3ID0gZnVuY3Rpb24gRGF0YVZpZXcoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkRGF0YVZpZXcsIERBVEFfVklFVyk7XG4gICAgYW5JbnN0YW5jZShidWZmZXIsICRBcnJheUJ1ZmZlciwgREFUQV9WSUVXKTtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYnVmZmVyWyRMRU5HVEhdO1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoKGJ5dGVMZW5ndGgpO1xuICAgIGlmIChvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgdGhpc1skQlVGRkVSXSA9IGJ1ZmZlcjtcbiAgICB0aGlzWyRPRkZTRVRdID0gb2Zmc2V0O1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIGFkZEdldHRlcigkQXJyYXlCdWZmZXIsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCVUZGRVIsICdfYicpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX09GRlNFVCwgJ19vJyk7XG4gIH1cblxuICByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXSA8PCAyNCA+PiAyNDtcbiAgICB9LFxuICAgIGdldFVpbnQ4OiBmdW5jdGlvbiBnZXRVaW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIChieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF0pIDw8IDE2ID4+IDE2O1xuICAgIH0sXG4gICAgZ2V0VWludDE2OiBmdW5jdGlvbiBnZXRVaW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSkgPj4+IDA7XG4gICAgfSxcbiAgICBnZXRGbG9hdDMyOiBmdW5jdGlvbiBnZXRGbG9hdDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCAyMywgNCk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCA1MiwgOCk7XG4gICAgfSxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEludDE2OiBmdW5jdGlvbiBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDE2OiBmdW5jdGlvbiBzZXRVaW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEludDMyOiBmdW5jdGlvbiBzZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDMyOiBmdW5jdGlvbiBzZXRVaW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0MzI6IGZ1bmN0aW9uIHNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRjMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0NjQ6IGZ1bmN0aW9uIHNldEZsb2F0NjQoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRjY0LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgJEFycmF5QnVmZmVyKDEpO1xuICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9KSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgJEFycmF5QnVmZmVyKE5hTik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgcmV0dXJuICRBcnJheUJ1ZmZlci5uYW1lICE9IEFSUkFZX0JVRkZFUjtcbiAgfSkpIHtcbiAgICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyKTtcbiAgICAgIHJldHVybiBuZXcgQmFzZUJ1ZmZlcih0b0luZGV4KGxlbmd0aCkpO1xuICAgIH07XG4gICAgdmFyIEFycmF5QnVmZmVyUHJvdG8gPSAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXSA9IEJhc2VCdWZmZXJbUFJPVE9UWVBFXTtcbiAgICBmb3IgKHZhciBrZXlzID0gZ09QTihCYXNlQnVmZmVyKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOykge1xuICAgICAgaWYgKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSkgaGlkZSgkQXJyYXlCdWZmZXIsIGtleSwgQmFzZUJ1ZmZlcltrZXldKTtcbiAgICB9XG4gICAgaWYgKCFMSUJSQVJZKSBBcnJheUJ1ZmZlclByb3RvLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9XG4gIC8vIGlPUyBTYWZhcmkgNy54IGJ1Z1xuICB2YXIgdmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSk7XG4gIHZhciAkc2V0SW50OCA9ICREYXRhVmlld1tQUk9UT1RZUEVdLnNldEludDg7XG4gIHZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdmlldy5zZXRJbnQ4KDEsIDIxNDc0ODM2NDkpO1xuICBpZiAodmlldy5nZXRJbnQ4KDApIHx8ICF2aWV3LmdldEludDgoMSkpIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG59XG5zZXRUb1N0cmluZ1RhZygkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5zZXRUb1N0cmluZ1RhZygkRGF0YVZpZXcsIERBVEFfVklFVyk7XG5oaWRlKCREYXRhVmlld1tQUk9UT1RZUEVdLCAkdHlwZWQuVklFVywgdHJ1ZSk7XG5leHBvcnRzW0FSUkFZX0JVRkZFUl0gPSAkQXJyYXlCdWZmZXI7XG5leHBvcnRzW0RBVEFfVklFV10gPSAkRGF0YVZpZXc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8032\n")},237:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var global = __webpack_require__(7526);\nvar hide = __webpack_require__(3341);\nvar uid = __webpack_require__(4415);\nvar TYPED = uid('typed_array');\nvar VIEW = uid('view');\nvar ABV = !!(global.ArrayBuffer && global.DataView);\nvar CONSTR = ABV;\nvar i = 0;\nvar l = 9;\nvar Typed;\n\nvar TypedArrayConstructors = (\n  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'\n).split(',');\n\nwhile (i < l) {\n  if (Typed = global[TypedArrayConstructors[i++]]) {\n    hide(Typed.prototype, TYPED, true);\n    hide(Typed.prototype, VIEW, true);\n  } else CONSTR = false;\n}\n\nmodule.exports = {\n  ABV: ABV,\n  CONSTR: CONSTR,\n  TYPED: TYPED,\n  VIEW: VIEW\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM3LmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyxJQUFXO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQyxJQUFTO0FBQzVCLFVBQVUsbUJBQU8sQ0FBQyxJQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQuanM/MGY4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBUWVBFRCA9IHVpZCgndHlwZWRfYXJyYXknKTtcbnZhciBWSUVXID0gdWlkKCd2aWV3Jyk7XG52YXIgQUJWID0gISEoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGdsb2JhbC5EYXRhVmlldyk7XG52YXIgQ09OU1RSID0gQUJWO1xudmFyIGkgPSAwO1xudmFyIGwgPSA5O1xudmFyIFR5cGVkO1xuXG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9IChcbiAgJ0ludDhBcnJheSxVaW50OEFycmF5LFVpbnQ4Q2xhbXBlZEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5J1xuKS5zcGxpdCgnLCcpO1xuXG53aGlsZSAoaSA8IGwpIHtcbiAgaWYgKFR5cGVkID0gZ2xvYmFsW1R5cGVkQXJyYXlDb25zdHJ1Y3RvcnNbaSsrXV0pIHtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVFlQRUQsIHRydWUpO1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgfSBlbHNlIENPTlNUUiA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQUJWOiBBQlYsXG4gIENPTlNUUjogQ09OU1RSLFxuICBUWVBFRDogVFlQRUQsXG4gIFZJRVc6IFZJRVdcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///237\n")},4415:module=>{eval("var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQxNS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcz9jYTVhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4415\n")},4514:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var global = __webpack_require__(7526);\nvar navigator = global.navigator;\n\nmodule.exports = navigator && navigator.userAgent || '';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDUxNC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBVztBQUNoQzs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191c2VyLWFnZW50LmpzP2EyNWYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG5hdmlnYXRvciA9IGdsb2JhbC5uYXZpZ2F0b3I7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4514\n")},2888:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var isObject = __webpack_require__(3305);\nmodule.exports = function (it, TYPE) {\n  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');\n  return it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg4OC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL192YWxpZGF0ZS1jb2xsZWN0aW9uLmpzP2IzOWEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVFlQRSkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSB8fCBpdC5fdCAhPT0gVFlQRSkgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2888\n")},5392:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var global = __webpack_require__(7526);\nvar core = __webpack_require__(6094);\nvar LIBRARY = __webpack_require__(2750);\nvar wksExt = __webpack_require__(7960);\nvar defineProperty = (__webpack_require__(7967).f);\nmodule.exports = function (name) {\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM5Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBVztBQUNoQyxXQUFXLG1CQUFPLENBQUMsSUFBUztBQUM1QixjQUFjLG1CQUFPLENBQUMsSUFBWTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsSUFBWTtBQUNqQyxxQkFBcUIsNkJBQXlCO0FBQzlDO0FBQ0EsMkRBQTJELHFCQUFxQjtBQUNoRixtRkFBbUYsdUJBQXVCO0FBQzFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1kZWZpbmUuanM/M2E3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5392\n")},7960:(__unused_webpack_module,exports,__webpack_require__)=>{eval("exports.f = __webpack_require__(7574);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk2MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxQ0FBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qcz8zN2M4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7960\n")},7574:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var store = __webpack_require__(4556)('wks');\nvar uid = __webpack_require__(4415);\nvar Symbol = (__webpack_require__(7526).Symbol);\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzU3NC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsSUFBVztBQUMvQixVQUFVLG1CQUFPLENBQUMsSUFBUTtBQUMxQixhQUFhLGtDQUEyQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanM/MmI0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7574\n")},762:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var classof = __webpack_require__(4848);\nvar ITERATOR = __webpack_require__(7574)('iterator');\nvar Iterators = __webpack_require__(906);\nmodule.exports = (__webpack_require__(6094).getIteratorMethod) = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYyLmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyxJQUFZO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQyxJQUFRO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLEdBQWM7QUFDdEMsaUJBQWlCLDZDQUFvQztBQUNyRDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcz8yN2VlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///762\n")},6289:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://github.com/benjamingr/RexExp.escape\nvar $export = __webpack_require__(2127);\nvar $re = __webpack_require__(7963)(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI4OS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLFVBQVUsbUJBQU8sQ0FBQyxJQUFhLG9CQUFvQjs7QUFFbkQsK0JBQStCLDhCQUE4QixtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUuanM/ZDBjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtaW5nci9SZXhFeHAuZXNjYXBlXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRyZSA9IHJlcXVpcmUoJy4vX3JlcGxhY2VyJykoL1tcXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVnRXhwJywgeyBlc2NhcGU6IGZ1bmN0aW9uIGVzY2FwZShpdCkgeyByZXR1cm4gJHJlKGl0KTsgfSB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6289\n")},9620:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\nvar $export = __webpack_require__(2127);\n\n$export($export.P, 'Array', { copyWithin: __webpack_require__(4438) });\n\n__webpack_require__(8184)('copyWithin');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYyMC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQyw4QkFBOEIsWUFBWSxtQkFBTyxDQUFDLElBQXNCLEdBQUc7O0FBRTNFLG1CQUFPLENBQUMsSUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4uanM/NzQ0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7IGNvcHlXaXRoaW46IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJykgfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdjb3B5V2l0aGluJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9620\n")},8888:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar $every = __webpack_require__(6179)(4);\n\n$export($export.P + $export.F * !__webpack_require__(6884)([].every, true), 'Array', {\n  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])\n  every: function every(callbackfn /* , thisArg */) {\n    return $every(this, callbackfn, arguments[1]);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODg4OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxJQUFrQjs7QUFFdkMsaUNBQWlDLG1CQUFPLENBQUMsSUFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzPzYwOTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZXZlcnkgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNCk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5ldmVyeSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjUgLyAxNS40LjQuMTYgQXJyYXkucHJvdG90eXBlLmV2ZXJ5KGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZXZlcnkodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8888\n")},7762:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\nvar $export = __webpack_require__(2127);\n\n$export($export.P, 'Array', { fill: __webpack_require__(5564) });\n\n__webpack_require__(8184)('fill');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzc2Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQyw4QkFBOEIsTUFBTSxtQkFBTyxDQUFDLElBQWUsR0FBRzs7QUFFOUQsbUJBQU8sQ0FBQyxJQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzPzZjN2IiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5JywgeyBmaWxsOiByZXF1aXJlKCcuL19hcnJheS1maWxsJykgfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmaWxsJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7762\n")},9813:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar $filter = __webpack_require__(6179)(2);\n\n$export($export.P + $export.F * !__webpack_require__(6884)([].filter, true), 'Array', {\n  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])\n  filter: function filter(callbackfn /* , thisArg */) {\n    return $filter(this, callbackfn, arguments[1]);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTgxMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyxJQUFrQjs7QUFFeEMsaUNBQWlDLG1CQUFPLENBQUMsSUFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlci5qcz9kMjVmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgyKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZpbHRlciwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjcgLyAxNS40LjQuMjAgQXJyYXkucHJvdG90eXBlLmZpbHRlcihjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9813\n")},5369:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)\nvar $export = __webpack_require__(2127);\nvar $find = __webpack_require__(6179)(6);\nvar KEY = 'findIndex';\nvar forced = true;\n// Shouldn't skip holes\nif (KEY in []) Array(1)[KEY](function () { forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  findIndex: function findIndex(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n__webpack_require__(8184)(KEY);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM2OS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsWUFBWSxtQkFBTyxDQUFDLElBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpQkFBaUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQU8sQ0FBQyxJQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4LmpzPzIwZDYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjkgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmaW5kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDYpO1xudmFyIEtFWSA9ICdmaW5kSW5kZXgnO1xudmFyIGZvcmNlZCA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEtFWSBpbiBbXSkgQXJyYXkoMSlbS0VZXShmdW5jdGlvbiAoKSB7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5369\n")},5144:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)\nvar $export = __webpack_require__(2127);\nvar $find = __webpack_require__(6179)(5);\nvar KEY = 'find';\nvar forced = true;\n// Shouldn't skip holes\nif (KEY in []) Array(1)[KEY](function () { forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  find: function find(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n__webpack_require__(8184)(KEY);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTE0NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsWUFBWSxtQkFBTyxDQUFDLElBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpQkFBaUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQU8sQ0FBQyxJQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzPzc1MTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjggQXJyYXkucHJvdG90eXBlLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmluZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg1KTtcbnZhciBLRVkgPSAnZmluZCc7XG52YXIgZm9yY2VkID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZiAoS0VZIGluIFtdKSBBcnJheSgxKVtLRVldKGZ1bmN0aW9uICgpIHsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5144\n")},3504:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar $forEach = __webpack_require__(6179)(0);\nvar STRICT = __webpack_require__(6884)([].forEach, true);\n\n$export($export.P + $export.F * !STRICT, 'Array', {\n  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])\n  forEach: function forEach(callbackfn /* , thisArg */) {\n    return $forEach(this, callbackfn, arguments[1]);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUwNC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFrQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsSUFBa0I7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoLmpzP2YzZTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZm9yRWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKTtcbnZhciBTVFJJQ1QgPSByZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZm9yRWFjaCwgdHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIVNUUklDVCwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTAgLyAxNS40LjQuMTggQXJyYXkucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3504\n")},3863:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar ctx = __webpack_require__(5052);\nvar $export = __webpack_require__(2127);\nvar toObject = __webpack_require__(8270);\nvar call = __webpack_require__(7368);\nvar isArrayIter = __webpack_require__(1508);\nvar toLength = __webpack_require__(1485);\nvar createProperty = __webpack_require__(7227);\nvar getIterFn = __webpack_require__(762);\n\n$export($export.S + $export.F * !__webpack_require__(8931)(function (iter) { Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n    var O = toObject(arrayLike);\n    var C = typeof this == 'function' ? this : Array;\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var index = 0;\n    var iterFn = getIterFn(O);\n    var length, result, step, iterator;\n    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {\n      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for (result = new C(length); length > index; index++) {\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg2My5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFVBQVUsbUJBQU8sQ0FBQyxJQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLFdBQVcsbUJBQU8sQ0FBQyxJQUFjO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLElBQWtCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLHFCQUFxQixtQkFBTyxDQUFDLElBQW9CO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLEdBQTRCOztBQUVwRCxpQ0FBaUMsbUJBQU8sQ0FBQyxJQUFnQixvQkFBb0IsbUJBQW1CO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdDQUFnQztBQUN4RjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanM/MWM0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3863\n")},4609:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar $indexOf = __webpack_require__(1464)(false);\nvar $native = [].indexOf;\nvar NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;\n\n$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(6884)($native)), 'Array', {\n  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])\n  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {\n    return NEGATIVE_ZERO\n      // convert -0 to +0\n      ? $native.apply(this, arguments) || 0\n      : $indexOf(this, searchElement, arguments[1]);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYwOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFtQjtBQUMxQztBQUNBOztBQUVBLG1EQUFtRCxtQkFBTyxDQUFDLElBQWtCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZi5qcz81N2U3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciAkbmF0aXZlID0gW10uaW5kZXhPZjtcbnZhciBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0uaW5kZXhPZigxLCAtMCkgPCAwO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMSAvIDE1LjQuNC4xNCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gTkVHQVRJVkVfWkVST1xuICAgICAgLy8gY29udmVydCAtMCB0byArMFxuICAgICAgPyAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMFxuICAgICAgOiAkaW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4609\n")},7899:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Array', { isArray: __webpack_require__(7981) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg5OS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQyw4QkFBOEIsU0FBUyxtQkFBTyxDQUFDLElBQWEsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheS5qcz8yY2FmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDIyLjEuMi4yIC8gMTUuNC4zLjIgQXJyYXkuaXNBcnJheShhcmcpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0FycmF5JywgeyBpc0FycmF5OiByZXF1aXJlKCcuL19pcy1hcnJheScpIH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7899\n")},5165:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar addToUnscopables = __webpack_require__(8184);\nvar step = __webpack_require__(4970);\nvar Iterators = __webpack_require__(906);\nvar toIObject = __webpack_require__(7221);\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = __webpack_require__(8175)(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTE2NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHVCQUF1QixtQkFBTyxDQUFDLElBQXVCO0FBQ3RELFdBQVcsbUJBQU8sQ0FBQyxJQUFjO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLEdBQWM7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMsSUFBZTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFnQjtBQUN6QyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanM/Y2FkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5165\n")},6511:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// 22.1.3.13 Array.prototype.join(separator)\nvar $export = __webpack_require__(2127);\nvar toIObject = __webpack_require__(7221);\nvar arrayJoin = [].join;\n\n// fallback for not array-like strings\n$export($export.P + $export.F * (__webpack_require__(1249) != Object || !__webpack_require__(6884)(arrayJoin)), 'Array', {\n  join: function join(separator) {\n    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjUxMS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsSUFBZTtBQUN2Qzs7QUFFQTtBQUNBLGlDQUFpQyxtQkFBTyxDQUFDLElBQVksZ0JBQWdCLG1CQUFPLENBQUMsSUFBa0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5qb2luLmpzPzM3M2YiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5qb2luKHNlcGFyYXRvcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5Sm9pbiA9IFtdLmpvaW47XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBzdHJpbmdzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChyZXF1aXJlKCcuL19pb2JqZWN0JykgIT0gT2JqZWN0IHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoYXJyYXlKb2luKSksICdBcnJheScsIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodG9JT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6511\n")},3706:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar toIObject = __webpack_require__(7221);\nvar toInteger = __webpack_require__(7087);\nvar toLength = __webpack_require__(1485);\nvar $native = [].lastIndexOf;\nvar NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;\n\n$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(6884)($native)), 'Array', {\n  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])\n  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {\n    // convert -0 to +0\n    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;\n    var O = toIObject(this);\n    var length = toLength(O.length);\n    var index = length - 1;\n    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));\n    if (index < 0) index = length + index;\n    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;\n    return -1;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcwNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsSUFBZTtBQUN2QyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQztBQUNBOztBQUVBLG1EQUFtRCxtQkFBTyxDQUFDLElBQWtCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mLmpzPzk4NjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgJG5hdGl2ZSA9IFtdLmxhc3RJbmRleE9mO1xudmFyIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5sYXN0SW5kZXhPZigxLCAtMCkgPCAwO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNCAvIDE1LjQuNC4xNSBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCA9IEBbKi0xXSAqLykge1xuICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICBpZiAoTkVHQVRJVkVfWkVSTykgcmV0dXJuICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwO1xuICAgIHZhciBPID0gdG9JT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHRvSW50ZWdlcihhcmd1bWVudHNbMV0pKTtcbiAgICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IGxlbmd0aCArIGluZGV4O1xuICAgIGZvciAoO2luZGV4ID49IDA7IGluZGV4LS0pIGlmIChpbmRleCBpbiBPKSBpZiAoT1tpbmRleF0gPT09IHNlYXJjaEVsZW1lbnQpIHJldHVybiBpbmRleCB8fCAwO1xuICAgIHJldHVybiAtMTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3706\n")},4913:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar $map = __webpack_require__(6179)(1);\n\n$export($export.P + $export.F * !__webpack_require__(6884)([].map, true), 'Array', {\n  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])\n  map: function map(callbackfn /* , thisArg */) {\n    return $map(this, callbackfn, arguments[1]);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkxMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyxJQUFrQjs7QUFFckMsaUNBQWlDLG1CQUFPLENBQUMsSUFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm1hcC5qcz82ZDY3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJG1hcCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgxKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLm1hcCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE1IC8gMTUuNC40LjE5IEFycmF5LnByb3RvdHlwZS5tYXAoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4913\n")},4570:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar createProperty = __webpack_require__(7227);\n\n// WebKit Array.of isn't generic\n$export($export.S + $export.F * __webpack_require__(9448)(function () {\n  function F() { /* empty */ }\n  return !(Array.of.call(F) instanceof F);\n}), 'Array', {\n  // 22.1.2.3 Array.of( ...items)\n  of: function of(/* ...args */) {\n    var index = 0;\n    var aLen = arguments.length;\n    var result = new (typeof this == 'function' ? this : Array)(aLen);\n    while (aLen > index) createProperty(result, index, arguments[index++]);\n    result.length = aLen;\n    return result;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU3MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLHFCQUFxQixtQkFBTyxDQUFDLElBQW9COztBQUVqRDtBQUNBLGdDQUFnQyxtQkFBTyxDQUFDLElBQVU7QUFDbEQsaUJBQWlCO0FBQ2pCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanM/ZTgwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbi8vIFdlYktpdCBBcnJheS5vZiBpc24ndCBnZW5lcmljXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiAhKEFycmF5Lm9mLmNhbGwoRikgaW5zdGFuY2VvZiBGKTtcbn0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcbiAgb2Y6IGZ1bmN0aW9uIG9mKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KShhTGVuKTtcbiAgICB3aGlsZSAoYUxlbiA+IGluZGV4KSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBhTGVuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4570\n")},7874:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar $reduce = __webpack_require__(6543);\n\n$export($export.P + $export.F * !__webpack_require__(6884)([].reduceRight, true), 'Array', {\n  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])\n  reduceRight: function reduceRight(callbackfn /* , initialValue */) {\n    return $reduce(this, callbackfn, arguments.length, arguments[1], true);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg3NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyxJQUFpQjs7QUFFdkMsaUNBQWlDLG1CQUFPLENBQUMsSUFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qcz80OGY4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlUmlnaHQsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOSAvIDE1LjQuNC4yMiBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgdHJ1ZSk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7874\n")},1449:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar $reduce = __webpack_require__(6543);\n\n$export($export.P + $export.F * !__webpack_require__(6884)([].reduce, true), 'Array', {\n  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])\n  reduce: function reduce(callbackfn /* , initialValue */) {\n    return $reduce(this, callbackfn, arguments.length, arguments[1], false);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ0OS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyxJQUFpQjs7QUFFdkMsaUNBQWlDLG1CQUFPLENBQUMsSUFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcz8wY2Q4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTggLyAxNS40LjQuMjEgQXJyYXkucHJvdG90eXBlLnJlZHVjZShjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIGZhbHNlKTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1449\n")},5853:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar html = __webpack_require__(1308);\nvar cof = __webpack_require__(5089);\nvar toAbsoluteIndex = __webpack_require__(157);\nvar toLength = __webpack_require__(1485);\nvar arraySlice = [].slice;\n\n// fallback for not array-like ES3 strings and DOM objects\n$export($export.P + $export.F * __webpack_require__(9448)(function () {\n  if (html) arraySlice.call(html);\n}), 'Array', {\n  slice: function slice(begin, end) {\n    var len = toLength(this.length);\n    var klass = cof(this);\n    end = end === undefined ? len : end;\n    if (klass == 'Array') return arraySlice.call(this, begin, end);\n    var start = toAbsoluteIndex(begin, len);\n    var upTo = toAbsoluteIndex(end, len);\n    var size = toLength(upTo - start);\n    var cloned = new Array(size);\n    var i = 0;\n    for (; i < size; i++) cloned[i] = klass == 'String'\n      ? this.charAt(start + i)\n      : this[start + i];\n    return cloned;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTg1My5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyxJQUFTO0FBQzVCLFVBQVUsbUJBQU8sQ0FBQyxJQUFRO0FBQzFCLHNCQUFzQixtQkFBTyxDQUFDLEdBQXNCO0FBQ3BELGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDOztBQUVBO0FBQ0EsZ0NBQWdDLG1CQUFPLENBQUMsSUFBVTtBQUNsRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UuanM/MjNiZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFycmF5U2xpY2UgPSBbXS5zbGljZTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgaWYgKGh0bWwpIGFycmF5U2xpY2UuY2FsbChodG1sKTtcbn0pLCAnQXJyYXknLCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKSB7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHRoaXMubGVuZ3RoKTtcbiAgICB2YXIga2xhc3MgPSBjb2YodGhpcyk7XG4gICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQ7XG4gICAgaWYgKGtsYXNzID09ICdBcnJheScpIHJldHVybiBhcnJheVNsaWNlLmNhbGwodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdmFyIHN0YXJ0ID0gdG9BYnNvbHV0ZUluZGV4KGJlZ2luLCBsZW4pO1xuICAgIHZhciB1cFRvID0gdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKTtcbiAgICB2YXIgc2l6ZSA9IHRvTGVuZ3RoKHVwVG8gLSBzdGFydCk7XG4gICAgdmFyIGNsb25lZCA9IG5ldyBBcnJheShzaXplKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBzaXplOyBpKyspIGNsb25lZFtpXSA9IGtsYXNzID09ICdTdHJpbmcnXG4gICAgICA/IHRoaXMuY2hhckF0KHN0YXJ0ICsgaSlcbiAgICAgIDogdGhpc1tzdGFydCArIGldO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5853\n")},8892:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar $some = __webpack_require__(6179)(3);\n\n$export($export.P + $export.F * !__webpack_require__(6884)([].some, true), 'Array', {\n  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])\n  some: function some(callbackfn /* , thisArg */) {\n    return $some(this, callbackfn, arguments[1]);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODg5Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyxJQUFrQjs7QUFFdEMsaUNBQWlDLG1CQUFPLENBQUMsSUFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvbWUuanM/NzU5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRzb21lID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDMpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uc29tZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjIzIC8gMTUuNC40LjE3IEFycmF5LnByb3RvdHlwZS5zb21lKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJHNvbWUodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8892\n")},7075:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar aFunction = __webpack_require__(3387);\nvar toObject = __webpack_require__(8270);\nvar fails = __webpack_require__(9448);\nvar $sort = [].sort;\nvar test = [1, 2, 3];\n\n$export($export.P + $export.F * (fails(function () {\n  // IE8-\n  test.sort(undefined);\n}) || !fails(function () {\n  // V8 bug\n  test.sort(null);\n  // Old WebKit\n}) || !__webpack_require__(6884)($sort)), 'Array', {\n  // 22.1.3.25 Array.prototype.sort(comparefn)\n  sort: function sort(comparefn) {\n    return comparefn === undefined\n      ? $sort.call(toObject(this))\n      : $sort.call(toObject(this), aFunction(comparefn));\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA3NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsWUFBWSxtQkFBTyxDQUFDLElBQVU7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxNQUFNLG1CQUFPLENBQUMsSUFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb3J0LmpzPzU1ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgJHNvcnQgPSBbXS5zb3J0O1xudmFyIHRlc3QgPSBbMSwgMiwgM107XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gSUU4LVxuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIFY4IGJ1Z1xuICB0ZXN0LnNvcnQobnVsbCk7XG4gIC8vIE9sZCBXZWJLaXRcbn0pIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJHNvcnQpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjUgQXJyYXkucHJvdG90eXBlLnNvcnQoY29tcGFyZWZuKVxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZFxuICAgICAgPyAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpKVxuICAgICAgOiAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpLCBhRnVuY3Rpb24oY29tcGFyZWZuKSk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7075\n")},6209:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(5762)('Array');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIwOS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBTyxDQUFDLElBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMuanM/ZDA0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdBcnJheScpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6209\n")},3292:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.3.3.1 / 15.9.4.4 Date.now()\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzI5Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQyw2QkFBNkIsbUJBQW1CLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLm5vdy5qcz83OGNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDIwLjMuMy4xIC8gMTUuOS40LjQgRGF0ZS5ub3coKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdEYXRlJywgeyBub3c6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3292\n")},9429:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()\nvar $export = __webpack_require__(2127);\nvar toISOString = __webpack_require__(5385);\n\n// PhantomJS / old WebKit has a broken implementations\n$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {\n  toISOString: toISOString\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQyOS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLElBQXVCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZy5qcz84ZWE1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIDIwLjMuNC4zNiAvIDE1LjkuNS40MyBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSVNPU3RyaW5nID0gcmVxdWlyZSgnLi9fZGF0ZS10by1pc28tc3RyaW5nJyk7XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgIT09IHRvSVNPU3RyaW5nKSwgJ0RhdGUnLCB7XG4gIHRvSVNPU3RyaW5nOiB0b0lTT1N0cmluZ1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9429\n")},2346:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar toObject = __webpack_require__(8270);\nvar toPrimitive = __webpack_require__(3048);\n\n$export($export.P + $export.F * __webpack_require__(9448)(function () {\n  return new Date(NaN).toJSON() !== null\n    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;\n}), 'Date', {\n  // eslint-disable-next-line no-unused-vars\n  toJSON: function toJSON(key) {\n    var O = toObject(this);\n    var pv = toPrimitive(O);\n    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM0Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLElBQWlCOztBQUUzQyxnQ0FBZ0MsbUJBQU8sQ0FBQyxJQUFVO0FBQ2xEO0FBQ0Esb0NBQW9DLDJCQUEyQixhQUFhO0FBQzVFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbi5qcz8wMjk4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IERhdGUoTmFOKS50b0pTT04oKSAhPT0gbnVsbFxuICAgIHx8IERhdGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHsgdG9JU09TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDE7IH0gfSkgIT09IDE7XG59KSwgJ0RhdGUnLCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTihrZXkpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBwdiA9IHRvUHJpbWl0aXZlKE8pO1xuICAgIHJldHVybiB0eXBlb2YgcHYgPT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHB2KSA/IG51bGwgOiBPLnRvSVNPU3RyaW5nKCk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2346\n")},8951:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var TO_PRIMITIVE = __webpack_require__(7574)('toPrimitive');\nvar proto = Date.prototype;\n\nif (!(TO_PRIMITIVE in proto)) __webpack_require__(3341)(proto, TO_PRIMITIVE, __webpack_require__(107));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk1MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsbUJBQU8sQ0FBQyxJQUFRO0FBQ25DOztBQUVBLDhCQUE4QixtQkFBTyxDQUFDLElBQVMsdUJBQXVCLG1CQUFPLENBQUMsR0FBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUuanM/YzhjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVE9fUFJJTUlUSVZFID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvUHJpbWl0aXZlJyk7XG52YXIgcHJvdG8gPSBEYXRlLnByb3RvdHlwZTtcblxuaWYgKCEoVE9fUFJJTUlUSVZFIGluIHByb3RvKSkgcmVxdWlyZSgnLi9faGlkZScpKHByb3RvLCBUT19QUklNSVRJVkUsIHJlcXVpcmUoJy4vX2RhdGUtdG8tcHJpbWl0aXZlJykpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8951\n")},7849:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var DateProto = Date.prototype;\nvar INVALID_DATE = 'Invalid Date';\nvar TO_STRING = 'toString';\nvar $toString = DateProto[TO_STRING];\nvar getTime = DateProto.getTime;\nif (new Date(NaN) + '' != INVALID_DATE) {\n  __webpack_require__(8859)(DateProto, TO_STRING, function toString() {\n    var value = getTime.call(this);\n    // eslint-disable-next-line no-self-compare\n    return value === value ? $toString.call(this) : INVALID_DATE;\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg0OS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1CQUFPLENBQUMsSUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcuanM/ODdiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRGF0ZVByb3RvID0gRGF0ZS5wcm90b3R5cGU7XG52YXIgSU5WQUxJRF9EQVRFID0gJ0ludmFsaWQgRGF0ZSc7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSBEYXRlUHJvdG9bVE9fU1RSSU5HXTtcbnZhciBnZXRUaW1lID0gRGF0ZVByb3RvLmdldFRpbWU7XG5pZiAobmV3IERhdGUoTmFOKSArICcnICE9IElOVkFMSURfREFURSkge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKERhdGVQcm90bywgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRUaW1lLmNhbGwodGhpcyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAkdG9TdHJpbmcuY2FsbCh0aGlzKSA6IElOVkFMSURfREFURTtcbiAgfSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7849\n")},5049:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)\nvar $export = __webpack_require__(2127);\n\n$export($export.P, 'Function', { bind: __webpack_require__(5538) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA0OS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQyxpQ0FBaUMsTUFBTSxtQkFBTyxDQUFDLElBQVMsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kLmpzP2Q5MmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMi4zLjIgLyAxNS4zLjQuNSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCh0aGlzQXJnLCBhcmdzLi4uKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdGdW5jdGlvbicsIHsgYmluZDogcmVxdWlyZSgnLi9fYmluZCcpIH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5049\n")},5502:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar isObject = __webpack_require__(3305);\nvar getPrototypeOf = __webpack_require__(627);\nvar HAS_INSTANCE = __webpack_require__(7574)('hasInstance');\nvar FunctionProto = Function.prototype;\n// 19.2.3.6 Function.prototype[@@hasInstance](V)\nif (!(HAS_INSTANCE in FunctionProto)) (__webpack_require__(7967).f)(FunctionProto, HAS_INSTANCE, { value: function (O) {\n  if (typeof this != 'function' || !isObject(O)) return false;\n  if (!isObject(this.prototype)) return O instanceof this;\n  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:\n  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;\n  return false;\n} });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUwMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLHFCQUFxQixtQkFBTyxDQUFDLEdBQWU7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsSUFBUTtBQUNuQztBQUNBO0FBQ0Esc0NBQXNDLDZCQUF5QixnQ0FBZ0M7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlLmpzPzIxN2IiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSEFTX0lOU1RBTkNFID0gcmVxdWlyZSgnLi9fd2tzJykoJ2hhc0luc3RhbmNlJyk7XG52YXIgRnVuY3Rpb25Qcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIDE5LjIuMy42IEZ1bmN0aW9uLnByb3RvdHlwZVtAQGhhc0luc3RhbmNlXShWKVxuaWYgKCEoSEFTX0lOU1RBTkNFIGluIEZ1bmN0aW9uUHJvdG8pKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKEZ1bmN0aW9uUHJvdG8sIEhBU19JTlNUQU5DRSwgeyB2YWx1ZTogZnVuY3Rpb24gKE8pIHtcbiAgaWYgKHR5cGVvZiB0aGlzICE9ICdmdW5jdGlvbicgfHwgIWlzT2JqZWN0KE8pKSByZXR1cm4gZmFsc2U7XG4gIGlmICghaXNPYmplY3QodGhpcy5wcm90b3R5cGUpKSByZXR1cm4gTyBpbnN0YW5jZW9mIHRoaXM7XG4gIC8vIGZvciBlbnZpcm9ubWVudCB3L28gbmF0aXZlIGBAQGhhc0luc3RhbmNlYCBsb2dpYyBlbm91Z2ggYGluc3RhbmNlb2ZgLCBidXQgYWRkIHRoaXM6XG4gIHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpIGlmICh0aGlzLnByb3RvdHlwZSA9PT0gTykgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn0gfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5502\n")},489:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var dP = (__webpack_require__(7967).f);\nvar FProto = Function.prototype;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// 19.2.4.2 name\nNAME in FProto || __webpack_require__(1763) && dP(FProto, NAME, {\n  configurable: true,\n  get: function () {\n    try {\n      return ('' + this).match(nameRE)[1];\n    } catch (e) {\n      return '';\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg5LmpzIiwibWFwcGluZ3MiOiJBQUFBLFNBQVMsNkJBQXlCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLElBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qcz83ZjdmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgRlByb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIG5hbWVSRSA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopLztcbnZhciBOQU1FID0gJ25hbWUnO1xuXG4vLyAxOS4yLjQuMiBuYW1lXG5OQU1FIGluIEZQcm90byB8fCByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIGRQKEZQcm90bywgTkFNRSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKCcnICsgdGhpcykubWF0Y2gobmFtZVJFKVsxXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///489\n")},3386:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar strong = __webpack_require__(6197);\nvar validate = __webpack_require__(2888);\nvar MAP = 'Map';\n\n// 23.1 Map Objects\nmodule.exports = __webpack_require__(8933)(MAP, function (get) {\n  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.1.3.6 Map.prototype.get(key)\n  get: function get(key) {\n    var entry = strong.getEntry(validate(this, MAP), key);\n    return entry && entry.v;\n  },\n  // 23.1.3.9 Map.prototype.set(key, value)\n  set: function set(key, value) {\n    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);\n  }\n}, strong, true);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM4Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxJQUFzQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsSUFBd0I7QUFDL0M7O0FBRUE7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFlO0FBQ3hDLDBCQUEwQjtBQUMxQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hcC5qcz9mNDAwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIE1BUCA9ICdNYXAnO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShNQVAsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3386\n")},6648:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.3 Math.acosh(x)\nvar $export = __webpack_require__(2127);\nvar log1p = __webpack_require__(1473);\nvar sqrt = Math.sqrt;\nvar $acosh = Math.acosh;\n\n$export($export.S + $export.F * !($acosh\n  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509\n  && Math.floor($acosh(Number.MAX_VALUE)) == 710\n  // Tor Browser bug: Math.acosh(Infinity) -> NaN\n  && $acosh(Infinity) == Infinity\n), 'Math', {\n  acosh: function acosh(x) {\n    return (x = +x) < 1 ? NaN : x > 94906265.62425156\n      ? Math.log(x) + Math.LN2\n      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjY0OC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyxJQUFlO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hY29zaC5qcz83ZjI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIDIwLjIuMi4zIE1hdGguYWNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbG9nMXAgPSByZXF1aXJlKCcuL19tYXRoLWxvZzFwJyk7XG52YXIgc3FydCA9IE1hdGguc3FydDtcbnZhciAkYWNvc2ggPSBNYXRoLmFjb3NoO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFjb3NoXG4gIC8vIFY4IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM1MDlcbiAgJiYgTWF0aC5mbG9vcigkYWNvc2goTnVtYmVyLk1BWF9WQUxVRSkpID09IDcxMFxuICAvLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYWNvc2goSW5maW5pdHkpIC0+IE5hTlxuICAmJiAkYWNvc2goSW5maW5pdHkpID09IEluZmluaXR5XG4pLCAnTWF0aCcsIHtcbiAgYWNvc2g6IGZ1bmN0aW9uIGFjb3NoKHgpIHtcbiAgICByZXR1cm4gKHggPSAreCkgPCAxID8gTmFOIDogeCA+IDk0OTA2MjY1LjYyNDI1MTU2XG4gICAgICA/IE1hdGgubG9nKHgpICsgTWF0aC5MTjJcbiAgICAgIDogbG9nMXAoeCAtIDEgKyBzcXJ0KHggLSAxKSAqIHNxcnQoeCArIDEpKTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6648\n")},5771:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.5 Math.asinh(x)\nvar $export = __webpack_require__(2127);\nvar $asinh = Math.asinh;\n\nfunction asinh(x) {\n  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));\n}\n\n// Tor Browser bug: Math.asinh(0) -> -0\n$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc3MS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXNpbmguanM/NTM2YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhc2luaCA9IE1hdGguYXNpbmg7XG5cbmZ1bmN0aW9uIGFzaW5oKHgpIHtcbiAgcmV0dXJuICFpc0Zpbml0ZSh4ID0gK3gpIHx8IHggPT0gMCA/IHggOiB4IDwgMCA/IC1hc2luaCgteCkgOiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgMSkpO1xufVxuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXNpbmgoMCkgLT4gLTBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXNpbmggJiYgMSAvICRhc2luaCgwKSA+IDApLCAnTWF0aCcsIHsgYXNpbmg6IGFzaW5oIH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5771\n")},2392:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.7 Math.atanh(x)\nvar $export = __webpack_require__(2127);\nvar $atanh = Math.atanh;\n\n// Tor Browser bug: Math.atanh(-0) -> 0\n$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {\n  atanh: function atanh(x) {\n    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM5Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanM/ZDlhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuNyBNYXRoLmF0YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhdGFuaCA9IE1hdGguYXRhbmg7XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hdGFuaCgtMCkgLT4gMFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhdGFuaCAmJiAxIC8gJGF0YW5oKC0wKSA8IDApLCAnTWF0aCcsIHtcbiAgYXRhbmg6IGZ1bmN0aW9uIGF0YW5oKHgpIHtcbiAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2392\n")},2335:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.9 Math.cbrt(x)\nvar $export = __webpack_require__(2127);\nvar sign = __webpack_require__(3733);\n\n$export($export.S, 'Math', {\n  cbrt: function cbrt(x) {\n    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMzNS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyxJQUFjOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jYnJ0LmpzP2Y5YWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMi4yLjkgTWF0aC5jYnJ0KHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHNpZ24gPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjYnJ0OiBmdW5jdGlvbiBjYnJ0KHgpIHtcbiAgICByZXR1cm4gc2lnbih4ID0gK3gpICogTWF0aC5wb3coTWF0aC5hYnMoeCksIDEgLyAzKTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2335\n")},4896:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.11 Math.clz32(x)\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Math', {\n  clz32: function clz32(x) {\n    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg5Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jbHozMi5qcz8zMmQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIDIwLjIuMi4xMSBNYXRoLmNsejMyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNsejMyOiBmdW5jdGlvbiBjbHozMih4KSB7XG4gICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMSAtIE1hdGguZmxvb3IoTWF0aC5sb2coeCArIDAuNSkgKiBNYXRoLkxPRzJFKSA6IDMyO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4896\n")},4521:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.12 Math.cosh(x)\nvar $export = __webpack_require__(2127);\nvar exp = Math.exp;\n\n$export($export.S, 'Math', {\n  cosh: function cosh(x) {\n    return (exp(x = +x) + exp(-x)) / 2;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDUyMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNvc2guanM/MjVjOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuMTIgTWF0aC5jb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGV4cCA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNvc2g6IGZ1bmN0aW9uIGNvc2goeCkge1xuICAgIHJldHVybiAoZXhwKHggPSAreCkgKyBleHAoLXgpKSAvIDI7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4521\n")},9147:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.14 Math.expm1(x)\nvar $export = __webpack_require__(2127);\nvar $expm1 = __webpack_require__(5551);\n\n$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTE0Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxJQUFlOztBQUVwQyxrRUFBa0UsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xLmpzPzlmM2MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICgkZXhwbTEgIT0gTWF0aC5leHBtMSksICdNYXRoJywgeyBleHBtMTogJGV4cG0xIH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9147\n")},1318:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.16 Math.fround(x)\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Math', { fround: __webpack_require__(2122) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMxOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQyw2QkFBNkIsUUFBUSxtQkFBTyxDQUFDLElBQWdCLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5mcm91bmQuanM/MDQyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgZnJvdW5kOiByZXF1aXJlKCcuL19tYXRoLWZyb3VuZCcpIH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1318\n")},4352:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])\nvar $export = __webpack_require__(2127);\nvar abs = Math.abs;\n\n$export($export.S, 'Math', {\n  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars\n    var sum = 0;\n    var i = 0;\n    var aLen = arguments.length;\n    var larg = 0;\n    var arg, div;\n    while (i < aLen) {\n      arg = abs(arguments[i++]);\n      if (larg < arg) {\n        div = larg / arg;\n        sum = sum * div * div + 1;\n        larg = arg;\n      } else if (arg > 0) {\n        div = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDM1Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanM/YzdjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuMTcgTWF0aC5oeXBvdChbdmFsdWUxWywgdmFsdWUyWywg4oCmIF1dXSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYWJzID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaHlwb3Q6IGZ1bmN0aW9uIGh5cG90KHZhbHVlMSwgdmFsdWUyKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBsYXJnID0gMDtcbiAgICB2YXIgYXJnLCBkaXY7XG4gICAgd2hpbGUgKGkgPCBhTGVuKSB7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuICAgICAgaWYgKGxhcmcgPCBhcmcpIHtcbiAgICAgICAgZGl2ID0gbGFyZyAvIGFyZztcbiAgICAgICAgc3VtID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZiAoYXJnID4gMCkge1xuICAgICAgICBkaXYgPSBhcmcgLyBsYXJnO1xuICAgICAgICBzdW0gKz0gZGl2ICogZGl2O1xuICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG4gICAgfVxuICAgIHJldHVybiBsYXJnID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogbGFyZyAqIE1hdGguc3FydChzdW0pO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4352\n")},5327:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.18 Math.imul(x, y)\nvar $export = __webpack_require__(2127);\nvar $imul = Math.imul;\n\n// some WebKit versions fails with big numbers, some has wrong arity\n$export($export.S + $export.F * __webpack_require__(9448)(function () {\n  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;\n}), 'Math', {\n  imul: function imul(x, y) {\n    var UINT16 = 0xffff;\n    var xn = +x;\n    var yn = +y;\n    var xl = UINT16 & xn;\n    var yl = UINT16 & yn;\n    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMyNy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDOztBQUVBO0FBQ0EsZ0NBQWdDLG1CQUFPLENBQUMsSUFBVTtBQUNsRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmltdWwuanM/ZjRmZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuMTggTWF0aC5pbXVsKHgsIHkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRpbXVsID0gTWF0aC5pbXVsO1xuXG4vLyBzb21lIFdlYktpdCB2ZXJzaW9ucyBmYWlscyB3aXRoIGJpZyBudW1iZXJzLCBzb21lIGhhcyB3cm9uZyBhcml0eVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICRpbXVsKDB4ZmZmZmZmZmYsIDUpICE9IC01IHx8ICRpbXVsLmxlbmd0aCAhPSAyO1xufSksICdNYXRoJywge1xuICBpbXVsOiBmdW5jdGlvbiBpbXVsKHgsIHkpIHtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmO1xuICAgIHZhciB4biA9ICt4O1xuICAgIHZhciB5biA9ICt5O1xuICAgIHZhciB4bCA9IFVJTlQxNiAmIHhuO1xuICAgIHZhciB5bCA9IFVJTlQxNiAmIHluO1xuICAgIHJldHVybiAwIHwgeGwgKiB5bCArICgoVUlOVDE2ICYgeG4gPj4+IDE2KSAqIHlsICsgeGwgKiAoVUlOVDE2ICYgeW4gPj4+IDE2KSA8PCAxNiA+Pj4gMCk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5327\n")},7509:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.21 Math.log10(x)\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Math', {\n  log10: function log10(x) {\n    return Math.log(x) * Math.LOG10E;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUwOS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxMC5qcz83ODcyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzEwOiBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpICogTWF0aC5MT0cxMEU7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7509\n")},5909:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.20 Math.log1p(x)\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Math', { log1p: __webpack_require__(1473) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkwOS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQyw2QkFBNkIsT0FBTyxtQkFBTyxDQUFDLElBQWUsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzPzA0OWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgbG9nMXA6IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKSB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5909\n")},9584:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.22 Math.log2(x)\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Math', {\n  log2: function log2(x) {\n    return Math.log(x) / Math.LN2;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTU4NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzP2E2OWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpIHtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9584\n")},345:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.28 Math.sign(x)\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Math', { sign: __webpack_require__(3733) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ1LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7O0FBRWpDLDZCQUE2QixNQUFNLG1CQUFPLENBQUMsSUFBYyxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcz8wYjIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgc2lnbjogcmVxdWlyZSgnLi9fbWF0aC1zaWduJykgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///345\n")},9134:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.30 Math.sinh(x)\nvar $export = __webpack_require__(2127);\nvar expm1 = __webpack_require__(5551);\nvar exp = Math.exp;\n\n// V8 near Chromium 38 has a problem with very small numbers\n$export($export.S + $export.F * __webpack_require__(9448)(function () {\n  return !Math.sinh(-2e-17) != -2e-17;\n}), 'Math', {\n  sinh: function sinh(x) {\n    return Math.abs(x = +x) < 1\n      ? (expm1(x) - expm1(-x)) / 2\n      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTEzNC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyxJQUFlO0FBQ25DOztBQUVBO0FBQ0EsZ0NBQWdDLG1CQUFPLENBQUMsSUFBVTtBQUNsRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpbmguanM/NmMxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4yLjIuMzAgTWF0aC5zaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xudmFyIGV4cCA9IE1hdGguZXhwO1xuXG4vLyBWOCBuZWFyIENocm9taXVtIDM4IGhhcyBhIHByb2JsZW0gd2l0aCB2ZXJ5IHNtYWxsIG51bWJlcnNcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhTWF0aC5zaW5oKC0yZS0xNykgIT0gLTJlLTE3O1xufSksICdNYXRoJywge1xuICBzaW5oOiBmdW5jdGlvbiBzaW5oKHgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoeCA9ICt4KSA8IDFcbiAgICAgID8gKGV4cG0xKHgpIC0gZXhwbTEoLXgpKSAvIDJcbiAgICAgIDogKGV4cCh4IC0gMSkgLSBleHAoLXggLSAxKSkgKiAoTWF0aC5FIC8gMik7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9134\n")},7901:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.33 Math.tanh(x)\nvar $export = __webpack_require__(2127);\nvar expm1 = __webpack_require__(5551);\nvar exp = Math.exp;\n\n$export($export.S, 'Math', {\n  tanh: function tanh(x) {\n    var a = expm1(x = +x);\n    var b = expm1(-x);\n    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzkwMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyxJQUFlO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzP2M3YzYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMi4yLjMzIE1hdGgudGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBleHBtMSA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcbnZhciBleHAgPSBNYXRoLmV4cDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0YW5oOiBmdW5jdGlvbiB0YW5oKHgpIHtcbiAgICB2YXIgYSA9IGV4cG0xKHggPSAreCk7XG4gICAgdmFyIGIgPSBleHBtMSgteCk7XG4gICAgcmV0dXJuIGEgPT0gSW5maW5pdHkgPyAxIDogYiA9PSBJbmZpbml0eSA/IC0xIDogKGEgLSBiKSAvIChleHAoeCkgKyBleHAoLXgpKTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7901\n")},6592:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.2.2.34 Math.trunc(x)\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Math', {\n  trunc: function trunc(it) {\n    return (it > 0 ? Math.floor : Math.ceil)(it);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU5Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcz84NGI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIDIwLjIuMi4zNCBNYXRoLnRydW5jKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRydW5jOiBmdW5jdGlvbiB0cnVuYyhpdCkge1xuICAgIHJldHVybiAoaXQgPiAwID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbCkoaXQpO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6592\n")},4509:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar global = __webpack_require__(7526);\nvar has = __webpack_require__(7917);\nvar cof = __webpack_require__(5089);\nvar inheritIfRequired = __webpack_require__(8880);\nvar toPrimitive = __webpack_require__(3048);\nvar fails = __webpack_require__(9448);\nvar gOPN = (__webpack_require__(9415).f);\nvar gOPD = (__webpack_require__(8641).f);\nvar dP = (__webpack_require__(7967).f);\nvar $trim = (__webpack_require__(629).trim);\nvar NUMBER = 'Number';\nvar $Number = global[NUMBER];\nvar Base = $Number;\nvar proto = $Number.prototype;\n// Opera ~12 has broken Object#toString\nvar BROKEN_COF = cof(__webpack_require__(4719)(proto)) == NUMBER;\nvar TRIM = 'trim' in String.prototype;\n\n// 7.1.3 ToNumber(argument)\nvar toNumber = function (argument) {\n  var it = toPrimitive(argument, false);\n  if (typeof it == 'string' && it.length > 2) {\n    it = TRIM ? it.trim() : $trim(it, 3);\n    var first = it.charCodeAt(0);\n    var third, radix, maxCode;\n    if (first === 43 || first === 45) {\n      third = it.charCodeAt(2);\n      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix\n    } else if (first === 48) {\n      switch (it.charCodeAt(1)) {\n        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i\n        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i\n        default: return +it;\n      }\n      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {\n        code = digits.charCodeAt(i);\n        // parseInt parses a string to a first unavailable symbol\n        // but ToNumber should return NaN if a string contains unavailable symbols\n        if (code < 48 || code > maxCode) return NaN;\n      } return parseInt(digits, radix);\n    }\n  } return +it;\n};\n\nif (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {\n  $Number = function Number(value) {\n    var it = arguments.length < 1 ? 0 : value;\n    var that = this;\n    return that instanceof $Number\n      // check on 1..constructor(foo) case\n      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)\n        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);\n  };\n  for (var keys = __webpack_require__(1763) ? gOPN(Base) : (\n    // ES3:\n    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +\n    // ES6 (in case, if modules with ES6 Number statics required before):\n    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +\n    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'\n  ).split(','), j = 0, key; keys.length > j; j++) {\n    if (has(Base, key = keys[j]) && !has($Number, key)) {\n      dP($Number, key, gOPD(Base, key));\n    }\n  }\n  $Number.prototype = proto;\n  proto.constructor = $Number;\n  __webpack_require__(8859)(global, NUMBER, $Number);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDUwOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxJQUFXO0FBQ2hDLFVBQVUsbUJBQU8sQ0FBQyxJQUFRO0FBQzFCLFVBQVUsbUJBQU8sQ0FBQyxJQUFRO0FBQzFCLHdCQUF3QixtQkFBTyxDQUFDLElBQXdCO0FBQ3hELGtCQUFrQixtQkFBTyxDQUFDLElBQWlCO0FBQzNDLFlBQVksbUJBQU8sQ0FBQyxJQUFVO0FBQzlCLFdBQVcsNkJBQTJCO0FBQ3RDLFdBQVcsNkJBQTJCO0FBQ3RDLFNBQVMsNkJBQXlCO0FBQ2xDLFlBQVksK0JBQThCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxJQUFrQjtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsTUFBTTtBQUNOO0FBQ0EscUNBQXFDLGNBQWMsT0FBTztBQUMxRCxzQ0FBc0MsY0FBYyxPQUFPO0FBQzNEO0FBQ0E7QUFDQSxxRUFBcUUsT0FBTztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMkJBQTJCO0FBQ3RFO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1CQUFPLENBQUMsSUFBYTtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanM/YzVmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciAkdHJpbSA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcbnZhciBOVU1CRVIgPSAnTnVtYmVyJztcbnZhciAkTnVtYmVyID0gZ2xvYmFsW05VTUJFUl07XG52YXIgQmFzZSA9ICROdW1iZXI7XG52YXIgcHJvdG8gPSAkTnVtYmVyLnByb3RvdHlwZTtcbi8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xudmFyIEJST0tFTl9DT0YgPSBjb2YocmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpKHByb3RvKSkgPT0gTlVNQkVSO1xudmFyIFRSSU0gPSAndHJpbScgaW4gU3RyaW5nLnByb3RvdHlwZTtcblxuLy8gNy4xLjMgVG9OdW1iZXIoYXJndW1lbnQpXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGl0ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIGZhbHNlKTtcbiAgaWYgKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyKSB7XG4gICAgaXQgPSBUUklNID8gaXQudHJpbSgpIDogJHRyaW0oaXQsIDMpO1xuICAgIHZhciBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHRoaXJkLCByYWRpeCwgbWF4Q29kZTtcbiAgICBpZiAoZmlyc3QgPT09IDQzIHx8IGZpcnN0ID09PSA0NSkge1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYgKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKSByZXR1cm4gTmFOOyAvLyBOdW1iZXIoJysweDEnKSBzaG91bGQgYmUgTmFOLCBvbGQgVjggZml4XG4gICAgfSBlbHNlIGlmIChmaXJzdCA9PT0gNDgpIHtcbiAgICAgIHN3aXRjaCAoaXQuY2hhckNvZGVBdCgxKSkge1xuICAgICAgICBjYXNlIDY2OiBjYXNlIDk4OiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzk6IGNhc2UgMTExOiByYWRpeCA9IDg7IG1heENvZGUgPSA1NTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wb1swLTddKyQvaVxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgZGlnaXRzID0gaXQuc2xpY2UoMiksIGkgPSAwLCBsID0gZGlnaXRzLmxlbmd0aCwgY29kZTsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb2RlID0gZGlnaXRzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIC8vIHBhcnNlSW50IHBhcnNlcyBhIHN0cmluZyB0byBhIGZpcnN0IHVuYXZhaWxhYmxlIHN5bWJvbFxuICAgICAgICAvLyBidXQgVG9OdW1iZXIgc2hvdWxkIHJldHVybiBOYU4gaWYgYSBzdHJpbmcgY29udGFpbnMgdW5hdmFpbGFibGUgc3ltYm9sc1xuICAgICAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKSByZXR1cm4gTmFOO1xuICAgICAgfSByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59O1xuXG5pZiAoISROdW1iZXIoJyAwbzEnKSB8fCAhJE51bWJlcignMGIxJykgfHwgJE51bWJlcignKzB4MScpKSB7XG4gICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpIHtcbiAgICB2YXIgaXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMSA/IDAgOiB2YWx1ZTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIHRoYXQgaW5zdGFuY2VvZiAkTnVtYmVyXG4gICAgICAvLyBjaGVjayBvbiAxLi5jb25zdHJ1Y3Rvcihmb28pIGNhc2VcbiAgICAgICYmIChCUk9LRU5fQ09GID8gZmFpbHMoZnVuY3Rpb24gKCkgeyBwcm90by52YWx1ZU9mLmNhbGwodGhhdCk7IH0pIDogY29mKHRoYXQpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSh0b051bWJlcihpdCkpLCB0aGF0LCAkTnVtYmVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BOKEJhc2UpIDogKFxuICAgIC8vIEVTMzpcbiAgICAnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFksJyArXG4gICAgLy8gRVM2IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVM2IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICAgJ0VQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUiwnICtcbiAgICAnTUlOX1NBRkVfSU5URUdFUixwYXJzZUZsb2F0LHBhcnNlSW50LGlzSW50ZWdlcidcbiAgKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKykge1xuICAgIGlmIChoYXMoQmFzZSwga2V5ID0ga2V5c1tqXSkgJiYgIWhhcygkTnVtYmVyLCBrZXkpKSB7XG4gICAgICBkUCgkTnVtYmVyLCBrZXksIGdPUEQoQmFzZSwga2V5KSk7XG4gICAgfVxuICB9XG4gICROdW1iZXIucHJvdG90eXBlID0gcHJvdG87XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJE51bWJlcjtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsIE5VTUJFUiwgJE51bWJlcik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4509\n")},4419:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.1.2.1 Number.EPSILON\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQxOS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQywrQkFBK0IsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uLmpzPzJlMzciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBFUFNJTE9OOiBNYXRoLnBvdygyLCAtNTIpIH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4419\n")},1933:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.1.2.2 Number.isFinite(number)\nvar $export = __webpack_require__(2127);\nvar _isFinite = (__webpack_require__(7526).isFinite);\n\n$export($export.S, 'Number', {\n  isFinite: function isFinite(it) {\n    return typeof it == 'number' && _isFinite(it);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkzMy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGdCQUFnQixvQ0FBNkI7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlLmpzP2ZjYTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgX2lzRmluaXRlID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuaXNGaW5pdGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1933\n")},3157:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.1.2.3 Number.isInteger(number)\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Number', { isInteger: __webpack_require__(3842) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE1Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQywrQkFBK0IsV0FBVyxtQkFBTyxDQUFDLElBQWUsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlci5qcz83Y2RmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IGlzSW50ZWdlcjogcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpIH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3157\n")},9497:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.1.2.4 Number.isNaN(number)\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Number', {\n  isNaN: function isNaN(number) {\n    // eslint-disable-next-line no-self-compare\n    return number != number;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQ5Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzP2VlMWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc05hTjogZnVuY3Rpb24gaXNOYU4obnVtYmVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9497\n")},4104:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.1.2.5 Number.isSafeInteger(number)\nvar $export = __webpack_require__(2127);\nvar isInteger = __webpack_require__(3842);\nvar abs = Math.abs;\n\n$export($export.S, 'Number', {\n  isSafeInteger: function isSafeInteger(number) {\n    return isInteger(number) && abs(number) <= 0x1fffffffffffff;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEwNC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanM/YjFiMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4xLjIuNSBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKTtcbnZhciBhYnMgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIobnVtYmVyKSB7XG4gICAgcmV0dXJuIGlzSW50ZWdlcihudW1iZXIpICYmIGFicyhudW1iZXIpIDw9IDB4MWZmZmZmZmZmZmZmZmY7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4104\n")},210:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.1.2.6 Number.MAX_SAFE_INTEGER\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEwLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7O0FBRWpDLCtCQUErQixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanM/ODdmMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IE1BWF9TQUZFX0lOVEVHRVI6IDB4MWZmZmZmZmZmZmZmZmYgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///210\n")},6576:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 20.1.2.10 Number.MIN_SAFE_INTEGER\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU3Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQywrQkFBK0IscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzPzkyNzgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMjAuMS4yLjEwIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgTUlOX1NBRkVfSU5URUdFUjogLTB4MWZmZmZmZmZmZmZmZmYgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6576\n")},4437:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var $export = __webpack_require__(2127);\nvar $parseFloat = __webpack_require__(3589);\n// 20.1.2.12 Number.parseFloat(string)\n$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQzNy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsSUFBVztBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFnQjtBQUMxQztBQUNBLGdGQUFnRix5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzPzVkZjIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAyMC4xLjIuMTIgTnVtYmVyLnBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCAnTnVtYmVyJywgeyBwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdCB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4437\n")},8050:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var $export = __webpack_require__(2127);\nvar $parseInt = __webpack_require__(2738);\n// 20.1.2.13 Number.parseInt(string, radix)\n$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODA1MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsSUFBVztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFjO0FBQ3RDO0FBQ0EsNEVBQTRFLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50LmpzPzA0ZmYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDIwLjEuMi4xMyBOdW1iZXIucGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUludCAhPSAkcGFyc2VJbnQpLCAnTnVtYmVyJywgeyBwYXJzZUludDogJHBhcnNlSW50IH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8050\n")},7727:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar toInteger = __webpack_require__(7087);\nvar aNumberValue = __webpack_require__(5122);\nvar repeat = __webpack_require__(7926);\nvar $toFixed = 1.0.toFixed;\nvar floor = Math.floor;\nvar data = [0, 0, 0, 0, 0, 0];\nvar ERROR = 'Number.toFixed: incorrect invocation!';\nvar ZERO = '0';\n\nvar multiply = function (n, c) {\n  var i = -1;\n  var c2 = c;\n  while (++i < 6) {\n    c2 += n * data[i];\n    data[i] = c2 % 1e7;\n    c2 = floor(c2 / 1e7);\n  }\n};\nvar divide = function (n) {\n  var i = 6;\n  var c = 0;\n  while (--i >= 0) {\n    c += data[i];\n    data[i] = floor(c / n);\n    c = (c % n) * 1e7;\n  }\n};\nvar numToString = function () {\n  var i = 6;\n  var s = '';\n  while (--i >= 0) {\n    if (s !== '' || i === 0 || data[i] !== 0) {\n      var t = String(data[i]);\n      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;\n    }\n  } return s;\n};\nvar pow = function (x, n, acc) {\n  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);\n};\nvar log = function (x) {\n  var n = 0;\n  var x2 = x;\n  while (x2 >= 4096) {\n    n += 12;\n    x2 /= 4096;\n  }\n  while (x2 >= 2) {\n    n += 1;\n    x2 /= 2;\n  } return n;\n};\n\n$export($export.P + $export.F * (!!$toFixed && (\n  0.00008.toFixed(3) !== '0.000' ||\n  0.9.toFixed(0) !== '1' ||\n  1.255.toFixed(2) !== '1.25' ||\n  1000000000000000128.0.toFixed(0) !== '1000000000000000128'\n) || !__webpack_require__(9448)(function () {\n  // V8 ~ Android 4.3-\n  $toFixed.call({});\n})), 'Number', {\n  toFixed: function toFixed(fractionDigits) {\n    var x = aNumberValue(this, ERROR);\n    var f = toInteger(fractionDigits);\n    var s = '';\n    var m = ZERO;\n    var e, z, j, k;\n    if (f < 0 || f > 20) throw RangeError(ERROR);\n    // eslint-disable-next-line no-self-compare\n    if (x != x) return 'NaN';\n    if (x <= -1e21 || x >= 1e21) return String(x);\n    if (x < 0) {\n      s = '-';\n      x = -x;\n    }\n    if (x > 1e-21) {\n      e = log(x * pow(2, 69, 1)) - 69;\n      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);\n      z *= 0x10000000000000;\n      e = 52 - e;\n      if (e > 0) {\n        multiply(0, z);\n        j = f;\n        while (j >= 7) {\n          multiply(1e7, 0);\n          j -= 7;\n        }\n        multiply(pow(10, j, 1), 0);\n        j = e - 1;\n        while (j >= 23) {\n          divide(1 << 23);\n          j -= 23;\n        }\n        divide(1 << j);\n        multiply(1, 1);\n        divide(2);\n        m = numToString();\n      } else {\n        multiply(0, z);\n        multiply(1 << -e, 0);\n        m = numToString() + repeat.call(ZERO, f);\n      }\n    }\n    if (f > 0) {\n      k = m.length;\n      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));\n    } else {\n      m = s + m;\n    } return m;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzcyNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsSUFBbUI7QUFDOUMsYUFBYSxtQkFBTyxDQUFDLElBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1CQUFPLENBQUMsSUFBVTtBQUN4QjtBQUNBLGtCQUFrQjtBQUNsQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZC5qcz8wMzZjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpO1xudmFyICR0b0ZpeGVkID0gMS4wLnRvRml4ZWQ7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGRhdGEgPSBbMCwgMCwgMCwgMCwgMCwgMF07XG52YXIgRVJST1IgPSAnTnVtYmVyLnRvRml4ZWQ6IGluY29ycmVjdCBpbnZvY2F0aW9uISc7XG52YXIgWkVSTyA9ICcwJztcblxudmFyIG11bHRpcGx5ID0gZnVuY3Rpb24gKG4sIGMpIHtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIGMyID0gYztcbiAgd2hpbGUgKCsraSA8IDYpIHtcbiAgICBjMiArPSBuICogZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gYzIgJSAxZTc7XG4gICAgYzIgPSBmbG9vcihjMiAvIDFlNyk7XG4gIH1cbn07XG52YXIgZGl2aWRlID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIGkgPSA2O1xuICB2YXIgYyA9IDA7XG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIGMgKz0gZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gZmxvb3IoYyAvIG4pO1xuICAgIGMgPSAoYyAlIG4pICogMWU3O1xuICB9XG59O1xudmFyIG51bVRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSA9IDY7XG4gIHZhciBzID0gJyc7XG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIGlmIChzICE9PSAnJyB8fCBpID09PSAwIHx8IGRhdGFbaV0gIT09IDApIHtcbiAgICAgIHZhciB0ID0gU3RyaW5nKGRhdGFbaV0pO1xuICAgICAgcyA9IHMgPT09ICcnID8gdCA6IHMgKyByZXBlYXQuY2FsbChaRVJPLCA3IC0gdC5sZW5ndGgpICsgdDtcbiAgICB9XG4gIH0gcmV0dXJuIHM7XG59O1xudmFyIHBvdyA9IGZ1bmN0aW9uICh4LCBuLCBhY2MpIHtcbiAgcmV0dXJuIG4gPT09IDAgPyBhY2MgOiBuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpO1xufTtcbnZhciBsb2cgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbiA9IDA7XG4gIHZhciB4MiA9IHg7XG4gIHdoaWxlICh4MiA+PSA0MDk2KSB7XG4gICAgbiArPSAxMjtcbiAgICB4MiAvPSA0MDk2O1xuICB9XG4gIHdoaWxlICh4MiA+PSAyKSB7XG4gICAgbiArPSAxO1xuICAgIHgyIC89IDI7XG4gIH0gcmV0dXJuIG47XG59O1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICghISR0b0ZpeGVkICYmIChcbiAgMC4wMDAwOC50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gIDAuOS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgMS4yNTUudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gIDEwMDAwMDAwMDAwMDAwMDAxMjguMC50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCdcbikgfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9GaXhlZC5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9GaXhlZDogZnVuY3Rpb24gdG9GaXhlZChmcmFjdGlvbkRpZ2l0cykge1xuICAgIHZhciB4ID0gYU51bWJlclZhbHVlKHRoaXMsIEVSUk9SKTtcbiAgICB2YXIgZiA9IHRvSW50ZWdlcihmcmFjdGlvbkRpZ2l0cyk7XG4gICAgdmFyIHMgPSAnJztcbiAgICB2YXIgbSA9IFpFUk87XG4gICAgdmFyIGUsIHosIGosIGs7XG4gICAgaWYgKGYgPCAwIHx8IGYgPiAyMCkgdGhyb3cgUmFuZ2VFcnJvcihFUlJPUik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmICh4ICE9IHgpIHJldHVybiAnTmFOJztcbiAgICBpZiAoeCA8PSAtMWUyMSB8fCB4ID49IDFlMjEpIHJldHVybiBTdHJpbmcoeCk7XG4gICAgaWYgKHggPCAwKSB7XG4gICAgICBzID0gJy0nO1xuICAgICAgeCA9IC14O1xuICAgIH1cbiAgICBpZiAoeCA+IDFlLTIxKSB7XG4gICAgICBlID0gbG9nKHggKiBwb3coMiwgNjksIDEpKSAtIDY5O1xuICAgICAgeiA9IGUgPCAwID8geCAqIHBvdygyLCAtZSwgMSkgOiB4IC8gcG93KDIsIGUsIDEpO1xuICAgICAgeiAqPSAweDEwMDAwMDAwMDAwMDAwO1xuICAgICAgZSA9IDUyIC0gZTtcbiAgICAgIGlmIChlID4gMCkge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgaiA9IGY7XG4gICAgICAgIHdoaWxlIChqID49IDcpIHtcbiAgICAgICAgICBtdWx0aXBseSgxZTcsIDApO1xuICAgICAgICAgIGogLT0gNztcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseShwb3coMTAsIGosIDEpLCAwKTtcbiAgICAgICAgaiA9IGUgLSAxO1xuICAgICAgICB3aGlsZSAoaiA+PSAyMykge1xuICAgICAgICAgIGRpdmlkZSgxIDw8IDIzKTtcbiAgICAgICAgICBqIC09IDIzO1xuICAgICAgICB9XG4gICAgICAgIGRpdmlkZSgxIDw8IGopO1xuICAgICAgICBtdWx0aXBseSgxLCAxKTtcbiAgICAgICAgZGl2aWRlKDIpO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBtdWx0aXBseSgxIDw8IC1lLCAwKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCkgKyByZXBlYXQuY2FsbChaRVJPLCBmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGYgPiAwKSB7XG4gICAgICBrID0gbS5sZW5ndGg7XG4gICAgICBtID0gcyArIChrIDw9IGYgPyAnMC4nICsgcmVwZWF0LmNhbGwoWkVSTywgZiAtIGspICsgbSA6IG0uc2xpY2UoMCwgayAtIGYpICsgJy4nICsgbS5zbGljZShrIC0gZikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gcyArIG07XG4gICAgfSByZXR1cm4gbTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7727\n")},6701:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar $fails = __webpack_require__(9448);\nvar aNumberValue = __webpack_require__(5122);\nvar $toPrecision = 1.0.toPrecision;\n\n$export($export.P + $export.F * ($fails(function () {\n  // IE7-\n  return $toPrecision.call(1, undefined) !== '1';\n}) || !$fails(function () {\n  // V8 ~ Android 4.3-\n  $toPrecision.call({});\n})), 'Number', {\n  toPrecision: function toPrecision(precision) {\n    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');\n    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjcwMS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxJQUFVO0FBQy9CLG1CQUFtQixtQkFBTyxDQUFDLElBQW1CO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHNCQUFzQjtBQUN0QixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanM/NTRhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKTtcbnZhciAkdG9QcmVjaXNpb24gPSAxLjAudG9QcmVjaXNpb247XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIElFNy1cbiAgcmV0dXJuICR0b1ByZWNpc2lvbi5jYWxsKDEsIHVuZGVmaW5lZCkgIT09ICcxJztcbn0pIHx8ICEkZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9QcmVjaXNpb24uY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvUHJlY2lzaW9uOiBmdW5jdGlvbiB0b1ByZWNpc2lvbihwcmVjaXNpb24pIHtcbiAgICB2YXIgdGhhdCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCAnTnVtYmVyI3RvUHJlY2lzaW9uOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgICByZXR1cm4gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyAkdG9QcmVjaXNpb24uY2FsbCh0aGF0KSA6ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQsIHByZWNpc2lvbik7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6701\n")},1430:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 19.1.3.1 Object.assign(target, source)\nvar $export = __webpack_require__(2127);\n\n$export($export.S + $export.F, 'Object', { assign: __webpack_require__(8206) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQzMC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQywyQ0FBMkMsUUFBUSxtQkFBTyxDQUFDLElBQWtCLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcz9mNzUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJykgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1430\n")},935:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var $export = __webpack_require__(2127);\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', { create: __webpack_require__(4719) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTM1LmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDO0FBQ0EsK0JBQStCLFFBQVEsbUJBQU8sQ0FBQyxJQUFrQixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanM/ODQ3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgY3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///935\n")},7067:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var $export = __webpack_require__(2127);\n// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)\n$export($export.S + $export.F * !__webpack_require__(1763), 'Object', { defineProperties: __webpack_require__(1626) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA2Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsSUFBVztBQUNqQztBQUNBLGlDQUFpQyxtQkFBTyxDQUFDLElBQWdCLGVBQWUsa0JBQWtCLG1CQUFPLENBQUMsSUFBZSxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcz81OGIyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMyAvIDE1LjIuMy43IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0aWVzOiByZXF1aXJlKCcuL19vYmplY3QtZHBzJykgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7067\n")},6064:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var $export = __webpack_require__(2127);\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n$export($export.S + $export.F * !__webpack_require__(1763), 'Object', { defineProperty: (__webpack_require__(7967).f) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA2NC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsSUFBVztBQUNqQztBQUNBLGlDQUFpQyxtQkFBTyxDQUFDLElBQWdCLGVBQWUsZ0JBQWdCLDZCQUF5QixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanM/MWMwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mIH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6064\n")},8236:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 19.1.2.5 Object.freeze(O)\nvar isObject = __webpack_require__(3305);\nvar meta = (__webpack_require__(2988).onFreeze);\n\n__webpack_require__(923)('freeze', function ($freeze) {\n  return function freeze(it) {\n    return $freeze && isObject(it) ? $freeze(meta(it)) : it;\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODIzNi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLFdBQVcsb0NBQTJCOztBQUV0QyxtQkFBTyxDQUFDLEdBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzPzBkNmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjUgT2JqZWN0LmZyZWV6ZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdmcmVlemUnLCBmdW5jdGlvbiAoJGZyZWV6ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KSB7XG4gICAgcmV0dXJuICRmcmVlemUgJiYgaXNPYmplY3QoaXQpID8gJGZyZWV6ZShtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8236\n")},2642:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\nvar toIObject = __webpack_require__(7221);\nvar $getOwnPropertyDescriptor = (__webpack_require__(8641).f);\n\n__webpack_require__(923)('getOwnPropertyDescriptor', function () {\n  return function getOwnPropertyDescriptor(it, key) {\n    return $getOwnPropertyDescriptor(toIObject(it), key);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY0Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkMsZ0NBQWdDLDZCQUEyQjs7QUFFM0QsbUJBQU8sQ0FBQyxHQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcz85OTg2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2642\n")},1895:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 19.1.2.7 Object.getOwnPropertyNames(O)\n__webpack_require__(923)('getOwnPropertyNames', function () {\n  return (__webpack_require__(4765).f);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg5NS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLG1CQUFPLENBQUMsR0FBZTtBQUN2QixTQUFTLDZCQUErQjtBQUN4QyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzPzI1ZGIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlOYW1lcycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpLmY7XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1895\n")},3e3:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 19.1.2.9 Object.getPrototypeOf(O)\nvar toObject = __webpack_require__(8270);\nvar $getPrototypeOf = __webpack_require__(627);\n\n__webpack_require__(923)('getPrototypeOf', function () {\n  return function getPrototypeOf(it) {\n    return $getPrototypeOf(toObject(it));\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAwMC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLEdBQWU7O0FBRTdDLG1CQUFPLENBQUMsR0FBZTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzP2U0ZjciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCkge1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3000\n")},9073:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 19.1.2.11 Object.isExtensible(O)\nvar isObject = __webpack_require__(3305);\n\n__webpack_require__(923)('isExtensible', function ($isExtensible) {\n  return function isExtensible(it) {\n    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA3My5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxJQUFjOztBQUVyQyxtQkFBTyxDQUFDLEdBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcz8xNjViIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDE5LjEuMi4xMSBPYmplY3QuaXNFeHRlbnNpYmxlKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0V4dGVuc2libGUnLCBmdW5jdGlvbiAoJGlzRXh0ZW5zaWJsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKGl0KSA6IHRydWUgOiBmYWxzZTtcbiAgfTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9073\n")},9318:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 19.1.2.12 Object.isFrozen(O)\nvar isObject = __webpack_require__(3305);\n\n__webpack_require__(923)('isFrozen', function ($isFrozen) {\n  return function isFrozen(it) {\n    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTMxOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxJQUFjOztBQUVyQyxtQkFBTyxDQUFDLEdBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuLmpzPzY2YzgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjEyIE9iamVjdC5pc0Zyb3plbihPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNGcm96ZW4nLCBmdW5jdGlvbiAoJGlzRnJvemVuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc0Zyb3plbihpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNGcm96ZW4gPyAkaXNGcm96ZW4oaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9318\n")},5032:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 19.1.2.13 Object.isSealed(O)\nvar isObject = __webpack_require__(3305);\n\n__webpack_require__(923)('isSealed', function ($isSealed) {\n  return function isSealed(it) {\n    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAzMi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxJQUFjOztBQUVyQyxtQkFBTyxDQUFDLEdBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkLmpzPzU3ZjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjEzIE9iamVjdC5pc1NlYWxlZChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNTZWFsZWQnLCBmdW5jdGlvbiAoJGlzU2VhbGVkKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc1NlYWxlZChpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNTZWFsZWQgPyAkaXNTZWFsZWQoaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5032\n")},8451:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 19.1.3.10 Object.is(value1, value2)\nvar $export = __webpack_require__(2127);\n$export($export.S, 'Object', { is: __webpack_require__(7359) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQ1MS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLCtCQUErQixJQUFJLG1CQUFPLENBQUMsSUFBZSxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy5qcz9kYjk3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIDE5LjEuMy4xMCBPYmplY3QuaXModmFsdWUxLCB2YWx1ZTIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGlzOiByZXF1aXJlKCcuL19zYW1lLXZhbHVlJykgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8451\n")},8647:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 19.1.2.14 Object.keys(O)\nvar toObject = __webpack_require__(8270);\nvar $keys = __webpack_require__(1311);\n\n__webpack_require__(923)('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODY0Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyxJQUFnQjs7QUFFcEMsbUJBQU8sQ0FBQyxHQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanM/NDU2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8647\n")},5572:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 19.1.2.15 Object.preventExtensions(O)\nvar isObject = __webpack_require__(3305);\nvar meta = (__webpack_require__(2988).onFreeze);\n\n__webpack_require__(923)('preventExtensions', function ($preventExtensions) {\n  return function preventExtensions(it) {\n    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTU3Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLFdBQVcsb0NBQTJCOztBQUV0QyxtQkFBTyxDQUFDLEdBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zLmpzPzlhZWEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjE1IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdwcmV2ZW50RXh0ZW5zaW9ucycsIGZ1bmN0aW9uICgkcHJldmVudEV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKGl0KSB7XG4gICAgcmV0dXJuICRwcmV2ZW50RXh0ZW5zaW9ucyAmJiBpc09iamVjdChpdCkgPyAkcHJldmVudEV4dGVuc2lvbnMobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5572\n")},3822:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 19.1.2.17 Object.seal(O)\nvar isObject = __webpack_require__(3305);\nvar meta = (__webpack_require__(2988).onFreeze);\n\n__webpack_require__(923)('seal', function ($seal) {\n  return function seal(it) {\n    return $seal && isObject(it) ? $seal(meta(it)) : it;\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzgyMi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLFdBQVcsb0NBQTJCOztBQUV0QyxtQkFBTyxDQUFDLEdBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbC5qcz9jZjZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdzZWFsJywgZnVuY3Rpb24gKCRzZWFsKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzZWFsKGl0KSB7XG4gICAgcmV0dXJuICRzZWFsICYmIGlzT2JqZWN0KGl0KSA/ICRzZWFsKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3822\n")},8132:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = __webpack_require__(2127);\n$export($export.S, 'Object', { setPrototypeOf: (__webpack_require__(5170).set) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODEzMi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLCtCQUErQixnQkFBZ0IsK0JBQTJCLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanM/ZmQyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0IH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8132\n")},7482:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// 19.1.3.6 Object.prototype.toString()\nvar classof = __webpack_require__(4848);\nvar test = {};\ntest[__webpack_require__(7574)('toStringTag')] = 'z';\nif (test + '' != '[object z]') {\n  __webpack_require__(8859)(Object.prototype, 'toString', function toString() {\n    return '[object ' + classof(this) + ']';\n  }, true);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ4Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVk7QUFDbEM7QUFDQSxLQUFLLG1CQUFPLENBQUMsSUFBUTtBQUNyQjtBQUNBLEVBQUUsbUJBQU8sQ0FBQyxJQUFhO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanM/MDZkYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIHRlc3QgPSB7fTtcbnRlc3RbcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyldID0gJ3onO1xuaWYgKHRlc3QgKyAnJyAhPSAnW29iamVjdCB6XScpIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG4gIH0sIHRydWUpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7482\n")},6108:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var $export = __webpack_require__(2127);\nvar $parseFloat = __webpack_require__(3589);\n// 18.2.4 parseFloat(string)\n$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEwOC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsSUFBVztBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFnQjtBQUMxQztBQUNBLCtEQUErRCx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtZmxvYXQuanM/YjcyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDE4LjIuNCBwYXJzZUZsb2F0KHN0cmluZylcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCB7IHBhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0IH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6108\n")},571:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var $export = __webpack_require__(2127);\nvar $parseInt = __webpack_require__(2738);\n// 18.2.5 parseInt(string, radix)\n$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTcxLmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLElBQWM7QUFDdEM7QUFDQSwyREFBMkQscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qcz8xOGQwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XG4vLyAxOC4yLjUgcGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlSW50ICE9ICRwYXJzZUludCksIHsgcGFyc2VJbnQ6ICRwYXJzZUludCB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///571\n")},6517:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar LIBRARY = __webpack_require__(2750);\nvar global = __webpack_require__(7526);\nvar ctx = __webpack_require__(5052);\nvar classof = __webpack_require__(4848);\nvar $export = __webpack_require__(2127);\nvar isObject = __webpack_require__(3305);\nvar aFunction = __webpack_require__(3387);\nvar anInstance = __webpack_require__(6440);\nvar forOf = __webpack_require__(8790);\nvar speciesConstructor = __webpack_require__(9190);\nvar task = (__webpack_require__(2780).set);\nvar microtask = __webpack_require__(1384)();\nvar newPromiseCapabilityModule = __webpack_require__(4258);\nvar perform = __webpack_require__(128);\nvar userAgent = __webpack_require__(4514);\nvar promiseResolve = __webpack_require__(5957);\nvar PROMISE = 'Promise';\nvar TypeError = global.TypeError;\nvar process = global.process;\nvar versions = process && process.versions;\nvar v8 = versions && versions.v8 || '';\nvar $Promise = global[PROMISE];\nvar isNode = classof(process) == 'process';\nvar empty = function () { /* empty */ };\nvar Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;\nvar newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;\n\nvar USE_NATIVE = !!function () {\n  try {\n    // correct subclassing with @@species support\n    var promise = $Promise.resolve(1);\n    var FakePromise = (promise.constructor = {})[__webpack_require__(7574)('species')] = function (exec) {\n      exec(empty, empty);\n    };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function')\n      && promise.then(empty) instanceof FakePromise\n      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n      // we can't detect it synchronously, so just check versions\n      && v8.indexOf('6.6') !== 0\n      && userAgent.indexOf('Chrome/66') === -1;\n  } catch (e) { /* empty */ }\n}();\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar notify = function (promise, isReject) {\n  if (promise._n) return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function () {\n    var value = promise._v;\n    var ok = promise._s == 1;\n    var i = 0;\n    var run = function (reaction) {\n      var handler = ok ? reaction.ok : reaction.fail;\n      var resolve = reaction.resolve;\n      var reject = reaction.reject;\n      var domain = reaction.domain;\n      var result, then, exited;\n      try {\n        if (handler) {\n          if (!ok) {\n            if (promise._h == 2) onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if (handler === true) result = value;\n          else {\n            if (domain) domain.enter();\n            result = handler(value); // may throw\n            if (domain) {\n              domain.exit();\n              exited = true;\n            }\n          }\n          if (result === reaction.promise) {\n            reject(TypeError('Promise-chain cycle'));\n          } else if (then = isThenable(result)) {\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch (e) {\n        if (domain && !exited) domain.exit();\n        reject(e);\n      }\n    };\n    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if (isReject && !promise._h) onUnhandled(promise);\n  });\n};\nvar onUnhandled = function (promise) {\n  task.call(global, function () {\n    var value = promise._v;\n    var unhandled = isUnhandled(promise);\n    var result, handler, console;\n    if (unhandled) {\n      result = perform(function () {\n        if (isNode) {\n          process.emit('unhandledRejection', value, promise);\n        } else if (handler = global.onunhandledrejection) {\n          handler({ promise: promise, reason: value });\n        } else if ((console = global.console) && console.error) {\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if (unhandled && result.e) throw result.v;\n  });\n};\nvar isUnhandled = function (promise) {\n  return promise._h !== 1 && (promise._a || promise._c).length === 0;\n};\nvar onHandleUnhandled = function (promise) {\n  task.call(global, function () {\n    var handler;\n    if (isNode) {\n      process.emit('rejectionHandled', promise);\n    } else if (handler = global.onrejectionhandled) {\n      handler({ promise: promise, reason: promise._v });\n    }\n  });\n};\nvar $reject = function (value) {\n  var promise = this;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if (!promise._a) promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function (value) {\n  var promise = this;\n  var then;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if (promise === value) throw TypeError(\"Promise can't be resolved itself\");\n    if (then = isThenable(value)) {\n      microtask(function () {\n        var wrapper = { _w: promise, _d: false }; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch (e) {\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch (e) {\n    $reject.call({ _w: promise, _d: false }, e); // wrap\n  }\n};\n\n// constructor polyfill\nif (!USE_NATIVE) {\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor) {\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch (err) {\n      $reject.call(this, err);\n    }\n  };\n  // eslint-disable-next-line no-unused-vars\n  Internal = function Promise(executor) {\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = __webpack_require__(6065)($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected) {\n      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if (this._a) this._a.push(reaction);\n      if (this._s) notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function (onRejected) {\n      return this.then(undefined, onRejected);\n    }\n  });\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject = ctx($reject, promise, 1);\n  };\n  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {\n    return C === $Promise || C === Wrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });\n__webpack_require__(3844)($Promise, PROMISE);\n__webpack_require__(5762)(PROMISE);\nWrapper = __webpack_require__(6094)[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r) {\n    var capability = newPromiseCapability(this);\n    var $$reject = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x) {\n    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(8931)(function (iter) {\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform(function () {\n      var values = [];\n      var index = 0;\n      var remaining = 1;\n      forOf(iterable, false, function (promise) {\n        var $index = index++;\n        var alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      forOf(iterable, false, function (promise) {\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQsbUJBQW1CO0FBQzlFLG1CQUFPLENBQUMsSUFBc0I7QUFDOUIsbUJBQU8sQ0FBQyxJQUFnQjtBQUN4QixVQUFVLG1CQUFPLENBQUMsSUFBUzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0RBQWdELG1CQUFPLENBQUMsSUFBZ0I7QUFDeEU7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanM/NTUxYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciB0YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi9fdXNlci1hZ2VudCcpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucztcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4IHx8ICcnO1xudmFyICRQcm9taXNlID0gZ2xvYmFsW1BST01JU0VdO1xudmFyIGlzTm9kZSA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xudmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIEludGVybmFsLCBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIE93blByb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZjtcblxudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSA9ICRQcm9taXNlLnJlc29sdmUoMSk7XG4gICAgdmFyIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbiAoZXhlYykge1xuICAgICAgZXhlYyhlbXB0eSwgZW1wdHkpO1xuICAgIH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZVxuICAgICAgLy8gdjggNi42IChOb2RlIDEwIGFuZCBDaHJvbWUgNjYpIGhhdmUgYSBidWcgd2l0aCByZXNvbHZpbmcgY3VzdG9tIHRoZW5hYmxlc1xuICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODMwNTY1XG4gICAgICAvLyB3ZSBjYW4ndCBkZXRlY3QgaXQgc3luY2hyb25vdXNseSwgc28ganVzdCBjaGVjayB2ZXJzaW9uc1xuICAgICAgJiYgdjguaW5kZXhPZignNi42JykgIT09IDBcbiAgICAgICYmIHVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUvNjYnKSA9PT0gLTE7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbiAocHJvbWlzZSwgaXNSZWplY3QpIHtcbiAgaWYgKHByb21pc2UuX24pIHJldHVybjtcbiAgcHJvbWlzZS5fbiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2M7XG4gIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgb2sgPSBwcm9taXNlLl9zID09IDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbiAocmVhY3Rpb24pIHtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gICAgICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gICAgICB2YXIgcmVqZWN0ID0gcmVhY3Rpb24ucmVqZWN0O1xuICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgICAgIHZhciByZXN1bHQsIHRoZW4sIGV4aXRlZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2ggPT0gMikgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTsgLy8gbWF5IHRocm93XG4gICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSBydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpIG9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgdW5oYW5kbGVkID0gaXNVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgdmFyIHJlc3VsdCwgaGFuZGxlciwgY29uc29sZTtcbiAgICBpZiAodW5oYW5kbGVkKSB7XG4gICAgICByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pIHtcbiAgICAgICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZSB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmICh1bmhhbmRsZWQgJiYgcmVzdWx0LmUpIHRocm93IHJlc3VsdC52O1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICByZXR1cm4gcHJvbWlzZS5faCAhPT0gMSAmJiAocHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jKS5sZW5ndGggPT09IDA7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpIHtcbiAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3YgfSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICBwcm9taXNlLl9zID0gMjtcbiAgaWYgKCFwcm9taXNlLl9hKSBwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xuICBub3RpZnkocHJvbWlzZSwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgdmFyIHRoZW47XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmICh0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0geyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgJHJlamVjdC5jYWxsKHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9LCBlKTsgLy8gd3JhcFxuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJFByb21pc2UsIFBST01JU0UsICdfaCcpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoY3R4KCRyZXNvbHZlLCB0aGlzLCAxKSwgY3R4KCRyZWplY3QsIHRoaXMsIDEpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9hKSB0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX3MpIG5vdGlmeSh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcbiAgICB0aGlzLnJlamVjdCA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgICByZXR1cm4gQyA9PT0gJFByb21pc2UgfHwgQyA9PT0gV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFByb21pc2U6ICRQcm9taXNlIH0pO1xucmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vX2NvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKTtcbiAgICB2YXIgJCRyZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoTElCUkFSWSAmJiB0aGlzID09PSBXcmFwcGVyID8gJFByb21pc2UgOiB0aGlzLCB4KTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyICRpbmRleCA9IGluZGV4Kys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1skaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6517\n")},7103:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)\nvar $export = __webpack_require__(2127);\nvar aFunction = __webpack_require__(3387);\nvar anObject = __webpack_require__(4228);\nvar rApply = ((__webpack_require__(7526).Reflect) || {}).apply;\nvar fApply = Function.apply;\n// MS Edge argumentsList argument is optional\n$export($export.S + $export.F * !__webpack_require__(9448)(function () {\n  rApply(function () { /* empty */ });\n}), 'Reflect', {\n  apply: function apply(target, thisArgument, argumentsList) {\n    var T = aFunction(target);\n    var L = anObject(argumentsList);\n    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzEwMy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsY0FBYyxtQ0FBNEIsTUFBTTtBQUNoRDtBQUNBO0FBQ0EsaUNBQWlDLG1CQUFPLENBQUMsSUFBVTtBQUNuRCx1QkFBdUIsYUFBYTtBQUNwQyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseS5qcz9kZjFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDI2LjEuMSBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciByQXBwbHkgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuYXBwbHk7XG52YXIgZkFwcGx5ID0gRnVuY3Rpb24uYXBwbHk7XG4vLyBNUyBFZGdlIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByQXBwbHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KSB7XG4gICAgdmFyIFQgPSBhRnVuY3Rpb24odGFyZ2V0KTtcbiAgICB2YXIgTCA9IGFuT2JqZWN0KGFyZ3VtZW50c0xpc3QpO1xuICAgIHJldHVybiByQXBwbHkgPyByQXBwbHkoVCwgdGhpc0FyZ3VtZW50LCBMKSA6IGZBcHBseS5jYWxsKFQsIHRoaXNBcmd1bWVudCwgTCk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7103\n")},2586:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])\nvar $export = __webpack_require__(2127);\nvar create = __webpack_require__(4719);\nvar aFunction = __webpack_require__(3387);\nvar anObject = __webpack_require__(4228);\nvar isObject = __webpack_require__(3305);\nvar fails = __webpack_require__(9448);\nvar bind = __webpack_require__(5538);\nvar rConstruct = ((__webpack_require__(7526).Reflect) || {}).construct;\n\n// MS Edge supports only 2 arguments and argumentsList argument is optional\n// FF Nightly sets third argument as `new.target`, but does not create `this` from it\nvar NEW_TARGET_BUG = fails(function () {\n  function F() { /* empty */ }\n  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);\n});\nvar ARGS_BUG = !fails(function () {\n  rConstruct(function () { /* empty */ });\n});\n\n$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {\n  construct: function construct(Target, args /* , newTarget */) {\n    aFunction(Target);\n    anObject(args);\n    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);\n    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);\n    if (Target == newTarget) {\n      // w/o altered newTarget, optimization for 0-4 arguments\n      switch (args.length) {\n        case 0: return new Target();\n        case 1: return new Target(args[0]);\n        case 2: return new Target(args[0], args[1]);\n        case 3: return new Target(args[0], args[1], args[2]);\n        case 4: return new Target(args[0], args[1], args[2], args[3]);\n      }\n      // w/o altered newTarget, lot of arguments case\n      var $args = [null];\n      $args.push.apply($args, args);\n      return new (bind.apply(Target, $args))();\n    }\n    // with altered newTarget, not support built-in constructors\n    var proto = newTarget.prototype;\n    var instance = create(isObject(proto) ? proto : Object.prototype);\n    var result = Function.apply.call(Target, instance, args);\n    return isObject(result) ? result : instance;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjU4Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxJQUFrQjtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFlO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyxJQUFVO0FBQzlCLFdBQVcsbUJBQU8sQ0FBQyxJQUFTO0FBQzVCLGtCQUFrQixtQ0FBNEIsTUFBTTs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLG9DQUFvQyxhQUFhO0FBQ2pELENBQUM7QUFDRDtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanM/MjM5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyNi4xLjIgUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IFssIG5ld1RhcmdldF0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9fYmluZCcpO1xudmFyIHJDb25zdHJ1Y3QgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuY29uc3RydWN0O1xuXG4vLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHMgYW5kIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbi8vIEZGIE5pZ2h0bHkgc2V0cyB0aGlyZCBhcmd1bWVudCBhcyBgbmV3LnRhcmdldGAsIGJ1dCBkb2VzIG5vdCBjcmVhdGUgYHRoaXNgIGZyb20gaXRcbnZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gIShyQ29uc3RydWN0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG59KTtcbnZhciBBUkdTX0JVRyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRyksICdSZWZsZWN0Jywge1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGNvbnN0cnVjdChUYXJnZXQsIGFyZ3MgLyogLCBuZXdUYXJnZXQgKi8pIHtcbiAgICBhRnVuY3Rpb24oVGFyZ2V0KTtcbiAgICBhbk9iamVjdChhcmdzKTtcbiAgICB2YXIgbmV3VGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBUYXJnZXQgOiBhRnVuY3Rpb24oYXJndW1lbnRzWzJdKTtcbiAgICBpZiAoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKSByZXR1cm4gckNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG4gICAgaWYgKFRhcmdldCA9PSBuZXdUYXJnZXQpIHtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBUYXJnZXQoKTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH1cbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICAkYXJncy5wdXNoLmFwcGx5KCRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGJpbmQuYXBwbHkoVGFyZ2V0LCAkYXJncykpKCk7XG4gICAgfVxuICAgIC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuICAgIHZhciBwcm90byA9IG5ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgdmFyIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IEZ1bmN0aW9uLmFwcGx5LmNhbGwoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2586\n")},2552:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)\nvar dP = __webpack_require__(7967);\nvar $export = __webpack_require__(2127);\nvar anObject = __webpack_require__(4228);\nvar toPrimitive = __webpack_require__(3048);\n\n// MS Edge has broken Reflect.defineProperty - throwing instead of returning false\n$export($export.S + $export.F * __webpack_require__(9448)(function () {\n  // eslint-disable-next-line no-undef\n  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });\n}), 'Reflect', {\n  defineProperty: function defineProperty(target, propertyKey, attributes) {\n    anObject(target);\n    propertyKey = toPrimitive(propertyKey, true);\n    anObject(attributes);\n    try {\n      dP.f(target, propertyKey, attributes);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjU1Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFNBQVMsbUJBQU8sQ0FBQyxJQUFjO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLElBQWlCOztBQUUzQztBQUNBLGdDQUFnQyxtQkFBTyxDQUFDLElBQVU7QUFDbEQ7QUFDQSxnQ0FBZ0MsT0FBTyxVQUFVLFFBQVEsVUFBVTtBQUNuRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eS5qcz84OGNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDI2LjEuMyBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4vLyBNUyBFZGdlIGhhcyBicm9rZW4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSAtIHRocm93aW5nIGluc3RlYWQgb2YgcmV0dXJuaW5nIGZhbHNlXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShkUC5mKHt9LCAxLCB7IHZhbHVlOiAxIH0pLCAxLCB7IHZhbHVlOiAyIH0pO1xufSksICdSZWZsZWN0Jywge1xuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcykge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcHJvcGVydHlLZXkgPSB0b1ByaW1pdGl2ZShwcm9wZXJ0eUtleSwgdHJ1ZSk7XG4gICAgYW5PYmplY3QoYXR0cmlidXRlcyk7XG4gICAgdHJ5IHtcbiAgICAgIGRQLmYodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2552\n")},4376:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 26.1.4 Reflect.deleteProperty(target, propertyKey)\nvar $export = __webpack_require__(2127);\nvar gOPD = (__webpack_require__(8641).f);\nvar anObject = __webpack_require__(4228);\n\n$export($export.S, 'Reflect', {\n  deleteProperty: function deleteProperty(target, propertyKey) {\n    var desc = gOPD(anObject(target), propertyKey);\n    return desc && !desc.configurable ? false : delete target[propertyKey];\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDM3Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLFdBQVcsNkJBQTJCO0FBQ3RDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eS5qcz9iYTE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHZhciBkZXNjID0gZ09QRChhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4376\n")},5153:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// 26.1.5 Reflect.enumerate(target)\nvar $export = __webpack_require__(2127);\nvar anObject = __webpack_require__(4228);\nvar Enumerate = function (iterated) {\n  this._t = anObject(iterated); // target\n  this._i = 0;                  // next index\n  var keys = this._k = [];      // keys\n  var key;\n  for (key in iterated) keys.push(key);\n};\n__webpack_require__(6032)(Enumerate, 'Object', function () {\n  var that = this;\n  var keys = that._k;\n  var key;\n  do {\n    if (that._i >= keys.length) return { value: undefined, done: true };\n  } while (!((key = keys[that._i++]) in that._t));\n  return { value: key, done: false };\n});\n\n$export($export.S, 'Reflect', {\n  enumerate: function enumerate(target) {\n    return new Enumerate(target);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTE1My5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckM7QUFDQSxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxtQkFBTyxDQUFDLElBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLElBQUk7QUFDSixXQUFXO0FBQ1gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanM/N2ZmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyAyNi4xLjUgUmVmbGVjdC5lbnVtZXJhdGUodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIEVudW1lcmF0ZSA9IGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gYW5PYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB2YXIga2V5cyA9IHRoaXMuX2sgPSBbXTsgICAgICAvLyBrZXlzXG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIGl0ZXJhdGVkKSBrZXlzLnB1c2goa2V5KTtcbn07XG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKEVudW1lcmF0ZSwgJ09iamVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB2YXIga2V5cyA9IHRoYXQuX2s7XG4gIHZhciBrZXk7XG4gIGRvIHtcbiAgICBpZiAodGhhdC5faSA+PSBrZXlzLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9IHdoaWxlICghKChrZXkgPSBrZXlzW3RoYXQuX2krK10pIGluIHRoYXQuX3QpKTtcbiAgcmV0dXJuIHsgdmFsdWU6IGtleSwgZG9uZTogZmFsc2UgfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGVudW1lcmF0ZTogZnVuY3Rpb24gZW51bWVyYXRlKHRhcmdldCkge1xuICAgIHJldHVybiBuZXcgRW51bWVyYXRlKHRhcmdldCk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5153\n")},2650:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)\nvar gOPD = __webpack_require__(8641);\nvar $export = __webpack_require__(2127);\nvar anObject = __webpack_require__(4228);\n\n$export($export.S, 'Reflect', {\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {\n    return gOPD.f(anObject(target), propertyKey);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY1MC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxJQUFnQjtBQUNuQyxjQUFjLG1CQUFPLENBQUMsSUFBVztBQUNqQyxlQUFlLG1CQUFPLENBQUMsSUFBYzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzP2ViZGUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMjYuMS43IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2650\n")},1104:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 26.1.8 Reflect.getPrototypeOf(target)\nvar $export = __webpack_require__(2127);\nvar getProto = __webpack_require__(627);\nvar anObject = __webpack_require__(4228);\n\n$export($export.S, 'Reflect', {\n  getPrototypeOf: function getPrototypeOf(target) {\n    return getProto(anObject(target));\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEwNC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxHQUFlO0FBQ3RDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mLmpzPzJkMzQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMjYuMS44IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBnZXRQcm90byA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZih0YXJnZXQpIHtcbiAgICByZXR1cm4gZ2V0UHJvdG8oYW5PYmplY3QodGFyZ2V0KSk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1104\n")},1879:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 26.1.6 Reflect.get(target, propertyKey [, receiver])\nvar gOPD = __webpack_require__(8641);\nvar getPrototypeOf = __webpack_require__(627);\nvar has = __webpack_require__(7917);\nvar $export = __webpack_require__(2127);\nvar isObject = __webpack_require__(3305);\nvar anObject = __webpack_require__(4228);\n\nfunction get(target, propertyKey /* , receiver */) {\n  var receiver = arguments.length < 3 ? target : arguments[2];\n  var desc, proto;\n  if (anObject(target) === receiver) return target[propertyKey];\n  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')\n    ? desc.value\n    : desc.get !== undefined\n      ? desc.get.call(receiver)\n      : undefined;\n  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);\n}\n\n$export($export.S, 'Reflect', { get: get });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg3OS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxJQUFnQjtBQUNuQyxxQkFBcUIsbUJBQU8sQ0FBQyxHQUFlO0FBQzVDLFVBQVUsbUJBQU8sQ0FBQyxJQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxVQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LmpzP2QxODUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMjYuMS42IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgWywgcmVjZWl2ZXJdKVxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3BlcnR5S2V5IC8qICwgcmVjZWl2ZXIgKi8pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl07XG4gIHZhciBkZXNjLCBwcm90bztcbiAgaWYgKGFuT2JqZWN0KHRhcmdldCkgPT09IHJlY2VpdmVyKSByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgaWYgKGRlc2MgPSBnT1BELmYodGFyZ2V0LCBwcm9wZXJ0eUtleSkpIHJldHVybiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICA/IGRlc2MudmFsdWVcbiAgICA6IGRlc2MuZ2V0ICE9PSB1bmRlZmluZWRcbiAgICAgID8gZGVzYy5nZXQuY2FsbChyZWNlaXZlcilcbiAgICAgIDogdW5kZWZpbmVkO1xuICBpZiAoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSkgcmV0dXJuIGdldChwcm90bywgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgeyBnZXQ6IGdldCB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1879\n")},1883:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 26.1.9 Reflect.has(target, propertyKey)\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Reflect', {\n  has: function has(target, propertyKey) {\n    return propertyKey in target;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg4My5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5oYXMuanM/ZjZiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyNi4xLjkgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiBwcm9wZXJ0eUtleSBpbiB0YXJnZXQ7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1883\n")},5433:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 26.1.10 Reflect.isExtensible(target)\nvar $export = __webpack_require__(2127);\nvar anObject = __webpack_require__(4228);\nvar $isExtensible = Object.isExtensible;\n\n$export($export.S, 'Reflect', {\n  isExtensible: function isExtensible(target) {\n    anObject(target);\n    return $isExtensible ? $isExtensible(target) : true;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQzMy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZS5qcz8yMjUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDI2LjEuMTAgUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKHRhcmdldCkge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcmV0dXJuICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKHRhcmdldCkgOiB0cnVlO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5433\n")},5e3:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 26.1.11 Reflect.ownKeys(target)\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Reflect', { ownKeys: __webpack_require__(6222) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAwMC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQyxnQ0FBZ0MsU0FBUyxtQkFBTyxDQUFDLElBQWEsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzP2M2OTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMjYuMS4xMSBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgeyBvd25LZXlzOiByZXF1aXJlKCcuL19vd24ta2V5cycpIH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5000\n")},5932:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 26.1.12 Reflect.preventExtensions(target)\nvar $export = __webpack_require__(2127);\nvar anObject = __webpack_require__(4228);\nvar $preventExtensions = Object.preventExtensions;\n\n$export($export.S, 'Reflect', {\n  preventExtensions: function preventExtensions(target) {\n    anObject(target);\n    try {\n      if ($preventExtensions) $preventExtensions(target);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkzMi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zLmpzP2ExOWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMjYuMS4xMiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciAkcHJldmVudEV4dGVuc2lvbnMgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCkge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICgkcHJldmVudEV4dGVuc2lvbnMpICRwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5932\n")},6316:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 26.1.14 Reflect.setPrototypeOf(target, proto)\nvar $export = __webpack_require__(2127);\nvar setProto = __webpack_require__(5170);\n\nif (setProto) $export($export.S, 'Reflect', {\n  setPrototypeOf: function setPrototypeOf(target, proto) {\n    setProto.check(target, proto);\n    try {\n      setProto.set(target, proto);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMxNi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanM/OTI3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyNi4xLjE0IFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgc2V0UHJvdG8gPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKTtcblxuaWYgKHNldFByb3RvKSAkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKSB7XG4gICAgc2V0UHJvdG8uY2hlY2sodGFyZ2V0LCBwcm90byk7XG4gICAgdHJ5IHtcbiAgICAgIHNldFByb3RvLnNldCh0YXJnZXQsIHByb3RvKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6316\n")},5443:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])\nvar dP = __webpack_require__(7967);\nvar gOPD = __webpack_require__(8641);\nvar getPrototypeOf = __webpack_require__(627);\nvar has = __webpack_require__(7917);\nvar $export = __webpack_require__(2127);\nvar createDesc = __webpack_require__(1996);\nvar anObject = __webpack_require__(4228);\nvar isObject = __webpack_require__(3305);\n\nfunction set(target, propertyKey, V /* , receiver */) {\n  var receiver = arguments.length < 4 ? target : arguments[3];\n  var ownDesc = gOPD.f(anObject(target), propertyKey);\n  var existingDescriptor, proto;\n  if (!ownDesc) {\n    if (isObject(proto = getPrototypeOf(target))) {\n      return set(proto, propertyKey, V, receiver);\n    }\n    ownDesc = createDesc(0);\n  }\n  if (has(ownDesc, 'value')) {\n    if (ownDesc.writable === false || !isObject(receiver)) return false;\n    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {\n      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;\n      existingDescriptor.value = V;\n      dP.f(receiver, propertyKey, existingDescriptor);\n    } else dP.f(receiver, propertyKey, createDesc(0, V));\n    return true;\n  }\n  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);\n}\n\n$export($export.S, 'Reflect', { set: set });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ0My5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFNBQVMsbUJBQU8sQ0FBQyxJQUFjO0FBQy9CLFdBQVcsbUJBQU8sQ0FBQyxJQUFnQjtBQUNuQyxxQkFBcUIsbUJBQU8sQ0FBQyxHQUFlO0FBQzVDLFVBQVUsbUJBQU8sQ0FBQyxJQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLElBQWtCO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsVUFBVSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcz85MjUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDI2LjEuMTMgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbLCByZWNlaXZlcl0pXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIC8qICwgcmVjZWl2ZXIgKi8pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDQgPyB0YXJnZXQgOiBhcmd1bWVudHNbM107XG4gIHZhciBvd25EZXNjID0gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgdmFyIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG87XG4gIGlmICghb3duRGVzYykge1xuICAgIGlmIChpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKSB7XG4gICAgICByZXR1cm4gc2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgICBvd25EZXNjID0gY3JlYXRlRGVzYygwKTtcbiAgfVxuICBpZiAoaGFzKG93bkRlc2MsICd2YWx1ZScpKSB7XG4gICAgaWYgKG93bkRlc2Mud3JpdGFibGUgPT09IGZhbHNlIHx8ICFpc09iamVjdChyZWNlaXZlcikpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZXhpc3RpbmdEZXNjcmlwdG9yID0gZ09QRC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSkpIHtcbiAgICAgIGlmIChleGlzdGluZ0Rlc2NyaXB0b3IuZ2V0IHx8IGV4aXN0aW5nRGVzY3JpcHRvci5zZXQgfHwgZXhpc3RpbmdEZXNjcmlwdG9yLndyaXRhYmxlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZXhpc3RpbmdEZXNjcmlwdG9yLnZhbHVlID0gVjtcbiAgICAgIGRQLmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5LCBleGlzdGluZ0Rlc2NyaXB0b3IpO1xuICAgIH0gZWxzZSBkUC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgY3JlYXRlRGVzYygwLCBWKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG93bkRlc2Muc2V0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IChvd25EZXNjLnNldC5jYWxsKHJlY2VpdmVyLCBWKSwgdHJ1ZSk7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgc2V0OiBzZXQgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5443\n")},8301:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var global = __webpack_require__(7526);\nvar inheritIfRequired = __webpack_require__(8880);\nvar dP = (__webpack_require__(7967).f);\nvar gOPN = (__webpack_require__(9415).f);\nvar isRegExp = __webpack_require__(5411);\nvar $flags = __webpack_require__(1158);\nvar $RegExp = global.RegExp;\nvar Base = $RegExp;\nvar proto = $RegExp.prototype;\nvar re1 = /a/g;\nvar re2 = /a/g;\n// \"new\" creates a new object, old webkit buggy here\nvar CORRECT_NEW = new $RegExp(re1) !== re1;\n\nif (__webpack_require__(1763) && (!CORRECT_NEW || __webpack_require__(9448)(function () {\n  re2[__webpack_require__(7574)('match')] = false;\n  // RegExp constructor can alter flags and IsRegExp works correct with @@match\n  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';\n}))) {\n  $RegExp = function RegExp(p, f) {\n    var tiRE = this instanceof $RegExp;\n    var piRE = isRegExp(p);\n    var fiU = f === undefined;\n    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p\n      : inheritIfRequired(CORRECT_NEW\n        ? new Base(piRE && !fiU ? p.source : p, f)\n        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)\n      , tiRE ? this : proto, $RegExp);\n  };\n  var proxy = function (key) {\n    key in $RegExp || dP($RegExp, key, {\n      configurable: true,\n      get: function () { return Base[key]; },\n      set: function (it) { Base[key] = it; }\n    });\n  };\n  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);\n  proto.constructor = $RegExp;\n  $RegExp.prototype = proto;\n  __webpack_require__(8859)(global, 'RegExp', $RegExp);\n}\n\n__webpack_require__(5762)('RegExp');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODMwMS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBVztBQUNoQyx3QkFBd0IsbUJBQU8sQ0FBQyxJQUF3QjtBQUN4RCxTQUFTLDZCQUF5QjtBQUNsQyxXQUFXLDZCQUEyQjtBQUN0QyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxhQUFhLG1CQUFPLENBQUMsSUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLG1CQUFPLENBQUMsSUFBZ0Isc0JBQXNCLG1CQUFPLENBQUMsSUFBVTtBQUNwRSxNQUFNLG1CQUFPLENBQUMsSUFBUTtBQUN0QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QywyQkFBMkI7QUFDM0IsS0FBSztBQUNMO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLElBQWE7QUFDdkI7O0FBRUEsbUJBQU8sQ0FBQyxJQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuY29uc3RydWN0b3IuanM/M2IyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbnZhciAkZmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xudmFyICRSZWdFeHAgPSBnbG9iYWwuUmVnRXhwO1xudmFyIEJhc2UgPSAkUmVnRXhwO1xudmFyIHByb3RvID0gJFJlZ0V4cC5wcm90b3R5cGU7XG52YXIgcmUxID0gL2EvZztcbnZhciByZTIgPSAvYS9nO1xuLy8gXCJuZXdcIiBjcmVhdGVzIGEgbmV3IG9iamVjdCwgb2xkIHdlYmtpdCBidWdneSBoZXJlXG52YXIgQ09SUkVDVF9ORVcgPSBuZXcgJFJlZ0V4cChyZTEpICE9PSByZTE7XG5cbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICghQ09SUkVDVF9ORVcgfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJlMltyZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKV0gPSBmYWxzZTtcbiAgLy8gUmVnRXhwIGNvbnN0cnVjdG9yIGNhbiBhbHRlciBmbGFncyBhbmQgSXNSZWdFeHAgd29ya3MgY29ycmVjdCB3aXRoIEBAbWF0Y2hcbiAgcmV0dXJuICRSZWdFeHAocmUxKSAhPSByZTEgfHwgJFJlZ0V4cChyZTIpID09IHJlMiB8fCAkUmVnRXhwKHJlMSwgJ2knKSAhPSAnL2EvaSc7XG59KSkpIHtcbiAgJFJlZ0V4cCA9IGZ1bmN0aW9uIFJlZ0V4cChwLCBmKSB7XG4gICAgdmFyIHRpUkUgPSB0aGlzIGluc3RhbmNlb2YgJFJlZ0V4cDtcbiAgICB2YXIgcGlSRSA9IGlzUmVnRXhwKHApO1xuICAgIHZhciBmaVUgPSBmID09PSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuICF0aVJFICYmIHBpUkUgJiYgcC5jb25zdHJ1Y3RvciA9PT0gJFJlZ0V4cCAmJiBmaVUgPyBwXG4gICAgICA6IGluaGVyaXRJZlJlcXVpcmVkKENPUlJFQ1RfTkVXXG4gICAgICAgID8gbmV3IEJhc2UocGlSRSAmJiAhZmlVID8gcC5zb3VyY2UgOiBwLCBmKVxuICAgICAgICA6IEJhc2UoKHBpUkUgPSBwIGluc3RhbmNlb2YgJFJlZ0V4cCkgPyBwLnNvdXJjZSA6IHAsIHBpUkUgJiYgZmlVID8gJGZsYWdzLmNhbGwocCkgOiBmKVxuICAgICAgLCB0aVJFID8gdGhpcyA6IHByb3RvLCAkUmVnRXhwKTtcbiAgfTtcbiAgdmFyIHByb3h5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGtleSBpbiAkUmVnRXhwIHx8IGRQKCRSZWdFeHAsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCYXNlW2tleV07IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChpdCkgeyBCYXNlW2tleV0gPSBpdDsgfVxuICAgIH0pO1xuICB9O1xuICBmb3IgKHZhciBrZXlzID0gZ09QTihCYXNlKSwgaSA9IDA7IGtleXMubGVuZ3RoID4gaTspIHByb3h5KGtleXNbaSsrXSk7XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJFJlZ0V4cDtcbiAgJFJlZ0V4cC5wcm90b3R5cGUgPSBwcm90bztcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsICdSZWdFeHAnLCAkUmVnRXhwKTtcbn1cblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnUmVnRXhwJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8301\n")},4116:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar regexpExec = __webpack_require__(9600);\n__webpack_require__(2127)({\n  target: 'RegExp',\n  proto: true,\n  forced: regexpExec !== /./.exec\n}, {\n  exec: regexpExec\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDExNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGlCQUFpQixtQkFBTyxDQUFDLElBQWdCO0FBQ3pDLG1CQUFPLENBQUMsSUFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5leGVjLmpzP2IwYzUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYycpO1xucmVxdWlyZSgnLi9fZXhwb3J0Jykoe1xuICB0YXJnZXQ6ICdSZWdFeHAnLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiByZWdleHBFeGVjICE9PSAvLi8uZXhlY1xufSwge1xuICBleGVjOiByZWdleHBFeGVjXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4116\n")},9638:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// 21.2.5.3 get RegExp.prototype.flags()\nif (__webpack_require__(1763) && /./g.flags != 'g') (__webpack_require__(7967).f)(RegExp.prototype, 'flags', {\n  configurable: true,\n  get: __webpack_require__(1158)\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYzOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksbUJBQU8sQ0FBQyxJQUFnQix3QkFBd0IsNkJBQXlCO0FBQzdFO0FBQ0EsT0FBTyxtQkFBTyxDQUFDLElBQVU7QUFDekIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MuanM/Mzg0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFncygpXG5pZiAocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAvLi9nLmZsYWdzICE9ICdnJykgcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihSZWdFeHAucHJvdG90eXBlLCAnZmxhZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiByZXF1aXJlKCcuL19mbGFncycpXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9638\n")},4040:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar anObject = __webpack_require__(4228);\nvar toLength = __webpack_require__(1485);\nvar advanceStringIndex = __webpack_require__(8828);\nvar regExpExec = __webpack_require__(2535);\n\n// @@match logic\n__webpack_require__(9228)('match', 1, function (defined, MATCH, $match, maybeCallNative) {\n  return [\n    // `String.prototype.match` method\n    // https://tc39.github.io/ecma262/#sec-string.prototype.match\n    function match(regexp) {\n      var O = defined(this);\n      var fn = regexp == undefined ? undefined : regexp[MATCH];\n      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));\n    },\n    // `RegExp.prototype[@@match]` method\n    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match\n    function (regexp) {\n      var res = maybeCallNative($match, regexp, this);\n      if (res.done) return res.value;\n      var rx = anObject(regexp);\n      var S = String(this);\n      if (!rx.global) return regExpExec(rx, S);\n      var fullUnicode = rx.unicode;\n      rx.lastIndex = 0;\n      var A = [];\n      var n = 0;\n      var result;\n      while ((result = regExpExec(rx, S)) !== null) {\n        var matchStr = String(result[0]);\n        A[n] = matchStr;\n        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n        n++;\n      }\n      return n === 0 ? null : A;\n    }\n  ];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA0MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyx5QkFBeUIsbUJBQU8sQ0FBQyxJQUF5QjtBQUMxRCxpQkFBaUIsbUJBQU8sQ0FBQyxJQUF5Qjs7QUFFbEQ7QUFDQSxtQkFBTyxDQUFDLElBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaC5qcz80OTE3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuL19hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xuXG4vLyBAQG1hdGNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ21hdGNoJywgMSwgZnVuY3Rpb24gKGRlZmluZWQsIE1BVENILCAkbWF0Y2gsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLm1hdGNoYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLm1hdGNoXG4gICAgZnVuY3Rpb24gbWF0Y2gocmVnZXhwKSB7XG4gICAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgICB2YXIgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW01BVENIXTtcbiAgICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBtYXRjaFxuICAgIGZ1bmN0aW9uIChyZWdleHApIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoJG1hdGNoLCByZWdleHAsIHRoaXMpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYgKCFyeC5nbG9iYWwpIHJldHVybiByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgIHZhciBmdWxsVW5pY29kZSA9IHJ4LnVuaWNvZGU7XG4gICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIEEgPSBbXTtcbiAgICAgIHZhciBuID0gMDtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICB3aGlsZSAoKHJlc3VsdCA9IHJlZ0V4cEV4ZWMocngsIFMpKSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgQVtuXSA9IG1hdGNoU3RyO1xuICAgICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgdG9MZW5ndGgocngubGFzdEluZGV4KSwgZnVsbFVuaWNvZGUpO1xuICAgICAgICBuKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gbiA9PT0gMCA/IG51bGwgOiBBO1xuICAgIH1cbiAgXTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4040\n")},8305:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar anObject = __webpack_require__(4228);\nvar toObject = __webpack_require__(8270);\nvar toLength = __webpack_require__(1485);\nvar toInteger = __webpack_require__(7087);\nvar advanceStringIndex = __webpack_require__(8828);\nvar regExpExec = __webpack_require__(2535);\nvar max = Math.max;\nvar min = Math.min;\nvar floor = Math.floor;\nvar SUBSTITUTION_SYMBOLS = /\\$([$&`']|\\d\\d?|<[^>]*>)/g;\nvar SUBSTITUTION_SYMBOLS_NO_NAMED = /\\$([$&`']|\\d\\d?)/g;\n\nvar maybeToString = function (it) {\n  return it === undefined ? it : String(it);\n};\n\n// @@replace logic\n__webpack_require__(9228)('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {\n  return [\n    // `String.prototype.replace` method\n    // https://tc39.github.io/ecma262/#sec-string.prototype.replace\n    function replace(searchValue, replaceValue) {\n      var O = defined(this);\n      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];\n      return fn !== undefined\n        ? fn.call(searchValue, O, replaceValue)\n        : $replace.call(String(O), searchValue, replaceValue);\n    },\n    // `RegExp.prototype[@@replace]` method\n    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace\n    function (regexp, replaceValue) {\n      var res = maybeCallNative($replace, regexp, this, replaceValue);\n      if (res.done) return res.value;\n\n      var rx = anObject(regexp);\n      var S = String(this);\n      var functionalReplace = typeof replaceValue === 'function';\n      if (!functionalReplace) replaceValue = String(replaceValue);\n      var global = rx.global;\n      if (global) {\n        var fullUnicode = rx.unicode;\n        rx.lastIndex = 0;\n      }\n      var results = [];\n      while (true) {\n        var result = regExpExec(rx, S);\n        if (result === null) break;\n        results.push(result);\n        if (!global) break;\n        var matchStr = String(result[0]);\n        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n      }\n      var accumulatedResult = '';\n      var nextSourcePosition = 0;\n      for (var i = 0; i < results.length; i++) {\n        result = results[i];\n        var matched = String(result[0]);\n        var position = max(min(toInteger(result.index), S.length), 0);\n        var captures = [];\n        // NOTE: This is equivalent to\n        //   captures = result.slice(1).map(maybeToString)\n        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in\n        // the slice polyfill when slicing native arrays) \"doesn't work\" in safari 9 and\n        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.\n        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));\n        var namedCaptures = result.groups;\n        if (functionalReplace) {\n          var replacerArgs = [matched].concat(captures, position, S);\n          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);\n          var replacement = String(replaceValue.apply(undefined, replacerArgs));\n        } else {\n          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);\n        }\n        if (position >= nextSourcePosition) {\n          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;\n          nextSourcePosition = position + matched.length;\n        }\n      }\n      return accumulatedResult + S.slice(nextSourcePosition);\n    }\n  ];\n\n    // https://tc39.github.io/ecma262/#sec-getsubstitution\n  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {\n    var tailPos = position + matched.length;\n    var m = captures.length;\n    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;\n    if (namedCaptures !== undefined) {\n      namedCaptures = toObject(namedCaptures);\n      symbols = SUBSTITUTION_SYMBOLS;\n    }\n    return $replace.call(replacement, symbols, function (match, ch) {\n      var capture;\n      switch (ch.charAt(0)) {\n        case '$': return '$';\n        case '&': return matched;\n        case '`': return str.slice(0, position);\n        case \"'\": return str.slice(tailPos);\n        case '<':\n          capture = namedCaptures[ch.slice(1, -1)];\n          break;\n        default: // \\d\\d?\n          var n = +ch;\n          if (n === 0) return match;\n          if (n > m) {\n            var f = floor(n / 10);\n            if (f === 0) return match;\n            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);\n            return match;\n          }\n          capture = captures[n - 1];\n      }\n      return capture === undefined ? '' : capture;\n    });\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODMwNS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFlO0FBQ3ZDLHlCQUF5QixtQkFBTyxDQUFDLElBQXlCO0FBQzFELGlCQUFpQixtQkFBTyxDQUFDLElBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQU8sQ0FBQyxJQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UuanM/YTQ4MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi9fYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFMgPSAvXFwkKFskJmAnXXxcXGRcXGQ/fDxbXj5dKj4pL2c7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQgPSAvXFwkKFskJmAnXXxcXGRcXGQ/KS9nO1xuXG52YXIgbWF5YmVUb1N0cmluZyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG5cbi8vIEBAcmVwbGFjZSBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFJFUExBQ0UsICRyZXBsYWNlLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGxhY2VcbiAgICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICAgIHZhciBmbiA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICAgIDogJHJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHJlcGxhY2VcbiAgICBmdW5jdGlvbiAocmVnZXhwLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoJHJlcGxhY2UsIHJlZ2V4cCwgdGhpcywgcmVwbGFjZVZhbHVlKTtcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIGZ1bmN0aW9uYWxSZXBsYWNlID0gdHlwZW9mIHJlcGxhY2VWYWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIGlmICghZnVuY3Rpb25hbFJlcGxhY2UpIHJlcGxhY2VWYWx1ZSA9IFN0cmluZyhyZXBsYWNlVmFsdWUpO1xuICAgICAgdmFyIGdsb2JhbCA9IHJ4Lmdsb2JhbDtcbiAgICAgIGlmIChnbG9iYWwpIHtcbiAgICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGJyZWFrO1xuICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgaWYgKCFnbG9iYWwpIGJyZWFrO1xuICAgICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgIH1cbiAgICAgIHZhciBhY2N1bXVsYXRlZFJlc3VsdCA9ICcnO1xuICAgICAgdmFyIG5leHRTb3VyY2VQb3NpdGlvbiA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpXTtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbWF4KG1pbih0b0ludGVnZXIocmVzdWx0LmluZGV4KSwgUy5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGNhcHR1cmVzID0gW107XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgICAvLyAgIGNhcHR1cmVzID0gcmVzdWx0LnNsaWNlKDEpLm1hcChtYXliZVRvU3RyaW5nKVxuICAgICAgICAvLyBidXQgZm9yIHNvbWUgcmVhc29uIGBuYXRpdmVTbGljZS5jYWxsKHJlc3VsdCwgMSwgcmVzdWx0Lmxlbmd0aClgIChjYWxsZWQgaW5cbiAgICAgICAgLy8gdGhlIHNsaWNlIHBvbHlmaWxsIHdoZW4gc2xpY2luZyBuYXRpdmUgYXJyYXlzKSBcImRvZXNuJ3Qgd29ya1wiIGluIHNhZmFyaSA5IGFuZFxuICAgICAgICAvLyBjYXVzZXMgYSBjcmFzaCAoaHR0cHM6Ly9wYXN0ZWJpbi5jb20vTjIxUXplUUEpIHdoZW4gdHJ5aW5nIHRvIGRlYnVnIGl0LlxuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykgY2FwdHVyZXMucHVzaChtYXliZVRvU3RyaW5nKHJlc3VsdFtqXSkpO1xuICAgICAgICB2YXIgbmFtZWRDYXB0dXJlcyA9IHJlc3VsdC5ncm91cHM7XG4gICAgICAgIGlmIChmdW5jdGlvbmFsUmVwbGFjZSkge1xuICAgICAgICAgIHZhciByZXBsYWNlckFyZ3MgPSBbbWF0Y2hlZF0uY29uY2F0KGNhcHR1cmVzLCBwb3NpdGlvbiwgUyk7XG4gICAgICAgICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkgcmVwbGFjZXJBcmdzLnB1c2gobmFtZWRDYXB0dXJlcyk7XG4gICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gU3RyaW5nKHJlcGxhY2VWYWx1ZS5hcHBseSh1bmRlZmluZWQsIHJlcGxhY2VyQXJncykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcGxhY2VtZW50ID0gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIFMsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPj0gbmV4dFNvdXJjZVBvc2l0aW9uKSB7XG4gICAgICAgICAgYWNjdW11bGF0ZWRSZXN1bHQgKz0gUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24sIHBvc2l0aW9uKSArIHJlcGxhY2VtZW50O1xuICAgICAgICAgIG5leHRTb3VyY2VQb3NpdGlvbiA9IHBvc2l0aW9uICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRlZFJlc3VsdCArIFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uKTtcbiAgICB9XG4gIF07XG5cbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZXRzdWJzdGl0dXRpb25cbiAgZnVuY3Rpb24gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIHN0ciwgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlbWVudCkge1xuICAgIHZhciB0YWlsUG9zID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcbiAgICB2YXIgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEO1xuICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcbiAgICAgIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MUztcbiAgICB9XG4gICAgcmV0dXJuICRyZXBsYWNlLmNhbGwocmVwbGFjZW1lbnQsIHN5bWJvbHMsIGZ1bmN0aW9uIChtYXRjaCwgY2gpIHtcbiAgICAgIHZhciBjYXB0dXJlO1xuICAgICAgc3dpdGNoIChjaC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnJCc6IHJldHVybiAnJCc7XG4gICAgICAgIGNhc2UgJyYnOiByZXR1cm4gbWF0Y2hlZDtcbiAgICAgICAgY2FzZSAnYCc6IHJldHVybiBzdHIuc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gc3RyLnNsaWNlKHRhaWxQb3MpO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBjYXB0dXJlID0gbmFtZWRDYXB0dXJlc1tjaC5zbGljZSgxLCAtMSldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiAvLyBcXGRcXGQ/XG4gICAgICAgICAgdmFyIG4gPSArY2g7XG4gICAgICAgICAgaWYgKG4gPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICBpZiAobiA+IG0pIHtcbiAgICAgICAgICAgIHZhciBmID0gZmxvb3IobiAvIDEwKTtcbiAgICAgICAgICAgIGlmIChmID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICBpZiAoZiA8PSBtKSByZXR1cm4gY2FwdHVyZXNbZiAtIDFdID09PSB1bmRlZmluZWQgPyBjaC5jaGFyQXQoMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaC5jaGFyQXQoMSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhcHR1cmUgPSBjYXB0dXJlc1tuIC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xuICAgIH0pO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8305\n")},4701:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar anObject = __webpack_require__(4228);\nvar sameValue = __webpack_require__(7359);\nvar regExpExec = __webpack_require__(2535);\n\n// @@search logic\n__webpack_require__(9228)('search', 1, function (defined, SEARCH, $search, maybeCallNative) {\n  return [\n    // `String.prototype.search` method\n    // https://tc39.github.io/ecma262/#sec-string.prototype.search\n    function search(regexp) {\n      var O = defined(this);\n      var fn = regexp == undefined ? undefined : regexp[SEARCH];\n      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));\n    },\n    // `RegExp.prototype[@@search]` method\n    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search\n    function (regexp) {\n      var res = maybeCallNative($search, regexp, this);\n      if (res.done) return res.value;\n      var rx = anObject(regexp);\n      var S = String(this);\n      var previousLastIndex = rx.lastIndex;\n      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;\n      var result = regExpExec(rx, S);\n      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;\n      return result === null ? -1 : result.index;\n    }\n  ];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcwMS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFlO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLElBQXlCOztBQUVsRDtBQUNBLG1CQUFPLENBQUMsSUFBZTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoLmpzPzM4NmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBzYW1lVmFsdWUgPSByZXF1aXJlKCcuL19zYW1lLXZhbHVlJyk7XG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbi8vIEBAc2VhcmNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NlYXJjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBTRUFSQ0gsICRzZWFyY2gsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnNlYXJjaGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zZWFyY2hcbiAgICBmdW5jdGlvbiBzZWFyY2gocmVnZXhwKSB7XG4gICAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgICB2YXIgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW1NFQVJDSF07XG4gICAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtTRUFSQ0hdKFN0cmluZyhPKSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzZWFyY2hcbiAgICBmdW5jdGlvbiAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKCRzZWFyY2gsIHJlZ2V4cCwgdGhpcyk7XG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICB2YXIgcHJldmlvdXNMYXN0SW5kZXggPSByeC5sYXN0SW5kZXg7XG4gICAgICBpZiAoIXNhbWVWYWx1ZShwcmV2aW91c0xhc3RJbmRleCwgMCkpIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICBpZiAoIXNhbWVWYWx1ZShyeC5sYXN0SW5kZXgsIHByZXZpb3VzTGFzdEluZGV4KSkgcngubGFzdEluZGV4ID0gcHJldmlvdXNMYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gLTEgOiByZXN1bHQuaW5kZXg7XG4gICAgfVxuICBdO1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4701\n")},341:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar isRegExp = __webpack_require__(5411);\nvar anObject = __webpack_require__(4228);\nvar speciesConstructor = __webpack_require__(9190);\nvar advanceStringIndex = __webpack_require__(8828);\nvar toLength = __webpack_require__(1485);\nvar callRegExpExec = __webpack_require__(2535);\nvar regexpExec = __webpack_require__(9600);\nvar fails = __webpack_require__(9448);\nvar $min = Math.min;\nvar $push = [].push;\nvar $SPLIT = 'split';\nvar LENGTH = 'length';\nvar LAST_INDEX = 'lastIndex';\nvar MAX_UINT32 = 0xffffffff;\n\n// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError\nvar SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });\n\n// @@split logic\n__webpack_require__(9228)('split', 2, function (defined, SPLIT, $split, maybeCallNative) {\n  var internalSplit;\n  if (\n    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||\n    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||\n    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||\n    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||\n    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||\n    ''[$SPLIT](/.?/)[LENGTH]\n  ) {\n    // based on es5-shim implementation, need to rework it\n    internalSplit = function (separator, limit) {\n      var string = String(this);\n      if (separator === undefined && limit === 0) return [];\n      // If `separator` is not a regex, use native split\n      if (!isRegExp(separator)) return $split.call(string, separator, limit);\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var match, lastIndex, lastLength;\n      while (match = regexpExec.call(separatorCopy, string)) {\n        lastIndex = separatorCopy[LAST_INDEX];\n        if (lastIndex > lastLastIndex) {\n          output.push(string.slice(lastLastIndex, match.index));\n          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));\n          lastLength = match[0][LENGTH];\n          lastLastIndex = lastIndex;\n          if (output[LENGTH] >= splitLimit) break;\n        }\n        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop\n      }\n      if (lastLastIndex === string[LENGTH]) {\n        if (lastLength || !separatorCopy.test('')) output.push('');\n      } else output.push(string.slice(lastLastIndex));\n      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;\n    };\n  // Chakra, V8\n  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {\n    internalSplit = function (separator, limit) {\n      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);\n    };\n  } else {\n    internalSplit = $split;\n  }\n\n  return [\n    // `String.prototype.split` method\n    // https://tc39.github.io/ecma262/#sec-string.prototype.split\n    function split(separator, limit) {\n      var O = defined(this);\n      var splitter = separator == undefined ? undefined : separator[SPLIT];\n      return splitter !== undefined\n        ? splitter.call(separator, O, limit)\n        : internalSplit.call(String(O), separator, limit);\n    },\n    // `RegExp.prototype[@@split]` method\n    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split\n    //\n    // NOTE: This cannot be properly polyfilled in engines that don't support\n    // the 'y' flag.\n    function (regexp, limit) {\n      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);\n      if (res.done) return res.value;\n\n      var rx = anObject(regexp);\n      var S = String(this);\n      var C = speciesConstructor(rx, RegExp);\n\n      var unicodeMatching = rx.unicode;\n      var flags = (rx.ignoreCase ? 'i' : '') +\n                  (rx.multiline ? 'm' : '') +\n                  (rx.unicode ? 'u' : '') +\n                  (SUPPORTS_Y ? 'y' : 'g');\n\n      // ^(? + rx + ) is needed, in combination with some S slicing, to\n      // simulate the 'y' flag.\n      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);\n      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0) return [];\n      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];\n      var p = 0;\n      var q = 0;\n      var A = [];\n      while (q < S.length) {\n        splitter.lastIndex = SUPPORTS_Y ? q : 0;\n        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));\n        var e;\n        if (\n          z === null ||\n          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p\n        ) {\n          q = advanceStringIndex(S, q, unicodeMatching);\n        } else {\n          A.push(S.slice(p, q));\n          if (A.length === lim) return A;\n          for (var i = 1; i <= z.length - 1; i++) {\n            A.push(z[i]);\n            if (A.length === lim) return A;\n          }\n          q = p = e;\n        }\n      }\n      A.push(S.slice(p));\n      return A;\n    }\n  ];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQxLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLHlCQUF5QixtQkFBTyxDQUFDLElBQXdCO0FBQ3pELHlCQUF5QixtQkFBTyxDQUFDLElBQXlCO0FBQzFELGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLHFCQUFxQixtQkFBTyxDQUFDLElBQXlCO0FBQ3RELGlCQUFpQixtQkFBTyxDQUFDLElBQWdCO0FBQ3pDLFlBQVksbUJBQU8sQ0FBQyxJQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQywwQkFBMEI7O0FBRWhFO0FBQ0EsbUJBQU8sQ0FBQyxJQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanM/MjhhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4vX2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjYWxsUmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyICRtaW4gPSBNYXRoLm1pbjtcbnZhciAkcHVzaCA9IFtdLnB1c2g7XG52YXIgJFNQTElUID0gJ3NwbGl0JztcbnZhciBMRU5HVEggPSAnbGVuZ3RoJztcbnZhciBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG52YXIgTUFYX1VJTlQzMiA9IDB4ZmZmZmZmZmY7XG5cbi8vIGJhYmVsLW1pbmlmeSB0cmFuc3BpbGVzIFJlZ0V4cCgneCcsICd5JykgLT4gL3gveSBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG52YXIgU1VQUE9SVFNfWSA9ICFmYWlscyhmdW5jdGlvbiAoKSB7IFJlZ0V4cChNQVhfVUlOVDMyLCAneScpOyB9KTtcblxuLy8gQEBzcGxpdCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzcGxpdCcsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBTUExJVCwgJHNwbGl0LCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgdmFyIGludGVybmFsU3BsaXQ7XG4gIGlmIChcbiAgICAnYWJiYydbJFNQTElUXSgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgICd0ZXN0J1skU1BMSVRdKC8oPzopLywgLTEpW0xFTkdUSF0gIT0gNCB8fFxuICAgICdhYidbJFNQTElUXSgvKD86YWIpKi8pW0xFTkdUSF0gIT0gMiB8fFxuICAgICcuJ1skU1BMSVRdKC8oLj8pKC4/KS8pW0xFTkdUSF0gIT0gNCB8fFxuICAgICcuJ1skU1BMSVRdKC8oKSgpLylbTEVOR1RIXSA+IDEgfHxcbiAgICAnJ1skU1BMSVRdKC8uPy8pW0xFTkdUSF1cbiAgKSB7XG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwKSByZXR1cm4gW107XG4gICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgaWYgKCFpc1JlZ0V4cChzZXBhcmF0b3IpKSByZXR1cm4gJHNwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgc3BsaXRMaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfVUlOVDMyIDogbGltaXQgPj4+IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgd2hpbGUgKG1hdGNoID0gcmVnZXhwRXhlYy5jYWxsKHNlcGFyYXRvckNvcHksIHN0cmluZykpIHtcbiAgICAgICAgbGFzdEluZGV4ID0gc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXTtcbiAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICBpZiAobWF0Y2hbTEVOR1RIXSA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmdbTEVOR1RIXSkgJHB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZiAob3V0cHV0W0xFTkdUSF0gPj0gc3BsaXRMaW1pdCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0gPT09IG1hdGNoLmluZGV4KSBzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdKys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmdbTEVOR1RIXSkge1xuICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yQ29weS50ZXN0KCcnKSkgb3V0cHV0LnB1c2goJycpO1xuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0W0xFTkdUSF0gPiBzcGxpdExpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmICgnMCdbJFNQTElUXSh1bmRlZmluZWQsIDApW0xFTkdUSF0pIHtcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogJHNwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpbnRlcm5hbFNwbGl0ID0gJHNwbGl0O1xuICB9XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zcGxpdFxuICAgIGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICAgIHZhciBzcGxpdHRlciA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgICAgcmV0dXJuIHNwbGl0dGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBzcGxpdHRlci5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpXG4gICAgICAgIDogaW50ZXJuYWxTcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHNwbGl0XG4gICAgLy9cbiAgICAvLyBOT1RFOiBUaGlzIGNhbm5vdCBiZSBwcm9wZXJseSBwb2x5ZmlsbGVkIGluIGVuZ2luZXMgdGhhdCBkb24ndCBzdXBwb3J0XG4gICAgLy8gdGhlICd5JyBmbGFnLlxuICAgIGZ1bmN0aW9uIChyZWdleHAsIGxpbWl0KSB7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKGludGVybmFsU3BsaXQsIHJlZ2V4cCwgdGhpcywgbGltaXQsIGludGVybmFsU3BsaXQgIT09ICRzcGxpdCk7XG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHJ4LCBSZWdFeHApO1xuXG4gICAgICB2YXIgdW5pY29kZU1hdGNoaW5nID0gcngudW5pY29kZTtcbiAgICAgIHZhciBmbGFncyA9IChyeC5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyeC5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJ4LnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKFNVUFBPUlRTX1kgPyAneScgOiAnZycpO1xuXG4gICAgICAvLyBeKD8gKyByeCArICkgaXMgbmVlZGVkLCBpbiBjb21iaW5hdGlvbiB3aXRoIHNvbWUgUyBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgdmFyIHNwbGl0dGVyID0gbmV3IEMoU1VQUE9SVFNfWSA/IHJ4IDogJ14oPzonICsgcnguc291cmNlICsgJyknLCBmbGFncyk7XG4gICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmIChsaW0gPT09IDApIHJldHVybiBbXTtcbiAgICAgIGlmIChTLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTKSA9PT0gbnVsbCA/IFtTXSA6IFtdO1xuICAgICAgdmFyIHAgPSAwO1xuICAgICAgdmFyIHEgPSAwO1xuICAgICAgdmFyIEEgPSBbXTtcbiAgICAgIHdoaWxlIChxIDwgUy5sZW5ndGgpIHtcbiAgICAgICAgc3BsaXR0ZXIubGFzdEluZGV4ID0gU1VQUE9SVFNfWSA/IHEgOiAwO1xuICAgICAgICB2YXIgeiA9IGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTVVBQT1JUU19ZID8gUyA6IFMuc2xpY2UocSkpO1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHogPT09IG51bGwgfHxcbiAgICAgICAgICAoZSA9ICRtaW4odG9MZW5ndGgoc3BsaXR0ZXIubGFzdEluZGV4ICsgKFNVUFBPUlRTX1kgPyAwIDogcSkpLCBTLmxlbmd0aCkpID09PSBwXG4gICAgICAgICkge1xuICAgICAgICAgIHEgPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgcSwgdW5pY29kZU1hdGNoaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBLnB1c2goUy5zbGljZShwLCBxKSk7XG4gICAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHoubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBBLnB1c2goeltpXSk7XG4gICAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHEgPSBwID0gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgQS5wdXNoKFMuc2xpY2UocCkpO1xuICAgICAgcmV0dXJuIEE7XG4gICAgfVxuICBdO1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///341\n")},8604:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n__webpack_require__(9638);\nvar anObject = __webpack_require__(4228);\nvar $flags = __webpack_require__(1158);\nvar DESCRIPTORS = __webpack_require__(1763);\nvar TO_STRING = 'toString';\nvar $toString = /./[TO_STRING];\n\nvar define = function (fn) {\n  __webpack_require__(8859)(RegExp.prototype, TO_STRING, fn, true);\n};\n\n// 21.2.5.14 RegExp.prototype.toString()\nif (__webpack_require__(9448)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {\n  define(function toString() {\n    var R = anObject(this);\n    return '/'.concat(R.source, '/',\n      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);\n  });\n// FF44- RegExp#toString has a wrong name\n} else if ($toString.name != TO_STRING) {\n  define(function toString() {\n    return $toString.call(this);\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODYwNC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLG1CQUFPLENBQUMsSUFBb0I7QUFDNUIsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsYUFBYSxtQkFBTyxDQUFDLElBQVU7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsSUFBZ0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBLEVBQUUsbUJBQU8sQ0FBQyxJQUFhO0FBQ3ZCOztBQUVBO0FBQ0EsSUFBSSxtQkFBTyxDQUFDLElBQVUsZ0JBQWdCLHdCQUF3Qix5QkFBeUIsY0FBYztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanM/NmI1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRmbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gLy4vW1RPX1NUUklOR107XG5cbnZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZuLCB0cnVlKTtcbn07XG5cbi8vIDIxLjIuNS4xNCBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nKClcbmlmIChyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHsgcmV0dXJuICR0b1N0cmluZy5jYWxsKHsgc291cmNlOiAnYScsIGZsYWdzOiAnYicgfSkgIT0gJy9hL2InOyB9KSkge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgICByZXR1cm4gJy8nLmNvbmNhdChSLnNvdXJjZSwgJy8nLFxuICAgICAgJ2ZsYWdzJyBpbiBSID8gUi5mbGFncyA6ICFERVNDUklQVE9SUyAmJiBSIGluc3RhbmNlb2YgUmVnRXhwID8gJGZsYWdzLmNhbGwoUikgOiB1bmRlZmluZWQpO1xuICB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG59IGVsc2UgaWYgKCR0b1N0cmluZy5uYW1lICE9IFRPX1NUUklORykge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICR0b1N0cmluZy5jYWxsKHRoaXMpO1xuICB9KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8604\n")},1632:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar strong = __webpack_require__(6197);\nvar validate = __webpack_require__(2888);\nvar SET = 'Set';\n\n// 23.2 Set Objects\nmodule.exports = __webpack_require__(8933)(SET, function (get) {\n  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.2.3.1 Set.prototype.add(value)\n  add: function add(value) {\n    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);\n  }\n}, strong);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYzMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxJQUFzQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsSUFBd0I7QUFDL0M7O0FBRUE7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFlO0FBQ3hDLDBCQUEwQjtBQUMxQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnNldC5qcz80ZjdmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNFVCA9ICdTZXQnO1xuXG4vLyAyMy4yIFNldCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShTRVQsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHZhbGlkYXRlKHRoaXMsIFNFVCksIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1632\n")},7360:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// B.2.3.2 String.prototype.anchor(name)\n__webpack_require__(2468)('anchor', function (createHTML) {\n  return function anchor(name) {\n    return createHTML(this, 'a', 'name', name);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM2MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsbUJBQU8sQ0FBQyxJQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3IuanM/ODQ0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4yIFN0cmluZy5wcm90b3R5cGUuYW5jaG9yKG5hbWUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdhbmNob3InLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYW5jaG9yKG5hbWUpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICduYW1lJywgbmFtZSk7XG4gIH07XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7360\n")},9011:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// B.2.3.3 String.prototype.big()\n__webpack_require__(2468)('big', function (createHTML) {\n  return function big() {\n    return createHTML(this, 'big', '', '');\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAxMS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsbUJBQU8sQ0FBQyxJQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5iaWcuanM/OWM4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4zIFN0cmluZy5wcm90b3R5cGUuYmlnKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JpZycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBiaWcoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JpZycsICcnLCAnJyk7XG4gIH07XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9011\n")},4591:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// B.2.3.4 String.prototype.blink()\n__webpack_require__(2468)('blink', function (createHTML) {\n  return function blink() {\n    return createHTML(this, 'blink', '', '');\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU5MS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsbUJBQU8sQ0FBQyxJQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qcz9mYTgzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjQgU3RyaW5nLnByb3RvdHlwZS5ibGluaygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdibGluaycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBibGluaygpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmxpbmsnLCAnJywgJycpO1xuICB9O1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4591\n")},7334:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// B.2.3.5 String.prototype.bold()\n__webpack_require__(2468)('bold', function (createHTML) {\n  return function bold() {\n    return createHTML(this, 'b', '', '');\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMzNC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsbUJBQU8sQ0FBQyxJQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkLmpzPzQ4YzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNSBTdHJpbmcucHJvdG90eXBlLmJvbGQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYm9sZCcsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBib2xkKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdiJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7334\n")},2405:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar $at = __webpack_require__(1212)(false);\n$export($export.P, 'String', {\n  // 21.1.3.3 String.prototype.codePointAt(pos)\n  codePointAt: function codePointAt(pos) {\n    return $at(this, pos);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQwNS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLFVBQVUsbUJBQU8sQ0FBQyxJQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0LmpzP2EwMzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKShmYWxzZSk7XG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjMgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdChwb3MpXG4gIGNvZGVQb2ludEF0OiBmdW5jdGlvbiBjb2RlUG9pbnRBdChwb3MpIHtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2405\n")},7224:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])\n\nvar $export = __webpack_require__(2127);\nvar toLength = __webpack_require__(1485);\nvar context = __webpack_require__(8942);\nvar ENDS_WITH = 'endsWith';\nvar $endsWith = ''[ENDS_WITH];\n\n$export($export.P + $export.F * __webpack_require__(5203)(ENDS_WITH), 'String', {\n  endsWith: function endsWith(searchString /* , endPosition = @length */) {\n    var that = context(this, searchString, ENDS_WITH);\n    var endPosition = arguments.length > 1 ? arguments[1] : undefined;\n    var len = toLength(that.length);\n    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);\n    var search = String(searchString);\n    return $endsWith\n      ? $endsWith.call(that, search, end)\n      : that.slice(end - search.length, end) === search;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIyNC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhO0FBQ2IsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsY0FBYyxtQkFBTyxDQUFDLElBQW1CO0FBQ3pDO0FBQ0E7O0FBRUEsZ0NBQWdDLG1CQUFPLENBQUMsSUFBb0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanM/YWVmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG52YXIgRU5EU19XSVRIID0gJ2VuZHNXaXRoJztcbnZhciAkZW5kc1dpdGggPSAnJ1tFTkRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKEVORFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pIHtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBFTkRTX1dJVEgpO1xuICAgIHZhciBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aCk7XG4gICAgdmFyIGVuZCA9IGVuZFBvc2l0aW9uID09PSB1bmRlZmluZWQgPyBsZW4gOiBNYXRoLm1pbih0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbik7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkZW5kc1dpdGhcbiAgICAgID8gJGVuZHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBlbmQpXG4gICAgICA6IHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7224\n")},7083:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// B.2.3.6 String.prototype.fixed()\n__webpack_require__(2468)('fixed', function (createHTML) {\n  return function fixed() {\n    return createHTML(this, 'tt', '', '');\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA4My5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsbUJBQU8sQ0FBQyxJQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qcz9kMjYzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjYgU3RyaW5nLnByb3RvdHlwZS5maXhlZCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmaXhlZCcsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmaXhlZCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAndHQnLCAnJywgJycpO1xuICB9O1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7083\n")},9213:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// B.2.3.7 String.prototype.fontcolor(color)\n__webpack_require__(2468)('fontcolor', function (createHTML) {\n  return function fontcolor(color) {\n    return createHTML(this, 'font', 'color', color);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIxMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsbUJBQU8sQ0FBQyxJQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3IuanM/NmMzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy43IFN0cmluZy5wcm90b3R5cGUuZm9udGNvbG9yKGNvbG9yKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZm9udGNvbG9yJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRjb2xvcihjb2xvcikge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdmb250JywgJ2NvbG9yJywgY29sb3IpO1xuICB9O1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9213\n")},8437:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// B.2.3.8 String.prototype.fontsize(size)\n__webpack_require__(2468)('fontsize', function (createHTML) {\n  return function fontsize(size) {\n    return createHTML(this, 'font', 'size', size);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQzNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsbUJBQU8sQ0FBQyxJQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qcz85ZWM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjggU3RyaW5nLnByb3RvdHlwZS5mb250c2l6ZShzaXplKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZm9udHNpemUnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9udHNpemUoc2l6ZSkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdmb250JywgJ3NpemUnLCBzaXplKTtcbiAgfTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8437\n")},2220:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var $export = __webpack_require__(2127);\nvar toAbsoluteIndex = __webpack_require__(157);\nvar fromCharCode = String.fromCharCode;\nvar $fromCodePoint = String.fromCodePoint;\n\n// length should be 1, old FF problem\n$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {\n  // 21.1.2.2 String.fromCodePoint(...codePoints)\n  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars\n    var res = [];\n    var aLen = arguments.length;\n    var i = 0;\n    var code;\n    while (aLen > i) {\n      code = +arguments[i++];\n      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');\n      res.push(code < 0x10000\n        ? fromCharCode(code)\n        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)\n      );\n    } return res.join('');\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIyMC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsSUFBVztBQUNqQyxzQkFBc0IsbUJBQU8sQ0FBQyxHQUFzQjtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzPzU2OTUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG52YXIgJGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludDtcblxuLy8gbGVuZ3RoIHNob3VsZCBiZSAxLCBvbGQgRkYgcHJvYmxlbVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoISEkZnJvbUNvZGVQb2ludCAmJiAkZnJvbUNvZGVQb2ludC5sZW5ndGggIT0gMSksICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi4yIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNvZGVQb2ludHMpXG4gIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoeCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGNvZGU7XG4gICAgd2hpbGUgKGFMZW4gPiBpKSB7XG4gICAgICBjb2RlID0gK2FyZ3VtZW50c1tpKytdO1xuICAgICAgaWYgKHRvQWJzb2x1dGVJbmRleChjb2RlLCAweDEwZmZmZikgIT09IGNvZGUpIHRocm93IFJhbmdlRXJyb3IoY29kZSArICcgaXMgbm90IGEgdmFsaWQgY29kZSBwb2ludCcpO1xuICAgICAgcmVzLnB1c2goY29kZSA8IDB4MTAwMDBcbiAgICAgICAgPyBmcm9tQ2hhckNvZGUoY29kZSlcbiAgICAgICAgOiBmcm9tQ2hhckNvZGUoKChjb2RlIC09IDB4MTAwMDApID4+IDEwKSArIDB4ZDgwMCwgY29kZSAlIDB4NDAwICsgMHhkYzAwKVxuICAgICAgKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2220\n")},8872:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("// 21.1.3.7 String.prototype.includes(searchString, position = 0)\n\nvar $export = __webpack_require__(2127);\nvar context = __webpack_require__(8942);\nvar INCLUDES = 'includes';\n\n$export($export.P + $export.F * __webpack_require__(5203)(INCLUDES), 'String', {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~context(this, searchString, INCLUDES)\n      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODg3Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhO0FBQ2IsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsY0FBYyxtQkFBTyxDQUFDLElBQW1CO0FBQ3pDOztBQUVBLGdDQUFnQyxtQkFBTyxDQUFDLElBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanM/MmZkYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBJTkNMVURFUyA9ICdpbmNsdWRlcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoSU5DTFVERVMpLCAnU3RyaW5nJywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgcmV0dXJuICEhfmNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBJTkNMVURFUylcbiAgICAgIC5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8872\n")},9839:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// B.2.3.9 String.prototype.italics()\n__webpack_require__(2468)('italics', function (createHTML) {\n  return function italics() {\n    return createHTML(this, 'i', '', '');\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTgzOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsbUJBQU8sQ0FBQyxJQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzLmpzP2QwYjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOSBTdHJpbmcucHJvdG90eXBlLml0YWxpY3MoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnaXRhbGljcycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpdGFsaWNzKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdpJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9839\n")},2975:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $at = __webpack_require__(1212)(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n__webpack_require__(8175)(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk3NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFVBQVUsbUJBQU8sQ0FBQyxJQUFjOztBQUVoQztBQUNBLG1CQUFPLENBQUMsSUFBZ0I7QUFDeEIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFdBQVc7QUFDWCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcz81ZGYzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2975\n")},6549:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// B.2.3.10 String.prototype.link(url)\n__webpack_require__(2468)('link', function (createHTML) {\n  return function link(url) {\n    return createHTML(this, 'a', 'href', url);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU0OS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsbUJBQU8sQ0FBQyxJQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzP2I1NGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTAgU3RyaW5nLnByb3RvdHlwZS5saW5rKHVybClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2xpbmsnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gbGluayh1cmwpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICdocmVmJywgdXJsKTtcbiAgfTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6549\n")},3483:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var $export = __webpack_require__(2127);\nvar toIObject = __webpack_require__(7221);\nvar toLength = __webpack_require__(1485);\n\n$export($export.S, 'String', {\n  // 21.1.2.4 String.raw(callSite, ...substitutions)\n  raw: function raw(callSite) {\n    var tpl = toIObject(callSite.raw);\n    var len = toLength(tpl.length);\n    var aLen = arguments.length;\n    var res = [];\n    var i = 0;\n    while (len > i) {\n      res.push(String(tpl[i++]));\n      if (i < aLen) res.push(String(arguments[i]));\n    } return res.join('');\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ4My5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsSUFBVztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFlO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzPzc4OGQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi40IFN0cmluZy5yYXcoY2FsbFNpdGUsIC4uLnN1YnN0aXR1dGlvbnMpXG4gIHJhdzogZnVuY3Rpb24gcmF3KGNhbGxTaXRlKSB7XG4gICAgdmFyIHRwbCA9IHRvSU9iamVjdChjYWxsU2l0ZS5yYXcpO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0cGwubGVuZ3RoKTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAobGVuID4gaSkge1xuICAgICAgcmVzLnB1c2goU3RyaW5nKHRwbFtpKytdKSk7XG4gICAgICBpZiAoaSA8IGFMZW4pIHJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3483\n")},4894:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var $export = __webpack_require__(2127);\n\n$export($export.P, 'String', {\n  // 21.1.3.13 String.prototype.repeat(count)\n  repeat: __webpack_require__(7926)\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg5NC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsSUFBVzs7QUFFakM7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxJQUFrQjtBQUNwQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanM/MTRiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjEzIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KGNvdW50KVxuICByZXBlYXQ6IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4894\n")},2818:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// B.2.3.11 String.prototype.small()\n__webpack_require__(2468)('small', function (createHTML) {\n  return function small() {\n    return createHTML(this, 'small', '', '');\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjgxOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsbUJBQU8sQ0FBQyxJQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbC5qcz9mMzg2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjExIFN0cmluZy5wcm90b3R5cGUuc21hbGwoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc21hbGwnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc21hbGwoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3NtYWxsJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2818\n")},177:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("// 21.1.3.18 String.prototype.startsWith(searchString [, position ])\n\nvar $export = __webpack_require__(2127);\nvar toLength = __webpack_require__(1485);\nvar context = __webpack_require__(8942);\nvar STARTS_WITH = 'startsWith';\nvar $startsWith = ''[STARTS_WITH];\n\n$export($export.P + $export.F * __webpack_require__(5203)(STARTS_WITH), 'String', {\n  startsWith: function startsWith(searchString /* , position = 0 */) {\n    var that = context(this, searchString, STARTS_WITH);\n    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));\n    var search = String(searchString);\n    return $startsWith\n      ? $startsWith.call(that, search, index)\n      : that.slice(index, index + search.length) === search;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7QUFDYixjQUFjLG1CQUFPLENBQUMsSUFBVztBQUNqQyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxjQUFjLG1CQUFPLENBQUMsSUFBbUI7QUFDekM7QUFDQTs7QUFFQSxnQ0FBZ0MsbUJBQU8sQ0FBQyxJQUFvQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanM/ZjU1OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMS4xLjMuMTggU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyBbLCBwb3NpdGlvbiBdKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIFNUQVJUU19XSVRIID0gJ3N0YXJ0c1dpdGgnO1xudmFyICRzdGFydHNXaXRoID0gJydbU1RBUlRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKFNUQVJUU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBTVEFSVFNfV0lUSCk7XG4gICAgdmFyIGluZGV4ID0gdG9MZW5ndGgoTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSk7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkc3RhcnRzV2l0aFxuICAgICAgPyAkc3RhcnRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgaW5kZXgpXG4gICAgICA6IHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///177\n")},8543:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// B.2.3.12 String.prototype.strike()\n__webpack_require__(2468)('strike', function (createHTML) {\n  return function strike() {\n    return createHTML(this, 'strike', '', '');\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU0My5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsbUJBQU8sQ0FBQyxJQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UuanM/MTQ0OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMiBTdHJpbmcucHJvdG90eXBlLnN0cmlrZSgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdHJpa2UnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc3RyaWtlKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdHJpa2UnLCAnJywgJycpO1xuICB9O1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8543\n")},3559:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// B.2.3.13 String.prototype.sub()\n__webpack_require__(2468)('sub', function (createHTML) {\n  return function sub() {\n    return createHTML(this, 'sub', '', '');\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU1OS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsbUJBQU8sQ0FBQyxJQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdWIuanM/NjczZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMyBTdHJpbmcucHJvdG90eXBlLnN1YigpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdWInLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc3ViKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdWInLCAnJywgJycpO1xuICB9O1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3559\n")},4153:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// B.2.3.14 String.prototype.sup()\n__webpack_require__(2468)('sup', function (createHTML) {\n  return function sup() {\n    return createHTML(this, 'sup', '', '');\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE1My5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsbUJBQU8sQ0FBQyxJQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdXAuanM/MjQyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xNCBTdHJpbmcucHJvdG90eXBlLnN1cCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdXAnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc3VwKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdXAnLCAnJywgJycpO1xuICB9O1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4153\n")},957:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// 21.1.3.25 String.prototype.trim()\n__webpack_require__(629)('trim', function ($trim) {\n  return function trim() {\n    return $trim(this, 3);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTU3LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxtQkFBTyxDQUFDLEdBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0uanM/NGYzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyAyMS4xLjMuMjUgU3RyaW5nLnByb3RvdHlwZS50cmltKClcbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW0nLCBmdW5jdGlvbiAoJHRyaW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDMpO1xuICB9O1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///957\n")},9650:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// ECMAScript 6 symbols shim\nvar global = __webpack_require__(7526);\nvar has = __webpack_require__(7917);\nvar DESCRIPTORS = __webpack_require__(1763);\nvar $export = __webpack_require__(2127);\nvar redefine = __webpack_require__(8859);\nvar META = (__webpack_require__(2988).KEY);\nvar $fails = __webpack_require__(9448);\nvar shared = __webpack_require__(4556);\nvar setToStringTag = __webpack_require__(3844);\nvar uid = __webpack_require__(4415);\nvar wks = __webpack_require__(7574);\nvar wksExt = __webpack_require__(7960);\nvar wksDefine = __webpack_require__(5392);\nvar enumKeys = __webpack_require__(5969);\nvar isArray = __webpack_require__(7981);\nvar anObject = __webpack_require__(4228);\nvar isObject = __webpack_require__(3305);\nvar toObject = __webpack_require__(8270);\nvar toIObject = __webpack_require__(7221);\nvar toPrimitive = __webpack_require__(3048);\nvar createDesc = __webpack_require__(1996);\nvar _create = __webpack_require__(4719);\nvar gOPNExt = __webpack_require__(4765);\nvar $GOPD = __webpack_require__(8641);\nvar $GOPS = __webpack_require__(1060);\nvar $DP = __webpack_require__(7967);\nvar $keys = __webpack_require__(1311);\nvar gOPD = $GOPD.f;\nvar dP = $DP.f;\nvar gOPN = gOPNExt.f;\nvar $Symbol = global.Symbol;\nvar $JSON = global.JSON;\nvar _stringify = $JSON && $JSON.stringify;\nvar PROTOTYPE = 'prototype';\nvar HIDDEN = wks('_hidden');\nvar TO_PRIMITIVE = wks('toPrimitive');\nvar isEnum = {}.propertyIsEnumerable;\nvar SymbolRegistry = shared('symbol-registry');\nvar AllSymbols = shared('symbols');\nvar OPSymbols = shared('op-symbols');\nvar ObjectProto = Object[PROTOTYPE];\nvar USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;\nvar QObject = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function () {\n  return _create(dP({}, 'a', {\n    get: function () { return dP(this, 'a', { value: 7 }).a; }\n  })).a != 7;\n}) ? function (it, key, D) {\n  var protoDesc = gOPD(ObjectProto, key);\n  if (protoDesc) delete ObjectProto[key];\n  dP(it, key, D);\n  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function (tag) {\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D) {\n  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if (has(AllSymbols, key)) {\n    if (!D.enumerable) {\n      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\n      D = _create(D, { enumerable: createDesc(0, false) });\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P) {\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P));\n  var i = 0;\n  var l = keys.length;\n  var key;\n  while (l > i) $defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P) {\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key) {\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n  it = toIObject(it);\n  key = toPrimitive(key, true);\n  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;\n  var D = gOPD(it, key);\n  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it) {\n  var names = gOPN(toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\n  var IS_OP = it === ObjectProto;\n  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif (!USE_NATIVE) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function (value) {\n      if (this === ObjectProto) $set.call(OPSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString() {\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f = $defineProperty;\n  (__webpack_require__(9415).f) = gOPNExt.f = $getOwnPropertyNames;\n  (__webpack_require__(8449).f) = $propertyIsEnumerable;\n  $GOPS.f = $getOwnPropertySymbols;\n\n  if (DESCRIPTORS && !__webpack_require__(2750)) {\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function (name) {\n    return wrap(wks(name));\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });\n\nfor (var es6Symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);\n\nfor (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function (key) {\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');\n    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;\n  },\n  useSetter: function () { setter = true; },\n  useSimple: function () { setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives\n// https://bugs.chromium.org/p/v8/issues/detail?id=3443\nvar FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });\n\n$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {\n  getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n    return $GOPS.f(toObject(it));\n  }\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it) {\n    var args = [it];\n    var i = 1;\n    var replacer, $replacer;\n    while (arguments.length > i) args.push(arguments[i++]);\n    $replacer = replacer = args[1];\n    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n    if (!isArray(replacer)) replacer = function (key, value) {\n      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n      if (!isSymbol(value)) return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(3341)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSwrQ0FBK0MsYUFBYTs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxNQUFNLFFBQVEsaUNBQWlDO0FBQ3BHLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0Esb0NBQW9DLG1CQUFPLENBQUMsSUFBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzPzhhODEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkR09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJyAmJiAhISRHT1BTLmY7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRQKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkge1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xuICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXQgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gICRHT1BTLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIENocm9tZSAzOCBhbmQgMzkgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIGZhaWxzIG9uIHByaW1pdGl2ZXNcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM0NDNcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gJGZhaWxzKGZ1bmN0aW9uICgpIHsgJEdPUFMuZigxKTsgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogRkFJTFNfT05fUFJJTUlUSVZFUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgICByZXR1cm4gJEdPUFMuZih0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9650\n")},5706:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar $typed = __webpack_require__(237);\nvar buffer = __webpack_require__(8032);\nvar anObject = __webpack_require__(4228);\nvar toAbsoluteIndex = __webpack_require__(157);\nvar toLength = __webpack_require__(1485);\nvar isObject = __webpack_require__(3305);\nvar ArrayBuffer = (__webpack_require__(7526).ArrayBuffer);\nvar speciesConstructor = __webpack_require__(9190);\nvar $ArrayBuffer = buffer.ArrayBuffer;\nvar $DataView = buffer.DataView;\nvar $isView = $typed.ABV && ArrayBuffer.isView;\nvar $slice = $ArrayBuffer.prototype.slice;\nvar VIEW = $typed.VIEW;\nvar ARRAY_BUFFER = 'ArrayBuffer';\n\n$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });\n\n$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {\n  // 24.1.3.1 ArrayBuffer.isView(arg)\n  isView: function isView(it) {\n    return $isView && $isView(it) || isObject(it) && VIEW in it;\n  }\n});\n\n$export($export.P + $export.U + $export.F * __webpack_require__(9448)(function () {\n  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;\n}), ARRAY_BUFFER, {\n  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)\n  slice: function slice(start, end) {\n    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix\n    var len = anObject(this).byteLength;\n    var first = toAbsoluteIndex(start, len);\n    var fin = toAbsoluteIndex(end === undefined ? len : end, len);\n    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));\n    var viewS = new $DataView(this);\n    var viewT = new $DataView(result);\n    var index = 0;\n    while (first < fin) {\n      viewT.setUint8(index++, viewS.getUint8(first++));\n    } return result;\n  }\n});\n\n__webpack_require__(5762)(ARRAY_BUFFER);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTcwNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxHQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxJQUFpQjtBQUN0QyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxzQkFBc0IsbUJBQU8sQ0FBQyxHQUFzQjtBQUNwRCxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxrQkFBa0IsdUNBQWdDO0FBQ2xELHlCQUF5QixtQkFBTyxDQUFDLElBQXdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4RUFBOEUsMkJBQTJCOztBQUV6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCw0Q0FBNEMsbUJBQU8sQ0FBQyxJQUFVO0FBQzlEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsQ0FBQzs7QUFFRCxtQkFBTyxDQUFDLElBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qcz9jNjZmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbnZhciBidWZmZXIgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIEFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuQXJyYXlCdWZmZXI7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyICRBcnJheUJ1ZmZlciA9IGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbnZhciAkRGF0YVZpZXcgPSBidWZmZXIuRGF0YVZpZXc7XG52YXIgJGlzVmlldyA9ICR0eXBlZC5BQlYgJiYgQXJyYXlCdWZmZXIuaXNWaWV3O1xudmFyICRzbGljZSA9ICRBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG52YXIgVklFVyA9ICR0eXBlZC5WSUVXO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEFycmF5QnVmZmVyICE9PSAkQXJyYXlCdWZmZXIpLCB7IEFycmF5QnVmZmVyOiAkQXJyYXlCdWZmZXIgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISR0eXBlZC5DT05TVFIsIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjMuMSBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKVxuICBpc1ZpZXc6IGZ1bmN0aW9uIGlzVmlldyhpdCkge1xuICAgIHJldHVybiAkaXNWaWV3ICYmICRpc1ZpZXcoaXQpIHx8IGlzT2JqZWN0KGl0KSAmJiBWSUVXIGluIGl0O1xuICB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlUgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFuZXcgJEFycmF5QnVmZmVyKDIpLnNsaWNlKDEsIHVuZGVmaW5lZCkuYnl0ZUxlbmd0aDtcbn0pLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS40LjMgQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKCRzbGljZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJHNsaWNlLmNhbGwoYW5PYmplY3QodGhpcyksIHN0YXJ0KTsgLy8gRkYgZml4XG4gICAgdmFyIGxlbiA9IGFuT2JqZWN0KHRoaXMpLmJ5dGVMZW5ndGg7XG4gICAgdmFyIGZpcnN0ID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICAgIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQsIGxlbik7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRBcnJheUJ1ZmZlcikpKHRvTGVuZ3RoKGZpbiAtIGZpcnN0KSk7XG4gICAgdmFyIHZpZXdTID0gbmV3ICREYXRhVmlldyh0aGlzKTtcbiAgICB2YXIgdmlld1QgPSBuZXcgJERhdGFWaWV3KHJlc3VsdCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoZmlyc3QgPCBmaW4pIHtcbiAgICAgIHZpZXdULnNldFVpbnQ4KGluZGV4KyssIHZpZXdTLmdldFVpbnQ4KGZpcnN0KyspKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKEFSUkFZX0JVRkZFUik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5706\n")},660:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var $export = __webpack_require__(2127);\n$export($export.G + $export.W + $export.F * !(__webpack_require__(237).ABV), {\n  DataView: (__webpack_require__(8032).DataView)\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjYwLmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLDZDQUE2Qyw4QkFBdUI7QUFDcEUsWUFBWSxvQ0FBbUM7QUFDL0MsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcuanM/MjYyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fdHlwZWQnKS5BQlYsIHtcbiAgRGF0YVZpZXc6IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpLkRhdGFWaWV3XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///660\n")},7925:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(7209)('Float32', 4, function (init) {\n  return function Float32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzkyNS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBTyxDQUFDLElBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheS5qcz82M2Q5Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7925\n")},2490:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(7209)('Float64', 8, function (init) {\n  return function Float64Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ5MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBTyxDQUFDLElBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheS5qcz80ZGRhIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0NjQnLCA4LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQ2NEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2490\n")},1220:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(7209)('Int16', 2, function (init) {\n  return function Int16Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIyMC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBTyxDQUFDLElBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanM/MTVhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1220\n")},8066:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(7209)('Int32', 4, function (init) {\n  return function Int32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODA2Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBTyxDQUFDLElBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXkuanM/YjZlNCJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8066\n")},8699:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(7209)('Int8', 1, function (init) {\n  return function Int8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODY5OS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBTyxDQUFDLElBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qcz9iMDVjIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8699\n")},2087:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(7209)('Uint16', 2, function (init) {\n  return function Uint16Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA4Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBTyxDQUFDLElBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzP2FmNTYiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDE2JywgMiwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2087\n")},8537:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(7209)('Uint32', 4, function (init) {\n  return function Uint32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODUzNy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBTyxDQUFDLElBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5LmpzPzljMjkiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8537\n")},4702:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(7209)('Uint8', 1, function (init) {\n  return function Uint8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcwMi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBTyxDQUFDLElBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanM/MzRlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4702\n")},333:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(7209)('Uint8', 1, function (init) {\n  return function Uint8ClampedArray(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n}, true);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMzLmpzIiwibWFwcGluZ3MiOiJBQUFBLG1CQUFPLENBQUMsSUFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzPzZhYTIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhDbGFtcGVkQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0sIHRydWUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///333\n")},9397:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar global = __webpack_require__(7526);\nvar each = __webpack_require__(6179)(0);\nvar redefine = __webpack_require__(8859);\nvar meta = __webpack_require__(2988);\nvar assign = __webpack_require__(8206);\nvar weak = __webpack_require__(9882);\nvar isObject = __webpack_require__(3305);\nvar validate = __webpack_require__(2888);\nvar NATIVE_WEAK_MAP = __webpack_require__(2888);\nvar IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;\nvar WEAK_MAP = 'WeakMap';\nvar getWeak = meta.getWeak;\nvar isExtensible = Object.isExtensible;\nvar uncaughtFrozenStore = weak.ufstore;\nvar InternalMap;\n\nvar wrapper = function (get) {\n  return function WeakMap() {\n    return get(this, arguments.length > 0 ? arguments[0] : undefined);\n  };\n};\n\nvar methods = {\n  // 23.3.3.3 WeakMap.prototype.get(key)\n  get: function get(key) {\n    if (isObject(key)) {\n      var data = getWeak(key);\n      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);\n      return data ? data[this._i] : undefined;\n    }\n  },\n  // 23.3.3.5 WeakMap.prototype.set(key, value)\n  set: function set(key, value) {\n    return weak.def(validate(this, WEAK_MAP), key, value);\n  }\n};\n\n// 23.3 WeakMap Objects\nvar $WeakMap = module.exports = __webpack_require__(8933)(WEAK_MAP, wrapper, methods, weak, true, true);\n\n// IE11 WeakMap frozen keys fix\nif (NATIVE_WEAK_MAP && IS_IE11) {\n  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);\n  assign(InternalMap.prototype, methods);\n  meta.NEED = true;\n  each(['delete', 'has', 'get', 'set'], function (key) {\n    var proto = $WeakMap.prototype;\n    var method = proto[key];\n    redefine(proto, key, function (a, b) {\n      // store frozen objects on internal weakmap shim\n      if (isObject(a) && !isExtensible(a)) {\n        if (!this._f) this._f = new InternalMap();\n        var result = this._f[key](a, b);\n        return key == 'set' ? this : result;\n      // store all the rest on native weakmap\n      } return method.call(this, a, b);\n    });\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTM5Ny5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxJQUFXO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQyxJQUFrQjtBQUNyQyxlQUFlLG1CQUFPLENBQUMsSUFBYTtBQUNwQyxXQUFXLG1CQUFPLENBQUMsSUFBUztBQUM1QixhQUFhLG1CQUFPLENBQUMsSUFBa0I7QUFDdkMsV0FBVyxtQkFBTyxDQUFDLElBQW9CO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxJQUF3QjtBQUMvQyxzQkFBc0IsbUJBQU8sQ0FBQyxJQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsbUJBQU8sQ0FBQyxJQUFlOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsS0FBSztBQUNMLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcz8xMGFkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBlYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKTtcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBOQVRJVkVfV0VBS19NQVAgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgSVNfSUUxMSA9ICFnbG9iYWwuQWN0aXZlWE9iamVjdCAmJiAnQWN0aXZlWE9iamVjdCcgaW4gZ2xvYmFsO1xudmFyIFdFQUtfTUFQID0gJ1dlYWtNYXAnO1xudmFyIGdldFdlYWsgPSBtZXRhLmdldFdlYWs7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gd2Vhay51ZnN0b3JlO1xudmFyIEludGVybmFsTWFwO1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59O1xuXG52YXIgbWV0aG9kcyA9IHtcbiAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSkuZ2V0KGtleSk7XG4gICAgICByZXR1cm4gZGF0YSA/IGRhdGFbdGhpcy5faV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB3ZWFrLmRlZih2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCksIGtleSwgdmFsdWUpO1xuICB9XG59O1xuXG4vLyAyMy4zIFdlYWtNYXAgT2JqZWN0c1xudmFyICRXZWFrTWFwID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoV0VBS19NQVAsIHdyYXBwZXIsIG1ldGhvZHMsIHdlYWssIHRydWUsIHRydWUpO1xuXG4vLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG5pZiAoTkFUSVZFX1dFQUtfTUFQICYmIElTX0lFMTEpIHtcbiAgSW50ZXJuYWxNYXAgPSB3ZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIFdFQUtfTUFQKTtcbiAgYXNzaWduKEludGVybmFsTWFwLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gIG1ldGEuTkVFRCA9IHRydWU7XG4gIGVhY2goWydkZWxldGUnLCAnaGFzJywgJ2dldCcsICdzZXQnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBwcm90byA9ICRXZWFrTWFwLnByb3RvdHlwZTtcbiAgICB2YXIgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZWRlZmluZShwcm90bywga2V5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgLy8gc3RvcmUgZnJvemVuIG9iamVjdHMgb24gaW50ZXJuYWwgd2Vha21hcCBzaGltXG4gICAgICBpZiAoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSkge1xuICAgICAgICBpZiAoIXRoaXMuX2YpIHRoaXMuX2YgPSBuZXcgSW50ZXJuYWxNYXAoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Zba2V5XShhLCBiKTtcbiAgICAgICAgcmV0dXJuIGtleSA9PSAnc2V0JyA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAvLyBzdG9yZSBhbGwgdGhlIHJlc3Qgb24gbmF0aXZlIHdlYWttYXBcbiAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xuICAgIH0pO1xuICB9KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9397\n")},8163:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar weak = __webpack_require__(9882);\nvar validate = __webpack_require__(2888);\nvar WEAK_SET = 'WeakSet';\n\n// 23.4 WeakSet Objects\n__webpack_require__(8933)(WEAK_SET, function (get) {\n  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.4.3.1 WeakSet.prototype.add(value)\n  add: function add(value) {\n    return weak.def(validate(this, WEAK_SET), value, true);\n  }\n}, weak, false, true);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE2My5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFdBQVcsbUJBQU8sQ0FBQyxJQUFvQjtBQUN2QyxlQUFlLG1CQUFPLENBQUMsSUFBd0I7QUFDL0M7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLElBQWU7QUFDdkIsOEJBQThCO0FBQzlCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1zZXQuanM/YzAyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFdFQUtfU0VUID0gJ1dlYWtTZXQnO1xuXG4vLyAyMy40IFdlYWtTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiB3ZWFrLmRlZih2YWxpZGF0ZSh0aGlzLCBXRUFLX1NFVCksIHZhbHVlLCB0cnVlKTtcbiAgfVxufSwgd2VhaywgZmFsc2UsIHRydWUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8163\n")},9766:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap\nvar $export = __webpack_require__(2127);\nvar flattenIntoArray = __webpack_require__(2322);\nvar toObject = __webpack_require__(8270);\nvar toLength = __webpack_require__(1485);\nvar aFunction = __webpack_require__(3387);\nvar arraySpeciesCreate = __webpack_require__(3191);\n\n$export($export.P, 'Array', {\n  flatMap: function flatMap(callbackfn /* , thisArg */) {\n    var O = toObject(this);\n    var sourceLen, A;\n    aFunction(callbackfn);\n    sourceLen = toLength(O.length);\n    A = arraySpeciesCreate(O, 0);\n    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);\n    return A;\n  }\n});\n\n__webpack_require__(8184)('flatMap');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTc2Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsdUJBQXVCLG1CQUFPLENBQUMsSUFBdUI7QUFDdEQsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsSUFBZTtBQUN2Qyx5QkFBeUIsbUJBQU8sQ0FBQyxJQUF5Qjs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELG1CQUFPLENBQUMsSUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuZmxhdC1tYXAuanM/ZTk1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWZsYXRNYXAvI3NlYy1BcnJheS5wcm90b3R5cGUuZmxhdE1hcFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBmbGF0dGVuSW50b0FycmF5ID0gcmVxdWlyZSgnLi9fZmxhdHRlbi1pbnRvLWFycmF5Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBmbGF0TWFwOiBmdW5jdGlvbiBmbGF0TWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgc291cmNlTGVuLCBBO1xuICAgIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgICBzb3VyY2VMZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICBmbGF0dGVuSW50b0FycmF5KEEsIE8sIE8sIHNvdXJjZUxlbiwgMCwgMSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmbGF0TWFwJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9766\n")},1390:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten\nvar $export = __webpack_require__(2127);\nvar flattenIntoArray = __webpack_require__(2322);\nvar toObject = __webpack_require__(8270);\nvar toLength = __webpack_require__(1485);\nvar toInteger = __webpack_require__(7087);\nvar arraySpeciesCreate = __webpack_require__(3191);\n\n$export($export.P, 'Array', {\n  flatten: function flatten(/* depthArg = 1 */) {\n    var depthArg = arguments[0];\n    var O = toObject(this);\n    var sourceLen = toLength(O.length);\n    var A = arraySpeciesCreate(O, 0);\n    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));\n    return A;\n  }\n});\n\n__webpack_require__(8184)('flatten');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM5MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsdUJBQXVCLG1CQUFPLENBQUMsSUFBdUI7QUFDdEQsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsSUFBZTtBQUN2Qyx5QkFBeUIsbUJBQU8sQ0FBQyxJQUF5Qjs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxtQkFBTyxDQUFDLElBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmZsYXR0ZW4uanM/NzFmMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWZsYXRNYXAvI3NlYy1BcnJheS5wcm90b3R5cGUuZmxhdHRlblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBmbGF0dGVuSW50b0FycmF5ID0gcmVxdWlyZSgnLi9fZmxhdHRlbi1pbnRvLWFycmF5Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBmbGF0dGVuOiBmdW5jdGlvbiBmbGF0dGVuKC8qIGRlcHRoQXJnID0gMSAqLykge1xuICAgIHZhciBkZXB0aEFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBzb3VyY2VMZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgZmxhdHRlbkludG9BcnJheShBLCBPLCBPLCBzb3VyY2VMZW4sIDAsIGRlcHRoQXJnID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoQXJnKSk7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnZmxhdHRlbicpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1390\n")},9087:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// https://github.com/tc39/Array.prototype.includes\nvar $export = __webpack_require__(2127);\nvar $includes = __webpack_require__(1464)(true);\n\n$export($export.P, 'Array', {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n__webpack_require__(8184)('includes');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA4Ny5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsSUFBbUI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxtQkFBTyxDQUFDLElBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzPzY3NjIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRpbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnaW5jbHVkZXMnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9087\n")},3642:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask\nvar $export = __webpack_require__(2127);\nvar microtask = __webpack_require__(1384)();\nvar process = (__webpack_require__(7526).process);\nvar isNode = __webpack_require__(5089)(process) == 'process';\n\n$export($export.G, {\n  asap: function asap(fn) {\n    var domain = isNode && process.domain;\n    microtask(domain ? domain.bind(fn) : fn);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY0Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLElBQWM7QUFDdEMsY0FBYyxtQ0FBNEI7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLElBQVE7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFzYXAuanM/MGQyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vcndhbGRyb24vdGMzOS1ub3Rlcy9ibG9iL21hc3Rlci9lczYvMjAxNC0wOS9zZXB0LTI1Lm1kIzUxMC1nbG9iYWxhc2FwLWZvci1lbnF1ZXVpbmctYS1taWNyb3Rhc2tcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBwcm9jZXNzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucHJvY2VzcztcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7XG4gIGFzYXA6IGZ1bmN0aW9uIGFzYXAoZm4pIHtcbiAgICB2YXIgZG9tYWluID0gaXNOb2RlICYmIHByb2Nlc3MuZG9tYWluO1xuICAgIG1pY3JvdGFzayhkb21haW4gPyBkb21haW4uYmluZChmbikgOiBmbik7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3642\n")},9676:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://github.com/ljharb/proposal-is-error\nvar $export = __webpack_require__(2127);\nvar cof = __webpack_require__(5089);\n\n$export($export.S, 'Error', {\n  isError: function isError(it) {\n    return cof(it) === 'Error';\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY3Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLFVBQVUsbUJBQU8sQ0FBQyxJQUFROztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3IuanM/NDI3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL3Byb3Bvc2FsLWlzLWVycm9yXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0Vycm9yJywge1xuICBpc0Vycm9yOiBmdW5jdGlvbiBpc0Vycm9yKGl0KSB7XG4gICAgcmV0dXJuIGNvZihpdCkgPT09ICdFcnJvcic7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9676\n")},1692:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://github.com/tc39/proposal-global\nvar $export = __webpack_require__(2127);\n\n$export($export.G, { global: __webpack_require__(7526) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY5Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQyxxQkFBcUIsUUFBUSxtQkFBTyxDQUFDLElBQVcsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5nbG9iYWwuanM/MGMzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7IGdsb2JhbDogcmVxdWlyZSgnLi9fZ2xvYmFsJykgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1692\n")},7367:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from\n__webpack_require__(9307)('Map');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM2Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLG1CQUFPLENBQUMsSUFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLmZyb20uanM/NDE2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdNYXAnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7367\n")},5738:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of\n__webpack_require__(8966)('Map');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTczOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLG1CQUFPLENBQUMsSUFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLm9mLmpzPzcyOWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtbWFwLm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdNYXAnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5738\n")},1657:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar $export = __webpack_require__(2127);\n\n$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(4490)('Map') });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY1Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQyx3Q0FBd0MsUUFBUSxtQkFBTyxDQUFDLElBQXVCLFVBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanM/NDcwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ01hcCcsIHsgdG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnTWFwJykgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1657\n")},6764:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://rwaldron.github.io/proposal-math-extensions/\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Math', {\n  clamp: function clamp(x, lower, upper) {\n    return Math.min(upper, Math.max(lower, x));\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjc2NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5jbGFtcC5qcz8wOWUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2xhbXA6IGZ1bmN0aW9uIGNsYW1wKHgsIGxvd2VyLCB1cHBlcikge1xuICAgIHJldHVybiBNYXRoLm1pbih1cHBlciwgTWF0aC5tYXgobG93ZXIsIHgpKTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6764\n")},447:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://rwaldron.github.io/proposal-math-extensions/\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7O0FBRWpDLDZCQUE2Qiw0QkFBNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5kZWctcGVyLXJhZC5qcz8wYzAwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgREVHX1BFUl9SQUQ6IE1hdGguUEkgLyAxODAgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///447\n")},8330:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://rwaldron.github.io/proposal-math-extensions/\nvar $export = __webpack_require__(2127);\nvar RAD_PER_DEG = 180 / Math.PI;\n\n$export($export.S, 'Math', {\n  degrees: function degrees(radians) {\n    return radians * RAD_PER_DEG;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODMzMC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmRlZ3JlZXMuanM/Mjc0OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIFJBRF9QRVJfREVHID0gMTgwIC8gTWF0aC5QSTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBkZWdyZWVzOiBmdW5jdGlvbiBkZWdyZWVzKHJhZGlhbnMpIHtcbiAgICByZXR1cm4gcmFkaWFucyAqIFJBRF9QRVJfREVHO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8330\n")},8423:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://rwaldron.github.io/proposal-math-extensions/\nvar $export = __webpack_require__(2127);\nvar scale = __webpack_require__(7836);\nvar fround = __webpack_require__(2122);\n\n$export($export.S, 'Math', {\n  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {\n    return fround(scale(x, inLow, inHigh, outLow, outHigh));\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQyMy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyxJQUFlO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyxJQUFnQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguZnNjYWxlLmpzPzFmOTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzY2FsZSA9IHJlcXVpcmUoJy4vX21hdGgtc2NhbGUnKTtcbnZhciBmcm91bmQgPSByZXF1aXJlKCcuL19tYXRoLWZyb3VuZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGZzY2FsZTogZnVuY3Rpb24gZnNjYWxlKHgsIGluTG93LCBpbkhpZ2gsIG91dExvdywgb3V0SGlnaCkge1xuICAgIHJldHVybiBmcm91bmQoc2NhbGUoeCwgaW5Mb3csIGluSGlnaCwgb3V0TG93LCBvdXRIaWdoKSk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8423\n")},4117:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://gist.github.com/BrendanEich/4294d5c212a6d2254703\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Math', {\n  iaddh: function iaddh(x0, x1, y0, y1) {\n    var $x0 = x0 >>> 0;\n    var $x1 = x1 >>> 0;\n    var $y0 = y0 >>> 0;\n    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDExNy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pYWRkaC5qcz85YzAwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlhZGRoOiBmdW5jdGlvbiBpYWRkaCh4MCwgeDEsIHkwLCB5MSkge1xuICAgIHZhciAkeDAgPSB4MCA+Pj4gMDtcbiAgICB2YXIgJHgxID0geDEgPj4+IDA7XG4gICAgdmFyICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgKyAoeTEgPj4+IDApICsgKCgkeDAgJiAkeTAgfCAoJHgwIHwgJHkwKSAmIH4oJHgwICsgJHkwID4+PiAwKSkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4117\n")},269:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://gist.github.com/BrendanEich/4294d5c212a6d2254703\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Math', {\n  imulh: function imulh(u, v) {\n    var UINT16 = 0xffff;\n    var $u = +u;\n    var $v = +v;\n    var u0 = $u & UINT16;\n    var v0 = $v & UINT16;\n    var u1 = $u >> 16;\n    var v1 = $v >> 16;\n    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);\n    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pbXVsaC5qcz9iNGMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGltdWxoOiBmdW5jdGlvbiBpbXVsaCh1LCB2KSB7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZjtcbiAgICB2YXIgJHUgPSArdTtcbiAgICB2YXIgJHYgPSArdjtcbiAgICB2YXIgdTAgPSAkdSAmIFVJTlQxNjtcbiAgICB2YXIgdjAgPSAkdiAmIFVJTlQxNjtcbiAgICB2YXIgdTEgPSAkdSA+PiAxNjtcbiAgICB2YXIgdjEgPSAkdiA+PiAxNjtcbiAgICB2YXIgdCA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+IDE2KTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///269\n")},3758:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://gist.github.com/BrendanEich/4294d5c212a6d2254703\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Math', {\n  isubh: function isubh(x0, x1, y0, y1) {\n    var $x0 = x0 >>> 0;\n    var $x1 = x1 >>> 0;\n    var $y0 = y0 >>> 0;\n    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc1OC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pc3ViaC5qcz8yZjc4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlzdWJoOiBmdW5jdGlvbiBpc3ViaCh4MCwgeDEsIHkwLCB5MSkge1xuICAgIHZhciAkeDAgPSB4MCA+Pj4gMDtcbiAgICB2YXIgJHgxID0geDEgPj4+IDA7XG4gICAgdmFyICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgLSAoeTEgPj4+IDApIC0gKCh+JHgwICYgJHkwIHwgfigkeDAgXiAkeTApICYgJHgwIC0gJHkwID4+PiAwKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3758\n")},391:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://rwaldron.github.io/proposal-math-extensions/\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkxLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7O0FBRWpDLDZCQUE2Qiw0QkFBNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5yYWQtcGVyLWRlZy5qcz8xZjE4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgUkFEX1BFUl9ERUc6IDE4MCAvIE1hdGguUEkgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///391\n")},4633:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://rwaldron.github.io/proposal-math-extensions/\nvar $export = __webpack_require__(2127);\nvar DEG_PER_RAD = Math.PI / 180;\n\n$export($export.S, 'Math', {\n  radians: function radians(degrees) {\n    return degrees * DEG_PER_RAD;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYzMy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnJhZGlhbnMuanM/NjkyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIERFR19QRVJfUkFEID0gTWF0aC5QSSAvIDE4MDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICByYWRpYW5zOiBmdW5jdGlvbiByYWRpYW5zKGRlZ3JlZXMpIHtcbiAgICByZXR1cm4gZGVncmVlcyAqIERFR19QRVJfUkFEO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4633\n")},9557:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://rwaldron.github.io/proposal-math-extensions/\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Math', { scale: __webpack_require__(7836) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTU1Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQyw2QkFBNkIsT0FBTyxtQkFBTyxDQUFDLElBQWUsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnNjYWxlLmpzP2M3NzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBzY2FsZTogcmVxdWlyZSgnLi9fbWF0aC1zY2FsZScpIH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9557\n")},6043:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// http://jfbastien.github.io/papers/Math.signbit.html\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Math', { signbit: function signbit(x) {\n  // eslint-disable-next-line no-self-compare\n  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;\n} });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA0My5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5zaWduYml0LmpzP2VkN2UiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cDovL2pmYmFzdGllbi5naXRodWIuaW8vcGFwZXJzL01hdGguc2lnbmJpdC5odG1sXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IHNpZ25iaXQ6IGZ1bmN0aW9uIHNpZ25iaXQoeCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiAoeCA9ICt4KSAhPSB4ID8geCA6IHggPT0gMCA/IDEgLyB4ID09IEluZmluaXR5IDogeCA+IDA7XG59IH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6043\n")},3702:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://gist.github.com/BrendanEich/4294d5c212a6d2254703\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'Math', {\n  umulh: function umulh(u, v) {\n    var UINT16 = 0xffff;\n    var $u = +u;\n    var $v = +v;\n    var u0 = $u & UINT16;\n    var v0 = $v & UINT16;\n    var u1 = $u >>> 16;\n    var v1 = $v >>> 16;\n    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);\n    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcwMi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgudW11bGguanM/OGE1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB1bXVsaDogZnVuY3Rpb24gdW11bGgodSwgdikge1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmY7XG4gICAgdmFyICR1ID0gK3U7XG4gICAgdmFyICR2ID0gK3Y7XG4gICAgdmFyIHUwID0gJHUgJiBVSU5UMTY7XG4gICAgdmFyIHYwID0gJHYgJiBVSU5UMTY7XG4gICAgdmFyIHUxID0gJHUgPj4+IDE2O1xuICAgIHZhciB2MSA9ICR2ID4+PiAxNjtcbiAgICB2YXIgdCA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+Pj4gMTYpICsgKCh1MCAqIHYxID4+PiAwKSArICh0ICYgVUlOVDE2KSA+Pj4gMTYpO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3702\n")},7531:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar toObject = __webpack_require__(8270);\nvar aFunction = __webpack_require__(3387);\nvar $defineProperty = __webpack_require__(7967);\n\n// B.2.2.2 Object.prototype.__defineGetter__(P, getter)\n__webpack_require__(1763) && $export($export.P + __webpack_require__(1913), 'Object', {\n  __defineGetter__: function __defineGetter__(P, getter) {\n    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUzMS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkMsc0JBQXNCLG1CQUFPLENBQUMsSUFBYzs7QUFFNUM7QUFDQSxtQkFBTyxDQUFDLElBQWdCLHlCQUF5QixtQkFBTyxDQUFDLElBQXNCO0FBQy9FO0FBQ0EsMkNBQTJDLDhEQUE4RDtBQUN6RztBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXIuanM/NDUwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4vLyBCLjIuMi4yIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVHZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpIHtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwgeyBnZXQ6IGFGdW5jdGlvbihnZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7531\n")},5039:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar toObject = __webpack_require__(8270);\nvar aFunction = __webpack_require__(3387);\nvar $defineProperty = __webpack_require__(7967);\n\n// B.2.2.3 Object.prototype.__defineSetter__(P, setter)\n__webpack_require__(1763) && $export($export.P + __webpack_require__(1913), 'Object', {\n  __defineSetter__: function __defineSetter__(P, setter) {\n    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAzOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkMsc0JBQXNCLG1CQUFPLENBQUMsSUFBYzs7QUFFNUM7QUFDQSxtQkFBTyxDQUFDLElBQWdCLHlCQUF5QixtQkFBTyxDQUFDLElBQXNCO0FBQy9FO0FBQ0EsMkNBQTJDLDhEQUE4RDtBQUN6RztBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXIuanM/ZmVlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4vLyBCLjIuMi4zIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVTZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpIHtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwgeyBzZXQ6IGFGdW5jdGlvbihzZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5039\n")},7146:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://github.com/tc39/proposal-object-values-entries\nvar $export = __webpack_require__(2127);\nvar $entries = __webpack_require__(3854)(true);\n\n$export($export.S, 'Object', {\n  entries: function entries(it) {\n    return $entries(it);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE0Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFvQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzLmpzP2ZmYzEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRlbnRyaWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKGl0KSB7XG4gICAgcmV0dXJuICRlbnRyaWVzKGl0KTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7146\n")},4614:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://github.com/tc39/proposal-object-getownpropertydescriptors\nvar $export = __webpack_require__(2127);\nvar ownKeys = __webpack_require__(6222);\nvar toIObject = __webpack_require__(7221);\nvar gOPD = __webpack_require__(8641);\nvar createProperty = __webpack_require__(7227);\n\n$export($export.S, 'Object', {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {\n    var O = toIObject(object);\n    var getDesc = gOPD.f;\n    var keys = ownKeys(O);\n    var result = {};\n    var i = 0;\n    var key, desc;\n    while (keys.length > i) {\n      desc = getDesc(O, key = keys[i++]);\n      if (desc !== undefined) createProperty(result, key, desc);\n    }\n    return result;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYxNC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyxJQUFhO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkMsV0FBVyxtQkFBTyxDQUFDLElBQWdCO0FBQ25DLHFCQUFxQixtQkFBTyxDQUFDLElBQW9COztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcz84ZTZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG93bktleXMgPSByZXF1aXJlKCcuL19vd24ta2V5cycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICAgIHZhciBnZXREZXNjID0gZ09QRC5mO1xuICAgIHZhciBrZXlzID0gb3duS2V5cyhPKTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXksIGRlc2M7XG4gICAgd2hpbGUgKGtleXMubGVuZ3RoID4gaSkge1xuICAgICAgZGVzYyA9IGdldERlc2MoTywga2V5ID0ga2V5c1tpKytdKTtcbiAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5LCBkZXNjKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4614\n")},4300:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar toObject = __webpack_require__(8270);\nvar toPrimitive = __webpack_require__(3048);\nvar getPrototypeOf = __webpack_require__(627);\nvar getOwnPropertyDescriptor = (__webpack_require__(8641).f);\n\n// B.2.2.4 Object.prototype.__lookupGetter__(P)\n__webpack_require__(1763) && $export($export.P + __webpack_require__(1913), 'Object', {\n  __lookupGetter__: function __lookupGetter__(P) {\n    var O = toObject(this);\n    var K = toPrimitive(P, true);\n    var D;\n    do {\n      if (D = getOwnPropertyDescriptor(O, K)) return D.get;\n    } while (O = getPrototypeOf(O));\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMwMC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLElBQWlCO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLEdBQWU7QUFDNUMsK0JBQStCLDZCQUEyQjs7QUFFMUQ7QUFDQSxtQkFBTyxDQUFDLElBQWdCLHlCQUF5QixtQkFBTyxDQUFDLElBQXNCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXIuanM/YjlhMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbi8vIEIuMi4yLjQgT2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cEdldHRlcl9fKFApXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19sb29rdXBHZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBHZXR0ZXJfXyhQKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICAgIHZhciBEO1xuICAgIGRvIHtcbiAgICAgIGlmIChEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKSByZXR1cm4gRC5nZXQ7XG4gICAgfSB3aGlsZSAoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4300\n")},6328:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar $export = __webpack_require__(2127);\nvar toObject = __webpack_require__(8270);\nvar toPrimitive = __webpack_require__(3048);\nvar getPrototypeOf = __webpack_require__(627);\nvar getOwnPropertyDescriptor = (__webpack_require__(8641).f);\n\n// B.2.2.5 Object.prototype.__lookupSetter__(P)\n__webpack_require__(1763) && $export($export.P + __webpack_require__(1913), 'Object', {\n  __lookupSetter__: function __lookupSetter__(P) {\n    var O = toObject(this);\n    var K = toPrimitive(P, true);\n    var D;\n    do {\n      if (D = getOwnPropertyDescriptor(O, K)) return D.set;\n    } while (O = getPrototypeOf(O));\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMyOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLElBQWlCO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLEdBQWU7QUFDNUMsK0JBQStCLDZCQUEyQjs7QUFFMUQ7QUFDQSxtQkFBTyxDQUFDLElBQWdCLHlCQUF5QixtQkFBTyxDQUFDLElBQXNCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXIuanM/NjRkNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbi8vIEIuMi4yLjUgT2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cFNldHRlcl9fKFApXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19sb29rdXBTZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBTZXR0ZXJfXyhQKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICAgIHZhciBEO1xuICAgIGRvIHtcbiAgICAgIGlmIChEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKSByZXR1cm4gRC5zZXQ7XG4gICAgfSB3aGlsZSAoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6328\n")},7594:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://github.com/tc39/proposal-object-values-entries\nvar $export = __webpack_require__(2127);\nvar $values = __webpack_require__(3854)(false);\n\n$export($export.S, 'Object', {\n  values: function values(it) {\n    return $values(it);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzU5NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyxJQUFvQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanM/ODYxNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHZhbHVlcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKGZhbHNlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKGl0KSB7XG4gICAgcmV0dXJuICR2YWx1ZXMoaXQpO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7594\n")},9530:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// https://github.com/zenparsing/es-observable\nvar $export = __webpack_require__(2127);\nvar global = __webpack_require__(7526);\nvar core = __webpack_require__(6094);\nvar microtask = __webpack_require__(1384)();\nvar OBSERVABLE = __webpack_require__(7574)('observable');\nvar aFunction = __webpack_require__(3387);\nvar anObject = __webpack_require__(4228);\nvar anInstance = __webpack_require__(6440);\nvar redefineAll = __webpack_require__(6065);\nvar hide = __webpack_require__(3341);\nvar forOf = __webpack_require__(8790);\nvar RETURN = forOf.RETURN;\n\nvar getMethod = function (fn) {\n  return fn == null ? undefined : aFunction(fn);\n};\n\nvar cleanupSubscription = function (subscription) {\n  var cleanup = subscription._c;\n  if (cleanup) {\n    subscription._c = undefined;\n    cleanup();\n  }\n};\n\nvar subscriptionClosed = function (subscription) {\n  return subscription._o === undefined;\n};\n\nvar closeSubscription = function (subscription) {\n  if (!subscriptionClosed(subscription)) {\n    subscription._o = undefined;\n    cleanupSubscription(subscription);\n  }\n};\n\nvar Subscription = function (observer, subscriber) {\n  anObject(observer);\n  this._c = undefined;\n  this._o = observer;\n  observer = new SubscriptionObserver(this);\n  try {\n    var cleanup = subscriber(observer);\n    var subscription = cleanup;\n    if (cleanup != null) {\n      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };\n      else aFunction(cleanup);\n      this._c = cleanup;\n    }\n  } catch (e) {\n    observer.error(e);\n    return;\n  } if (subscriptionClosed(this)) cleanupSubscription(this);\n};\n\nSubscription.prototype = redefineAll({}, {\n  unsubscribe: function unsubscribe() { closeSubscription(this); }\n});\n\nvar SubscriptionObserver = function (subscription) {\n  this._s = subscription;\n};\n\nSubscriptionObserver.prototype = redefineAll({}, {\n  next: function next(value) {\n    var subscription = this._s;\n    if (!subscriptionClosed(subscription)) {\n      var observer = subscription._o;\n      try {\n        var m = getMethod(observer.next);\n        if (m) return m.call(observer, value);\n      } catch (e) {\n        try {\n          closeSubscription(subscription);\n        } finally {\n          throw e;\n        }\n      }\n    }\n  },\n  error: function error(value) {\n    var subscription = this._s;\n    if (subscriptionClosed(subscription)) throw value;\n    var observer = subscription._o;\n    subscription._o = undefined;\n    try {\n      var m = getMethod(observer.error);\n      if (!m) throw value;\n      value = m.call(observer, value);\n    } catch (e) {\n      try {\n        cleanupSubscription(subscription);\n      } finally {\n        throw e;\n      }\n    } cleanupSubscription(subscription);\n    return value;\n  },\n  complete: function complete(value) {\n    var subscription = this._s;\n    if (!subscriptionClosed(subscription)) {\n      var observer = subscription._o;\n      subscription._o = undefined;\n      try {\n        var m = getMethod(observer.complete);\n        value = m ? m.call(observer, value) : undefined;\n      } catch (e) {\n        try {\n          cleanupSubscription(subscription);\n        } finally {\n          throw e;\n        }\n      } cleanupSubscription(subscription);\n      return value;\n    }\n  }\n});\n\nvar $Observable = function Observable(subscriber) {\n  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);\n};\n\nredefineAll($Observable.prototype, {\n  subscribe: function subscribe(observer) {\n    return new Subscription(observer, this._f);\n  },\n  forEach: function forEach(fn) {\n    var that = this;\n    return new (core.Promise || global.Promise)(function (resolve, reject) {\n      aFunction(fn);\n      var subscription = that.subscribe({\n        next: function (value) {\n          try {\n            return fn(value);\n          } catch (e) {\n            reject(e);\n            subscription.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve\n      });\n    });\n  }\n});\n\nredefineAll($Observable, {\n  from: function from(x) {\n    var C = typeof this === 'function' ? this : $Observable;\n    var method = getMethod(anObject(x)[OBSERVABLE]);\n    if (method) {\n      var observable = anObject(method.call(x));\n      return observable.constructor === C ? observable : new C(function (observer) {\n        return observable.subscribe(observer);\n      });\n    }\n    return new C(function (observer) {\n      var done = false;\n      microtask(function () {\n        if (!done) {\n          try {\n            if (forOf(x, false, function (it) {\n              observer.next(it);\n              if (done) return RETURN;\n            }) === RETURN) return;\n          } catch (e) {\n            if (done) throw e;\n            observer.error(e);\n            return;\n          } observer.complete();\n        }\n      });\n      return function () { done = true; };\n    });\n  },\n  of: function of() {\n    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];\n    return new (typeof this === 'function' ? this : $Observable)(function (observer) {\n      var done = false;\n      microtask(function () {\n        if (!done) {\n          for (var j = 0; j < items.length; ++j) {\n            observer.next(items[j]);\n            if (done) return;\n          } observer.complete();\n        }\n      });\n      return function () { done = true; };\n    });\n  }\n});\n\nhide($Observable.prototype, OBSERVABLE, function () { return this; });\n\n$export($export.G, { Observable: $Observable });\n\n__webpack_require__(5762)('Observable');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTUzMC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsYUFBYSxtQkFBTyxDQUFDLElBQVc7QUFDaEMsV0FBVyxtQkFBTyxDQUFDLElBQVM7QUFDNUIsZ0JBQWdCLG1CQUFPLENBQUMsSUFBYztBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFRO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsSUFBZ0I7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsSUFBaUI7QUFDM0MsV0FBVyxtQkFBTyxDQUFDLElBQVM7QUFDNUIsWUFBWSxtQkFBTyxDQUFDLElBQVc7QUFDL0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLHVDQUF1QztBQUN2Qyx3Q0FBd0M7QUFDeEMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxPQUFPO0FBQ1AsMkJBQTJCO0FBQzNCLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxnRUFBZ0UsTUFBTTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLE9BQU87QUFDUCwyQkFBMkI7QUFDM0IsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRCxzREFBc0QsY0FBYzs7QUFFcEUscUJBQXFCLHlCQUF5Qjs7QUFFOUMsbUJBQU8sQ0FBQyxJQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlLmpzPzM3YjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgT0JTRVJWQUJMRSA9IHJlcXVpcmUoJy4vX3drcycpKCdvYnNlcnZhYmxlJyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgUkVUVVJOID0gZm9yT2YuUkVUVVJOO1xuXG52YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiA9PSBudWxsID8gdW5kZWZpbmVkIDogYUZ1bmN0aW9uKGZuKTtcbn07XG5cbnZhciBjbGVhbnVwU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICB2YXIgY2xlYW51cCA9IHN1YnNjcmlwdGlvbi5fYztcbiAgaWYgKGNsZWFudXApIHtcbiAgICBzdWJzY3JpcHRpb24uX2MgPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cCgpO1xuICB9XG59O1xuXG52YXIgc3Vic2NyaXB0aW9uQ2xvc2VkID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICByZXR1cm4gc3Vic2NyaXB0aW9uLl9vID09PSB1bmRlZmluZWQ7XG59O1xuXG52YXIgY2xvc2VTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIGlmICghc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHtcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICB9XG59O1xuXG52YXIgU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzdWJzY3JpYmVyKSB7XG4gIGFuT2JqZWN0KG9ic2VydmVyKTtcbiAgdGhpcy5fYyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fbyA9IG9ic2VydmVyO1xuICBvYnNlcnZlciA9IG5ldyBTdWJzY3JpcHRpb25PYnNlcnZlcih0aGlzKTtcbiAgdHJ5IHtcbiAgICB2YXIgY2xlYW51cCA9IHN1YnNjcmliZXIob2JzZXJ2ZXIpO1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSBjbGVhbnVwO1xuICAgIGlmIChjbGVhbnVwICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgY2xlYW51cC51bnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJykgY2xlYW51cCA9IGZ1bmN0aW9uICgpIHsgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICBlbHNlIGFGdW5jdGlvbihjbGVhbnVwKTtcbiAgICAgIHRoaXMuX2MgPSBjbGVhbnVwO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgIHJldHVybjtcbiAgfSBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHRoaXMpKSBjbGVhbnVwU3Vic2NyaXB0aW9uKHRoaXMpO1xufTtcblxuU3Vic2NyaXB0aW9uLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKHt9LCB7XG4gIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHsgY2xvc2VTdWJzY3JpcHRpb24odGhpcyk7IH1cbn0pO1xuXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIHRoaXMuX3MgPSBzdWJzY3JpcHRpb247XG59O1xuXG5TdWJzY3JpcHRpb25PYnNlcnZlci5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KHZhbHVlKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSkge1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHRocm93IHZhbHVlO1xuICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmVycm9yKTtcbiAgICAgIGlmICghbSkgdGhyb3cgdmFsdWU7XG4gICAgICB2YWx1ZSA9IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUodmFsdWUpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZiAoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKSB7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5jb21wbGV0ZSk7XG4gICAgICAgIHZhbHVlID0gbSA/IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpIDogdW5kZWZpbmVkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgJE9ic2VydmFibGUgPSBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZXIpIHtcbiAgYW5JbnN0YW5jZSh0aGlzLCAkT2JzZXJ2YWJsZSwgJ09ic2VydmFibGUnLCAnX2YnKS5fZiA9IGFGdW5jdGlvbihzdWJzY3JpYmVyKTtcbn07XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwge1xuICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmVyLCB0aGlzLl9mKTtcbiAgfSxcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IChjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGFGdW5jdGlvbihmbik7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhhdC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgIGNvbXBsZXRlOiByZXNvbHZlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLCB7XG4gIGZyb206IGZ1bmN0aW9uIGZyb20oeCkge1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGU7XG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZChhbk9iamVjdCh4KVtPQlNFUlZBQkxFXSk7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgdmFyIG9ic2VydmFibGUgPSBhbk9iamVjdChtZXRob2QuY2FsbCh4KSk7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZS5jb25zdHJ1Y3RvciA9PT0gQyA/IG9ic2VydmFibGUgOiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmb3JPZih4LCBmYWxzZSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXQpO1xuICAgICAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuIFJFVFVSTjtcbiAgICAgICAgICAgIH0pID09PSBSRVRVUk4pIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkgdGhyb3cgZTtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfSxcbiAgb2Y6IGZ1bmN0aW9uIG9mKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBuZXcgQXJyYXkobCk7IGkgPCBsOykgaXRlbXNbaV0gPSBhcmd1bWVudHNbaSsrXTtcbiAgICByZXR1cm4gbmV3ICh0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZSkoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdGVtc1tqXSk7XG4gICAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbmhpZGUoJE9ic2VydmFibGUucHJvdG90eXBlLCBPQlNFUlZBQkxFLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHsgT2JzZXJ2YWJsZTogJE9ic2VydmFibGUgfSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ09ic2VydmFibGUnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9530\n")},8583:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("// https://github.com/tc39/proposal-promise-finally\n\nvar $export = __webpack_require__(2127);\nvar core = __webpack_require__(6094);\nvar global = __webpack_require__(7526);\nvar speciesConstructor = __webpack_require__(9190);\nvar promiseResolve = __webpack_require__(5957);\n\n$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {\n  var C = speciesConstructor(this, core.Promise || global.Promise);\n  var isFunction = typeof onFinally == 'function';\n  return this.then(\n    isFunction ? function (x) {\n      return promiseResolve(C, onFinally()).then(function () { return x; });\n    } : onFinally,\n    isFunction ? function (e) {\n      return promiseResolve(C, onFinally()).then(function () { throw e; });\n    } : onFinally\n  );\n} });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU4My5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhO0FBQ2IsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsV0FBVyxtQkFBTyxDQUFDLElBQVM7QUFDNUIsYUFBYSxtQkFBTyxDQUFDLElBQVc7QUFDaEMseUJBQXlCLG1CQUFPLENBQUMsSUFBd0I7QUFDekQscUJBQXFCLG1CQUFPLENBQUMsSUFBb0I7O0FBRWpELDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxXQUFXO0FBQzFFLE1BQU07QUFDTjtBQUNBLCtEQUErRCxVQUFVO0FBQ3pFLE1BQU07QUFDTjtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzPzA5N2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS1maW5hbGx5XG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnUHJvbWlzZScsIHsgJ2ZpbmFsbHknOiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSk7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHg7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHksXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyBlOyB9KTtcbiAgICB9IDogb25GaW5hbGx5XG4gICk7XG59IH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8583\n")},1041:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// https://github.com/tc39/proposal-promise-try\nvar $export = __webpack_require__(2127);\nvar newPromiseCapability = __webpack_require__(4258);\nvar perform = __webpack_require__(128);\n\n$export($export.S, 'Promise', { 'try': function (callbackfn) {\n  var promiseCapability = newPromiseCapability.f(this);\n  var result = perform(callbackfn);\n  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);\n  return promiseCapability.promise;\n} });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA0MS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsMkJBQTJCLG1CQUFPLENBQUMsSUFBMkI7QUFDOUQsY0FBYyxtQkFBTyxDQUFDLEdBQVk7O0FBRWxDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS50cnkuanM/YTljYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcm9taXNlLXRyeVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1Byb21pc2UnLCB7ICd0cnknOiBmdW5jdGlvbiAoY2FsbGJhY2tmbikge1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gcGVyZm9ybShjYWxsYmFja2ZuKTtcbiAgKHJlc3VsdC5lID8gcHJvbWlzZUNhcGFiaWxpdHkucmVqZWN0IDogcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZSkocmVzdWx0LnYpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn0gfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1041\n")},7491:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var metadata = __webpack_require__(7380);\nvar anObject = __webpack_require__(4228);\nvar toMetaKey = metadata.key;\nvar ordinaryDefineOwnMetadata = metadata.set;\n\nmetadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {\n  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));\n} });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ5MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBYTtBQUNwQyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQztBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWZpbmUtbWV0YWRhdGEuanM/ZTNkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5zZXQ7XG5cbm1ldGFkYXRhLmV4cCh7IGRlZmluZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWZpbmVNZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCB0YXJnZXRLZXkpIHtcbiAgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgYW5PYmplY3QodGFyZ2V0KSwgdG9NZXRhS2V5KHRhcmdldEtleSkpO1xufSB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7491\n")},4907:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var metadata = __webpack_require__(7380);\nvar anObject = __webpack_require__(4228);\nvar toMetaKey = metadata.key;\nvar getOrCreateMetadataMap = metadata.map;\nvar store = metadata.store;\n\nmetadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {\n  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);\n  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);\n  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;\n  if (metadataMap.size) return true;\n  var targetMetadata = store.get(target);\n  targetMetadata['delete'](targetKey);\n  return !!targetMetadata.size || store['delete'](target);\n} });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkwNy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBYTtBQUNwQyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQztBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YS5qcz9jZWFmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG52YXIgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCA9IG1ldGFkYXRhLm1hcDtcbnZhciBzdG9yZSA9IG1ldGFkYXRhLnN0b3JlO1xuXG5tZXRhZGF0YS5leHAoeyBkZWxldGVNZXRhZGF0YTogZnVuY3Rpb24gZGVsZXRlTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICB2YXIgdGFyZ2V0S2V5ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKTtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChhbk9iamVjdCh0YXJnZXQpLCB0YXJnZXRLZXksIGZhbHNlKTtcbiAgaWYgKG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgfHwgIW1ldGFkYXRhTWFwWydkZWxldGUnXShtZXRhZGF0YUtleSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKG1ldGFkYXRhTWFwLnNpemUpIHJldHVybiB0cnVlO1xuICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcbiAgdGFyZ2V0TWV0YWRhdGFbJ2RlbGV0ZSddKHRhcmdldEtleSk7XG4gIHJldHVybiAhIXRhcmdldE1ldGFkYXRhLnNpemUgfHwgc3RvcmVbJ2RlbGV0ZSddKHRhcmdldCk7XG59IH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4907\n")},9269:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var Set = __webpack_require__(1632);\nvar from = __webpack_require__(956);\nvar metadata = __webpack_require__(7380);\nvar anObject = __webpack_require__(4228);\nvar getPrototypeOf = __webpack_require__(627);\nvar ordinaryOwnMetadataKeys = metadata.keys;\nvar toMetaKey = metadata.key;\n\nvar ordinaryMetadataKeys = function (O, P) {\n  var oKeys = ordinaryOwnMetadataKeys(O, P);\n  var parent = getPrototypeOf(O);\n  if (parent === null) return oKeys;\n  var pKeys = ordinaryMetadataKeys(parent, P);\n  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;\n};\n\nmetadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {\n  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));\n} });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI2OS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBVztBQUM3QixXQUFXLG1CQUFPLENBQUMsR0FBd0I7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLElBQWE7QUFDcEMsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMscUJBQXFCLG1CQUFPLENBQUMsR0FBZTtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cy5qcz9iODBiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBTZXQgPSByZXF1aXJlKCcuL2VzNi5zZXQnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xudmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5cztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeU1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uIChPLCBQKSB7XG4gIHZhciBvS2V5cyA9IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIGlmIChwYXJlbnQgPT09IG51bGwpIHJldHVybiBvS2V5cztcbiAgdmFyIHBLZXlzID0gb3JkaW5hcnlNZXRhZGF0YUtleXMocGFyZW50LCBQKTtcbiAgcmV0dXJuIHBLZXlzLmxlbmd0aCA/IG9LZXlzLmxlbmd0aCA/IGZyb20obmV3IFNldChvS2V5cy5jb25jYXQocEtleXMpKSkgOiBwS2V5cyA6IG9LZXlzO1xufTtcblxubWV0YWRhdGEuZXhwKHsgZ2V0TWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRNZXRhZGF0YUtleXModGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeU1ldGFkYXRhS2V5cyhhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMV0pKTtcbn0gfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9269\n")},9100:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var metadata = __webpack_require__(7380);\nvar anObject = __webpack_require__(4228);\nvar getPrototypeOf = __webpack_require__(627);\nvar ordinaryHasOwnMetadata = metadata.has;\nvar ordinaryGetOwnMetadata = metadata.get;\nvar toMetaKey = metadata.key;\n\nvar ordinaryGetMetadata = function (MetadataKey, O, P) {\n  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);\n  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);\n  var parent = getPrototypeOf(O);\n  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;\n};\n\nmetadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {\n  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));\n} });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTEwMC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBYTtBQUNwQyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyxHQUFlO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS5qcz9lMzk0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzO1xudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXQ7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlHZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTywgUCkge1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmIChoYXNPd24pIHJldHVybiBvcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IHVuZGVmaW5lZDtcbn07XG5cbm1ldGFkYXRhLmV4cCh7IGdldE1ldGFkYXRhOiBmdW5jdGlvbiBnZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeUdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn0gfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9100\n")},9732:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var metadata = __webpack_require__(7380);\nvar anObject = __webpack_require__(4228);\nvar ordinaryOwnMetadataKeys = metadata.keys;\nvar toMetaKey = metadata.key;\n\nmetadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {\n  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));\n} });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTczMi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBYTtBQUNwQyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQztBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMuanM/N2NkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBtZXRhZGF0YS5rZXlzO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHsgZ2V0T3duTWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YUtleXModGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMV0pKTtcbn0gfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9732\n")},1319:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var metadata = __webpack_require__(7380);\nvar anObject = __webpack_require__(4228);\nvar ordinaryGetOwnMetadata = metadata.get;\nvar toMetaKey = metadata.key;\n\nmetadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {\n  return ordinaryGetOwnMetadata(metadataKey, anObject(target)\n    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));\n} });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMxOS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBYTtBQUNwQyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQztBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEuanM/MDZhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldDtcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7IGdldE93bk1ldGFkYXRhOiBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeUdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpXG4gICAgLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn0gfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1319\n")},1176:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var metadata = __webpack_require__(7380);\nvar anObject = __webpack_require__(4228);\nvar getPrototypeOf = __webpack_require__(627);\nvar ordinaryHasOwnMetadata = metadata.has;\nvar toMetaKey = metadata.key;\n\nvar ordinaryHasMetadata = function (MetadataKey, O, P) {\n  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);\n  if (hasOwn) return true;\n  var parent = getPrototypeOf(O);\n  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;\n};\n\nmetadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {\n  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));\n} });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE3Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBYTtBQUNwQyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyxHQUFlO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEuanM/ODk2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhcztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUhhc01ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYgKGhhc093bikgcmV0dXJuIHRydWU7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiBmYWxzZTtcbn07XG5cbm1ldGFkYXRhLmV4cCh7IGhhc01ldGFkYXRhOiBmdW5jdGlvbiBoYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeUhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn0gfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1176\n")},3107:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var metadata = __webpack_require__(7380);\nvar anObject = __webpack_require__(4228);\nvar ordinaryHasOwnMetadata = metadata.has;\nvar toMetaKey = metadata.key;\n\nmetadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {\n  return ordinaryHasOwnMetadata(metadataKey, anObject(target)\n    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));\n} });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEwNy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBYTtBQUNwQyxlQUFlLG1CQUFPLENBQUMsSUFBYztBQUNyQztBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEuanM/ZWMzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhcztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7IGhhc093bk1ldGFkYXRhOiBmdW5jdGlvbiBoYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeUhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpXG4gICAgLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn0gfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3107\n")},1691:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var $metadata = __webpack_require__(7380);\nvar anObject = __webpack_require__(4228);\nvar aFunction = __webpack_require__(3387);\nvar toMetaKey = $metadata.key;\nvar ordinaryDefineOwnMetadata = $metadata.set;\n\n$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {\n  return function decorator(target, targetKey) {\n    ordinaryDefineOwnMetadata(\n      metadataKey, metadataValue,\n      (targetKey !== undefined ? anObject : aFunction)(target),\n      toMetaKey(targetKey)\n    );\n  };\n} });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY5MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFhO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkM7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEuanM/M2E5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciB0b01ldGFLZXkgPSAkbWV0YWRhdGEua2V5O1xudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSAkbWV0YWRhdGEuc2V0O1xuXG4kbWV0YWRhdGEuZXhwKHsgbWV0YWRhdGE6IGZ1bmN0aW9uIG1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCB0YXJnZXRLZXkpIHtcbiAgICBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKFxuICAgICAgbWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsXG4gICAgICAodGFyZ2V0S2V5ICE9PSB1bmRlZmluZWQgPyBhbk9iamVjdCA6IGFGdW5jdGlvbikodGFyZ2V0KSxcbiAgICAgIHRvTWV0YUtleSh0YXJnZXRLZXkpXG4gICAgKTtcbiAgfTtcbn0gfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1691\n")},2577:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from\n__webpack_require__(9307)('Set');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjU3Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLG1CQUFPLENBQUMsSUFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc2V0LmZyb20uanM/ZGQ4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdTZXQnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2577\n")},9616:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of\n__webpack_require__(8966)('Set');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYxNi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLG1CQUFPLENBQUMsSUFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc2V0Lm9mLmpzPzk5YzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtc2V0Lm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdTZXQnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9616\n")},8223:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar $export = __webpack_require__(2127);\n\n$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(4490)('Set') });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODIyMy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQyx3Q0FBd0MsUUFBUSxtQkFBTyxDQUFDLElBQXVCLFVBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc2V0LnRvLWpzb24uanM/ZGI5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1NldCcsIHsgdG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0JykgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8223\n")},2687:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// https://github.com/mathiasbynens/String.prototype.at\nvar $export = __webpack_require__(2127);\nvar $at = __webpack_require__(1212)(true);\nvar $fails = __webpack_require__(9448);\n\nvar FORCED = $fails(function () {\n  return '𠮷'.at(0) !== '𠮷';\n});\n\n$export($export.P + $export.F * FORCED, 'String', {\n  at: function at(pos) {\n    return $at(this, pos);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY4Ny5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsVUFBVSxtQkFBTyxDQUFDLElBQWM7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLElBQVU7O0FBRS9CO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcuYXQuanM/MzUzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbnZhciBGT1JDRUQgPSAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ/CgrrcnLmF0KDApICE9PSAn8KCutyc7XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRUQsICdTdHJpbmcnLCB7XG4gIGF0OiBmdW5jdGlvbiBhdChwb3MpIHtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2687\n")},6311:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// https://tc39.github.io/String.prototype.matchAll/\nvar $export = __webpack_require__(2127);\nvar defined = __webpack_require__(3344);\nvar toLength = __webpack_require__(1485);\nvar isRegExp = __webpack_require__(5411);\nvar getFlags = __webpack_require__(1158);\nvar RegExpProto = RegExp.prototype;\n\nvar $RegExpStringIterator = function (regexp, string) {\n  this._r = regexp;\n  this._s = string;\n};\n\n__webpack_require__(6032)($RegExpStringIterator, 'RegExp String', function next() {\n  var match = this._r.exec(this._s);\n  return { value: match, done: match === null };\n});\n\n$export($export.P, 'String', {\n  matchAll: function matchAll(regexp) {\n    defined(this);\n    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');\n    var S = String(this);\n    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);\n    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);\n    rx.lastIndex = toLength(regexp.lastIndex);\n    return new $RegExpStringIterator(rx, S);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMxMS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsY0FBYyxtQkFBTyxDQUFDLElBQVk7QUFDbEMsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckMsZUFBZSxtQkFBTyxDQUFDLElBQVU7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQU8sQ0FBQyxJQUFnQjtBQUN4QjtBQUNBLFdBQVc7QUFDWCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsLmpzPzk4OGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9TdHJpbmcucHJvdG90eXBlLm1hdGNoQWxsL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbnZhciBnZXRGbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG52YXIgUmVnRXhwUHJvdG8gPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yID0gZnVuY3Rpb24gKHJlZ2V4cCwgc3RyaW5nKSB7XG4gIHRoaXMuX3IgPSByZWdleHA7XG4gIHRoaXMuX3MgPSBzdHJpbmc7XG59O1xuXG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKCRSZWdFeHBTdHJpbmdJdGVyYXRvciwgJ1JlZ0V4cCBTdHJpbmcnLCBmdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgbWF0Y2ggPSB0aGlzLl9yLmV4ZWModGhpcy5fcyk7XG4gIHJldHVybiB7IHZhbHVlOiBtYXRjaCwgZG9uZTogbWF0Y2ggPT09IG51bGwgfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgbWF0Y2hBbGw6IGZ1bmN0aW9uIG1hdGNoQWxsKHJlZ2V4cCkge1xuICAgIGRlZmluZWQodGhpcyk7XG4gICAgaWYgKCFpc1JlZ0V4cChyZWdleHApKSB0aHJvdyBUeXBlRXJyb3IocmVnZXhwICsgJyBpcyBub3QgYSByZWdleHAhJyk7XG4gICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgdmFyIGZsYWdzID0gJ2ZsYWdzJyBpbiBSZWdFeHBQcm90byA/IFN0cmluZyhyZWdleHAuZmxhZ3MpIDogZ2V0RmxhZ3MuY2FsbChyZWdleHApO1xuICAgIHZhciByeCA9IG5ldyBSZWdFeHAocmVnZXhwLnNvdXJjZSwgfmZsYWdzLmluZGV4T2YoJ2cnKSA/IGZsYWdzIDogJ2cnICsgZmxhZ3MpO1xuICAgIHJ4Lmxhc3RJbmRleCA9IHRvTGVuZ3RoKHJlZ2V4cC5sYXN0SW5kZXgpO1xuICAgIHJldHVybiBuZXcgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yKHJ4LCBTKTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6311\n")},5693:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// https://github.com/tc39/proposal-string-pad-start-end\nvar $export = __webpack_require__(2127);\nvar $pad = __webpack_require__(4472);\nvar userAgent = __webpack_require__(4514);\n\n// https://github.com/zloirock/core-js/issues/280\nvar WEBKIT_BUG = /Version\\/10\\.\\d+(\\.\\d+)?( Mobile\\/\\w+)? Safari\\//.test(userAgent);\n\n$export($export.P + $export.F * WEBKIT_BUG, 'String', {\n  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTY5My5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsV0FBVyxtQkFBTyxDQUFDLElBQWU7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsSUFBZTs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQuanM/ZWQ1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFkID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4vX3VzZXItYWdlbnQnKTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzI4MFxudmFyIFdFQktJVF9CVUcgPSAvVmVyc2lvblxcLzEwXFwuXFxkKyhcXC5cXGQrKT8oIE1vYmlsZVxcL1xcdyspPyBTYWZhcmlcXC8vLnRlc3QodXNlckFnZW50KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBXRUJLSVRfQlVHLCAnU3RyaW5nJywge1xuICBwYWRFbmQ6IGZ1bmN0aW9uIHBhZEVuZChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgZmFsc2UpO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5693\n")},5380:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// https://github.com/tc39/proposal-string-pad-start-end\nvar $export = __webpack_require__(2127);\nvar $pad = __webpack_require__(4472);\nvar userAgent = __webpack_require__(4514);\n\n// https://github.com/zloirock/core-js/issues/280\nvar WEBKIT_BUG = /Version\\/10\\.\\d+(\\.\\d+)?( Mobile\\/\\w+)? Safari\\//.test(userAgent);\n\n$export($export.P + $export.F * WEBKIT_BUG, 'String', {\n  padStart: function padStart(maxLength /* , fillString = ' ' */) {\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM4MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQVc7QUFDakMsV0FBVyxtQkFBTyxDQUFDLElBQWU7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsSUFBZTs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcz9mNTc2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYWQgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi9fdXNlci1hZ2VudCcpO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMjgwXG52YXIgV0VCS0lUX0JVRyA9IC9WZXJzaW9uXFwvMTBcXC5cXGQrKFxcLlxcZCspPyggTW9iaWxlXFwvXFx3Kyk/IFNhZmFyaVxcLy8udGVzdCh1c2VyQWdlbnQpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIFdFQktJVF9CVUcsICdTdHJpbmcnLCB7XG4gIHBhZFN0YXJ0OiBmdW5jdGlvbiBwYWRTdGFydChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5380\n")},62:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// https://github.com/sebmarkbage/ecmascript-string-left-right-trim\n__webpack_require__(629)('trimLeft', function ($trim) {\n  return function trimLeft() {\n    return $trim(this, 1);\n  };\n}, 'trimStart');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLG1CQUFPLENBQUMsR0FBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0LmpzPzIzYmUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbUxlZnQnLCBmdW5jdGlvbiAoJHRyaW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW1MZWZ0KCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAxKTtcbiAgfTtcbn0sICd0cmltU3RhcnQnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///62\n")},521:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n// https://github.com/sebmarkbage/ecmascript-string-left-right-trim\n__webpack_require__(629)('trimRight', function ($trim) {\n  return function trimRight() {\n    return $trim(this, 2);\n  };\n}, 'trimEnd');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIxLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxtQkFBTyxDQUFDLEdBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQuanM/N2MwZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltUmlnaHQnLCBmdW5jdGlvbiAoJHRyaW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW1SaWdodCgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMik7XG4gIH07XG59LCAndHJpbUVuZCcpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///521\n")},2820:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(5392)('asyncIterator');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjgyMC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBTyxDQUFDLElBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzP2FjNGQiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2820\n")},4180:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(5392)('observable');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE4MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBTyxDQUFDLElBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanM/YzdjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4180\n")},3537:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://github.com/tc39/proposal-global\nvar $export = __webpack_require__(2127);\n\n$export($export.S, 'System', { global: __webpack_require__(7526) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUzNy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXOztBQUVqQywrQkFBK0IsUUFBUSxtQkFBTyxDQUFDLElBQVcsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdGVncmFwaC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsLmpzP2EyMzQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZ2xvYmFsXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N5c3RlbScsIHsgZ2xvYmFsOiByZXF1aXJlKCcuL19nbG9iYWwnKSB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3537\n")},4748:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from\n__webpack_require__(9307)('WeakMap');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc0OC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLG1CQUFPLENBQUMsSUFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbS5qcz81ZDQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdXZWFrTWFwJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4748\n")},6841:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of\n__webpack_require__(8966)('WeakMap');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjg0MS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLG1CQUFPLENBQUMsSUFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcud2Vhay1tYXAub2YuanM/NzY0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrbWFwLm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdXZWFrTWFwJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6841\n")},2538:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from\n__webpack_require__(9307)('WeakSet');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUzOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLG1CQUFPLENBQUMsSUFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcud2Vhay1zZXQuZnJvbS5qcz81ZDkwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWtzZXQuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdXZWFrU2V0Jyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2538\n")},5339:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of\n__webpack_require__(8966)('WeakSet');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMzOS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLG1CQUFPLENBQUMsSUFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcud2Vhay1zZXQub2YuanM/YmRkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrc2V0Lm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdXZWFrU2V0Jyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5339\n")},5890:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var $iterators = __webpack_require__(5165);\nvar getKeys = __webpack_require__(1311);\nvar redefine = __webpack_require__(8859);\nvar global = __webpack_require__(7526);\nvar hide = __webpack_require__(3341);\nvar Iterators = __webpack_require__(906);\nvar wks = __webpack_require__(7574);\nvar ITERATOR = wks('iterator');\nvar TO_STRING_TAG = wks('toStringTag');\nvar ArrayValues = Iterators.Array;\n\nvar DOMIterables = {\n  CSSRuleList: true, // TODO: Not spec compliant, should be false.\n  CSSStyleDeclaration: false,\n  CSSValueList: false,\n  ClientRectList: false,\n  DOMRectList: false,\n  DOMStringList: false,\n  DOMTokenList: true,\n  DataTransferItemList: false,\n  FileList: false,\n  HTMLAllCollection: false,\n  HTMLCollection: false,\n  HTMLFormElement: false,\n  HTMLSelectElement: false,\n  MediaList: true, // TODO: Not spec compliant, should be false.\n  MimeTypeArray: false,\n  NamedNodeMap: false,\n  NodeList: true,\n  PaintRequestList: false,\n  Plugin: false,\n  PluginArray: false,\n  SVGLengthList: false,\n  SVGNumberList: false,\n  SVGPathSegList: false,\n  SVGPointList: false,\n  SVGStringList: false,\n  SVGTransformList: false,\n  SourceBufferList: false,\n  StyleSheetList: true, // TODO: Not spec compliant, should be false.\n  TextTrackCueList: false,\n  TextTrackList: false,\n  TouchList: false\n};\n\nfor (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {\n  var NAME = collections[i];\n  var explicit = DOMIterables[NAME];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  var key;\n  if (proto) {\n    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);\n    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n    Iterators[NAME] = ArrayValues;\n    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTg5MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFzQjtBQUMvQyxjQUFjLG1CQUFPLENBQUMsSUFBZ0I7QUFDdEMsZUFBZSxtQkFBTyxDQUFDLElBQWE7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLElBQVc7QUFDaEMsV0FBVyxtQkFBTyxDQUFDLElBQVM7QUFDNUIsZ0JBQWdCLG1CQUFPLENBQUMsR0FBYztBQUN0QyxVQUFVLG1CQUFPLENBQUMsSUFBUTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFEQUFxRCx3QkFBd0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcz9hYzZhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciAkaXRlcmF0b3JzID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gSXRlcmF0b3JzLkFycmF5O1xuXG52YXIgRE9NSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IGZhbHNlLFxuICBDU1NWYWx1ZUxpc3Q6IGZhbHNlLFxuICBDbGllbnRSZWN0TGlzdDogZmFsc2UsXG4gIERPTVJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NU3RyaW5nTGlzdDogZmFsc2UsXG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IGZhbHNlLFxuICBGaWxlTGlzdDogZmFsc2UsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MRm9ybUVsZW1lbnQ6IGZhbHNlLFxuICBIVE1MU2VsZWN0RWxlbWVudDogZmFsc2UsXG4gIE1lZGlhTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIE1pbWVUeXBlQXJyYXk6IGZhbHNlLFxuICBOYW1lZE5vZGVNYXA6IGZhbHNlLFxuICBOb2RlTGlzdDogdHJ1ZSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogZmFsc2UsXG4gIFBsdWdpbjogZmFsc2UsXG4gIFBsdWdpbkFycmF5OiBmYWxzZSxcbiAgU1ZHTGVuZ3RoTGlzdDogZmFsc2UsXG4gIFNWR051bWJlckxpc3Q6IGZhbHNlLFxuICBTVkdQYXRoU2VnTGlzdDogZmFsc2UsXG4gIFNWR1BvaW50TGlzdDogZmFsc2UsXG4gIFNWR1N0cmluZ0xpc3Q6IGZhbHNlLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiBmYWxzZSxcbiAgU291cmNlQnVmZmVyTGlzdDogZmFsc2UsXG4gIFN0eWxlU2hlZXRMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgVGV4dFRyYWNrQ3VlTGlzdDogZmFsc2UsXG4gIFRleHRUcmFja0xpc3Q6IGZhbHNlLFxuICBUb3VjaExpc3Q6IGZhbHNlXG59O1xuXG5mb3IgKHZhciBjb2xsZWN0aW9ucyA9IGdldEtleXMoRE9NSXRlcmFibGVzKSwgaSA9IDA7IGkgPCBjb2xsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IGNvbGxlY3Rpb25zW2ldO1xuICB2YXIgZXhwbGljaXQgPSBET01JdGVyYWJsZXNbTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICB2YXIga2V5O1xuICBpZiAocHJvdG8pIHtcbiAgICBpZiAoIXByb3RvW0lURVJBVE9SXSkgaGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZiAoIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBBcnJheVZhbHVlcztcbiAgICBpZiAoZXhwbGljaXQpIGZvciAoa2V5IGluICRpdGVyYXRvcnMpIGlmICghcHJvdG9ba2V5XSkgcmVkZWZpbmUocHJvdG8sIGtleSwgJGl0ZXJhdG9yc1trZXldLCB0cnVlKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5890\n")},5417:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("var $export = __webpack_require__(2127);\nvar $task = __webpack_require__(2780);\n$export($export.G + $export.B, {\n  setImmediate: $task.set,\n  clearImmediate: $task.clear\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQxNy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsSUFBVztBQUNqQyxZQUFZLG1CQUFPLENBQUMsSUFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcz8xMzBmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHRhc2sgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICR0YXNrLnNldCxcbiAgY2xlYXJJbW1lZGlhdGU6ICR0YXNrLmNsZWFyXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5417\n")},8772:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("// ie9- setTimeout & setInterval additional parameters fix\nvar global = __webpack_require__(7526);\nvar $export = __webpack_require__(2127);\nvar userAgent = __webpack_require__(4514);\nvar slice = [].slice;\nvar MSIE = /MSIE .\\./.test(userAgent); // <- dirty ie9- check\nvar wrap = function (set) {\n  return function (fn, time /* , ...args */) {\n    var boundArgs = arguments.length > 2;\n    var args = boundArgs ? slice.call(arguments, 2) : false;\n    return set(boundArgs ? function () {\n      // eslint-disable-next-line no-new-func\n      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);\n    } : fn, time);\n  };\n};\n$export($export.G + $export.B + $export.F * MSIE, {\n  setTimeout: wrap(global.setTimeout),\n  setInterval: wrap(global.setInterval)\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODc3Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxJQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLElBQWU7QUFDdkM7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXRlZ3JhcGgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzPzQ3OTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaWU5LSBzZXRUaW1lb3V0ICYgc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG52YXIgc2xpY2UgPSBbXS5zbGljZTtcbnZhciBNU0lFID0gL01TSUUgLlxcLi8udGVzdCh1c2VyQWdlbnQpOyAvLyA8LSBkaXJ0eSBpZTktIGNoZWNrXG52YXIgd3JhcCA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChmbiwgdGltZSAvKiAsIC4uLmFyZ3MgKi8pIHtcbiAgICB2YXIgYm91bmRBcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgdmFyIGFyZ3MgPSBib3VuZEFyZ3MgPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiBmYWxzZTtcbiAgICByZXR1cm4gc2V0KGJvdW5kQXJncyA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbikpLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gOiBmbiwgdGltZSk7XG4gIH07XG59O1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIgKyAkZXhwb3J0LkYgKiBNU0lFLCB7XG4gIHNldFRpbWVvdXQ6IHdyYXAoZ2xvYmFsLnNldFRpbWVvdXQpLFxuICBzZXRJbnRlcnZhbDogd3JhcChnbG9iYWwuc2V0SW50ZXJ2YWwpXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8772\n")},6813:(module,__unused_webpack_exports,__webpack_require__)=>{eval("__webpack_require__(9650);\n__webpack_require__(935);\n__webpack_require__(6064);\n__webpack_require__(7067);\n__webpack_require__(2642);\n__webpack_require__(3000);\n__webpack_require__(8647);\n__webpack_require__(1895);\n__webpack_require__(8236);\n__webpack_require__(3822);\n__webpack_require__(5572);\n__webpack_require__(9318);\n__webpack_require__(5032);\n__webpack_require__(9073);\n__webpack_require__(1430);\n__webpack_require__(8451);\n__webpack_require__(8132);\n__webpack_require__(7482);\n__webpack_require__(5049);\n__webpack_require__(489);\n__webpack_require__(5502);\n__webpack_require__(571);\n__webpack_require__(6108);\n__webpack_require__(4509);\n__webpack_require__(7727);\n__webpack_require__(6701);\n__webpack_require__(4419);\n__webpack_require__(1933);\n__webpack_require__(3157);\n__webpack_require__(9497);\n__webpack_require__(4104);\n__webpack_require__(210);\n__webpack_require__(6576);\n__webpack_require__(4437);\n__webpack_require__(8050);\n__webpack_require__(6648);\n__webpack_require__(5771);\n__webpack_require__(2392);\n__webpack_require__(2335);\n__webpack_require__(4896);\n__webpack_require__(4521);\n__webpack_require__(9147);\n__webpack_require__(1318);\n__webpack_require__(4352);\n__webpack_require__(5327);\n__webpack_require__(7509);\n__webpack_require__(5909);\n__webpack_require__(9584);\n__webpack_require__(345);\n__webpack_require__(9134);\n__webpack_require__(7901);\n__webpack_require__(6592);\n__webpack_require__(2220);\n__webpack_require__(3483);\n__webpack_require__(957);\n__webpack_require__(2975);\n__webpack_require__(2405);\n__webpack_require__(7224);\n__webpack_require__(8872);\n__webpack_require__(4894);\n__webpack_require__(177);\n__webpack_require__(7360);\n__webpack_require__(9011);\n__webpack_require__(4591);\n__webpack_require__(7334);\n__webpack_require__(7083);\n__webpack_require__(9213);\n__webpack_require__(8437);\n__webpack_require__(9839);\n__webpack_require__(6549);\n__webpack_require__(2818);\n__webpack_require__(8543);\n__webpack_require__(3559);\n__webpack_require__(4153);\n__webpack_require__(3292);\n__webpack_require__(2346);\n__webpack_require__(9429);\n__webpack_require__(7849);\n__webpack_require__(8951);\n__webpack_require__(7899);\n__webpack_require__(3863);\n__webpack_require__(4570);\n__webpack_require__(6511);\n__webpack_require__(5853);\n__webpack_require__(7075);\n__webpack_require__(3504);\n__webpack_require__(4913);\n__webpack_require__(9813);\n__webpack_require__(8892);\n__webpack_require__(8888);\n__webpack_require__(1449);\n__webpack_require__(7874);\n__webpack_require__(4609);\n__webpack_require__(3706);\n__webpack_require__(9620);\n__webpack_require__(7762);\n__webpack_require__(5144);\n__webpack_require__(5369);\n__webpack_require__(6209);\n__webpack_require__(5165);\n__webpack_require__(8301);\n__webpack_require__(4116);\n__webpack_require__(8604);\n__webpack_require__(9638);\n__webpack_require__(4040);\n__webpack_require__(8305);\n__webpack_require__(4701);\n__webpack_require__(341);\n__webpack_require__(6517);\n__webpack_require__(3386);\n__webpack_require__(1632);\n__webpack_require__(9397);\n__webpack_require__(8163);\n__webpack_require__(5706);\n__webpack_require__(660);\n__webpack_require__(8699);\n__webpack_require__(4702);\n__webpack_require__(333);\n__webpack_require__(1220);\n__webpack_require__(2087);\n__webpack_require__(8066);\n__webpack_require__(8537);\n__webpack_require__(7925);\n__webpack_require__(2490);\n__webpack_require__(7103);\n__webpack_require__(2586);\n__webpack_require__(2552);\n__webpack_require__(4376);\n__webpack_require__(5153);\n__webpack_require__(1879);\n__webpack_require__(2650);\n__webpack_require__(1104);\n__webpack_require__(1883);\n__webpack_require__(5433);\n__webpack_require__(5000);\n__webpack_require__(5932);\n__webpack_require__(5443);\n__webpack_require__(6316);\n__webpack_require__(9087);\n__webpack_require__(9766);\n__webpack_require__(1390);\n__webpack_require__(2687);\n__webpack_require__(5380);\n__webpack_require__(5693);\n__webpack_require__(62);\n__webpack_require__(521);\n__webpack_require__(6311);\n__webpack_require__(2820);\n__webpack_require__(4180);\n__webpack_require__(4614);\n__webpack_require__(7594);\n__webpack_require__(7146);\n__webpack_require__(7531);\n__webpack_require__(5039);\n__webpack_require__(4300);\n__webpack_require__(6328);\n__webpack_require__(1657);\n__webpack_require__(8223);\n__webpack_require__(5738);\n__webpack_require__(9616);\n__webpack_require__(6841);\n__webpack_require__(5339);\n__webpack_require__(7367);\n__webpack_require__(2577);\n__webpack_require__(4748);\n__webpack_require__(2538);\n__webpack_require__(1692);\n__webpack_require__(3537);\n__webpack_require__(9676);\n__webpack_require__(6764);\n__webpack_require__(447);\n__webpack_require__(8330);\n__webpack_require__(8423);\n__webpack_require__(4117);\n__webpack_require__(3758);\n__webpack_require__(269);\n__webpack_require__(391);\n__webpack_require__(4633);\n__webpack_require__(9557);\n__webpack_require__(3702);\n__webpack_require__(6043);\n__webpack_require__(8583);\n__webpack_require__(1041);\n__webpack_require__(7491);\n__webpack_require__(4907);\n__webpack_require__(9100);\n__webpack_require__(9269);\n__webpack_require__(1319);\n__webpack_require__(9732);\n__webpack_require__(1176);\n__webpack_require__(3107);\n__webpack_require__(1691);\n__webpack_require__(3642);\n__webpack_require__(9530);\n__webpack_require__(8772);\n__webpack_require__(5417);\n__webpack_require__(5890);\nmodule.exports = __webpack_require__(6094);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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MEI7QUFDbEMsbUJBQU8sQ0FBQyxJQUFzQjtBQUM5QixtQkFBTyxDQUFDLElBQXlCO0FBQ2pDLG1CQUFPLENBQUMsSUFBNEI7QUFDcEMsMENBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanM/NjZmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucGFyc2UtaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXNpbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hdGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNicnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jbHozMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNvc2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5leHBtMScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmh5cG90Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguaW11bCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC50YW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmF3Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy50cmltJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5iaWcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udGNvbG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcubGluaycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS5ub3cnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmpvaW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc29ydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZXZlcnknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5leGVjJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wcm9taXNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5oYXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmZsYXQtbWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmZsYXR0ZW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLmF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zZXQub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1tYXAub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1zZXQub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0LmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy53ZWFrLXNldC5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lmdsb2JhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmVycm9yLmlzLWVycm9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguY2xhbXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5kZWctcGVyLXJhZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmRlZ3JlZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5mc2NhbGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pYWRkaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaW11bGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5yYWQtcGVyLWRlZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnJhZGlhbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5zY2FsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguc2lnbmJpdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucHJvbWlzZS50cnknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWZpbmUtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXNhcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLnRpbWVycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5pbW1lZGlhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9fY29yZScpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6813\n")},8463:function(__unused_webpack_module,exports){eval('//packer version\n\n\n(function(global) {\n    // *************************************************************\n    //   LiteGraph CLASS                                     *******\n    // *************************************************************\n\n    /**\n     * The Global Scope. It contains all the registered node classes.\n     *\n     * @class LiteGraph\n     * @constructor\n     */\n\n    var LiteGraph = (global.LiteGraph = {\n        VERSION: 0.4,\n\n        CANVAS_GRID_SIZE: 10,\n\n        NODE_TITLE_HEIGHT: 30,\n        NODE_TITLE_TEXT_Y: 20,\n        NODE_SLOT_HEIGHT: 20,\n        NODE_WIDGET_HEIGHT: 20,\n        NODE_WIDTH: 140,\n        NODE_MIN_WIDTH: 50,\n        NODE_COLLAPSED_RADIUS: 10,\n        NODE_COLLAPSED_WIDTH: 80,\n        NODE_TITLE_COLOR: "#999",\n        NODE_SELECTED_TITLE_COLOR: "#FFF",\n        NODE_TEXT_SIZE: 14,\n        NODE_TEXT_COLOR: "#AAA",\n        NODE_SUBTEXT_SIZE: 12,\n        NODE_DEFAULT_COLOR: "#333",\n        NODE_DEFAULT_BGCOLOR: "#353535",\n        NODE_DEFAULT_BOXCOLOR: "#666",\n        NODE_DEFAULT_SHAPE: "box",\n        NODE_BOX_OUTLINE_COLOR: "#FFF",\n        DEFAULT_SHADOW_COLOR: "rgba(0,0,0,0.5)",\n        DEFAULT_GROUP_FONT: 24,\n\n        WIDGET_BGCOLOR: "#222",\n        WIDGET_OUTLINE_COLOR: "#666",\n        WIDGET_TEXT_COLOR: "#DDD",\n        WIDGET_SECONDARY_TEXT_COLOR: "#999",\n\n        LINK_COLOR: "#9A9",\n        EVENT_LINK_COLOR: "#A86",\n        CONNECTING_LINK_COLOR: "#AFA",\n\n        MAX_NUMBER_OF_NODES: 1000, //avoid infinite loops\n        DEFAULT_POSITION: [100, 100], //default node position\n        VALID_SHAPES: ["default", "box", "round", "card"], //,"circle"\n\n        //shapes are used for nodes but also for slots\n        BOX_SHAPE: 1,\n        ROUND_SHAPE: 2,\n        CIRCLE_SHAPE: 3,\n        CARD_SHAPE: 4,\n        ARROW_SHAPE: 5,\n        GRID_SHAPE: 6, // intended for slot arrays\n\n        //enums\n        INPUT: 1,\n        OUTPUT: 2,\n\n        EVENT: -1, //for outputs\n        ACTION: -1, //for inputs\n\n        NODE_MODES: ["Always", "On Event", "Never", "On Trigger"], // helper, will add "On Request" and more in the future\n        NODE_MODES_COLORS:["#666","#422","#333","#224","#626"], // use with node_box_coloured_by_mode\n        ALWAYS: 0,\n        ON_EVENT: 1,\n        NEVER: 2,\n        ON_TRIGGER: 3,\n\n        UP: 1,\n        DOWN: 2,\n        LEFT: 3,\n        RIGHT: 4,\n        CENTER: 5,\n\n        LINK_RENDER_MODES: ["Straight", "Linear", "Spline"], // helper\n        STRAIGHT_LINK: 0,\n        LINEAR_LINK: 1,\n        SPLINE_LINK: 2,\n\n        NORMAL_TITLE: 0,\n        NO_TITLE: 1,\n        TRANSPARENT_TITLE: 2,\n        AUTOHIDE_TITLE: 3,\n        VERTICAL_LAYOUT: "vertical", // arrange nodes vertically\n\n        proxy: null, //used to redirect calls\n        node_images_path: "",\n\n        debug: false,\n        catch_exceptions: true,\n        throw_errors: true,\n        allow_scripts: false, //if set to true some nodes like Formula would be allowed to evaluate code that comes from unsafe sources (like node configuration), which could lead to exploits\n        use_deferred_actions: true, //executes actions during the graph execution flow\n        registered_node_types: {}, //nodetypes by string\n        node_types_by_file_extension: {}, //used for dropping files in the canvas\n        Nodes: {}, //node types by classname\n\t\tGlobals: {}, //used to store vars between graphs\n\n        searchbox_extras: {}, //used to add extra features to the search box\n        auto_sort_node_types: false, // [true!] If set to true, will automatically sort node types / categories in the context menus\n\t\t\n\t\tnode_box_coloured_when_on: false, // [true!] this make the nodes box (top left circle) coloured when triggered (execute/action), visual feedback\n        node_box_coloured_by_mode: false, // [true!] nodebox based on node mode, visual feedback\n        \n        dialog_close_on_mouse_leave: true, // [false on mobile] better true if not touch device, TODO add an helper/listener to close if false\n        dialog_close_on_mouse_leave_delay: 500,\n        \n        shift_click_do_break_link_from: false, // [false!] prefer false if results too easy to break links - implement with ALT or TODO custom keys\n        click_do_break_link_to: false, // [false!]prefer false, way too easy to break links\n        \n        search_hide_on_mouse_leave: true, // [false on mobile] better true if not touch device, TODO add an helper/listener to close if false\n        search_filter_enabled: false, // [true!] enable filtering slots type in the search widget, !requires auto_load_slot_types or manual set registered_slot_[in/out]_types and slot_types_[in/out]\n        search_show_all_on_open: true, // [true!] opens the results list when opening the search widget\n        \n        auto_load_slot_types: false, // [if want false, use true, run, get vars values to be statically set, than disable] nodes types and nodeclass association with node types need to be calculated, if dont want this, calculate once and set registered_slot_[in/out]_types and slot_types_[in/out]\n        \n\t\t// set these values if not using auto_load_slot_types\n        registered_slot_in_types: {}, // slot types for nodeclass\n        registered_slot_out_types: {}, // slot types for nodeclass\n        slot_types_in: [], // slot types IN\n        slot_types_out: [], // slot types OUT\n        slot_types_default_in: [], // specify for each IN slot type a(/many) default node(s), use single string, array, or object (with node, title, parameters, ..) like for search\n\t\tslot_types_default_out: [], // specify for each OUT slot type a(/many) default node(s), use single string, array, or object (with node, title, parameters, ..) like for search\n\t\t\n\t\talt_drag_do_clone_nodes: false, // [true!] very handy, ALT click to clone and drag the new node\n\n\t\tdo_add_triggers_slots: false, // [true!] will create and connect event slots when using action/events connections, !WILL CHANGE node mode when using onTrigger (enable mode colors), onExecuted does not need this\n\t\t\n\t\tallow_multi_output_for_events: true, // [false!] being events, it is strongly reccomended to use them sequentially, one by one\n\n\t\tmiddle_click_slot_add_default_node: false, //[true!] allows to create and connect a ndoe clicking with the third button (wheel)\n\t\t\n\t\trelease_link_on_empty_shows_menu: false, //[true!] dragging a link to empty space will open a menu, add from list, search or defaults\n\t\t\n        pointerevents_method: "mouse", // "mouse"|"pointer" use mouse for retrocompatibility issues? (none found @ now)\n        // TODO implement pointercancel, gotpointercapture, lostpointercapture, (pointerover, pointerout if necessary)\n\n        ctrl_shift_v_paste_connect_unselected_outputs: false, //[true!] allows ctrl + shift + v to paste nodes with the outputs of the unselected nodes connected with the inputs of the newly pasted nodes\n\n        // if true, all newly created nodes/links will use string UUIDs for their id fields instead of integers.\n        // use this if you must have node IDs that are unique across all graphs and subgraphs.\n        use_uuids: false,\n\n        /**\n         * Register a node class so it can be listed when the user wants to create a new one\n         * @method registerNodeType\n         * @param {String} type name of the node and path\n         * @param {Class} base_class class containing the structure of a node\n         */\n\n        registerNodeType: function(type, base_class) {\n            if (!base_class.prototype) {\n                throw "Cannot register a simple object, it must be a class with a prototype";\n            }\n            base_class.type = type;\n\n            if (LiteGraph.debug) {\n                console.log("Node registered: " + type);\n            }\n\n            const classname = base_class.name;\n\n            const pos = type.lastIndexOf("/");\n            base_class.category = type.substring(0, pos);\n\n            if (!base_class.title) {\n                base_class.title = classname;\n            }\n\n            //extend class\n            for (var i in LGraphNode.prototype) {\n                if (!base_class.prototype[i]) {\n                    base_class.prototype[i] = LGraphNode.prototype[i];\n                }\n            }\n\n            const prev = this.registered_node_types[type];\n            if(prev) {\n                console.log("replacing node type: " + type);\n            }\n            if( !Object.prototype.hasOwnProperty.call( base_class.prototype, "shape") ) {\n                Object.defineProperty(base_class.prototype, "shape", {\n                    set: function(v) {\n                        switch (v) {\n                            case "default":\n                                delete this._shape;\n                                break;\n                            case "box":\n                                this._shape = LiteGraph.BOX_SHAPE;\n                                break;\n                            case "round":\n                                this._shape = LiteGraph.ROUND_SHAPE;\n                                break;\n                            case "circle":\n                                this._shape = LiteGraph.CIRCLE_SHAPE;\n                                break;\n                            case "card":\n                                this._shape = LiteGraph.CARD_SHAPE;\n                                break;\n                            default:\n                                this._shape = v;\n                        }\n                    },\n                    get: function() {\n                        return this._shape;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                \n\n                //used to know which nodes to create when dragging files to the canvas\n                if (base_class.supported_extensions) {\n                    for (let i in base_class.supported_extensions) {\n                        const ext = base_class.supported_extensions[i];\n                        if(ext && ext.constructor === String) {\n                            this.node_types_by_file_extension[ ext.toLowerCase() ] = base_class;\n                        }\n                    }\n                }\n            }\n\n            this.registered_node_types[type] = base_class;\n            if (base_class.constructor.name) {\n                this.Nodes[classname] = base_class;\n            }\n            if (LiteGraph.onNodeTypeRegistered) {\n                LiteGraph.onNodeTypeRegistered(type, base_class);\n            }\n            if (prev && LiteGraph.onNodeTypeReplaced) {\n                LiteGraph.onNodeTypeReplaced(type, base_class, prev);\n            }\n\n            //warnings\n            if (base_class.prototype.onPropertyChange) {\n                console.warn(\n                    "LiteGraph node class " +\n                        type +\n                        " has onPropertyChange method, it must be called onPropertyChanged with d at the end"\n                );\n            }\n            \n            // TODO one would want to know input and ouput :: this would allow through registerNodeAndSlotType to get all the slots types\n            if (this.auto_load_slot_types) {\n                new base_class(base_class.title || "tmpnode");\n            }\n        },\n\n        /**\n         * removes a node type from the system\n         * @method unregisterNodeType\n         * @param {String|Object} type name of the node or the node constructor itself\n         */\n        unregisterNodeType: function(type) {\n            const base_class =\n                type.constructor === String\n                    ? this.registered_node_types[type]\n                    : type;\n            if (!base_class) {\n                throw "node type not found: " + type;\n            }\n            delete this.registered_node_types[base_class.type];\n            if (base_class.constructor.name) {\n                delete this.Nodes[base_class.constructor.name];\n            }\n        },\n\n        /**\n        * Save a slot type and his node\n        * @method registerSlotType\n        * @param {String|Object} type name of the node or the node constructor itself\n        * @param {String} slot_type name of the slot type (variable type), eg. string, number, array, boolean, ..\n        */\n        registerNodeAndSlotType: function(type, slot_type, out){\n            out = out || false;\n            const base_class =\n                type.constructor === String &&\n                this.registered_node_types[type] !== "anonymous"\n                    ? this.registered_node_types[type]\n                    : type;\n\n            const class_type = base_class.constructor.type;\n\n            let allTypes = [];\n            if (typeof slot_type === "string") {\n                allTypes = slot_type.split(",");\n            } else if (slot_type == this.EVENT || slot_type == this.ACTION) {\n                allTypes = ["_event_"];\n            } else {\n                allTypes = ["*"];\n            }\n\n            for (let i = 0; i < allTypes.length; ++i) {\n                let slotType = allTypes[i];\n                if (slotType === "") {\n                    slotType = "*";\n                }\n                const registerTo = out\n                    ? "registered_slot_out_types"\n                    : "registered_slot_in_types";\n                if (this[registerTo][slotType] === undefined) {\n                    this[registerTo][slotType] = { nodes: [] };\n                }\n                if (!this[registerTo][slotType].nodes.includes(class_type)) {\n                    this[registerTo][slotType].nodes.push(class_type);\n                }\n\n                // check if is a new type\n                if (!out) {\n                    if (!this.slot_types_in.includes(slotType.toLowerCase())) {\n                        this.slot_types_in.push(slotType.toLowerCase());\n                        this.slot_types_in.sort();\n                    }\n                } else {\n                    if (!this.slot_types_out.includes(slotType.toLowerCase())) {\n                        this.slot_types_out.push(slotType.toLowerCase());\n                        this.slot_types_out.sort();\n                    }\n                }\n            }\n        },\n        \n        /**\n         * Create a new nodetype by passing an object with some properties\n         * like onCreate, inputs:Array, outputs:Array, properties, onExecute\n         * @method buildNodeClassFromObject\n         * @param {String} name node name with namespace (p.e.: \'math/sum\')\n         * @param {Object} object methods expected onCreate, inputs, outputs, properties, onExecute\n         */\n         buildNodeClassFromObject: function(\n            name,\n            object\n        ) {\n            var ctor_code = "";\n            if(object.inputs)\n            for(var i=0; i < object.inputs.length; ++i)\n            {\n                var _name = object.inputs[i][0];\n                var _type = object.inputs[i][1];\n                if(_type && _type.constructor === String)\n                    _type = \'"\'+_type+\'"\';\n                ctor_code += "this.addInput(\'"+_name+"\',"+_type+");\\n";\n            }\n            if(object.outputs)\n            for(var i=0; i < object.outputs.length; ++i)\n            {\n                var _name = object.outputs[i][0];\n                var _type = object.outputs[i][1];\n                if(_type && _type.constructor === String)\n                    _type = \'"\'+_type+\'"\';\n                ctor_code += "this.addOutput(\'"+_name+"\',"+_type+");\\n";\n            }\n            if(object.properties)\n            for(var i in object.properties)\n            {\n                var prop = object.properties[i];\n                if(prop && prop.constructor === String)\n                    prop = \'"\'+prop+\'"\';\n                ctor_code += "this.addProperty(\'"+i+"\',"+prop+");\\n";\n            }\n            ctor_code += "if(this.onCreate)this.onCreate()";\n            var classobj = Function(ctor_code);\n            for(var i in object)\n                if(i!="inputs" && i!="outputs" && i!="properties")\n                    classobj.prototype[i] = object[i];\n            classobj.title = object.title || name.split("/").pop();\n            classobj.desc = object.desc || "Generated from object";\n            this.registerNodeType(name, classobj);\n            return classobj;\n        },\n        \n        /**\n         * Create a new nodetype by passing a function, it wraps it with a proper class and generates inputs according to the parameters of the function.\n         * Useful to wrap simple methods that do not require properties, and that only process some input to generate an output.\n         * @method wrapFunctionAsNode\n         * @param {String} name node name with namespace (p.e.: \'math/sum\')\n         * @param {Function} func\n         * @param {Array} param_types [optional] an array containing the type of every parameter, otherwise parameters will accept any type\n         * @param {String} return_type [optional] string with the return type, otherwise it will be generic\n         * @param {Object} properties [optional] properties to be configurable\n         */\n        wrapFunctionAsNode: function(\n            name,\n            func,\n            param_types,\n            return_type,\n            properties\n        ) {\n            var params = Array(func.length);\n            var code = "";\n            if(param_types !== null) //null means no inputs\n            {\n                var names = LiteGraph.getParameterNames(func);\n                for (var i = 0; i < names.length; ++i) {\n                    var type = 0;\n                    if(param_types)\n                    {\n                        //type = param_types[i] != null ? "\'" + param_types[i] + "\'" : "0";\n                        if( param_types[i] != null && param_types[i].constructor === String )\n                            type = "\'" + param_types[i] + "\'" ;\n                        else if( param_types[i] != null )\n                            type = param_types[i];\n                    } \n                    code +=\n                        "this.addInput(\'" +\n                        names[i] +\n                        "\'," +\n                        type +\n                        ");\\n";\n                }\n            }\n            if(return_type !== null) //null means no output\n            code +=\n                "this.addOutput(\'out\'," +\n                (return_type != null ? (return_type.constructor === String ? "\'" + return_type + "\'" : return_type) : 0) +\n                ");\\n";\n            if (properties) {\n                code +=\n                    "this.properties = " + JSON.stringify(properties) + ";\\n";\n            }\n            var classobj = Function(code);\n            classobj.title = name.split("/").pop();\n            classobj.desc = "Generated from " + func.name;\n            classobj.prototype.onExecute = function onExecute() {\n                for (var i = 0; i < params.length; ++i) {\n                    params[i] = this.getInputData(i);\n                }\n                var r = func.apply(this, params);\n                this.setOutputData(0, r);\n            };\n            this.registerNodeType(name, classobj);\n            return classobj;\n        },\n\n        /**\n         * Removes all previously registered node\'s types\n         */\n        clearRegisteredTypes: function() {\n            this.registered_node_types = {};\n            this.node_types_by_file_extension = {};\n            this.Nodes = {};\n            this.searchbox_extras = {};\n        },\n\n        /**\n         * Adds this method to all nodetypes, existing and to be created\n         * (You can add it to LGraphNode.prototype but then existing node types wont have it)\n         * @method addNodeMethod\n         * @param {Function} func\n         */\n        addNodeMethod: function(name, func) {\n            LGraphNode.prototype[name] = func;\n            for (var i in this.registered_node_types) {\n                var type = this.registered_node_types[i];\n                if (type.prototype[name]) {\n                    type.prototype["_" + name] = type.prototype[name];\n                } //keep old in case of replacing\n                type.prototype[name] = func;\n            }\n        },\n\n        /**\n         * Create a node of a given type with a name. The node is not attached to any graph yet.\n         * @method createNode\n         * @param {String} type full name of the node class. p.e. "math/sin"\n         * @param {String} name a name to distinguish from other nodes\n         * @param {Object} options to set options\n         */\n\n        createNode: function(type, title, options) {\n            var base_class = this.registered_node_types[type];\n            if (!base_class) {\n                if (LiteGraph.debug) {\n                    console.log(\n                        \'GraphNode type "\' + type + \'" not registered.\'\n                    );\n                }\n                return null;\n            }\n\n            var prototype = base_class.prototype || base_class;\n\n            title = title || base_class.title || type;\n\n            var node = null;\n\n            if (LiteGraph.catch_exceptions) {\n                try {\n                    node = new base_class(title);\n                } catch (err) {\n                    console.error(err);\n                    return null;\n                }\n            } else {\n                node = new base_class(title);\n            }\n\n            node.type = type;\n\n            if (!node.title && title) {\n                node.title = title;\n            }\n            if (!node.properties) {\n                node.properties = {};\n            }\n            if (!node.properties_info) {\n                node.properties_info = [];\n            }\n            if (!node.flags) {\n                node.flags = {};\n            }\n            if (!node.size) {\n                node.size = node.computeSize();\n\t\t\t\t//call onresize?\n            }\n            if (!node.pos) {\n                node.pos = LiteGraph.DEFAULT_POSITION.concat();\n            }\n            if (!node.mode) {\n                node.mode = LiteGraph.ALWAYS;\n            }\n\n            //extra options\n            if (options) {\n                for (var i in options) {\n                    node[i] = options[i];\n                }\n            }\n\n\t\t\t// callback\n            if ( node.onNodeCreated ) {\n                node.onNodeCreated();\n            }\n            \n            return node;\n        },\n\n        /**\n         * Returns a registered node type with a given name\n         * @method getNodeType\n         * @param {String} type full name of the node class. p.e. "math/sin"\n         * @return {Class} the node class\n         */\n        getNodeType: function(type) {\n            return this.registered_node_types[type];\n        },\n\n        /**\n         * Returns a list of node types matching one category\n         * @method getNodeType\n         * @param {String} category category name\n         * @return {Array} array with all the node classes\n         */\n\n        getNodeTypesInCategory: function(category, filter) {\n            var r = [];\n            for (var i in this.registered_node_types) {\n                var type = this.registered_node_types[i];\n                if (type.filter != filter) {\n                    continue;\n                }\n\n                if (category == "") {\n                    if (type.category == null) {\n                        r.push(type);\n                    }\n                } else if (type.category == category) {\n                    r.push(type);\n                }\n            }\n\n            if (this.auto_sort_node_types) {\n                r.sort(function(a,b){return a.title.localeCompare(b.title)});\n            }\n\n            return r;\n        },\n\n        /**\n         * Returns a list with all the node type categories\n         * @method getNodeTypesCategories\n         * @param {String} filter only nodes with ctor.filter equal can be shown\n         * @return {Array} array with all the names of the categories\n         */\n        getNodeTypesCategories: function( filter ) {\n            var categories = { "": 1 };\n            for (var i in this.registered_node_types) {\n\t\t\t\tvar type = this.registered_node_types[i];\n                if ( type.category && !type.skip_list )\n                {\n\t\t\t\t\tif(type.filter != filter)\n\t\t\t\t\t\tcontinue;\n                    categories[type.category] = 1;\n                }\n            }\n            var result = [];\n            for (var i in categories) {\n                result.push(i);\n            }\n            return this.auto_sort_node_types ? result.sort() : result;\n        },\n\n        //debug purposes: reloads all the js scripts that matches a wildcard\n        reloadNodes: function(folder_wildcard) {\n            var tmp = document.getElementsByTagName("script");\n            //weird, this array changes by its own, so we use a copy\n            var script_files = [];\n            for (var i=0; i < tmp.length; i++) {\n                script_files.push(tmp[i]);\n            }\n\n            var docHeadObj = document.getElementsByTagName("head")[0];\n            folder_wildcard = document.location.href + folder_wildcard;\n\n            for (var i=0; i < script_files.length; i++) {\n                var src = script_files[i].src;\n                if (\n                    !src ||\n                    src.substr(0, folder_wildcard.length) != folder_wildcard\n                ) {\n                    continue;\n                }\n\n                try {\n                    if (LiteGraph.debug) {\n                        console.log("Reloading: " + src);\n                    }\n                    var dynamicScript = document.createElement("script");\n                    dynamicScript.type = "text/javascript";\n                    dynamicScript.src = src;\n                    docHeadObj.appendChild(dynamicScript);\n                    docHeadObj.removeChild(script_files[i]);\n                } catch (err) {\n                    if (LiteGraph.throw_errors) {\n                        throw err;\n                    }\n                    if (LiteGraph.debug) {\n                        console.log("Error while reloading " + src);\n                    }\n                }\n            }\n\n            if (LiteGraph.debug) {\n                console.log("Nodes reloaded");\n            }\n        },\n\n        //separated just to improve if it doesn\'t work\n        cloneObject: function(obj, target) {\n            if (obj == null) {\n                return null;\n            }\n            var r = JSON.parse(JSON.stringify(obj));\n            if (!target) {\n                return r;\n            }\n\n            for (var i in r) {\n                target[i] = r[i];\n            }\n            return target;\n        },\n\n        /*\n         * https://gist.github.com/jed/982883?permalink_comment_id=852670#gistcomment-852670\n         */\n        uuidv4: function() {\n            return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,a=>(a^Math.random()*16>>a/4).toString(16));\n        },\n\n        /**\n         * Returns if the types of two slots are compatible (taking into account wildcards, etc)\n         * @method isValidConnection\n         * @param {String} type_a\n         * @param {String} type_b\n         * @return {Boolean} true if they can be connected\n         */\n        isValidConnection: function(type_a, type_b) {\n\t\t\tif (type_a=="" || type_a==="*") type_a = 0;\n\t\t\tif (type_b=="" || type_b==="*") type_b = 0;\n            if (\n                !type_a //generic output\n                || !type_b // generic input\n                || type_a == type_b //same type (is valid for triggers)\n                || (type_a == LiteGraph.EVENT && type_b == LiteGraph.ACTION)\n            ) {\n                return true;\n            }\n\n            // Enforce string type to handle toLowerCase call (-1 number not ok)\n            type_a = String(type_a);\n            type_b = String(type_b);\n            type_a = type_a.toLowerCase();\n            type_b = type_b.toLowerCase();\n\n            // For nodes supporting multiple connection types\n            if (type_a.indexOf(",") == -1 && type_b.indexOf(",") == -1) {\n                return type_a == type_b;\n            }\n\n            // Check all permutations to see if one is valid\n            var supported_types_a = type_a.split(",");\n            var supported_types_b = type_b.split(",");\n            for (var i = 0; i < supported_types_a.length; ++i) {\n                for (var j = 0; j < supported_types_b.length; ++j) {\n                    if(this.isValidConnection(supported_types_a[i],supported_types_b[j])){\n\t\t\t\t\t//if (supported_types_a[i] == supported_types_b[j]) {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        },\n\n        /**\n         * Register a string in the search box so when the user types it it will recommend this node\n         * @method registerSearchboxExtra\n         * @param {String} node_type the node recommended\n         * @param {String} description text to show next to it\n         * @param {Object} data it could contain info of how the node should be configured\n         * @return {Boolean} true if they can be connected\n         */\n        registerSearchboxExtra: function(node_type, description, data) {\n            this.searchbox_extras[description.toLowerCase()] = {\n                type: node_type,\n                desc: description,\n                data: data\n            };\n        },\n\n        /**\n         * Wrapper to load files (from url using fetch or from file using FileReader)\n         * @method fetchFile\n         * @param {String|File|Blob} url the url of the file (or the file itself)\n         * @param {String} type an string to know how to fetch it: "text","arraybuffer","json","blob"\n         * @param {Function} on_complete callback(data)\n         * @param {Function} on_error in case of an error\n         * @return {FileReader|Promise} returns the object used to \n         */\n\t\tfetchFile: function( url, type, on_complete, on_error ) {\n\t\t\tvar that = this;\n\t\t\tif(!url)\n\t\t\t\treturn null;\n\n\t\t\ttype = type || "text";\n\t\t\tif( url.constructor === String )\n\t\t\t{\n\t\t\t\tif (url.substr(0, 4) == "http" && LiteGraph.proxy) {\n\t\t\t\t\turl = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);\n\t\t\t\t}\n\t\t\t\treturn fetch(url)\n\t\t\t\t.then(function(response) {\n\t\t\t\t\tif(!response.ok)\n\t\t\t\t\t\t throw new Error("File not found"); //it will be catch below\n\t\t\t\t\tif(type == "arraybuffer")\n\t\t\t\t\t\treturn response.arrayBuffer();\n\t\t\t\t\telse if(type == "text" || type == "string")\n\t\t\t\t\t\treturn response.text();\n\t\t\t\t\telse if(type == "json")\n\t\t\t\t\t\treturn response.json();\n\t\t\t\t\telse if(type == "blob")\n\t\t\t\t\t\treturn response.blob();\n\t\t\t\t})\n\t\t\t\t.then(function(data) {\n\t\t\t\t\tif(on_complete)\n\t\t\t\t\t\ton_complete(data);\n\t\t\t\t})\n\t\t\t\t.catch(function(error) {\n\t\t\t\t\tconsole.error("error fetching file:",url);\n\t\t\t\t\tif(on_error)\n\t\t\t\t\t\ton_error(error);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if( url.constructor === File || url.constructor === Blob)\n\t\t\t{\n\t\t\t\tvar reader = new FileReader();\n\t\t\t\treader.onload = function(e)\n\t\t\t\t{\n\t\t\t\t\tvar v = e.target.result;\n\t\t\t\t\tif( type == "json" )\n\t\t\t\t\t\tv = JSON.parse(v);\n\t\t\t\t\tif(on_complete)\n\t\t\t\t\t\ton_complete(v);\n\t\t\t\t}\n\t\t\t\tif(type == "arraybuffer")\n\t\t\t\t\treturn reader.readAsArrayBuffer(url);\n\t\t\t\telse if(type == "text" || type == "json")\n\t\t\t\t\treturn reader.readAsText(url);\n\t\t\t\telse if(type == "blob")\n\t\t\t\t\treturn reader.readAsBinaryString(url);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n    });\n\n    //timer that works everywhere\n    if (typeof performance != "undefined") {\n        LiteGraph.getTime = performance.now.bind(performance);\n    } else if (typeof Date != "undefined" && Date.now) {\n        LiteGraph.getTime = Date.now.bind(Date);\n    } else if (typeof process != "undefined") {\n        LiteGraph.getTime = function() {\n            var t = process.hrtime();\n            return t[0] * 0.001 + t[1] * 1e-6;\n        };\n    } else {\n        LiteGraph.getTime = function getTime() {\n            return new Date().getTime();\n        };\n    }\n\n    //*********************************************************************************\n    // LGraph CLASS\n    //*********************************************************************************\n\n    /**\n     * LGraph is the class that contain a full graph. We instantiate one and add nodes to it, and then we can run the execution loop.\n\t * supported callbacks:\n\t\t+ onNodeAdded: when a new node is added to the graph\n\t\t+ onNodeRemoved: when a node inside this graph is removed\n\t\t+ onNodeConnectionChange: some connection has changed in the graph (connected or disconnected)\n     *\n     * @class LGraph\n     * @constructor\n     * @param {Object} o data from previous serialization [optional]\n     */\n\n    function LGraph(o) {\n        if (LiteGraph.debug) {\n            console.log("Graph created");\n        }\n        this.list_of_graphcanvas = null;\n        this.clear();\n\n        if (o) {\n            this.configure(o);\n        }\n    }\n\n    global.LGraph = LiteGraph.LGraph = LGraph;\n\n    //default supported types\n    LGraph.supported_types = ["number", "string", "boolean"];\n\n    //used to know which types of connections support this graph (some graphs do not allow certain types)\n    LGraph.prototype.getSupportedTypes = function() {\n        return this.supported_types || LGraph.supported_types;\n    };\n\n    LGraph.STATUS_STOPPED = 1;\n    LGraph.STATUS_RUNNING = 2;\n\n    /**\n     * Removes all nodes from this graph\n     * @method clear\n     */\n\n    LGraph.prototype.clear = function() {\n        this.stop();\n        this.status = LGraph.STATUS_STOPPED;\n\n        this.last_node_id = 0;\n        this.last_link_id = 0;\n\n        this._version = -1; //used to detect changes\n\n        //safe clear\n        if (this._nodes) {\n            for (var i = 0; i < this._nodes.length; ++i) {\n                var node = this._nodes[i];\n                if (node.onRemoved) {\n                    node.onRemoved();\n                }\n            }\n        }\n\n        //nodes\n        this._nodes = [];\n        this._nodes_by_id = {};\n        this._nodes_in_order = []; //nodes sorted in execution order\n        this._nodes_executable = null; //nodes that contain onExecute sorted in execution order\n\n        //other scene stuff\n        this._groups = [];\n\n        //links\n        this.links = {}; //container with all the links\n\n        //iterations\n        this.iteration = 0;\n\n        //custom data\n        this.config = {};\n\t\tthis.vars = {};\n\t\tthis.extra = {}; //to store custom data\n\n        //timing\n        this.globaltime = 0;\n        this.runningtime = 0;\n        this.fixedtime = 0;\n        this.fixedtime_lapse = 0.01;\n        this.elapsed_time = 0.01;\n        this.last_update_time = 0;\n        this.starttime = 0;\n\n        this.catch_errors = true;\n\n        this.nodes_executing = [];\n        this.nodes_actioning = [];\n        this.nodes_executedAction = [];\n        \n        //subgraph_data\n        this.inputs = {};\n        this.outputs = {};\n\n        //notify canvas to redraw\n        this.change();\n\n        this.sendActionToCanvas("clear");\n    };\n\n    /**\n     * Attach Canvas to this graph\n     * @method attachCanvas\n     * @param {GraphCanvas} graph_canvas\n     */\n\n    LGraph.prototype.attachCanvas = function(graphcanvas) {\n        if (graphcanvas.constructor != LGraphCanvas) {\n            throw "attachCanvas expects a LGraphCanvas instance";\n        }\n        if (graphcanvas.graph && graphcanvas.graph != this) {\n            graphcanvas.graph.detachCanvas(graphcanvas);\n        }\n\n        graphcanvas.graph = this;\n\n        if (!this.list_of_graphcanvas) {\n            this.list_of_graphcanvas = [];\n        }\n        this.list_of_graphcanvas.push(graphcanvas);\n    };\n\n    /**\n     * Detach Canvas from this graph\n     * @method detachCanvas\n     * @param {GraphCanvas} graph_canvas\n     */\n    LGraph.prototype.detachCanvas = function(graphcanvas) {\n        if (!this.list_of_graphcanvas) {\n            return;\n        }\n\n        var pos = this.list_of_graphcanvas.indexOf(graphcanvas);\n        if (pos == -1) {\n            return;\n        }\n        graphcanvas.graph = null;\n        this.list_of_graphcanvas.splice(pos, 1);\n    };\n\n    /**\n     * Starts running this graph every interval milliseconds.\n     * @method start\n     * @param {number} interval amount of milliseconds between executions, if 0 then it renders to the monitor refresh rate\n     */\n\n    LGraph.prototype.start = function(interval) {\n        if (this.status == LGraph.STATUS_RUNNING) {\n            return;\n        }\n        this.status = LGraph.STATUS_RUNNING;\n\n        if (this.onPlayEvent) {\n            this.onPlayEvent();\n        }\n\n        this.sendEventToAllNodes("onStart");\n\n        //launch\n        this.starttime = LiteGraph.getTime();\n        this.last_update_time = this.starttime;\n        interval = interval || 0;\n        var that = this;\n\n\t\t//execute once per frame\n        if ( interval == 0 && typeof window != "undefined" && window.requestAnimationFrame ) {\n            function on_frame() {\n                if (that.execution_timer_id != -1) {\n                    return;\n                }\n                window.requestAnimationFrame(on_frame);\n\t\t\t\tif(that.onBeforeStep)\n\t\t\t\t\tthat.onBeforeStep();\n                that.runStep(1, !that.catch_errors);\n\t\t\t\tif(that.onAfterStep)\n\t\t\t\t\tthat.onAfterStep();\n            }\n            this.execution_timer_id = -1;\n            on_frame();\n        } else { //execute every \'interval\' ms\n            this.execution_timer_id = setInterval(function() {\n                //execute\n\t\t\t\tif(that.onBeforeStep)\n\t\t\t\t\tthat.onBeforeStep();\n                that.runStep(1, !that.catch_errors);\n\t\t\t\tif(that.onAfterStep)\n\t\t\t\t\tthat.onAfterStep();\n            }, interval);\n        }\n    };\n\n    /**\n     * Stops the execution loop of the graph\n     * @method stop execution\n     */\n\n    LGraph.prototype.stop = function() {\n        if (this.status == LGraph.STATUS_STOPPED) {\n            return;\n        }\n\n        this.status = LGraph.STATUS_STOPPED;\n\n        if (this.onStopEvent) {\n            this.onStopEvent();\n        }\n\n        if (this.execution_timer_id != null) {\n            if (this.execution_timer_id != -1) {\n                clearInterval(this.execution_timer_id);\n            }\n            this.execution_timer_id = null;\n        }\n\n        this.sendEventToAllNodes("onStop");\n    };\n\n    /**\n     * Run N steps (cycles) of the graph\n     * @method runStep\n     * @param {number} num number of steps to run, default is 1\n     * @param {Boolean} do_not_catch_errors [optional] if you want to try/catch errors \n     * @param {number} limit max number of nodes to execute (used to execute from start to a node)\n     */\n\n    LGraph.prototype.runStep = function(num, do_not_catch_errors, limit ) {\n        num = num || 1;\n\n        var start = LiteGraph.getTime();\n        this.globaltime = 0.001 * (start - this.starttime);\n\n        //not optimal: executes possible pending actions in node, problem is it is not optimized\n        //it is done here as if it was done in the later loop it wont be called in the node missed the onExecute\n        \n        //from now on it will iterate only on executable nodes which is faster\n        var nodes = this._nodes_executable\n            ? this._nodes_executable\n            : this._nodes;\n        if (!nodes) {\n            return;\n        }\n\n\t\tlimit = limit || nodes.length;\n\n        if (do_not_catch_errors) {\n            //iterations\n            for (var i = 0; i < num; i++) {\n                for (var j = 0; j < limit; ++j) {\n                    var node = nodes[j];\n                    if(LiteGraph.use_deferred_actions && node._waiting_actions && node._waiting_actions.length)\n                        node.executePendingActions();\n                    if (node.mode == LiteGraph.ALWAYS && node.onExecute) {\n                        //wrap node.onExecute();\n\t\t\t\t\t\tnode.doExecute();\n                    }\n                }\n\n                this.fixedtime += this.fixedtime_lapse;\n                if (this.onExecuteStep) {\n                    this.onExecuteStep();\n                }\n            }\n\n            if (this.onAfterExecute) {\n                this.onAfterExecute();\n            }\n        } else { //catch errors\n            try {\n                //iterations\n                for (var i = 0; i < num; i++) {\n                    for (var j = 0; j < limit; ++j) {\n                        var node = nodes[j];\n                        if(LiteGraph.use_deferred_actions && node._waiting_actions && node._waiting_actions.length)\n                            node.executePendingActions();\n                        if (node.mode == LiteGraph.ALWAYS && node.onExecute) {\n                            node.onExecute();\n                        }\n                    }\n\n                    this.fixedtime += this.fixedtime_lapse;\n                    if (this.onExecuteStep) {\n                        this.onExecuteStep();\n                    }\n                }\n\n                if (this.onAfterExecute) {\n                    this.onAfterExecute();\n                }\n                this.errors_in_execution = false;\n            } catch (err) {\n                this.errors_in_execution = true;\n                if (LiteGraph.throw_errors) {\n                    throw err;\n                }\n                if (LiteGraph.debug) {\n                    console.log("Error during execution: " + err);\n                }\n                this.stop();\n            }\n        }\n\n        var now = LiteGraph.getTime();\n        var elapsed = now - start;\n        if (elapsed == 0) {\n            elapsed = 1;\n        }\n        this.execution_time = 0.001 * elapsed;\n        this.globaltime += 0.001 * elapsed;\n        this.iteration += 1;\n        this.elapsed_time = (now - this.last_update_time) * 0.001;\n        this.last_update_time = now;\n        this.nodes_executing = [];\n        this.nodes_actioning = [];\n        this.nodes_executedAction = [];\n    };\n\n    /**\n     * Updates the graph execution order according to relevance of the nodes (nodes with only outputs have more relevance than\n     * nodes with only inputs.\n     * @method updateExecutionOrder\n     */\n    LGraph.prototype.updateExecutionOrder = function() {\n        this._nodes_in_order = this.computeExecutionOrder(false);\n        this._nodes_executable = [];\n        for (var i = 0; i < this._nodes_in_order.length; ++i) {\n            if (this._nodes_in_order[i].onExecute) {\n                this._nodes_executable.push(this._nodes_in_order[i]);\n            }\n        }\n    };\n\n    //This is more internal, it computes the executable nodes in order and returns it\n    LGraph.prototype.computeExecutionOrder = function(\n        only_onExecute,\n        set_level\n    ) {\n        var L = [];\n        var S = [];\n        var M = {};\n        var visited_links = {}; //to avoid repeating links\n        var remaining_links = {}; //to a\n\n        //search for the nodes without inputs (starting nodes)\n        for (var i = 0, l = this._nodes.length; i < l; ++i) {\n            var node = this._nodes[i];\n            if (only_onExecute && !node.onExecute) {\n                continue;\n            }\n\n            M[node.id] = node; //add to pending nodes\n\n            var num = 0; //num of input connections\n            if (node.inputs) {\n                for (var j = 0, l2 = node.inputs.length; j < l2; j++) {\n                    if (node.inputs[j] && node.inputs[j].link != null) {\n                        num += 1;\n                    }\n                }\n            }\n\n            if (num == 0) {\n                //is a starting node\n                S.push(node);\n                if (set_level) {\n                    node._level = 1;\n                }\n            } //num of input links\n            else {\n                if (set_level) {\n                    node._level = 0;\n                }\n                remaining_links[node.id] = num;\n            }\n        }\n\n        while (true) {\n            if (S.length == 0) {\n                break;\n            }\n\n            //get an starting node\n            var node = S.shift();\n            L.push(node); //add to ordered list\n            delete M[node.id]; //remove from the pending nodes\n\n            if (!node.outputs) {\n                continue;\n            }\n\n            //for every output\n            for (var i = 0; i < node.outputs.length; i++) {\n                var output = node.outputs[i];\n                //not connected\n                if (\n                    output == null ||\n                    output.links == null ||\n                    output.links.length == 0\n                ) {\n                    continue;\n                }\n\n                //for every connection\n                for (var j = 0; j < output.links.length; j++) {\n                    var link_id = output.links[j];\n                    var link = this.links[link_id];\n                    if (!link) {\n                        continue;\n                    }\n\n                    //already visited link (ignore it)\n                    if (visited_links[link.id]) {\n                        continue;\n                    }\n\n                    var target_node = this.getNodeById(link.target_id);\n                    if (target_node == null) {\n                        visited_links[link.id] = true;\n                        continue;\n                    }\n\n                    if (\n                        set_level &&\n                        (!target_node._level ||\n                            target_node._level <= node._level)\n                    ) {\n                        target_node._level = node._level + 1;\n                    }\n\n                    visited_links[link.id] = true; //mark as visited\n                    remaining_links[target_node.id] -= 1; //reduce the number of links remaining\n                    if (remaining_links[target_node.id] == 0) {\n                        S.push(target_node);\n                    } //if no more links, then add to starters array\n                }\n            }\n        }\n\n        //the remaining ones (loops)\n        for (var i in M) {\n            L.push(M[i]);\n        }\n\n        if (L.length != this._nodes.length && LiteGraph.debug) {\n            console.warn("something went wrong, nodes missing");\n        }\n\n        var l = L.length;\n\n        //save order number in the node\n        for (var i = 0; i < l; ++i) {\n            L[i].order = i;\n        }\n\n        //sort now by priority\n        L = L.sort(function(A, B) {\n            var Ap = A.constructor.priority || A.priority || 0;\n            var Bp = B.constructor.priority || B.priority || 0;\n            if (Ap == Bp) {\n                //if same priority, sort by order\n                return A.order - B.order;\n            }\n            return Ap - Bp; //sort by priority\n        });\n\n        //save order number in the node, again...\n        for (var i = 0; i < l; ++i) {\n            L[i].order = i;\n        }\n\n        return L;\n    };\n\n    /**\n     * Returns all the nodes that could affect this one (ancestors) by crawling all the inputs recursively.\n     * It doesn\'t include the node itself\n     * @method getAncestors\n     * @return {Array} an array with all the LGraphNodes that affect this node, in order of execution\n     */\n    LGraph.prototype.getAncestors = function(node) {\n        var ancestors = [];\n        var pending = [node];\n        var visited = {};\n\n        while (pending.length) {\n            var current = pending.shift();\n            if (!current.inputs) {\n                continue;\n            }\n            if (!visited[current.id] && current != node) {\n                visited[current.id] = true;\n                ancestors.push(current);\n            }\n\n            for (var i = 0; i < current.inputs.length; ++i) {\n                var input = current.getInputNode(i);\n                if (input && ancestors.indexOf(input) == -1) {\n                    pending.push(input);\n                }\n            }\n        }\n\n        ancestors.sort(function(a, b) {\n            return a.order - b.order;\n        });\n        return ancestors;\n    };\n\n    /**\n     * Positions every node in a more readable manner\n     * @method arrange\n     */\n    LGraph.prototype.arrange = function (margin, layout) {\n        margin = margin || 100;\n\n        const nodes = this.computeExecutionOrder(false, true);\n        const columns = [];\n        for (let i = 0; i < nodes.length; ++i) {\n            const node = nodes[i];\n            const col = node._level || 1;\n            if (!columns[col]) {\n                columns[col] = [];\n            }\n            columns[col].push(node);\n        }\n\n        let x = margin;\n\n        for (let i = 0; i < columns.length; ++i) {\n            const column = columns[i];\n            if (!column) {\n                continue;\n            }\n            let max_size = 100;\n            let y = margin + LiteGraph.NODE_TITLE_HEIGHT;\n            for (let j = 0; j < column.length; ++j) {\n                const node = column[j];\n                node.pos[0] = (layout == LiteGraph.VERTICAL_LAYOUT) ? y : x;\n                node.pos[1] = (layout == LiteGraph.VERTICAL_LAYOUT) ? x : y;\n                const max_size_index = (layout == LiteGraph.VERTICAL_LAYOUT) ? 1 : 0;\n                if (node.size[max_size_index] > max_size) {\n                    max_size = node.size[max_size_index];\n                }\n                const node_size_index = (layout == LiteGraph.VERTICAL_LAYOUT) ? 0 : 1;\n                y += node.size[node_size_index] + margin + LiteGraph.NODE_TITLE_HEIGHT;\n            }\n            x += max_size + margin;\n        }\n\n        this.setDirtyCanvas(true, true);\n    };\n\n    /**\n     * Returns the amount of time the graph has been running in milliseconds\n     * @method getTime\n     * @return {number} number of milliseconds the graph has been running\n     */\n    LGraph.prototype.getTime = function() {\n        return this.globaltime;\n    };\n\n    /**\n     * Returns the amount of time accumulated using the fixedtime_lapse var. This is used in context where the time increments should be constant\n     * @method getFixedTime\n     * @return {number} number of milliseconds the graph has been running\n     */\n\n    LGraph.prototype.getFixedTime = function() {\n        return this.fixedtime;\n    };\n\n    /**\n     * Returns the amount of time it took to compute the latest iteration. Take into account that this number could be not correct\n     * if the nodes are using graphical actions\n     * @method getElapsedTime\n     * @return {number} number of milliseconds it took the last cycle\n     */\n\n    LGraph.prototype.getElapsedTime = function() {\n        return this.elapsed_time;\n    };\n\n    /**\n     * Sends an event to all the nodes, useful to trigger stuff\n     * @method sendEventToAllNodes\n     * @param {String} eventname the name of the event (function to be called)\n     * @param {Array} params parameters in array format\n     */\n    LGraph.prototype.sendEventToAllNodes = function(eventname, params, mode) {\n        mode = mode || LiteGraph.ALWAYS;\n\n        var nodes = this._nodes_in_order ? this._nodes_in_order : this._nodes;\n        if (!nodes) {\n            return;\n        }\n\n        for (var j = 0, l = nodes.length; j < l; ++j) {\n            var node = nodes[j];\n\n            if (\n                node.constructor === LiteGraph.Subgraph &&\n                eventname != "onExecute"\n            ) {\n                if (node.mode == mode) {\n                    node.sendEventToAllNodes(eventname, params, mode);\n                }\n                continue;\n            }\n\n            if (!node[eventname] || node.mode != mode) {\n                continue;\n            }\n            if (params === undefined) {\n                node[eventname]();\n            } else if (params && params.constructor === Array) {\n                node[eventname].apply(node, params);\n            } else {\n                node[eventname](params);\n            }\n        }\n    };\n\n    LGraph.prototype.sendActionToCanvas = function(action, params) {\n        if (!this.list_of_graphcanvas) {\n            return;\n        }\n\n        for (var i = 0; i < this.list_of_graphcanvas.length; ++i) {\n            var c = this.list_of_graphcanvas[i];\n            if (c[action]) {\n                c[action].apply(c, params);\n            }\n        }\n    };\n\n    /**\n     * Adds a new node instance to this graph\n     * @method add\n     * @param {LGraphNode} node the instance of the node\n     */\n\n    LGraph.prototype.add = function(node, skip_compute_order) {\n        if (!node) {\n            return;\n        }\n\n        //groups\n        if (node.constructor === LGraphGroup) {\n            this._groups.push(node);\n            this.setDirtyCanvas(true);\n            this.change();\n            node.graph = this;\n            this._version++;\n            return;\n        }\n\n        //nodes\n        if (node.id != -1 && this._nodes_by_id[node.id] != null) {\n            console.warn(\n                "LiteGraph: there is already a node with this ID, changing it"\n            );\n            if (LiteGraph.use_uuids) {\n                node.id = LiteGraph.uuidv4();\n            }\n            else {\n                node.id = ++this.last_node_id;\n            }\n        }\n\n        if (this._nodes.length >= LiteGraph.MAX_NUMBER_OF_NODES) {\n            throw "LiteGraph: max number of nodes in a graph reached";\n        }\n\n        //give him an id\n        if (LiteGraph.use_uuids) {\n            if (node.id == null || node.id == -1)\n                node.id = LiteGraph.uuidv4();\n        }\n        else {\n            if (node.id == null || node.id == -1) {\n                node.id = ++this.last_node_id;\n            } else if (this.last_node_id < node.id) {\n                this.last_node_id = node.id;\n            }\n        }\n\n        node.graph = this;\n        this._version++;\n\n        this._nodes.push(node);\n        this._nodes_by_id[node.id] = node;\n\n        if (node.onAdded) {\n            node.onAdded(this);\n        }\n\n        if (this.config.align_to_grid) {\n            node.alignToGrid();\n        }\n\n        if (!skip_compute_order) {\n            this.updateExecutionOrder();\n        }\n\n        if (this.onNodeAdded) {\n            this.onNodeAdded(node);\n        }\n\n        this.setDirtyCanvas(true);\n        this.change();\n\n        return node; //to chain actions\n    };\n\n    /**\n     * Removes a node from the graph\n     * @method remove\n     * @param {LGraphNode} node the instance of the node\n     */\n\n    LGraph.prototype.remove = function(node) {\n        if (node.constructor === LiteGraph.LGraphGroup) {\n            var index = this._groups.indexOf(node);\n            if (index != -1) {\n                this._groups.splice(index, 1);\n            }\n            node.graph = null;\n            this._version++;\n            this.setDirtyCanvas(true, true);\n            this.change();\n            return;\n        }\n\n        if (this._nodes_by_id[node.id] == null) {\n            return;\n        } //not found\n\n        if (node.ignore_remove) {\n            return;\n        } //cannot be removed\n\n\t\tthis.beforeChange(); //sure? - almost sure is wrong\n\n        //disconnect inputs\n        if (node.inputs) {\n            for (var i = 0; i < node.inputs.length; i++) {\n                var slot = node.inputs[i];\n                if (slot.link != null) {\n                    node.disconnectInput(i);\n                }\n            }\n        }\n\n        //disconnect outputs\n        if (node.outputs) {\n            for (var i = 0; i < node.outputs.length; i++) {\n                var slot = node.outputs[i];\n                if (slot.links != null && slot.links.length) {\n                    node.disconnectOutput(i);\n                }\n            }\n        }\n\n        //node.id = -1; //why?\n\n        //callback\n        if (node.onRemoved) {\n            node.onRemoved();\n        }\n\n        node.graph = null;\n        this._version++;\n\n        //remove from canvas render\n        if (this.list_of_graphcanvas) {\n            for (var i = 0; i < this.list_of_graphcanvas.length; ++i) {\n                var canvas = this.list_of_graphcanvas[i];\n                if (canvas.selected_nodes[node.id]) {\n                    delete canvas.selected_nodes[node.id];\n                }\n                if (canvas.node_dragged == node) {\n                    canvas.node_dragged = null;\n                }\n            }\n        }\n\n        //remove from containers\n        var pos = this._nodes.indexOf(node);\n        if (pos != -1) {\n            this._nodes.splice(pos, 1);\n        }\n        delete this._nodes_by_id[node.id];\n\n        if (this.onNodeRemoved) {\n            this.onNodeRemoved(node);\n        }\n\n\t\t//close panels\n\t\tthis.sendActionToCanvas("checkPanels");\n\n        this.setDirtyCanvas(true, true);\n\t\tthis.afterChange(); //sure? - almost sure is wrong\n        this.change();\n\n        this.updateExecutionOrder();\n    };\n\n    /**\n     * Returns a node by its id.\n     * @method getNodeById\n     * @param {Number} id\n     */\n\n    LGraph.prototype.getNodeById = function(id) {\n        if (id == null) {\n            return null;\n        }\n        return this._nodes_by_id[id];\n    };\n\n    /**\n     * Returns a list of nodes that matches a class\n     * @method findNodesByClass\n     * @param {Class} classObject the class itself (not an string)\n     * @return {Array} a list with all the nodes of this type\n     */\n    LGraph.prototype.findNodesByClass = function(classObject, result) {\n        result = result || [];\n        result.length = 0;\n        for (var i = 0, l = this._nodes.length; i < l; ++i) {\n            if (this._nodes[i].constructor === classObject) {\n                result.push(this._nodes[i]);\n            }\n        }\n        return result;\n    };\n\n    /**\n     * Returns a list of nodes that matches a type\n     * @method findNodesByType\n     * @param {String} type the name of the node type\n     * @return {Array} a list with all the nodes of this type\n     */\n    LGraph.prototype.findNodesByType = function(type, result) {\n        var type = type.toLowerCase();\n        result = result || [];\n        result.length = 0;\n        for (var i = 0, l = this._nodes.length; i < l; ++i) {\n            if (this._nodes[i].type.toLowerCase() == type) {\n                result.push(this._nodes[i]);\n            }\n        }\n        return result;\n    };\n\n    /**\n     * Returns the first node that matches a name in its title\n     * @method findNodeByTitle\n     * @param {String} name the name of the node to search\n     * @return {Node} the node or null\n     */\n    LGraph.prototype.findNodeByTitle = function(title) {\n        for (var i = 0, l = this._nodes.length; i < l; ++i) {\n            if (this._nodes[i].title == title) {\n                return this._nodes[i];\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Returns a list of nodes that matches a name\n     * @method findNodesByTitle\n     * @param {String} name the name of the node to search\n     * @return {Array} a list with all the nodes with this name\n     */\n    LGraph.prototype.findNodesByTitle = function(title) {\n        var result = [];\n        for (var i = 0, l = this._nodes.length; i < l; ++i) {\n            if (this._nodes[i].title == title) {\n                result.push(this._nodes[i]);\n            }\n        }\n        return result;\n    };\n\n    /**\n     * Returns the top-most node in this position of the canvas\n     * @method getNodeOnPos\n     * @param {number} x the x coordinate in canvas space\n     * @param {number} y the y coordinate in canvas space\n     * @param {Array} nodes_list a list with all the nodes to search from, by default is all the nodes in the graph\n     * @return {LGraphNode} the node at this position or null\n     */\n    LGraph.prototype.getNodeOnPos = function(x, y, nodes_list, margin) {\n        nodes_list = nodes_list || this._nodes;\n\t\tvar nRet = null;\n        for (var i = nodes_list.length - 1; i >= 0; i--) {\n            var n = nodes_list[i];\n            if (n.isPointInside(x, y, margin)) {\n                // check for lesser interest nodes (TODO check for overlapping, use the top)\n\t\t\t\t/*if (typeof n == "LGraphGroup"){\n\t\t\t\t\tnRet = n;\n\t\t\t\t}else{*/\n\t\t\t\t\treturn n;\n\t\t\t\t/*}*/\n            }\n        }\n        return nRet;\n    };\n\n    /**\n     * Returns the top-most group in that position\n     * @method getGroupOnPos\n     * @param {number} x the x coordinate in canvas space\n     * @param {number} y the y coordinate in canvas space\n     * @return {LGraphGroup} the group or null\n     */\n    LGraph.prototype.getGroupOnPos = function(x, y) {\n        for (var i = this._groups.length - 1; i >= 0; i--) {\n            var g = this._groups[i];\n            if (g.isPointInside(x, y, 2, true)) {\n                return g;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Checks that the node type matches the node type registered, used when replacing a nodetype by a newer version during execution\n     * this replaces the ones using the old version with the new version\n     * @method checkNodeTypes\n     */\n    LGraph.prototype.checkNodeTypes = function() {\n        var changes = false;\n        for (var i = 0; i < this._nodes.length; i++) {\n            var node = this._nodes[i];\n            var ctor = LiteGraph.registered_node_types[node.type];\n            if (node.constructor == ctor) {\n                continue;\n            }\n            console.log("node being replaced by newer version: " + node.type);\n            var newnode = LiteGraph.createNode(node.type);\n            changes = true;\n            this._nodes[i] = newnode;\n            newnode.configure(node.serialize());\n            newnode.graph = this;\n            this._nodes_by_id[newnode.id] = newnode;\n            if (node.inputs) {\n                newnode.inputs = node.inputs.concat();\n            }\n            if (node.outputs) {\n                newnode.outputs = node.outputs.concat();\n            }\n        }\n        this.updateExecutionOrder();\n    };\n\n    // ********** GLOBALS *****************\n\n    LGraph.prototype.onAction = function(action, param, options) {\n        this._input_nodes = this.findNodesByClass(\n            LiteGraph.GraphInput,\n            this._input_nodes\n        );\n        for (var i = 0; i < this._input_nodes.length; ++i) {\n            var node = this._input_nodes[i];\n            if (node.properties.name != action) {\n                continue;\n            }\n            //wrap node.onAction(action, param);\n            node.actionDo(action, param, options);\n            break;\n        }\n    };\n\n    LGraph.prototype.trigger = function(action, param) {\n        if (this.onTrigger) {\n            this.onTrigger(action, param);\n        }\n    };\n\n    /**\n     * Tell this graph it has a global graph input of this type\n     * @method addGlobalInput\n     * @param {String} name\n     * @param {String} type\n     * @param {*} value [optional]\n     */\n    LGraph.prototype.addInput = function(name, type, value) {\n        var input = this.inputs[name];\n        if (input) {\n            //already exist\n            return;\n        }\n\n\t\tthis.beforeChange();\n        this.inputs[name] = { name: name, type: type, value: value };\n        this._version++;\n\t\tthis.afterChange();\n\n        if (this.onInputAdded) {\n            this.onInputAdded(name, type);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    };\n\n    /**\n     * Assign a data to the global graph input\n     * @method setGlobalInputData\n     * @param {String} name\n     * @param {*} data\n     */\n    LGraph.prototype.setInputData = function(name, data) {\n        var input = this.inputs[name];\n        if (!input) {\n            return;\n        }\n        input.value = data;\n    };\n\n    /**\n     * Returns the current value of a global graph input\n     * @method getInputData\n     * @param {String} name\n     * @return {*} the data\n     */\n    LGraph.prototype.getInputData = function(name) {\n        var input = this.inputs[name];\n        if (!input) {\n            return null;\n        }\n        return input.value;\n    };\n\n    /**\n     * Changes the name of a global graph input\n     * @method renameInput\n     * @param {String} old_name\n     * @param {String} new_name\n     */\n    LGraph.prototype.renameInput = function(old_name, name) {\n        if (name == old_name) {\n            return;\n        }\n\n        if (!this.inputs[old_name]) {\n            return false;\n        }\n\n        if (this.inputs[name]) {\n            console.error("there is already one input with that name");\n            return false;\n        }\n\n        this.inputs[name] = this.inputs[old_name];\n        delete this.inputs[old_name];\n        this._version++;\n\n        if (this.onInputRenamed) {\n            this.onInputRenamed(old_name, name);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    };\n\n    /**\n     * Changes the type of a global graph input\n     * @method changeInputType\n     * @param {String} name\n     * @param {String} type\n     */\n    LGraph.prototype.changeInputType = function(name, type) {\n        if (!this.inputs[name]) {\n            return false;\n        }\n\n        if (\n            this.inputs[name].type &&\n            String(this.inputs[name].type).toLowerCase() ==\n                String(type).toLowerCase()\n        ) {\n            return;\n        }\n\n        this.inputs[name].type = type;\n        this._version++;\n        if (this.onInputTypeChanged) {\n            this.onInputTypeChanged(name, type);\n        }\n    };\n\n    /**\n     * Removes a global graph input\n     * @method removeInput\n     * @param {String} name\n     * @param {String} type\n     */\n    LGraph.prototype.removeInput = function(name) {\n        if (!this.inputs[name]) {\n            return false;\n        }\n\n        delete this.inputs[name];\n        this._version++;\n\n        if (this.onInputRemoved) {\n            this.onInputRemoved(name);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n        return true;\n    };\n\n    /**\n     * Creates a global graph output\n     * @method addOutput\n     * @param {String} name\n     * @param {String} type\n     * @param {*} value\n     */\n    LGraph.prototype.addOutput = function(name, type, value) {\n        this.outputs[name] = { name: name, type: type, value: value };\n        this._version++;\n\n        if (this.onOutputAdded) {\n            this.onOutputAdded(name, type);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    };\n\n    /**\n     * Assign a data to the global output\n     * @method setOutputData\n     * @param {String} name\n     * @param {String} value\n     */\n    LGraph.prototype.setOutputData = function(name, value) {\n        var output = this.outputs[name];\n        if (!output) {\n            return;\n        }\n        output.value = value;\n    };\n\n    /**\n     * Returns the current value of a global graph output\n     * @method getOutputData\n     * @param {String} name\n     * @return {*} the data\n     */\n    LGraph.prototype.getOutputData = function(name) {\n        var output = this.outputs[name];\n        if (!output) {\n            return null;\n        }\n        return output.value;\n    };\n\n    /**\n     * Renames a global graph output\n     * @method renameOutput\n     * @param {String} old_name\n     * @param {String} new_name\n     */\n    LGraph.prototype.renameOutput = function(old_name, name) {\n        if (!this.outputs[old_name]) {\n            return false;\n        }\n\n        if (this.outputs[name]) {\n            console.error("there is already one output with that name");\n            return false;\n        }\n\n        this.outputs[name] = this.outputs[old_name];\n        delete this.outputs[old_name];\n        this._version++;\n\n        if (this.onOutputRenamed) {\n            this.onOutputRenamed(old_name, name);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    };\n\n    /**\n     * Changes the type of a global graph output\n     * @method changeOutputType\n     * @param {String} name\n     * @param {String} type\n     */\n    LGraph.prototype.changeOutputType = function(name, type) {\n        if (!this.outputs[name]) {\n            return false;\n        }\n\n        if (\n            this.outputs[name].type &&\n            String(this.outputs[name].type).toLowerCase() ==\n                String(type).toLowerCase()\n        ) {\n            return;\n        }\n\n        this.outputs[name].type = type;\n        this._version++;\n        if (this.onOutputTypeChanged) {\n            this.onOutputTypeChanged(name, type);\n        }\n    };\n\n    /**\n     * Removes a global graph output\n     * @method removeOutput\n     * @param {String} name\n     */\n    LGraph.prototype.removeOutput = function(name) {\n        if (!this.outputs[name]) {\n            return false;\n        }\n        delete this.outputs[name];\n        this._version++;\n\n        if (this.onOutputRemoved) {\n            this.onOutputRemoved(name);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n        return true;\n    };\n\n    LGraph.prototype.triggerInput = function(name, value) {\n        var nodes = this.findNodesByTitle(name);\n        for (var i = 0; i < nodes.length; ++i) {\n            nodes[i].onTrigger(value);\n        }\n    };\n\n    LGraph.prototype.setCallback = function(name, func) {\n        var nodes = this.findNodesByTitle(name);\n        for (var i = 0; i < nodes.length; ++i) {\n            nodes[i].setTrigger(func);\n        }\n    };\n\n\t//used for undo, called before any change is made to the graph\n    LGraph.prototype.beforeChange = function(info) {\n        if (this.onBeforeChange) {\n            this.onBeforeChange(this,info);\n        }\n        this.sendActionToCanvas("onBeforeChange", this);\n    };\n\n\t//used to resend actions, called after any change is made to the graph\n    LGraph.prototype.afterChange = function(info) {\n        if (this.onAfterChange) {\n            this.onAfterChange(this,info);\n        }\n        this.sendActionToCanvas("onAfterChange", this);\n    };\n\n    LGraph.prototype.connectionChange = function(node, link_info) {\n        this.updateExecutionOrder();\n        if (this.onConnectionChange) {\n            this.onConnectionChange(node);\n        }\n        this._version++;\n        this.sendActionToCanvas("onConnectionChange");\n    };\n\n    /**\n     * returns if the graph is in live mode\n     * @method isLive\n     */\n\n    LGraph.prototype.isLive = function() {\n        if (!this.list_of_graphcanvas) {\n            return false;\n        }\n\n        for (var i = 0; i < this.list_of_graphcanvas.length; ++i) {\n            var c = this.list_of_graphcanvas[i];\n            if (c.live_mode) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    /**\n     * clears the triggered slot animation in all links (stop visual animation)\n     * @method clearTriggeredSlots\n     */\n    LGraph.prototype.clearTriggeredSlots = function() {\n        for (var i in this.links) {\n            var link_info = this.links[i];\n            if (!link_info) {\n                continue;\n            }\n            if (link_info._last_time) {\n                link_info._last_time = 0;\n            }\n        }\n    };\n\n    /* Called when something visually changed (not the graph!) */\n    LGraph.prototype.change = function() {\n        if (LiteGraph.debug) {\n            console.log("Graph changed");\n        }\n        this.sendActionToCanvas("setDirty", [true, true]);\n        if (this.on_change) {\n            this.on_change(this);\n        }\n    };\n\n    LGraph.prototype.setDirtyCanvas = function(fg, bg) {\n        this.sendActionToCanvas("setDirty", [fg, bg]);\n    };\n\n    /**\n     * Destroys a link\n     * @method removeLink\n     * @param {Number} link_id\n     */\n    LGraph.prototype.removeLink = function(link_id) {\n        var link = this.links[link_id];\n        if (!link) {\n            return;\n        }\n        var node = this.getNodeById(link.target_id);\n        if (node) {\n            node.disconnectInput(link.target_slot);\n        }\n    };\n\n    //save and recover app state ***************************************\n    /**\n     * Creates a Object containing all the info about this graph, it can be serialized\n     * @method serialize\n     * @return {Object} value of the node\n     */\n    LGraph.prototype.serialize = function() {\n        var nodes_info = [];\n        for (var i = 0, l = this._nodes.length; i < l; ++i) {\n            nodes_info.push(this._nodes[i].serialize());\n        }\n\n        //pack link info into a non-verbose format\n        var links = [];\n        for (var i in this.links) {\n            //links is an OBJECT\n            var link = this.links[i];\n            if (!link.serialize) {\n                //weird bug I havent solved yet\n                console.warn(\n                    "weird LLink bug, link info is not a LLink but a regular object"\n                );\n                var link2 = new LLink();\n                for (var j in link) { \n                    link2[j] = link[j];\n                }\n                this.links[i] = link2;\n                link = link2;\n            }\n\n            links.push(link.serialize());\n        }\n\n        var groups_info = [];\n        for (var i = 0; i < this._groups.length; ++i) {\n            groups_info.push(this._groups[i].serialize());\n        }\n\n        var data = {\n            last_node_id: this.last_node_id,\n            last_link_id: this.last_link_id,\n            nodes: nodes_info,\n            links: links,\n            groups: groups_info,\n            config: this.config,\n\t\t\textra: this.extra,\n            version: LiteGraph.VERSION\n        };\n\n\t\tif(this.onSerialize)\n\t\t\tthis.onSerialize(data);\n\n        return data;\n    };\n\n    /**\n     * Configure a graph from a JSON string\n     * @method configure\n     * @param {String} str configure a graph from a JSON string\n     * @param {Boolean} returns if there was any error parsing\n     */\n    LGraph.prototype.configure = function(data, keep_old) {\n        if (!data) {\n            return;\n        }\n\n        if (!keep_old) {\n            this.clear();\n        }\n\n        var nodes = data.nodes;\n\n        //decode links info (they are very verbose)\n        if (data.links && data.links.constructor === Array) {\n            var links = [];\n            for (var i = 0; i < data.links.length; ++i) {\n                var link_data = data.links[i];\n\t\t\t\tif(!link_data) //weird bug\n\t\t\t\t{\n\t\t\t\t\tconsole.warn("serialized graph link data contains errors, skipping.");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n                var link = new LLink();\n                link.configure(link_data);\n                links[link.id] = link;\n            }\n            data.links = links;\n        }\n\n        //copy all stored fields\n        for (var i in data) {\n\t\t\tif(i == "nodes" || i == "groups" ) //links must be accepted\n\t\t\t\tcontinue;\n            this[i] = data[i];\n        }\n\n        var error = false;\n\n        //create nodes\n        this._nodes = [];\n        if (nodes) {\n            for (var i = 0, l = nodes.length; i < l; ++i) {\n                var n_info = nodes[i]; //stored info\n                var node = LiteGraph.createNode(n_info.type, n_info.title);\n                if (!node) {\n                    if (LiteGraph.debug) {\n                        console.log(\n                            "Node not found or has errors: " + n_info.type\n                        );\n                    }\n\n                    //in case of error we create a replacement node to avoid losing info\n                    node = new LGraphNode();\n                    node.last_serialization = n_info;\n                    node.has_errors = true;\n                    error = true;\n                    //continue;\n                }\n\n                node.id = n_info.id; //id it or it will create a new id\n                this.add(node, true); //add before configure, otherwise configure cannot create links\n            }\n\n            //configure nodes afterwards so they can reach each other\n            for (var i = 0, l = nodes.length; i < l; ++i) {\n                var n_info = nodes[i];\n                var node = this.getNodeById(n_info.id);\n                if (node) {\n                    node.configure(n_info);\n                }\n            }\n        }\n\n        //groups\n        this._groups.length = 0;\n        if (data.groups) {\n            for (var i = 0; i < data.groups.length; ++i) {\n                var group = new LiteGraph.LGraphGroup();\n                group.configure(data.groups[i]);\n                this.add(group);\n            }\n        }\n\n        this.updateExecutionOrder();\n\n\t\tthis.extra = data.extra || {};\n\n\t\tif(this.onConfigure)\n\t\t\tthis.onConfigure(data);\n\n        this._version++;\n        this.setDirtyCanvas(true, true);\n        return error;\n    };\n\n    LGraph.prototype.load = function(url, callback) {\n        var that = this;\n\n\t\t//from file\n\t\tif(url.constructor === File || url.constructor === Blob)\n\t\t{\n\t\t\tvar reader = new FileReader();\n\t\t\treader.addEventListener(\'load\', function(event) {\n\t\t\t\tvar data = JSON.parse(event.target.result);\n\t\t\t\tthat.configure(data);\n\t\t\t\tif(callback)\n\t\t\t\t\tcallback();\n\t\t\t});\n\t\t\t\n\t\t\treader.readAsText(url);\n\t\t\treturn;\n\t\t}\n\n\t\t//is a string, then an URL\n        var req = new XMLHttpRequest();\n        req.open("GET", url, true);\n        req.send(null);\n        req.onload = function(oEvent) {\n            if (req.status !== 200) {\n                console.error("Error loading graph:", req.status, req.response);\n                return;\n            }\n            var data = JSON.parse( req.response );\n            that.configure(data);\n\t\t\tif(callback)\n\t\t\t\tcallback();\n        };\n        req.onerror = function(err) {\n            console.error("Error loading graph:", err);\n        };\n    };\n\n    LGraph.prototype.onNodeTrace = function(node, msg, color) {\n        //TODO\n    };\n\n    //this is the class in charge of storing link information\n    function LLink(id, type, origin_id, origin_slot, target_id, target_slot) {\n        this.id = id;\n        this.type = type;\n        this.origin_id = origin_id;\n        this.origin_slot = origin_slot;\n        this.target_id = target_id;\n        this.target_slot = target_slot;\n\n        this._data = null;\n        this._pos = new Float32Array(2); //center\n    }\n\n    LLink.prototype.configure = function(o) {\n        if (o.constructor === Array) {\n            this.id = o[0];\n            this.origin_id = o[1];\n            this.origin_slot = o[2];\n            this.target_id = o[3];\n            this.target_slot = o[4];\n            this.type = o[5];\n        } else {\n            this.id = o.id;\n            this.type = o.type;\n            this.origin_id = o.origin_id;\n            this.origin_slot = o.origin_slot;\n            this.target_id = o.target_id;\n            this.target_slot = o.target_slot;\n        }\n    };\n\n    LLink.prototype.serialize = function() {\n        return [\n            this.id,\n            this.origin_id,\n            this.origin_slot,\n            this.target_id,\n            this.target_slot,\n            this.type\n        ];\n    };\n\n    LiteGraph.LLink = LLink;\n\n    // *************************************************************\n    //   Node CLASS                                          *******\n    // *************************************************************\n\n    /*\n\ttitle: string\n\tpos: [x,y]\n\tsize: [x,y]\n\n\tinput|output: every connection\n\t\t+  { name:string, type:string, pos: [x,y]=Optional, direction: "input"|"output", links: Array });\n\n\tgeneral properties:\n\t\t+ clip_area: if you render outside the node, it will be clipped\n\t\t+ unsafe_execution: not allowed for safe execution\n\t\t+ skip_repeated_outputs: when adding new outputs, it wont show if there is one already connected\n\t\t+ resizable: if set to false it wont be resizable with the mouse\n\t\t+ horizontal: slots are distributed horizontally\n\t\t+ widgets_start_y: widgets start at y distance from the top of the node\n\t\n\tflags object:\n\t\t+ collapsed: if it is collapsed\n\n\tsupported callbacks:\n\t\t+ onAdded: when added to graph (warning: this is called BEFORE the node is configured when loading)\n\t\t+ onRemoved: when removed from graph\n\t\t+ onStart:\twhen the graph starts playing\n\t\t+ onStop:\twhen the graph stops playing\n\t\t+ onDrawForeground: render the inside widgets inside the node\n\t\t+ onDrawBackground: render the background area inside the node (only in edit mode)\n\t\t+ onMouseDown\n\t\t+ onMouseMove\n\t\t+ onMouseUp\n\t\t+ onMouseEnter\n\t\t+ onMouseLeave\n\t\t+ onExecute: execute the node\n\t\t+ onPropertyChanged: when a property is changed in the panel (return true to skip default behaviour)\n\t\t+ onGetInputs: returns an array of possible inputs\n\t\t+ onGetOutputs: returns an array of possible outputs\n\t\t+ onBounding: in case this node has a bigger bounding than the node itself (the callback receives the bounding as [x,y,w,h])\n\t\t+ onDblClick: double clicked in the node\n\t\t+ onInputDblClick: input slot double clicked (can be used to automatically create a node connected)\n\t\t+ onOutputDblClick: output slot double clicked (can be used to automatically create a node connected)\n\t\t+ onConfigure: called after the node has been configured\n\t\t+ onSerialize: to add extra info when serializing (the callback receives the object that should be filled with the data)\n\t\t+ onSelected\n\t\t+ onDeselected\n\t\t+ onDropItem : DOM item dropped over the node\n\t\t+ onDropFile : file dropped over the node\n\t\t+ onConnectInput : if returns false the incoming connection will be canceled\n\t\t+ onConnectionsChange : a connection changed (new one or removed) (LiteGraph.INPUT or LiteGraph.OUTPUT, slot, true if connected, link_info, input_info )\n\t\t+ onAction: action slot triggered\n\t\t+ getExtraMenuOptions: to add option to context menu\n*/\n\n    /**\n     * Base Class for all the node type classes\n     * @class LGraphNode\n     * @param {String} name a name for the node\n     */\n\n    function LGraphNode(title) {\n        this._ctor(title);\n    }\n\n    global.LGraphNode = LiteGraph.LGraphNode = LGraphNode;\n\n    LGraphNode.prototype._ctor = function(title) {\n        this.title = title || "Unnamed";\n        this.size = [LiteGraph.NODE_WIDTH, 60];\n        this.graph = null;\n\n        this._pos = new Float32Array(10, 10);\n\n        Object.defineProperty(this, "pos", {\n            set: function(v) {\n                if (!v || v.length < 2) {\n                    return;\n                }\n                this._pos[0] = v[0];\n                this._pos[1] = v[1];\n            },\n            get: function() {\n                return this._pos;\n            },\n            enumerable: true\n        });\n\n        if (LiteGraph.use_uuids) {\n            this.id = LiteGraph.uuidv4();\n        }\n        else {\n            this.id = -1; //not know till not added\n        }\n        this.type = null;\n\n        //inputs available: array of inputs\n        this.inputs = [];\n        this.outputs = [];\n        this.connections = [];\n\n        //local data\n        this.properties = {}; //for the values\n        this.properties_info = []; //for the info\n\n        this.flags = {};\n    };\n\n    /**\n     * configure a node from an object containing the serialized info\n     * @method configure\n     */\n    LGraphNode.prototype.configure = function(info) {\n        if (this.graph) {\n            this.graph._version++;\n        }\n        for (var j in info) {\n            if (j == "properties") {\n                //i don\'t want to clone properties, I want to reuse the old container\n                for (var k in info.properties) {\n                    this.properties[k] = info.properties[k];\n                    if (this.onPropertyChanged) {\n                        this.onPropertyChanged( k, info.properties[k] );\n                    }\n                }\n                continue;\n            }\n\n            if (info[j] == null) {\n                continue;\n            } else if (typeof info[j] == "object") {\n                //object\n                if (this[j] && this[j].configure) {\n                    this[j].configure(info[j]);\n                } else {\n                    this[j] = LiteGraph.cloneObject(info[j], this[j]);\n                }\n            } //value\n            else {\n                this[j] = info[j];\n            }\n        }\n\n        if (!info.title) {\n            this.title = this.constructor.title;\n        }\n\n\t\tif (this.inputs) {\n\t\t\tfor (var i = 0; i < this.inputs.length; ++i) {\n\t\t\t\tvar input = this.inputs[i];\n\t\t\t\tvar link_info = this.graph ? this.graph.links[input.link] : null;\n\t\t\t\tif (this.onConnectionsChange)\n\t\t\t\t\tthis.onConnectionsChange( LiteGraph.INPUT, i, true, link_info, input ); //link_info has been created now, so its updated\n\n\t\t\t\tif( this.onInputAdded )\n\t\t\t\t\tthis.onInputAdded(input);\n\n\t\t\t}\n\t\t}\n\n\t\tif (this.outputs) {\n\t\t\tfor (var i = 0; i < this.outputs.length; ++i) {\n\t\t\t\tvar output = this.outputs[i];\n\t\t\t\tif (!output.links) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (var j = 0; j < output.links.length; ++j) {\n\t\t\t\t\tvar link_info = this.graph \t? this.graph.links[output.links[j]] : null;\n\t\t\t\t\tif (this.onConnectionsChange)\n\t\t\t\t\t\tthis.onConnectionsChange( LiteGraph.OUTPUT, i, true, link_info, output ); //link_info has been created now, so its updated\n\t\t\t\t}\n\n\t\t\t\tif( this.onOutputAdded )\n\t\t\t\t\tthis.onOutputAdded(output);\n\t\t\t}\n        }\n\n\t\tif( this.widgets )\n\t\t{\n\t\t\tfor (var i = 0; i < this.widgets.length; ++i)\n\t\t\t{\n\t\t\t\tvar w = this.widgets[i];\n\t\t\t\tif(!w)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(w.options && w.options.property && (this.properties[ w.options.property ] != undefined))\n\t\t\t\t\tw.value = JSON.parse( JSON.stringify( this.properties[ w.options.property ] ) );\n\t\t\t}\n\t\t\tif (info.widgets_values) {\n\t\t\t\tfor (var i = 0; i < info.widgets_values.length; ++i) {\n\t\t\t\t\tif (this.widgets[i]) {\n\t\t\t\t\t\tthis.widgets[i].value = info.widgets_values[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        if (this.onConfigure) {\n            this.onConfigure(info);\n        }\n    };\n\n    /**\n     * serialize the content\n     * @method serialize\n     */\n\n    LGraphNode.prototype.serialize = function() {\n        //create serialization object\n        var o = {\n            id: this.id,\n            type: this.type,\n            pos: this.pos,\n            size: this.size,\n            flags: LiteGraph.cloneObject(this.flags),\n\t\t\torder: this.order,\n            mode: this.mode\n        };\n\n        //special case for when there were errors\n        if (this.constructor === LGraphNode && this.last_serialization) {\n            return this.last_serialization;\n        }\n\n        if (this.inputs) {\n            o.inputs = this.inputs;\n        }\n\n        if (this.outputs) {\n            //clear outputs last data (because data in connections is never serialized but stored inside the outputs info)\n            for (var i = 0; i < this.outputs.length; i++) {\n                delete this.outputs[i]._data;\n            }\n            o.outputs = this.outputs;\n        }\n\n        if (this.title && this.title != this.constructor.title) {\n            o.title = this.title;\n        }\n\n        if (this.properties) {\n            o.properties = LiteGraph.cloneObject(this.properties);\n        }\n\n        if (this.widgets && this.serialize_widgets) {\n            o.widgets_values = [];\n            for (var i = 0; i < this.widgets.length; ++i) {\n\t\t\t\tif(this.widgets[i])\n\t                o.widgets_values[i] = this.widgets[i].value;\n\t\t\t\telse\n\t\t\t\t\to.widgets_values[i] = null;\n            }\n        }\n\n        if (!o.type) {\n            o.type = this.constructor.type;\n        }\n\n        if (this.color) {\n            o.color = this.color;\n        }\n        if (this.bgcolor) {\n            o.bgcolor = this.bgcolor;\n        }\n        if (this.boxcolor) {\n            o.boxcolor = this.boxcolor;\n        }\n        if (this.shape) {\n            o.shape = this.shape;\n        }\n\n        if (this.onSerialize) {\n            if (this.onSerialize(o)) {\n                console.warn(\n                    "node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter"\n                );\n            }\n        }\n\n        return o;\n    };\n\n    /* Creates a clone of this node */\n    LGraphNode.prototype.clone = function() {\n        var node = LiteGraph.createNode(this.type);\n        if (!node) {\n            return null;\n        }\n\n        //we clone it because serialize returns shared containers\n        var data = LiteGraph.cloneObject(this.serialize());\n\n        //remove links\n        if (data.inputs) {\n            for (var i = 0; i < data.inputs.length; ++i) {\n                data.inputs[i].link = null;\n            }\n        }\n\n        if (data.outputs) {\n            for (var i = 0; i < data.outputs.length; ++i) {\n                if (data.outputs[i].links) {\n                    data.outputs[i].links.length = 0;\n                }\n            }\n        }\n\n        delete data["id"];\n\n        if (LiteGraph.use_uuids) {\n            data["id"] = LiteGraph.uuidv4()\n        }\n\n        //remove links\n        node.configure(data);\n\n        return node;\n    };\n\n    /**\n     * serialize and stringify\n     * @method toString\n     */\n\n    LGraphNode.prototype.toString = function() {\n        return JSON.stringify(this.serialize());\n    };\n    //LGraphNode.prototype.deserialize = function(info) {} //this cannot be done from within, must be done in LiteGraph\n\n    /**\n     * get the title string\n     * @method getTitle\n     */\n\n    LGraphNode.prototype.getTitle = function() {\n        return this.title || this.constructor.title;\n    };\n\n    /**\n     * sets the value of a property\n     * @method setProperty\n     * @param {String} name\n     * @param {*} value\n     */\n    LGraphNode.prototype.setProperty = function(name, value) {\n        if (!this.properties) {\n            this.properties = {};\n        }\n\t\tif( value === this.properties[name] )\n\t\t\treturn;\n\t\tvar prev_value = this.properties[name];\n        this.properties[name] = value;\n        if (this.onPropertyChanged) {\n            if( this.onPropertyChanged(name, value, prev_value) === false ) //abort change\n\t\t\t\tthis.properties[name] = prev_value;\n        }\n\t\tif(this.widgets) //widgets could be linked to properties\n\t\t\tfor(var i = 0; i < this.widgets.length; ++i)\n\t\t\t{\n\t\t\t\tvar w = this.widgets[i];\n\t\t\t\tif(!w)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(w.options.property == name)\n\t\t\t\t{\n\t\t\t\t\tw.value = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n    };\n\n    // Execution *************************\n    /**\n     * sets the output data\n     * @method setOutputData\n     * @param {number} slot\n     * @param {*} data\n     */\n    LGraphNode.prototype.setOutputData = function(slot, data) {\n        if (!this.outputs) {\n            return;\n        }\n\n        //this maybe slow and a niche case\n        //if(slot && slot.constructor === String)\n        //\tslot = this.findOutputSlot(slot);\n\n        if (slot == -1 || slot >= this.outputs.length) {\n            return;\n        }\n\n        var output_info = this.outputs[slot];\n        if (!output_info) {\n            return;\n        }\n\n        //store data in the output itself in case we want to debug\n        output_info._data = data;\n\n        //if there are connections, pass the data to the connections\n        if (this.outputs[slot].links) {\n            for (var i = 0; i < this.outputs[slot].links.length; i++) {\n                var link_id = this.outputs[slot].links[i];\n\t\t\t\tvar link = this.graph.links[link_id];\n\t\t\t\tif(link)\n\t\t\t\t\tlink.data = data;\n            }\n        }\n    };\n\n    /**\n     * sets the output data type, useful when you want to be able to overwrite the data type\n     * @method setOutputDataType\n     * @param {number} slot\n     * @param {String} datatype\n     */\n    LGraphNode.prototype.setOutputDataType = function(slot, type) {\n        if (!this.outputs) {\n            return;\n        }\n        if (slot == -1 || slot >= this.outputs.length) {\n            return;\n        }\n        var output_info = this.outputs[slot];\n        if (!output_info) {\n            return;\n        }\n        //store data in the output itself in case we want to debug\n        output_info.type = type;\n\n        //if there are connections, pass the data to the connections\n        if (this.outputs[slot].links) {\n            for (var i = 0; i < this.outputs[slot].links.length; i++) {\n                var link_id = this.outputs[slot].links[i];\n                this.graph.links[link_id].type = type;\n            }\n        }\n    };\n\n    /**\n     * Retrieves the input data (data traveling through the connection) from one slot\n     * @method getInputData\n     * @param {number} slot\n     * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link\n     * @return {*} data or if it is not connected returns undefined\n     */\n    LGraphNode.prototype.getInputData = function(slot, force_update) {\n        if (!this.inputs) {\n            return;\n        } //undefined;\n\n        if (slot >= this.inputs.length || this.inputs[slot].link == null) {\n            return;\n        }\n\n        var link_id = this.inputs[slot].link;\n        var link = this.graph.links[link_id];\n        if (!link) {\n            //bug: weird case but it happens sometimes\n            return null;\n        }\n\n        if (!force_update) {\n            return link.data;\n        }\n\n        //special case: used to extract data from the incoming connection before the graph has been executed\n        var node = this.graph.getNodeById(link.origin_id);\n        if (!node) {\n            return link.data;\n        }\n\n        if (node.updateOutputData) {\n            node.updateOutputData(link.origin_slot);\n        } else if (node.onExecute) {\n            node.onExecute();\n        }\n\n        return link.data;\n    };\n\n    /**\n     * Retrieves the input data type (in case this supports multiple input types)\n     * @method getInputDataType\n     * @param {number} slot\n     * @return {String} datatype in string format\n     */\n    LGraphNode.prototype.getInputDataType = function(slot) {\n        if (!this.inputs) {\n            return null;\n        } //undefined;\n\n        if (slot >= this.inputs.length || this.inputs[slot].link == null) {\n            return null;\n        }\n        var link_id = this.inputs[slot].link;\n        var link = this.graph.links[link_id];\n        if (!link) {\n            //bug: weird case but it happens sometimes\n            return null;\n        }\n        var node = this.graph.getNodeById(link.origin_id);\n        if (!node) {\n            return link.type;\n        }\n        var output_info = node.outputs[link.origin_slot];\n        if (output_info) {\n            return output_info.type;\n        }\n        return null;\n    };\n\n    /**\n     * Retrieves the input data from one slot using its name instead of slot number\n     * @method getInputDataByName\n     * @param {String} slot_name\n     * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link\n     * @return {*} data or if it is not connected returns null\n     */\n    LGraphNode.prototype.getInputDataByName = function(\n        slot_name,\n        force_update\n    ) {\n        var slot = this.findInputSlot(slot_name);\n        if (slot == -1) {\n            return null;\n        }\n        return this.getInputData(slot, force_update);\n    };\n\n    /**\n     * tells you if there is a connection in one input slot\n     * @method isInputConnected\n     * @param {number} slot\n     * @return {boolean}\n     */\n    LGraphNode.prototype.isInputConnected = function(slot) {\n        if (!this.inputs) {\n            return false;\n        }\n        return slot < this.inputs.length && this.inputs[slot].link != null;\n    };\n\n    /**\n     * tells you info about an input connection (which node, type, etc)\n     * @method getInputInfo\n     * @param {number} slot\n     * @return {Object} object or null { link: id, name: string, type: string or 0 }\n     */\n    LGraphNode.prototype.getInputInfo = function(slot) {\n        if (!this.inputs) {\n            return null;\n        }\n        if (slot < this.inputs.length) {\n            return this.inputs[slot];\n        }\n        return null;\n    };\n\n    /**\n     * Returns the link info in the connection of an input slot\n     * @method getInputLink\n     * @param {number} slot\n     * @return {LLink} object or null\n     */\n    LGraphNode.prototype.getInputLink = function(slot) {\n        if (!this.inputs) {\n            return null;\n        }\n        if (slot < this.inputs.length) {\n            var slot_info = this.inputs[slot];\n\t\t\treturn this.graph.links[ slot_info.link ];\n        }\n        return null;\n    };\n\n    /**\n     * returns the node connected in the input slot\n     * @method getInputNode\n     * @param {number} slot\n     * @return {LGraphNode} node or null\n     */\n    LGraphNode.prototype.getInputNode = function(slot) {\n        if (!this.inputs) {\n            return null;\n        }\n        if (slot >= this.inputs.length) {\n            return null;\n        }\n        var input = this.inputs[slot];\n        if (!input || input.link === null) {\n            return null;\n        }\n        var link_info = this.graph.links[input.link];\n        if (!link_info) {\n            return null;\n        }\n        return this.graph.getNodeById(link_info.origin_id);\n    };\n\n    /**\n     * returns the value of an input with this name, otherwise checks if there is a property with that name\n     * @method getInputOrProperty\n     * @param {string} name\n     * @return {*} value\n     */\n    LGraphNode.prototype.getInputOrProperty = function(name) {\n        if (!this.inputs || !this.inputs.length) {\n            return this.properties ? this.properties[name] : null;\n        }\n\n        for (var i = 0, l = this.inputs.length; i < l; ++i) {\n            var input_info = this.inputs[i];\n            if (name == input_info.name && input_info.link != null) {\n                var link = this.graph.links[input_info.link];\n                if (link) {\n                    return link.data;\n                }\n            }\n        }\n        return this.properties[name];\n    };\n\n    /**\n     * tells you the last output data that went in that slot\n     * @method getOutputData\n     * @param {number} slot\n     * @return {Object}  object or null\n     */\n    LGraphNode.prototype.getOutputData = function(slot) {\n        if (!this.outputs) {\n            return null;\n        }\n        if (slot >= this.outputs.length) {\n            return null;\n        }\n\n        var info = this.outputs[slot];\n        return info._data;\n    };\n\n    /**\n     * tells you info about an output connection (which node, type, etc)\n     * @method getOutputInfo\n     * @param {number} slot\n     * @return {Object}  object or null { name: string, type: string, links: [ ids of links in number ] }\n     */\n    LGraphNode.prototype.getOutputInfo = function(slot) {\n        if (!this.outputs) {\n            return null;\n        }\n        if (slot < this.outputs.length) {\n            return this.outputs[slot];\n        }\n        return null;\n    };\n\n    /**\n     * tells you if there is a connection in one output slot\n     * @method isOutputConnected\n     * @param {number} slot\n     * @return {boolean}\n     */\n    LGraphNode.prototype.isOutputConnected = function(slot) {\n        if (!this.outputs) {\n            return false;\n        }\n        return (\n            slot < this.outputs.length &&\n            this.outputs[slot].links &&\n            this.outputs[slot].links.length\n        );\n    };\n\n    /**\n     * tells you if there is any connection in the output slots\n     * @method isAnyOutputConnected\n     * @return {boolean}\n     */\n    LGraphNode.prototype.isAnyOutputConnected = function() {\n        if (!this.outputs) {\n            return false;\n        }\n        for (var i = 0; i < this.outputs.length; ++i) {\n            if (this.outputs[i].links && this.outputs[i].links.length) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    /**\n     * retrieves all the nodes connected to this output slot\n     * @method getOutputNodes\n     * @param {number} slot\n     * @return {array}\n     */\n    LGraphNode.prototype.getOutputNodes = function(slot) {\n        if (!this.outputs || this.outputs.length == 0) {\n            return null;\n        }\n\n        if (slot >= this.outputs.length) {\n            return null;\n        }\n\n        var output = this.outputs[slot];\n        if (!output.links || output.links.length == 0) {\n            return null;\n        }\n\n        var r = [];\n        for (var i = 0; i < output.links.length; i++) {\n            var link_id = output.links[i];\n            var link = this.graph.links[link_id];\n            if (link) {\n                var target_node = this.graph.getNodeById(link.target_id);\n                if (target_node) {\n                    r.push(target_node);\n                }\n            }\n        }\n        return r;\n    };\n\n    LGraphNode.prototype.addOnTriggerInput = function(){\n        var trigS = this.findInputSlot("onTrigger");\n        if (trigS == -1){ //!trigS || \n            var input = this.addInput("onTrigger", LiteGraph.EVENT, {optional: true, nameLocked: true});\n            return this.findInputSlot("onTrigger");\n        }\n        return trigS;\n    }\n    \n    LGraphNode.prototype.addOnExecutedOutput = function(){\n        var trigS = this.findOutputSlot("onExecuted");\n        if (trigS == -1){ //!trigS || \n            var output = this.addOutput("onExecuted", LiteGraph.ACTION, {optional: true, nameLocked: true});\n            return this.findOutputSlot("onExecuted");\n        }\n        return trigS;\n    }\n    \n    LGraphNode.prototype.onAfterExecuteNode = function(param, options){\n        var trigS = this.findOutputSlot("onExecuted");\n        if (trigS != -1){\n            \n            //console.debug(this.id+":"+this.order+" triggering slot onAfterExecute");\n            //console.debug(param);\n            //console.debug(options);\n            this.triggerSlot(trigS, param, null, options);\n            \n        }\n    }    \n    \n    LGraphNode.prototype.changeMode = function(modeTo){\n        switch(modeTo){\n            case LiteGraph.ON_EVENT:\n                // this.addOnExecutedOutput();\n                break;\n                \n            case LiteGraph.ON_TRIGGER:\n                this.addOnTriggerInput();\n                this.addOnExecutedOutput();\n                break;\n                \n            case LiteGraph.NEVER:\n                break;\n                \n            case LiteGraph.ALWAYS:\n                break;\n                \n            case LiteGraph.ON_REQUEST:\n                break;\n            \n            default:\n                return false;\n                break;\n        }\n        this.mode = modeTo;\n        return true;\n    };\n\n    /**\n     * Triggers the execution of actions that were deferred when the action was triggered\n     * @method executePendingActions\n     */    \n    LGraphNode.prototype.executePendingActions = function() {\n        if(!this._waiting_actions || !this._waiting_actions.length)\n            return;\n        for(var i = 0; i < this._waiting_actions.length;++i)\n        {\n            var p = this._waiting_actions[i];\n            this.onAction(p[0],p[1],p[2],p[3],p[4]);\n        }        \n        this._waiting_actions.length = 0;\n    }\n\n    \n    /**\n     * Triggers the node code execution, place a boolean/counter to mark the node as being executed\n     * @method doExecute\n     * @param {*} param\n     * @param {*} options\n     */\n    LGraphNode.prototype.doExecute = function(param, options) {\n        options = options || {};\n        if (this.onExecute){\n            \n            // enable this to give the event an ID\n\t\t\tif (!options.action_call) options.action_call = this.id+"_exec_"+Math.floor(Math.random()*9999);\n            \n            this.graph.nodes_executing[this.id] = true; //.push(this.id);\n\n            this.onExecute(param, options);\n            \n            this.graph.nodes_executing[this.id] = false; //.pop();\n            \n            // save execution/action ref\n            this.exec_version = this.graph.iteration;\n            if(options && options.action_call){\n                this.action_call = options.action_call; // if (param)\n                this.graph.nodes_executedAction[this.id] = options.action_call;\n            }\n        }\n        else {\n        }\n        this.execute_triggered = 2; // the nFrames it will be used (-- each step), means "how old" is the event\n        if(this.onAfterExecuteNode) this.onAfterExecuteNode(param, options); // callback\n    };\n    \n    /**\n     * Triggers an action, wrapped by logics to control execution flow\n     * @method actionDo\n     * @param {String} action name\n     * @param {*} param\n     */\n    LGraphNode.prototype.actionDo = function(action, param, options, action_slot ) {\n        options = options || {};\n        if (this.onAction){\n            \n\t\t\t// enable this to give the event an ID\n            if (!options.action_call) options.action_call = this.id+"_"+(action?action:"action")+"_"+Math.floor(Math.random()*9999);\n            \n            this.graph.nodes_actioning[this.id] = (action?action:"actioning"); //.push(this.id);\n            \n            this.onAction(action, param, options, action_slot);\n            \n            this.graph.nodes_actioning[this.id] = false; //.pop();\n            \n            // save execution/action ref\n            if(options && options.action_call){\n                this.action_call = options.action_call; // if (param)\n                this.graph.nodes_executedAction[this.id] = options.action_call;\n            }\n        }\n        this.action_triggered = 2; // the nFrames it will be used (-- each step), means "how old" is the event\n        if(this.onAfterExecuteNode) this.onAfterExecuteNode(param, options);\n    };\n    \n    /**\n     * Triggers an event in this node, this will trigger any output with the same name\n     * @method trigger\n     * @param {String} event name ( "on_play", ... ) if action is equivalent to false then the event is send to all\n     * @param {*} param\n     */\n    LGraphNode.prototype.trigger = function(action, param, options) {\n        if (!this.outputs || !this.outputs.length) {\n            return;\n        }\n\n        if (this.graph)\n            this.graph._last_trigger_time = LiteGraph.getTime();\n\n        for (var i = 0; i < this.outputs.length; ++i) {\n            var output = this.outputs[i];\n            if ( !output || output.type !== LiteGraph.EVENT || (action && output.name != action) )\n                continue;\n            this.triggerSlot(i, param, null, options);\n        }\n    };\n\n    /**\n     * Triggers a slot event in this node: cycle output slots and launch execute/action on connected nodes\n     * @method triggerSlot\n     * @param {Number} slot the index of the output slot\n     * @param {*} param\n     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot\n     */\n    LGraphNode.prototype.triggerSlot = function(slot, param, link_id, options) {\n        options = options || {};\n        if (!this.outputs) {\n            return;\n        }\n\n\t\tif(slot == null)\n\t\t{\n\t\t\tconsole.error("slot must be a number");\n\t\t\treturn;\n\t\t}\n\n\t\tif(slot.constructor !== Number)\n\t\t\tconsole.warn("slot must be a number, use node.trigger(\'name\') if you want to use a string");\n\n        var output = this.outputs[slot];\n        if (!output) {\n            return;\n        }\n\n        var links = output.links;\n        if (!links || !links.length) {\n            return;\n        }\n\n        if (this.graph) {\n            this.graph._last_trigger_time = LiteGraph.getTime();\n        }\n\n        //for every link attached here\n        for (var k = 0; k < links.length; ++k) {\n            var id = links[k];\n            if (link_id != null && link_id != id) {\n                //to skip links\n                continue;\n            }\n            var link_info = this.graph.links[links[k]];\n            if (!link_info) {\n                //not connected\n                continue;\n            }\n            link_info._last_time = LiteGraph.getTime();\n            var node = this.graph.getNodeById(link_info.target_id);\n            if (!node) {\n                //node not found?\n                continue;\n            }\n\n            //used to mark events in graph\n            var target_connection = node.inputs[link_info.target_slot];\n\n\t\t\tif (node.mode === LiteGraph.ON_TRIGGER)\n\t\t\t{\n\t\t\t\t// generate unique trigger ID if not present\n\t\t\t\tif (!options.action_call) options.action_call = this.id+"_trigg_"+Math.floor(Math.random()*9999);\n                if (node.onExecute) {\n                    // -- wrapping node.onExecute(param); --\n                    node.doExecute(param, options);\n                }\n\t\t\t}\n\t\t\telse if (node.onAction) {\n                // generate unique action ID if not present\n\t\t\t\tif (!options.action_call) options.action_call = this.id+"_act_"+Math.floor(Math.random()*9999);\n                //pass the action name\n                var target_connection = node.inputs[link_info.target_slot];\n\n                //instead of executing them now, it will be executed in the next graph loop, to ensure data flow\n                if(LiteGraph.use_deferred_actions && node.onExecute)\n                {\n                    if(!node._waiting_actions)\n                        node._waiting_actions = [];\n                    node._waiting_actions.push([target_connection.name, param, options, link_info.target_slot]);\n                }\n                else\n                {\n                    // wrap node.onAction(target_connection.name, param);\n                    node.actionDo( target_connection.name, param, options, link_info.target_slot );\n                }\n            }\n        }\n    };\n\n    /**\n     * clears the trigger slot animation\n     * @method clearTriggeredSlot\n     * @param {Number} slot the index of the output slot\n     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot\n     */\n    LGraphNode.prototype.clearTriggeredSlot = function(slot, link_id) {\n        if (!this.outputs) {\n            return;\n        }\n\n        var output = this.outputs[slot];\n        if (!output) {\n            return;\n        }\n\n        var links = output.links;\n        if (!links || !links.length) {\n            return;\n        }\n\n        //for every link attached here\n        for (var k = 0; k < links.length; ++k) {\n            var id = links[k];\n            if (link_id != null && link_id != id) {\n                //to skip links\n                continue;\n            }\n            var link_info = this.graph.links[links[k]];\n            if (!link_info) {\n                //not connected\n                continue;\n            }\n            link_info._last_time = 0;\n        }\n    };\n\n    /**\n     * changes node size and triggers callback\n     * @method setSize\n     * @param {vec2} size\n     */\n    LGraphNode.prototype.setSize = function(size)\n\t{\n\t\tthis.size = size;\n\t\tif(this.onResize)\n\t\t\tthis.onResize(this.size);\n\t}\n\n    /**\n     * add a new property to this node\n     * @method addProperty\n     * @param {string} name\n     * @param {*} default_value\n     * @param {string} type string defining the output type ("vec3","number",...)\n     * @param {Object} extra_info this can be used to have special properties of the property (like values, etc)\n     */\n    LGraphNode.prototype.addProperty = function(\n        name,\n        default_value,\n        type,\n        extra_info\n    ) {\n        var o = { name: name, type: type, default_value: default_value };\n        if (extra_info) {\n            for (var i in extra_info) {\n                o[i] = extra_info[i];\n            }\n        }\n        if (!this.properties_info) {\n            this.properties_info = [];\n        }\n        this.properties_info.push(o);\n        if (!this.properties) {\n            this.properties = {};\n        }\n        this.properties[name] = default_value;\n        return o;\n    };\n\n    //connections\n\n    /**\n     * add a new output slot to use in this node\n     * @method addOutput\n     * @param {string} name\n     * @param {string} type string defining the output type ("vec3","number",...)\n     * @param {Object} extra_info this can be used to have special properties of an output (label, special color, position, etc)\n     */\n    LGraphNode.prototype.addOutput = function(name, type, extra_info) {\n        var output = { name: name, type: type, links: null };\n        if (extra_info) {\n            for (var i in extra_info) {\n                output[i] = extra_info[i];\n            }\n        }\n\n        if (!this.outputs) {\n            this.outputs = [];\n        }\n        this.outputs.push(output);\n        if (this.onOutputAdded) {\n            this.onOutputAdded(output);\n        }\n        \n        if (LiteGraph.auto_load_slot_types) LiteGraph.registerNodeAndSlotType(this,type,true);\n        \n        this.setSize( this.computeSize() );\n        this.setDirtyCanvas(true, true);\n        return output;\n    };\n\n    /**\n     * add a new output slot to use in this node\n     * @method addOutputs\n     * @param {Array} array of triplets like [[name,type,extra_info],[...]]\n     */\n    LGraphNode.prototype.addOutputs = function(array) {\n        for (var i = 0; i < array.length; ++i) {\n            var info = array[i];\n            var o = { name: info[0], type: info[1], link: null };\n            if (array[2]) {\n                for (var j in info[2]) {\n                    o[j] = info[2][j];\n                }\n            }\n\n            if (!this.outputs) {\n                this.outputs = [];\n            }\n            this.outputs.push(o);\n            if (this.onOutputAdded) {\n                this.onOutputAdded(o);\n            }\n            \n            if (LiteGraph.auto_load_slot_types) LiteGraph.registerNodeAndSlotType(this,info[1],true);\n            \n        }\n\n        this.setSize( this.computeSize() );\n        this.setDirtyCanvas(true, true);\n    };\n\n    /**\n     * remove an existing output slot\n     * @method removeOutput\n     * @param {number} slot\n     */\n    LGraphNode.prototype.removeOutput = function(slot) {\n        this.disconnectOutput(slot);\n        this.outputs.splice(slot, 1);\n        for (var i = slot; i < this.outputs.length; ++i) {\n            if (!this.outputs[i] || !this.outputs[i].links) {\n                continue;\n            }\n            var links = this.outputs[i].links;\n            for (var j = 0; j < links.length; ++j) {\n                var link = this.graph.links[links[j]];\n                if (!link) {\n                    continue;\n                }\n                link.origin_slot -= 1;\n            }\n        }\n\n        this.setSize( this.computeSize() );\n        if (this.onOutputRemoved) {\n            this.onOutputRemoved(slot);\n        }\n        this.setDirtyCanvas(true, true);\n    };\n\n    /**\n     * add a new input slot to use in this node\n     * @method addInput\n     * @param {string} name\n     * @param {string} type string defining the input type ("vec3","number",...), it its a generic one use 0\n     * @param {Object} extra_info this can be used to have special properties of an input (label, color, position, etc)\n     */\n    LGraphNode.prototype.addInput = function(name, type, extra_info) {\n        type = type || 0;\n        var input = { name: name, type: type, link: null };\n        if (extra_info) {\n            for (var i in extra_info) {\n                input[i] = extra_info[i];\n            }\n        }\n\n        if (!this.inputs) {\n            this.inputs = [];\n        }\n\n        this.inputs.push(input);\n        this.setSize( this.computeSize() );\n\n        if (this.onInputAdded) {\n            this.onInputAdded(input);\n\t\t}\n        \n        LiteGraph.registerNodeAndSlotType(this,type);\n\n        this.setDirtyCanvas(true, true);\n        return input;\n    };\n\n    /**\n     * add several new input slots in this node\n     * @method addInputs\n     * @param {Array} array of triplets like [[name,type,extra_info],[...]]\n     */\n    LGraphNode.prototype.addInputs = function(array) {\n        for (var i = 0; i < array.length; ++i) {\n            var info = array[i];\n            var o = { name: info[0], type: info[1], link: null };\n            if (array[2]) {\n                for (var j in info[2]) {\n                    o[j] = info[2][j];\n                }\n            }\n\n            if (!this.inputs) {\n                this.inputs = [];\n            }\n            this.inputs.push(o);\n            if (this.onInputAdded) {\n                this.onInputAdded(o);\n            }\n            \n            LiteGraph.registerNodeAndSlotType(this,info[1]);\n        }\n\n        this.setSize( this.computeSize() );\n        this.setDirtyCanvas(true, true);\n    };\n\n    /**\n     * remove an existing input slot\n     * @method removeInput\n     * @param {number} slot\n     */\n    LGraphNode.prototype.removeInput = function(slot) {\n        this.disconnectInput(slot);\n        var slot_info = this.inputs.splice(slot, 1);\n        for (var i = slot; i < this.inputs.length; ++i) {\n            if (!this.inputs[i]) {\n                continue;\n            }\n            var link = this.graph.links[this.inputs[i].link];\n            if (!link) {\n                continue;\n            }\n            link.target_slot -= 1;\n        }\n        this.setSize( this.computeSize() );\n        if (this.onInputRemoved) {\n            this.onInputRemoved(slot, slot_info[0] );\n        }\n        this.setDirtyCanvas(true, true);\n    };\n\n    /**\n     * add an special connection to this node (used for special kinds of graphs)\n     * @method addConnection\n     * @param {string} name\n     * @param {string} type string defining the input type ("vec3","number",...)\n     * @param {[x,y]} pos position of the connection inside the node\n     * @param {string} direction if is input or output\n     */\n    LGraphNode.prototype.addConnection = function(name, type, pos, direction) {\n        var o = {\n            name: name,\n            type: type,\n            pos: pos,\n            direction: direction,\n            links: null\n        };\n        this.connections.push(o);\n        return o;\n    };\n\n    /**\n     * computes the minimum size of a node according to its inputs and output slots\n     * @method computeSize\n     * @param {vec2} minHeight\n     * @return {vec2} the total size\n     */\n    LGraphNode.prototype.computeSize = function(out) {\n        if (this.constructor.size) {\n            return this.constructor.size.concat();\n        }\n\n        var rows = Math.max(\n            this.inputs ? this.inputs.length : 1,\n            this.outputs ? this.outputs.length : 1\n        );\n        var size = out || new Float32Array([0, 0]);\n        rows = Math.max(rows, 1);\n        var font_size = LiteGraph.NODE_TEXT_SIZE; //although it should be graphcanvas.inner_text_font size\n\n        var title_width = compute_text_size(this.title);\n        var input_width = 0;\n        var output_width = 0;\n\n        if (this.inputs) {\n            for (var i = 0, l = this.inputs.length; i < l; ++i) {\n                var input = this.inputs[i];\n                var text = input.label || input.name || "";\n                var text_width = compute_text_size(text);\n                if (input_width < text_width) {\n                    input_width = text_width;\n                }\n            }\n        }\n\n        if (this.outputs) {\n            for (var i = 0, l = this.outputs.length; i < l; ++i) {\n                var output = this.outputs[i];\n                var text = output.label || output.name || "";\n                var text_width = compute_text_size(text);\n                if (output_width < text_width) {\n                    output_width = text_width;\n                }\n            }\n        }\n\n        size[0] = Math.max(input_width + output_width + 10, title_width);\n        size[0] = Math.max(size[0], LiteGraph.NODE_WIDTH);\n        if (this.widgets && this.widgets.length) {\n            size[0] = Math.max(size[0], LiteGraph.NODE_WIDTH * 1.5);\n        }\n\n        size[1] = (this.constructor.slot_start_y || 0) + rows * LiteGraph.NODE_SLOT_HEIGHT;\n\n        var widgets_height = 0;\n        if (this.widgets && this.widgets.length) {\n            for (var i = 0, l = this.widgets.length; i < l; ++i) {\n                if (this.widgets[i].computeSize)\n                    widgets_height += this.widgets[i].computeSize(size[0])[1] + 4;\n                else\n                    widgets_height += LiteGraph.NODE_WIDGET_HEIGHT + 4;\n            }\n            widgets_height += 8;\n        }\n\n        //compute height using widgets height\n        if( this.widgets_up )\n            size[1] = Math.max( size[1], widgets_height );\n        else if( this.widgets_start_y != null )\n            size[1] = Math.max( size[1], widgets_height + this.widgets_start_y );\n        else\n            size[1] += widgets_height;\n\n        function compute_text_size(text) {\n            if (!text) {\n                return 0;\n            }\n            return font_size * text.length * 0.6;\n        }\n\n        if (\n            this.constructor.min_height &&\n            size[1] < this.constructor.min_height\n        ) {\n            size[1] = this.constructor.min_height;\n        }\n\n        size[1] += 6; //margin\n\n        return size;\n    };\n\n    /**\n     * returns all the info available about a property of this node.\n     *\n     * @method getPropertyInfo\n     * @param {String} property name of the property\n     * @return {Object} the object with all the available info\n    */\n    LGraphNode.prototype.getPropertyInfo = function( property )\n\t{\n        var info = null;\n\n\t\t//there are several ways to define info about a property\n\t\t//legacy mode\n\t\tif (this.properties_info) {\n            for (var i = 0; i < this.properties_info.length; ++i) {\n                if (this.properties_info[i].name == property) {\n                    info = this.properties_info[i];\n                    break;\n                }\n            }\n        }\n\t\t//litescene mode using the constructor\n\t\tif(this.constructor["@" + property])\n\t\t\tinfo = this.constructor["@" + property];\n\n\t\tif(this.constructor.widgets_info && this.constructor.widgets_info[property])\n\t\t\tinfo = this.constructor.widgets_info[property];\n\n\t\t//litescene mode using the constructor\n\t\tif (!info && this.onGetPropertyInfo) {\n            info = this.onGetPropertyInfo(property);\n        }\n\n        if (!info)\n            info = {};\n\t\tif(!info.type)\n\t\t\tinfo.type = typeof this.properties[property];\n\t\tif(info.widget == "combo")\n\t\t\tinfo.type = "enum";\n\n\t\treturn info;\n\t}\n\n    /**\n     * Defines a widget inside the node, it will be rendered on top of the node, you can control lots of properties\n     *\n     * @method addWidget\n     * @param {String} type the widget type (could be "number","string","combo"\n     * @param {String} name the text to show on the widget\n     * @param {String} value the default value\n     * @param {Function|String} callback function to call when it changes (optionally, it can be the name of the property to modify)\n     * @param {Object} options the object that contains special properties of this widget \n     * @return {Object} the created widget object\n     */\n    LGraphNode.prototype.addWidget = function( type, name, value, callback, options )\n\t{\n        if (!this.widgets) {\n            this.widgets = [];\n        }\n\n\t\tif(!options && callback && callback.constructor === Object)\n\t\t{\n\t\t\toptions = callback;\n\t\t\tcallback = null;\n\t\t}\n\n\t\tif(options && options.constructor === String) //options can be the property name\n\t\t\toptions = { property: options };\n\n\t\tif(callback && callback.constructor === String) //callback can be the property name\n\t\t{\n\t\t\tif(!options)\n\t\t\t\toptions = {};\n\t\t\toptions.property = callback;\n\t\t\tcallback = null;\n\t\t}\n\n\t\tif(callback && callback.constructor !== Function)\n\t\t{\n\t\t\tconsole.warn("addWidget: callback must be a function");\n\t\t\tcallback = null;\n\t\t}\n\n        var w = {\n            type: type.toLowerCase(),\n            name: name,\n            value: value,\n            callback: callback,\n            options: options || {}\n        };\n\n        if (w.options.y !== undefined) {\n            w.y = w.options.y;\n        }\n\n        if (!callback && !w.options.callback && !w.options.property) {\n            console.warn("LiteGraph addWidget(...) without a callback or property assigned");\n        }\n        if (type == "combo" && !w.options.values) {\n            throw "LiteGraph addWidget(\'combo\',...) requires to pass values in options: { values:[\'red\',\'blue\'] }";\n        }\n        this.widgets.push(w);\n\t\tthis.setSize( this.computeSize() );\n        return w;\n    };\n\n    LGraphNode.prototype.addCustomWidget = function(custom_widget) {\n        if (!this.widgets) {\n            this.widgets = [];\n        }\n        this.widgets.push(custom_widget);\n        return custom_widget;\n    };\n\n    /**\n     * returns the bounding of the object, used for rendering purposes\n     * @method getBounding\n     * @param out {Float32Array[4]?} [optional] a place to store the output, to free garbage\n     * @param compute_outer {boolean?} [optional] set to true to include the shadow and connection points in the bounding calculation\n     * @return {Float32Array[4]} the bounding box in format of [topleft_cornerx, topleft_cornery, width, height]\n     */\n    LGraphNode.prototype.getBounding = function(out, compute_outer) {\n        out = out || new Float32Array(4);\n        const nodePos = this.pos;\n        const isCollapsed = this.flags.collapsed;\n        const nodeSize = this.size;\n        \n        let left_offset = 0;\n        // 1 offset due to how nodes are rendered\n        let right_offset =  1 ;\n        let top_offset = 0;\n        let bottom_offset = 0;\n        \n        if (compute_outer) {\n            // 4 offset for collapsed node connection points\n            left_offset = 4;\n            // 6 offset for right shadow and collapsed node connection points\n            right_offset = 6 + left_offset;\n            // 4 offset for collapsed nodes top connection points\n            top_offset = 4;\n            // 5 offset for bottom shadow and collapsed node connection points\n            bottom_offset = 5 + top_offset;\n        }\n        \n        out[0] = nodePos[0] - left_offset;\n        out[1] = nodePos[1] - LiteGraph.NODE_TITLE_HEIGHT - top_offset;\n        out[2] = isCollapsed ?\n            (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH) + right_offset :\n            nodeSize[0] + right_offset;\n        out[3] = isCollapsed ?\n            LiteGraph.NODE_TITLE_HEIGHT + bottom_offset :\n            nodeSize[1] + LiteGraph.NODE_TITLE_HEIGHT + bottom_offset;\n\n        if (this.onBounding) {\n            this.onBounding(out);\n        }\n        return out;\n    };\n\n    /**\n     * checks if a point is inside the shape of a node\n     * @method isPointInside\n     * @param {number} x\n     * @param {number} y\n     * @return {boolean}\n     */\n    LGraphNode.prototype.isPointInside = function(x, y, margin, skip_title) {\n        margin = margin || 0;\n\n        var margin_top = this.graph && this.graph.isLive() ? 0 : LiteGraph.NODE_TITLE_HEIGHT;\n        if (skip_title) {\n            margin_top = 0;\n        }\n        if (this.flags && this.flags.collapsed) {\n            //if ( distance([x,y], [this.pos[0] + this.size[0]*0.5, this.pos[1] + this.size[1]*0.5]) < LiteGraph.NODE_COLLAPSED_RADIUS)\n            if (\n                isInsideRectangle(\n                    x,\n                    y,\n                    this.pos[0] - margin,\n                    this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT - margin,\n                    (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH) +\n                        2 * margin,\n                    LiteGraph.NODE_TITLE_HEIGHT + 2 * margin\n                )\n            ) {\n                return true;\n            }\n        } else if (\n            this.pos[0] - 4 - margin < x &&\n            this.pos[0] + this.size[0] + 4 + margin > x &&\n            this.pos[1] - margin_top - margin < y &&\n            this.pos[1] + this.size[1] + margin > y\n        ) {\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * checks if a point is inside a node slot, and returns info about which slot\n     * @method getSlotInPosition\n     * @param {number} x\n     * @param {number} y\n     * @return {Object} if found the object contains { input|output: slot object, slot: number, link_pos: [x,y] }\n     */\n    LGraphNode.prototype.getSlotInPosition = function(x, y) {\n        //search for inputs\n        var link_pos = new Float32Array(2);\n        if (this.inputs) {\n            for (var i = 0, l = this.inputs.length; i < l; ++i) {\n                var input = this.inputs[i];\n                this.getConnectionPos(true, i, link_pos);\n                if (\n                    isInsideRectangle(\n                        x,\n                        y,\n                        link_pos[0] - 10,\n                        link_pos[1] - 5,\n                        20,\n                        10\n                    )\n                ) {\n                    return { input: input, slot: i, link_pos: link_pos };\n                }\n            }\n        }\n\n        if (this.outputs) {\n            for (var i = 0, l = this.outputs.length; i < l; ++i) {\n                var output = this.outputs[i];\n                this.getConnectionPos(false, i, link_pos);\n                if (\n                    isInsideRectangle(\n                        x,\n                        y,\n                        link_pos[0] - 10,\n                        link_pos[1] - 5,\n                        20,\n                        10\n                    )\n                ) {\n                    return { output: output, slot: i, link_pos: link_pos };\n                }\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * returns the input slot with a given name (used for dynamic slots), -1 if not found\n     * @method findInputSlot\n     * @param {string} name the name of the slot\n     * @param {boolean} returnObj if the obj itself wanted\n     * @return {number_or_object} the slot (-1 if not found)\n     */\n    LGraphNode.prototype.findInputSlot = function(name,  returnObj) {\n        if (!this.inputs) {\n            return -1;\n        }\n        for (var i = 0, l = this.inputs.length; i < l; ++i) {\n            if (name == this.inputs[i].name) {\n                return !returnObj ? i : this.inputs[i];\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * returns the output slot with a given name (used for dynamic slots), -1 if not found\n     * @method findOutputSlot\n     * @param {string} name the name of the slot\n     * @param {boolean} returnObj if the obj itself wanted\n     * @return {number_or_object} the slot (-1 if not found)\n     */\n    LGraphNode.prototype.findOutputSlot = function(name, returnObj) {\n        returnObj = returnObj || false;\n        if (!this.outputs) {\n            return -1;\n        }\n        for (var i = 0, l = this.outputs.length; i < l; ++i) {\n            if (name == this.outputs[i].name) {\n                return !returnObj ? i : this.outputs[i];\n            }\n        }\n        return -1;\n    };\n    \n    // TODO refactor: USE SINGLE findInput/findOutput functions! :: merge options\n    \n    /**\n     * returns the first free input slot\n     * @method findInputSlotFree\n     * @param {object} options\n     * @return {number_or_object} the slot (-1 if not found)\n     */\n    LGraphNode.prototype.findInputSlotFree = function(optsIn) {\n        var optsIn = optsIn || {};\n        var optsDef = {returnObj: false\n                        ,typesNotAccepted: []\n                      };\n        var opts = Object.assign(optsDef,optsIn);\n        if (!this.inputs) {\n            return -1;\n        }\n        for (var i = 0, l = this.inputs.length; i < l; ++i) {\n            if (this.inputs[i].link && this.inputs[i].link != null) {\n                continue;\n            }\n            if (opts.typesNotAccepted && opts.typesNotAccepted.includes && opts.typesNotAccepted.includes(this.inputs[i].type)){\n                continue;\n            }\n            return !opts.returnObj ? i : this.inputs[i];\n        }\n        return -1;\n    };\n\n    /**\n     * returns the first output slot free\n     * @method findOutputSlotFree\n     * @param {object} options\n     * @return {number_or_object} the slot (-1 if not found)\n     */\n    LGraphNode.prototype.findOutputSlotFree = function(optsIn) {\n        var optsIn = optsIn || {};\n        var optsDef = { returnObj: false\n                        ,typesNotAccepted: []\n                      };\n        var opts = Object.assign(optsDef,optsIn);\n        if (!this.outputs) {\n            return -1;\n        }\n        for (var i = 0, l = this.outputs.length; i < l; ++i) {\n            if (this.outputs[i].links && this.outputs[i].links != null) {\n                continue;\n            }\n            if (opts.typesNotAccepted && opts.typesNotAccepted.includes && opts.typesNotAccepted.includes(this.outputs[i].type)){\n                continue;\n            }\n            return !opts.returnObj ? i : this.outputs[i];\n        }\n        return -1;\n    };\n    \n    /**\n     * findSlotByType for INPUTS\n     */\n    LGraphNode.prototype.findInputSlotByType = function(type, returnObj, preferFreeSlot, doNotUseOccupied) {\n        return this.findSlotByType(true, type, returnObj, preferFreeSlot, doNotUseOccupied);\n    };\n\n    /**\n     * findSlotByType for OUTPUTS\n     */\n    LGraphNode.prototype.findOutputSlotByType = function(type, returnObj, preferFreeSlot, doNotUseOccupied) {\n        return this.findSlotByType(false, type, returnObj, preferFreeSlot, doNotUseOccupied);\n    };\n    \n    /**\n     * returns the output (or input) slot with a given type, -1 if not found\n     * @method findSlotByType\n     * @param {boolean} input uise inputs instead of outputs\n     * @param {string} type the type of the slot\n     * @param {boolean} returnObj if the obj itself wanted\n     * @param {boolean} preferFreeSlot if we want a free slot (if not found, will return the first of the type anyway)\n     * @return {number_or_object} the slot (-1 if not found)\n     */\n    LGraphNode.prototype.findSlotByType = function(input, type, returnObj, preferFreeSlot, doNotUseOccupied) {\n        input = input || false;\n        returnObj = returnObj || false;\n        preferFreeSlot = preferFreeSlot || false;\n        doNotUseOccupied = doNotUseOccupied || false;\n        var aSlots = input ? this.inputs : this.outputs;\n        if (!aSlots) {\n            return -1;\n        }\n\t\t// !! empty string type is considered 0, * !!\n\t\tif (type == "" || type == "*") type = 0; \n        for (var i = 0, l = aSlots.length; i < l; ++i) {\n            var tFound = false;\n            var aSource = (type+"").toLowerCase().split(",");\n            var aDest = aSlots[i].type=="0"||aSlots[i].type=="*"?"0":aSlots[i].type;\n\t\t\taDest = (aDest+"").toLowerCase().split(",");\n            for(var sI=0;sI<aSource.length;sI++){\n                for(var dI=0;dI<aDest.length;dI++){\n\t\t\t\t\tif (aSource[sI]=="_event_") aSource[sI] = LiteGraph.EVENT;\n\t\t\t\t\tif (aDest[sI]=="_event_") aDest[sI] = LiteGraph.EVENT;\n\t\t\t\t\tif (aSource[sI]=="*") aSource[sI] = 0;\n\t\t\t\t\tif (aDest[sI]=="*") aDest[sI] = 0;\n\t\t\t\t\tif (aSource[sI] == aDest[dI]) {\n                        if (preferFreeSlot && aSlots[i].links && aSlots[i].links !== null) continue;\n                        return !returnObj ? i : aSlots[i];\n                    }\n                }\n            }\n        }\n        // if didnt find some, stop checking for free slots\n        if (preferFreeSlot && !doNotUseOccupied){\n            for (var i = 0, l = aSlots.length; i < l; ++i) {\n                var tFound = false;\n                var aSource = (type+"").toLowerCase().split(",");\n                var aDest = aSlots[i].type=="0"||aSlots[i].type=="*"?"0":aSlots[i].type;\n\t\t\t\taDest = (aDest+"").toLowerCase().split(",");\n                for(var sI=0;sI<aSource.length;sI++){\n                    for(var dI=0;dI<aDest.length;dI++){\n\t\t\t\t\t\tif (aSource[sI]=="*") aSource[sI] = 0;\n\t\t\t\t\t\tif (aDest[sI]=="*") aDest[sI] = 0;\n                        if (aSource[sI] == aDest[dI]) {\n                            return !returnObj ? i : aSlots[i];\n                        }\n                    }\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * connect this node output to the input of another node BY TYPE\n     * @method connectByType\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)\n     * @param {LGraphNode} node the target node\n     * @param {string} target_type the input slot type of the target node\n     * @return {Object} the link_info is created, otherwise null\n     */\n    LGraphNode.prototype.connectByType = function(slot, target_node, target_slotType, optsIn) {\n        var optsIn = optsIn || {};\n        var optsDef = { createEventInCase: true\n\t\t\t\t\t   \t,firstFreeIfOutputGeneralInCase: true\n                        ,generalTypeInCase: true\n                      };\n        var opts = Object.assign(optsDef,optsIn);\n        if (target_node && target_node.constructor === Number) {\n            target_node = this.graph.getNodeById(target_node);\n        }\n        var target_slot = target_node.findInputSlotByType(target_slotType, false, true);\n        if (target_slot >= 0 && target_slot !== null){\n            //console.debug("CONNbyTYPE type "+target_slotType+" for "+target_slot)\n            return this.connect(slot, target_node, target_slot);\n        }else{\n            //console.log("type "+target_slotType+" not found or not free?")\n            if (opts.createEventInCase && target_slotType == LiteGraph.EVENT){\n                // WILL CREATE THE onTrigger IN SLOT\n\t\t\t\t//console.debug("connect WILL CREATE THE onTrigger "+target_slotType+" to "+target_node);\n                return this.connect(slot, target_node, -1);\n            }\n\t\t\t// connect to the first general output slot if not found a specific type and \n            if (opts.generalTypeInCase){\n                var target_slot = target_node.findInputSlotByType(0, false, true, true);\n\t\t\t\t//console.debug("connect TO a general type (*, 0), if not found the specific type ",target_slotType," to ",target_node,"RES_SLOT:",target_slot);\n                if (target_slot >= 0){\n                    return this.connect(slot, target_node, target_slot);\n                }\n            }\n            // connect to the first free input slot if not found a specific type and this output is general\n            if (opts.firstFreeIfOutputGeneralInCase && (target_slotType == 0 || target_slotType == "*" || target_slotType == "")){\n                var target_slot = target_node.findInputSlotFree({typesNotAccepted: [LiteGraph.EVENT] });\n\t\t\t\t//console.debug("connect TO TheFirstFREE ",target_slotType," to ",target_node,"RES_SLOT:",target_slot);\n                if (target_slot >= 0){\n\t\t\t\t\treturn this.connect(slot, target_node, target_slot);\n                }\n            }\n\t\t\t\n\t\t\tconsole.debug("no way to connect type: ",target_slotType," to targetNODE ",target_node);\n\t\t\t//TODO filter\n\t\t\t\n            return null;\n        }\n    }\n    \n    /**\n     * connect this node input to the output of another node BY TYPE\n     * @method connectByType\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)\n     * @param {LGraphNode} node the target node\n     * @param {string} target_type the output slot type of the target node\n     * @return {Object} the link_info is created, otherwise null\n     */\n    LGraphNode.prototype.connectByTypeOutput = function(slot, source_node, source_slotType, optsIn) {\n        var optsIn = optsIn || {};\n        var optsDef = { createEventInCase: true\n                        ,firstFreeIfInputGeneralInCase: true\n                        ,generalTypeInCase: true\n                      };\n        var opts = Object.assign(optsDef,optsIn);\n        if (source_node && source_node.constructor === Number) {\n            source_node = this.graph.getNodeById(source_node);\n        }\n        var source_slot = source_node.findOutputSlotByType(source_slotType, false, true);\n        if (source_slot >= 0 && source_slot !== null){\n            //console.debug("CONNbyTYPE OUT! type "+source_slotType+" for "+source_slot)\n            return source_node.connect(source_slot, this, slot);\n        }else{\n            \n            // connect to the first general output slot if not found a specific type and \n            if (opts.generalTypeInCase){\n                var source_slot = source_node.findOutputSlotByType(0, false, true, true);\n                if (source_slot >= 0){\n                    return source_node.connect(source_slot, this, slot);\n                }\n            }\n            \n            if (opts.createEventInCase && source_slotType == LiteGraph.EVENT){\n                // WILL CREATE THE onExecuted OUT SLOT\n\t\t\t\tif (LiteGraph.do_add_triggers_slots){\n\t\t\t\t\tvar source_slot = source_node.addOnExecutedOutput();\n\t\t\t\t\treturn source_node.connect(source_slot, this, slot);\n\t\t\t\t}\n            }\n            // connect to the first free output slot if not found a specific type and this input is general\n            if (opts.firstFreeIfInputGeneralInCase && (source_slotType == 0 || source_slotType == "*" || source_slotType == "")){\n                var source_slot = source_node.findOutputSlotFree({typesNotAccepted: [LiteGraph.EVENT] });\n                if (source_slot >= 0){\n                    return source_node.connect(source_slot, this, slot);\n                }\n            }\n            \n\t\t\tconsole.debug("no way to connect byOUT type: ",source_slotType," to sourceNODE ",source_node);\n\t\t\t//TODO filter\n\t\t\t\n            //console.log("type OUT! "+source_slotType+" not found or not free?")\n            return null;\n        }\n    }\n    \n    /**\n     * connect this node output to the input of another node\n     * @method connect\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)\n     * @param {LGraphNode} node the target node\n     * @param {number_or_string} target_slot the input slot of the target node (could be the number of the slot or the string with the name of the slot, or -1 to connect a trigger)\n     * @return {Object} the link_info is created, otherwise null\n     */\n    LGraphNode.prototype.connect = function(slot, target_node, target_slot) {\n        target_slot = target_slot || 0;\n\n        if (!this.graph) {\n            //could be connected before adding it to a graph\n            console.log(\n                "Connect: Error, node doesn\'t belong to any graph. Nodes must be added first to a graph before connecting them."\n            ); //due to link ids being associated with graphs\n            return null;\n        }\n\n        //seek for the output slot\n        if (slot.constructor === String) {\n            slot = this.findOutputSlot(slot);\n            if (slot == -1) {\n                if (LiteGraph.debug) {\n                    console.log("Connect: Error, no slot of name " + slot);\n                }\n                return null;\n            }\n        } else if (!this.outputs || slot >= this.outputs.length) {\n            if (LiteGraph.debug) {\n                console.log("Connect: Error, slot number not found");\n            }\n            return null;\n        }\n\n        if (target_node && target_node.constructor === Number) {\n            target_node = this.graph.getNodeById(target_node);\n        }\n        if (!target_node) {\n            throw "target node is null";\n        }\n\n        //avoid loopback\n        if (target_node == this) {\n            return null;\n        }\n\n        //you can specify the slot by name\n        if (target_slot.constructor === String) {\n            target_slot = target_node.findInputSlot(target_slot);\n            if (target_slot == -1) {\n                if (LiteGraph.debug) {\n                    console.log(\n                        "Connect: Error, no slot of name " + target_slot\n                    );\n                }\n                return null;\n            }\n        } else if (target_slot === LiteGraph.EVENT) {\n            \n            if (LiteGraph.do_add_triggers_slots){\n\t            //search for first slot with event? :: NO this is done outside\n\t\t\t\t//console.log("Connect: Creating triggerEvent");\n\t            // force mode\n\t            target_node.changeMode(LiteGraph.ON_TRIGGER);\n\t            target_slot = target_node.findInputSlot("onTrigger");\n        \t}else{\n            \treturn null; // -- break --\n\t\t\t}\n        } else if (\n            !target_node.inputs ||\n            target_slot >= target_node.inputs.length\n        ) {\n            if (LiteGraph.debug) {\n                console.log("Connect: Error, slot number not found");\n            }\n            return null;\n        }\n\n\t\tvar changed = false;\n\n        var input = target_node.inputs[target_slot];\n        var link_info = null;\n        var output = this.outputs[slot];\n        \n        if (!this.outputs[slot]){\n            /*console.debug("Invalid slot passed: "+slot);\n            console.debug(this.outputs);*/\n            return null;\n        }\n\n        // allow target node to change slot\n        if (target_node.onBeforeConnectInput) {\n            // This way node can choose another slot (or make a new one?)\n            target_slot = target_node.onBeforeConnectInput(target_slot); //callback\n        }\n\n\t\t//check target_slot and check connection types\n        if (target_slot===false || target_slot===null || !LiteGraph.isValidConnection(output.type, input.type))\n\t\t{\n\t        this.setDirtyCanvas(false, true);\n\t\t\tif(changed)\n\t\t        this.graph.connectionChange(this, link_info);\n\t\t\treturn null;\n\t\t}else{\n\t\t\t//console.debug("valid connection",output.type, input.type);\n\t\t}\n\n        //allows nodes to block connection, callback\n        if (target_node.onConnectInput) {\n            if ( target_node.onConnectInput(target_slot, output.type, output, this, slot) === false ) {\n                return null;\n            }\n        }\n        if (this.onConnectOutput) { // callback\n            if ( this.onConnectOutput(slot, input.type, input, target_node, target_slot) === false ) {\n                return null;\n            }\n        }\n\n        //if there is something already plugged there, disconnect\n        if (target_node.inputs[target_slot] && target_node.inputs[target_slot].link != null) {\n\t\t\tthis.graph.beforeChange();\n            target_node.disconnectInput(target_slot, {doProcessChange: false});\n\t\t\tchanged = true;\n        }\n        if (output.links !== null && output.links.length){\n            switch(output.type){\n                case LiteGraph.EVENT:\n                    if (!LiteGraph.allow_multi_output_for_events){\n                        this.graph.beforeChange();\n                        this.disconnectOutput(slot, false, {doProcessChange: false}); // Input(target_slot, {doProcessChange: false});\n                        changed = true;\n                    }\n                break;\n                default:\n                break;\n            }\n        }\n\n        var nextId\n        if (LiteGraph.use_uuids)\n            nextId = LiteGraph.uuidv4();\n        else\n            nextId = ++this.graph.last_link_id;\n        \n\t\t//create link class\n\t\tlink_info = new LLink(\n\t\t\tnextId,\n\t\t\tinput.type || output.type,\n\t\t\tthis.id,\n\t\t\tslot,\n\t\t\ttarget_node.id,\n\t\t\ttarget_slot\n\t\t);\n\n\t\t//add to graph links list\n\t\tthis.graph.links[link_info.id] = link_info;\n\n\t\t//connect in output\n\t\tif (output.links == null) {\n\t\t\toutput.links = [];\n\t\t}\n\t\toutput.links.push(link_info.id);\n\t\t//connect in input\n\t\ttarget_node.inputs[target_slot].link = link_info.id;\n\t\tif (this.graph) {\n\t\t\tthis.graph._version++;\n\t\t}\n\t\tif (this.onConnectionsChange) {\n\t\t\tthis.onConnectionsChange(\n\t\t\t\tLiteGraph.OUTPUT,\n\t\t\t\tslot,\n\t\t\t\ttrue,\n\t\t\t\tlink_info,\n\t\t\t\toutput\n\t\t\t);\n\t\t} //link_info has been created now, so its updated\n\t\tif (target_node.onConnectionsChange) {\n\t\t\ttarget_node.onConnectionsChange(\n\t\t\t\tLiteGraph.INPUT,\n\t\t\t\ttarget_slot,\n\t\t\t\ttrue,\n\t\t\t\tlink_info,\n\t\t\t\tinput\n\t\t\t);\n\t\t}\n\t\tif (this.graph && this.graph.onNodeConnectionChange) {\n\t\t\tthis.graph.onNodeConnectionChange(\n\t\t\t\tLiteGraph.INPUT,\n\t\t\t\ttarget_node,\n\t\t\t\ttarget_slot,\n\t\t\t\tthis,\n\t\t\t\tslot\n\t\t\t);\n\t\t\tthis.graph.onNodeConnectionChange(\n\t\t\t\tLiteGraph.OUTPUT,\n\t\t\t\tthis,\n\t\t\t\tslot,\n\t\t\t\ttarget_node,\n\t\t\t\ttarget_slot\n\t\t\t);\n\t\t}\n\n        this.setDirtyCanvas(false, true);\n\t\tthis.graph.afterChange();\n\t\tthis.graph.connectionChange(this, link_info);\n\n        return link_info;\n    };\n\n    /**\n     * disconnect one output to an specific node\n     * @method disconnectOutput\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)\n     * @param {LGraphNode} target_node the target node to which this slot is connected [Optional, if not target_node is specified all nodes will be disconnected]\n     * @return {boolean} if it was disconnected successfully\n     */\n    LGraphNode.prototype.disconnectOutput = function(slot, target_node) {\n        if (slot.constructor === String) {\n            slot = this.findOutputSlot(slot);\n            if (slot == -1) {\n                if (LiteGraph.debug) {\n                    console.log("Connect: Error, no slot of name " + slot);\n                }\n                return false;\n            }\n        } else if (!this.outputs || slot >= this.outputs.length) {\n            if (LiteGraph.debug) {\n                console.log("Connect: Error, slot number not found");\n            }\n            return false;\n        }\n\n        //get output slot\n        var output = this.outputs[slot];\n        if (!output || !output.links || output.links.length == 0) {\n            return false;\n        }\n\n        //one of the output links in this slot\n        if (target_node) {\n            if (target_node.constructor === Number) {\n                target_node = this.graph.getNodeById(target_node);\n            }\n            if (!target_node) {\n                throw "Target Node not found";\n            }\n\n            for (var i = 0, l = output.links.length; i < l; i++) {\n                var link_id = output.links[i];\n                var link_info = this.graph.links[link_id];\n\n                //is the link we are searching for...\n                if (link_info.target_id == target_node.id) {\n                    output.links.splice(i, 1); //remove here\n                    var input = target_node.inputs[link_info.target_slot];\n                    input.link = null; //remove there\n                    delete this.graph.links[link_id]; //remove the link from the links pool\n                    if (this.graph) {\n                        this.graph._version++;\n                    }\n                    if (target_node.onConnectionsChange) {\n                        target_node.onConnectionsChange(\n                            LiteGraph.INPUT,\n                            link_info.target_slot,\n                            false,\n                            link_info,\n                            input\n                        );\n                    } //link_info hasn\'t been modified so its ok\n                    if (this.onConnectionsChange) {\n                        this.onConnectionsChange(\n                            LiteGraph.OUTPUT,\n                            slot,\n                            false,\n                            link_info,\n                            output\n                        );\n                    }\n                    if (this.graph && this.graph.onNodeConnectionChange) {\n                        this.graph.onNodeConnectionChange(\n                            LiteGraph.OUTPUT,\n                            this,\n                            slot\n                        );\n                    }\n                    if (this.graph && this.graph.onNodeConnectionChange) {\n                        this.graph.onNodeConnectionChange(\n                            LiteGraph.OUTPUT,\n                            this,\n                            slot\n                        );\n                        this.graph.onNodeConnectionChange(\n                            LiteGraph.INPUT,\n                            target_node,\n                            link_info.target_slot\n                        );\n                    }\n                    break;\n                }\n            }\n        } //all the links in this output slot\n        else {\n            for (var i = 0, l = output.links.length; i < l; i++) {\n                var link_id = output.links[i];\n                var link_info = this.graph.links[link_id];\n                if (!link_info) {\n                    //bug: it happens sometimes\n                    continue;\n                }\n\n                var target_node = this.graph.getNodeById(link_info.target_id);\n                var input = null;\n                if (this.graph) {\n                    this.graph._version++;\n                }\n                if (target_node) {\n                    input = target_node.inputs[link_info.target_slot];\n                    input.link = null; //remove other side link\n                    if (target_node.onConnectionsChange) {\n                        target_node.onConnectionsChange(\n                            LiteGraph.INPUT,\n                            link_info.target_slot,\n                            false,\n                            link_info,\n                            input\n                        );\n                    } //link_info hasn\'t been modified so its ok\n                    if (this.graph && this.graph.onNodeConnectionChange) {\n                        this.graph.onNodeConnectionChange(\n                            LiteGraph.INPUT,\n                            target_node,\n                            link_info.target_slot\n                        );\n                    }\n                }\n                delete this.graph.links[link_id]; //remove the link from the links pool\n                if (this.onConnectionsChange) {\n                    this.onConnectionsChange(\n                        LiteGraph.OUTPUT,\n                        slot,\n                        false,\n                        link_info,\n                        output\n                    );\n                }\n                if (this.graph && this.graph.onNodeConnectionChange) {\n                    this.graph.onNodeConnectionChange(\n                        LiteGraph.OUTPUT,\n                        this,\n                        slot\n                    );\n                    this.graph.onNodeConnectionChange(\n                        LiteGraph.INPUT,\n                        target_node,\n                        link_info.target_slot\n                    );\n                }\n            }\n            output.links = null;\n        }\n\n        this.setDirtyCanvas(false, true);\n        this.graph.connectionChange(this);\n        return true;\n    };\n\n    /**\n     * disconnect one input\n     * @method disconnectInput\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)\n     * @return {boolean} if it was disconnected successfully\n     */\n    LGraphNode.prototype.disconnectInput = function(slot) {\n        //seek for the output slot\n        if (slot.constructor === String) {\n            slot = this.findInputSlot(slot);\n            if (slot == -1) {\n                if (LiteGraph.debug) {\n                    console.log("Connect: Error, no slot of name " + slot);\n                }\n                return false;\n            }\n        } else if (!this.inputs || slot >= this.inputs.length) {\n            if (LiteGraph.debug) {\n                console.log("Connect: Error, slot number not found");\n            }\n            return false;\n        }\n\n        var input = this.inputs[slot];\n        if (!input) {\n            return false;\n        }\n\n        var link_id = this.inputs[slot].link;\n\t\tif(link_id != null)\n\t\t{\n\t\t\tthis.inputs[slot].link = null;\n\n\t\t\t//remove other side\n\t\t\tvar link_info = this.graph.links[link_id];\n\t\t\tif (link_info) {\n\t\t\t\tvar target_node = this.graph.getNodeById(link_info.origin_id);\n\t\t\t\tif (!target_node) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar output = target_node.outputs[link_info.origin_slot];\n\t\t\t\tif (!output || !output.links || output.links.length == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//search in the inputs list for this link\n\t\t\t\tfor (var i = 0, l = output.links.length; i < l; i++) {\n\t\t\t\t\tif (output.links[i] == link_id) {\n\t\t\t\t\t\toutput.links.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdelete this.graph.links[link_id]; //remove from the pool\n\t\t\t\tif (this.graph) {\n\t\t\t\t\tthis.graph._version++;\n\t\t\t\t}\n\t\t\t\tif (this.onConnectionsChange) {\n\t\t\t\t\tthis.onConnectionsChange(\n\t\t\t\t\t\tLiteGraph.INPUT,\n\t\t\t\t\t\tslot,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tlink_info,\n\t\t\t\t\t\tinput\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (target_node.onConnectionsChange) {\n\t\t\t\t\ttarget_node.onConnectionsChange(\n\t\t\t\t\t\tLiteGraph.OUTPUT,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tlink_info,\n\t\t\t\t\t\toutput\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (this.graph && this.graph.onNodeConnectionChange) {\n\t\t\t\t\tthis.graph.onNodeConnectionChange(\n\t\t\t\t\t\tLiteGraph.OUTPUT,\n\t\t\t\t\t\ttarget_node,\n\t\t\t\t\t\ti\n\t\t\t\t\t);\n\t\t\t\t\tthis.graph.onNodeConnectionChange(LiteGraph.INPUT, this, slot);\n\t\t\t\t}\n\t\t\t}\n\t\t} //link != null\n\n        this.setDirtyCanvas(false, true);\n\t\tif(this.graph)\n\t        this.graph.connectionChange(this);\n        return true;\n    };\n\n    /**\n     * returns the center of a connection point in canvas coords\n     * @method getConnectionPos\n     * @param {boolean} is_input true if if a input slot, false if it is an output\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)\n     * @param {vec2} out [optional] a place to store the output, to free garbage\n     * @return {[x,y]} the position\n     **/\n    LGraphNode.prototype.getConnectionPos = function(\n        is_input,\n        slot_number,\n        out\n    ) {\n        out = out || new Float32Array(2);\n        var num_slots = 0;\n        if (is_input && this.inputs) {\n            num_slots = this.inputs.length;\n        }\n        if (!is_input && this.outputs) {\n            num_slots = this.outputs.length;\n        }\n\n        var offset = LiteGraph.NODE_SLOT_HEIGHT * 0.5;\n\n        if (this.flags.collapsed) {\n            var w = this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH;\n            if (this.horizontal) {\n                out[0] = this.pos[0] + w * 0.5;\n                if (is_input) {\n                    out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT;\n                } else {\n                    out[1] = this.pos[1];\n                }\n            } else {\n                if (is_input) {\n                    out[0] = this.pos[0];\n                } else {\n                    out[0] = this.pos[0] + w;\n                }\n                out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT * 0.5;\n            }\n            return out;\n        }\n\n        //weird feature that never got finished\n        if (is_input && slot_number == -1) {\n            out[0] = this.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * 0.5;\n            out[1] = this.pos[1] + LiteGraph.NODE_TITLE_HEIGHT * 0.5;\n            return out;\n        }\n\n        //hard-coded pos\n        if (\n            is_input &&\n            num_slots > slot_number &&\n            this.inputs[slot_number].pos\n        ) {\n            out[0] = this.pos[0] + this.inputs[slot_number].pos[0];\n            out[1] = this.pos[1] + this.inputs[slot_number].pos[1];\n            return out;\n        } else if (\n            !is_input &&\n            num_slots > slot_number &&\n            this.outputs[slot_number].pos\n        ) {\n            out[0] = this.pos[0] + this.outputs[slot_number].pos[0];\n            out[1] = this.pos[1] + this.outputs[slot_number].pos[1];\n            return out;\n        }\n\n        //horizontal distributed slots\n        if (this.horizontal) {\n            out[0] =\n                this.pos[0] + (slot_number + 0.5) * (this.size[0] / num_slots);\n            if (is_input) {\n                out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT;\n            } else {\n                out[1] = this.pos[1] + this.size[1];\n            }\n            return out;\n        }\n\n        //default vertical slots\n        if (is_input) {\n            out[0] = this.pos[0] + offset;\n        } else {\n            out[0] = this.pos[0] + this.size[0] + 1 - offset;\n        }\n        out[1] =\n            this.pos[1] +\n            (slot_number + 0.7) * LiteGraph.NODE_SLOT_HEIGHT +\n            (this.constructor.slot_start_y || 0);\n        return out;\n    };\n\n    /* Force align to grid */\n    LGraphNode.prototype.alignToGrid = function() {\n        this.pos[0] =\n            LiteGraph.CANVAS_GRID_SIZE *\n            Math.round(this.pos[0] / LiteGraph.CANVAS_GRID_SIZE);\n        this.pos[1] =\n            LiteGraph.CANVAS_GRID_SIZE *\n            Math.round(this.pos[1] / LiteGraph.CANVAS_GRID_SIZE);\n    };\n\n    /* Console output */\n    LGraphNode.prototype.trace = function(msg) {\n        if (!this.console) {\n            this.console = [];\n        }\n\n        this.console.push(msg);\n        if (this.console.length > LGraphNode.MAX_CONSOLE) {\n            this.console.shift();\n        }\n\n\t\tif(this.graph.onNodeTrace)\n\t        this.graph.onNodeTrace(this, msg);\n    };\n\n    /* Forces to redraw or the main canvas (LGraphNode) or the bg canvas (links) */\n    LGraphNode.prototype.setDirtyCanvas = function(\n        dirty_foreground,\n        dirty_background\n    ) {\n        if (!this.graph) {\n            return;\n        }\n        this.graph.sendActionToCanvas("setDirty", [\n            dirty_foreground,\n            dirty_background\n        ]);\n    };\n\n    LGraphNode.prototype.loadImage = function(url) {\n        var img = new Image();\n        img.src = LiteGraph.node_images_path + url;\n        img.ready = false;\n\n        var that = this;\n        img.onload = function() {\n            this.ready = true;\n            that.setDirtyCanvas(true);\n        };\n        return img;\n    };\n\n    //safe LGraphNode action execution (not sure if safe)\n    /*\nLGraphNode.prototype.executeAction = function(action)\n{\n\tif(action == "") return false;\n\n\tif( action.indexOf(";") != -1 || action.indexOf("}") != -1)\n\t{\n\t\tthis.trace("Error: Action contains unsafe characters");\n\t\treturn false;\n\t}\n\n\tvar tokens = action.split("(");\n\tvar func_name = tokens[0];\n\tif( typeof(this[func_name]) != "function")\n\t{\n\t\tthis.trace("Error: Action not found on node: " + func_name);\n\t\treturn false;\n\t}\n\n\tvar code = action;\n\n\ttry\n\t{\n\t\tvar _foo = eval;\n\t\teval = null;\n\t\t(new Function("with(this) { " + code + "}")).call(this);\n\t\teval = _foo;\n\t}\n\tcatch (err)\n\t{\n\t\tthis.trace("Error executing action {" + action + "} :" + err);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n*/\n\n    /* Allows to get onMouseMove and onMouseUp events even if the mouse is out of focus */\n    LGraphNode.prototype.captureInput = function(v) {\n        if (!this.graph || !this.graph.list_of_graphcanvas) {\n            return;\n        }\n\n        var list = this.graph.list_of_graphcanvas;\n\n        for (var i = 0; i < list.length; ++i) {\n            var c = list[i];\n            //releasing somebody elses capture?!\n            if (!v && c.node_capturing_input != this) {\n                continue;\n            }\n\n            //change\n            c.node_capturing_input = v ? this : null;\n        }\n    };\n\n    /**\n     * Collapse the node to make it smaller on the canvas\n     * @method collapse\n     **/\n    LGraphNode.prototype.collapse = function(force) {\n        this.graph._version++;\n        if (this.constructor.collapsable === false && !force) {\n            return;\n        }\n        if (!this.flags.collapsed) {\n            this.flags.collapsed = true;\n        } else {\n            this.flags.collapsed = false;\n        }\n        this.setDirtyCanvas(true, true);\n    };\n\n    /**\n     * Forces the node to do not move or realign on Z\n     * @method pin\n     **/\n\n    LGraphNode.prototype.pin = function(v) {\n        this.graph._version++;\n        if (v === undefined) {\n            this.flags.pinned = !this.flags.pinned;\n        } else {\n            this.flags.pinned = v;\n        }\n    };\n\n    LGraphNode.prototype.localToScreen = function(x, y, graphcanvas) {\n        return [\n            (x + this.pos[0]) * graphcanvas.scale + graphcanvas.offset[0],\n            (y + this.pos[1]) * graphcanvas.scale + graphcanvas.offset[1]\n        ];\n    };\n\n    function LGraphGroup(title) {\n        this._ctor(title);\n    }\n\n    global.LGraphGroup = LiteGraph.LGraphGroup = LGraphGroup;\n\n    LGraphGroup.prototype._ctor = function(title) {\n        this.title = title || "Group";\n        this.font_size = 24;\n        this.color = LGraphCanvas.node_colors.pale_blue\n            ? LGraphCanvas.node_colors.pale_blue.groupcolor\n            : "#AAA";\n        this._bounding = new Float32Array([10, 10, 140, 80]);\n        this._pos = this._bounding.subarray(0, 2);\n        this._size = this._bounding.subarray(2, 4);\n        this._nodes = [];\n        this.graph = null;\n\n        Object.defineProperty(this, "pos", {\n            set: function(v) {\n                if (!v || v.length < 2) {\n                    return;\n                }\n                this._pos[0] = v[0];\n                this._pos[1] = v[1];\n            },\n            get: function() {\n                return this._pos;\n            },\n            enumerable: true\n        });\n\n        Object.defineProperty(this, "size", {\n            set: function(v) {\n                if (!v || v.length < 2) {\n                    return;\n                }\n                this._size[0] = Math.max(140, v[0]);\n                this._size[1] = Math.max(80, v[1]);\n            },\n            get: function() {\n                return this._size;\n            },\n            enumerable: true\n        });\n    };\n\n    LGraphGroup.prototype.configure = function(o) {\n        this.title = o.title;\n        this._bounding.set(o.bounding);\n        this.color = o.color;\n        this.font_size = o.font_size;\n    };\n\n    LGraphGroup.prototype.serialize = function() {\n        var b = this._bounding;\n        return {\n            title: this.title,\n            bounding: [\n                Math.round(b[0]),\n                Math.round(b[1]),\n                Math.round(b[2]),\n                Math.round(b[3])\n            ],\n            color: this.color,\n            font_size: this.font_size\n        };\n    };\n\n    LGraphGroup.prototype.move = function(deltax, deltay, ignore_nodes) {\n        this._pos[0] += deltax;\n        this._pos[1] += deltay;\n        if (ignore_nodes) {\n            return;\n        }\n        for (var i = 0; i < this._nodes.length; ++i) {\n            var node = this._nodes[i];\n            node.pos[0] += deltax;\n            node.pos[1] += deltay;\n        }\n    };\n\n    LGraphGroup.prototype.recomputeInsideNodes = function() {\n        this._nodes.length = 0;\n        var nodes = this.graph._nodes;\n        var node_bounding = new Float32Array(4);\n\n        for (var i = 0; i < nodes.length; ++i) {\n            var node = nodes[i];\n            node.getBounding(node_bounding);\n            if (!overlapBounding(this._bounding, node_bounding)) {\n                continue;\n            } //out of the visible area\n            this._nodes.push(node);\n        }\n    };\n\n    LGraphGroup.prototype.isPointInside = LGraphNode.prototype.isPointInside;\n    LGraphGroup.prototype.setDirtyCanvas = LGraphNode.prototype.setDirtyCanvas;\n\n    //****************************************\n\n    //Scale and Offset\n    function DragAndScale(element, skip_events) {\n        this.offset = new Float32Array([0, 0]);\n        this.scale = 1;\n        this.max_scale = 10;\n        this.min_scale = 0.1;\n        this.onredraw = null;\n        this.enabled = true;\n        this.last_mouse = [0, 0];\n        this.element = null;\n        this.visible_area = new Float32Array(4);\n\n        if (element) {\n            this.element = element;\n            if (!skip_events) {\n                this.bindEvents(element);\n            }\n        }\n    }\n\n    LiteGraph.DragAndScale = DragAndScale;\n\n    DragAndScale.prototype.bindEvents = function(element) {\n        this.last_mouse = new Float32Array(2);\n\n        this._binded_mouse_callback = this.onMouse.bind(this);\n\n\t\tLiteGraph.pointerListenerAdd(element,"down", this._binded_mouse_callback);\n\t\tLiteGraph.pointerListenerAdd(element,"move", this._binded_mouse_callback);\n\t\tLiteGraph.pointerListenerAdd(element,"up", this._binded_mouse_callback);\n\n        element.addEventListener(\n            "mousewheel",\n            this._binded_mouse_callback,\n            false\n        );\n        element.addEventListener("wheel", this._binded_mouse_callback, false);\n    };\n\n    DragAndScale.prototype.computeVisibleArea = function( viewport ) {\n        if (!this.element) {\n            this.visible_area[0] = this.visible_area[1] = this.visible_area[2] = this.visible_area[3] = 0;\n            return;\n        }\n        var width = this.element.width;\n        var height = this.element.height;\n        var startx = -this.offset[0];\n        var starty = -this.offset[1];\n\t\tif( viewport )\n\t\t{\n\t\t\tstartx += viewport[0] / this.scale;\n\t\t\tstarty += viewport[1] / this.scale;\n\t\t\twidth = viewport[2];\n\t\t\theight = viewport[3];\n\t\t}\n        var endx = startx + width / this.scale;\n        var endy = starty + height / this.scale;\n        this.visible_area[0] = startx;\n        this.visible_area[1] = starty;\n        this.visible_area[2] = endx - startx;\n        this.visible_area[3] = endy - starty;\n    };\n\n    DragAndScale.prototype.onMouse = function(e) {\n        if (!this.enabled) {\n            return;\n        }\n\n        var canvas = this.element;\n        var rect = canvas.getBoundingClientRect();\n        var x = e.clientX - rect.left;\n        var y = e.clientY - rect.top;\n        e.canvasx = x;\n        e.canvasy = y;\n        e.dragging = this.dragging;\n        \n\t\tvar is_inside = !this.viewport || ( this.viewport && x >= this.viewport[0] && x < (this.viewport[0] + this.viewport[2]) && y >= this.viewport[1] && y < (this.viewport[1] + this.viewport[3]) );\n\n\t\t//console.log("pointerevents: DragAndScale onMouse "+e.type+" "+is_inside);\n\t\t\n        var ignore = false;\n        if (this.onmouse) {\n            ignore = this.onmouse(e);\n        }\n\n        if (e.type == LiteGraph.pointerevents_method+"down" && is_inside) {\n            this.dragging = true;\n\t\t\tLiteGraph.pointerListenerRemove(canvas,"move",this._binded_mouse_callback);\n\t\t\tLiteGraph.pointerListenerAdd(document,"move",this._binded_mouse_callback);\n\t\t\tLiteGraph.pointerListenerAdd(document,"up",this._binded_mouse_callback);\n        } else if (e.type == LiteGraph.pointerevents_method+"move") {\n            if (!ignore) {\n                var deltax = x - this.last_mouse[0];\n                var deltay = y - this.last_mouse[1];\n                if (this.dragging) {\n                    this.mouseDrag(deltax, deltay);\n                }\n            }\n        } else if (e.type == LiteGraph.pointerevents_method+"up") {\n            this.dragging = false;\n\t\t\tLiteGraph.pointerListenerRemove(document,"move",this._binded_mouse_callback);\n\t\t\tLiteGraph.pointerListenerRemove(document,"up",this._binded_mouse_callback);\n\t\t\tLiteGraph.pointerListenerAdd(canvas,"move",this._binded_mouse_callback);\n        } else if ( is_inside &&\n            (e.type == "mousewheel" ||\n            e.type == "wheel" ||\n            e.type == "DOMMouseScroll")\n        ) {\n            e.eventType = "mousewheel";\n            if (e.type == "wheel") {\n                e.wheel = -e.deltaY;\n            } else {\n                e.wheel =\n                    e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;\n            }\n\n            //from stack overflow\n            e.delta = e.wheelDelta\n                ? e.wheelDelta / 40\n                : e.deltaY\n                ? -e.deltaY / 3\n                : 0;\n            this.changeDeltaScale(1.0 + e.delta * 0.05);\n        }\n\n        this.last_mouse[0] = x;\n        this.last_mouse[1] = y;\n\n\t\tif(is_inside)\n\t\t{\n\t        e.preventDefault();\n\t\t    e.stopPropagation();\n\t\t    return false;\n\t\t}\n    };\n\n    DragAndScale.prototype.toCanvasContext = function(ctx) {\n        ctx.scale(this.scale, this.scale);\n        ctx.translate(this.offset[0], this.offset[1]);\n    };\n\n    DragAndScale.prototype.convertOffsetToCanvas = function(pos) {\n        //return [pos[0] / this.scale - this.offset[0], pos[1] / this.scale - this.offset[1]];\n        return [\n            (pos[0] + this.offset[0]) * this.scale,\n            (pos[1] + this.offset[1]) * this.scale\n        ];\n    };\n\n    DragAndScale.prototype.convertCanvasToOffset = function(pos, out) {\n        out = out || [0, 0];\n        out[0] = pos[0] / this.scale - this.offset[0];\n        out[1] = pos[1] / this.scale - this.offset[1];\n        return out;\n    };\n\n    DragAndScale.prototype.mouseDrag = function(x, y) {\n        this.offset[0] += x / this.scale;\n        this.offset[1] += y / this.scale;\n\n        if (this.onredraw) {\n            this.onredraw(this);\n        }\n    };\n\n    DragAndScale.prototype.changeScale = function(value, zooming_center) {\n        if (value < this.min_scale) {\n            value = this.min_scale;\n        } else if (value > this.max_scale) {\n            value = this.max_scale;\n        }\n\n        if (value == this.scale) {\n            return;\n        }\n\n        if (!this.element) {\n            return;\n        }\n\n        var rect = this.element.getBoundingClientRect();\n        if (!rect) {\n            return;\n        }\n\n        zooming_center = zooming_center || [\n            rect.width * 0.5,\n            rect.height * 0.5\n        ];\n        var center = this.convertCanvasToOffset(zooming_center);\n        this.scale = value;\n        if (Math.abs(this.scale - 1) < 0.01) {\n            this.scale = 1;\n        }\n\n        var new_center = this.convertCanvasToOffset(zooming_center);\n        var delta_offset = [\n            new_center[0] - center[0],\n            new_center[1] - center[1]\n        ];\n\n        this.offset[0] += delta_offset[0];\n        this.offset[1] += delta_offset[1];\n\n        if (this.onredraw) {\n            this.onredraw(this);\n        }\n    };\n\n    DragAndScale.prototype.changeDeltaScale = function(value, zooming_center) {\n        this.changeScale(this.scale * value, zooming_center);\n    };\n\n    DragAndScale.prototype.reset = function() {\n        this.scale = 1;\n        this.offset[0] = 0;\n        this.offset[1] = 0;\n    };\n\n    //*********************************************************************************\n    // LGraphCanvas: LGraph renderer CLASS\n    //*********************************************************************************\n\n    /**\n     * This class is in charge of rendering one graph inside a canvas. And provides all the interaction required.\n     * Valid callbacks are: onNodeSelected, onNodeDeselected, onShowNodePanel, onNodeDblClicked\n     *\n     * @class LGraphCanvas\n     * @constructor\n     * @param {HTMLCanvas} canvas the canvas where you want to render (it accepts a selector in string format or the canvas element itself)\n     * @param {LGraph} graph [optional]\n     * @param {Object} options [optional] { skip_rendering, autoresize, viewport }\n     */\n    function LGraphCanvas(canvas, graph, options) {\n        this.options = options = options || {};\n\n        //if(graph === undefined)\n        //\tthrow ("No graph assigned");\n        this.background_image = LGraphCanvas.DEFAULT_BACKGROUND_IMAGE;\n\n        if (canvas && canvas.constructor === String) {\n            canvas = document.querySelector(canvas);\n        }\n\n        this.ds = new DragAndScale();\n        this.zoom_modify_alpha = true; //otherwise it generates ugly patterns when scaling down too much\n\n        this.title_text_font = "" + LiteGraph.NODE_TEXT_SIZE + "px Arial";\n        this.inner_text_font =\n            "normal " + LiteGraph.NODE_SUBTEXT_SIZE + "px Arial";\n        this.node_title_color = LiteGraph.NODE_TITLE_COLOR;\n        this.default_link_color = LiteGraph.LINK_COLOR;\n        this.default_connection_color = {\n            input_off: "#778",\n            input_on: "#7F7", //"#BBD"\n            output_off: "#778",\n            output_on: "#7F7" //"#BBD"\n\t\t};\n        this.default_connection_color_byType = {\n            /*number: "#7F7",\n            string: "#77F",\n            boolean: "#F77",*/\n        }\n        this.default_connection_color_byTypeOff = {\n            /*number: "#474",\n            string: "#447",\n            boolean: "#744",*/\n        };\n\n        this.highquality_render = true;\n        this.use_gradients = false; //set to true to render titlebar with gradients\n        this.editor_alpha = 1; //used for transition\n        this.pause_rendering = false;\n        this.clear_background = true;\n        this.clear_background_color = "#222";\n\n\t\tthis.read_only = false; //if set to true users cannot modify the graph\n        this.render_only_selected = true;\n        this.live_mode = false;\n        this.show_info = true;\n        this.allow_dragcanvas = true;\n        this.allow_dragnodes = true;\n        this.allow_interaction = true; //allow to control widgets, buttons, collapse, etc\n        this.multi_select = false; //allow selecting multi nodes without pressing extra keys\n        this.allow_searchbox = true;\n        this.allow_reconnect_links = true; //allows to change a connection with having to redo it again\n\t\tthis.align_to_grid = false; //snap to grid\n\n        this.drag_mode = false;\n        this.dragging_rectangle = null;\n\n        this.filter = null; //allows to filter to only accept some type of nodes in a graph\n\n\t\tthis.set_canvas_dirty_on_mouse_event = true; //forces to redraw the canvas if the mouse does anything\n        this.always_render_background = false;\n        this.render_shadows = true;\n        this.render_canvas_border = true;\n        this.render_connections_shadows = false; //too much cpu\n        this.render_connections_border = true;\n        this.render_curved_connections = false;\n        this.render_connection_arrows = false;\n        this.render_collapsed_slots = true;\n        this.render_execution_order = false;\n        this.render_title_colored = true;\n\t\tthis.render_link_tooltip = true;\n\n        this.links_render_mode = LiteGraph.SPLINE_LINK;\n\n        this.mouse = [0, 0]; //mouse in canvas coordinates, where 0,0 is the top-left corner of the blue rectangle\n        this.graph_mouse = [0, 0]; //mouse in graph coordinates, where 0,0 is the top-left corner of the blue rectangle\n\t\tthis.canvas_mouse = this.graph_mouse; //LEGACY: REMOVE THIS, USE GRAPH_MOUSE INSTEAD\n\n        //to personalize the search box\n        this.onSearchBox = null;\n        this.onSearchBoxSelection = null;\n\n        //callbacks\n        this.onMouse = null;\n        this.onDrawBackground = null; //to render background objects (behind nodes and connections) in the canvas affected by transform\n        this.onDrawForeground = null; //to render foreground objects (above nodes and connections) in the canvas affected by transform\n        this.onDrawOverlay = null; //to render foreground objects not affected by transform (for GUIs)\n\t\tthis.onDrawLinkTooltip = null; //called when rendering a tooltip\n\t\tthis.onNodeMoved = null; //called after moving a node\n\t\tthis.onSelectionChange = null; //called if the selection changes\n\t\tthis.onConnectingChange = null; //called before any link changes\n\t\tthis.onBeforeChange = null; //called before modifying the graph\n\t\tthis.onAfterChange = null; //called after modifying the graph\n\n        this.connections_width = 3;\n        this.round_radius = 8;\n\n        this.current_node = null;\n        this.node_widget = null; //used for widgets\n\t\tthis.over_link_center = null;\n        this.last_mouse_position = [0, 0];\n        this.visible_area = this.ds.visible_area;\n        this.visible_links = [];\n\n\t\tthis.viewport = options.viewport || null; //to constraint render area to a portion of the canvas\n\n        //link canvas and graph\n        if (graph) {\n            graph.attachCanvas(this);\n        }\n\n        this.setCanvas(canvas,options.skip_events);\n        this.clear();\n\n        if (!options.skip_render) {\n            this.startRendering();\n        }\n\n        this.autoresize = options.autoresize;\n    }\n\n    global.LGraphCanvas = LiteGraph.LGraphCanvas = LGraphCanvas;\n\n\tLGraphCanvas.DEFAULT_BACKGROUND_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=";\n\n    LGraphCanvas.link_type_colors = {\n        "-1": LiteGraph.EVENT_LINK_COLOR,\n        number: "#AAA",\n        node: "#DCA"\n    };\n    LGraphCanvas.gradients = {}; //cache of gradients\n\n    /**\n     * clears all the data inside\n     *\n     * @method clear\n     */\n    LGraphCanvas.prototype.clear = function() {\n        this.frame = 0;\n        this.last_draw_time = 0;\n        this.render_time = 0;\n        this.fps = 0;\n\n        //this.scale = 1;\n        //this.offset = [0,0];\n\n        this.dragging_rectangle = null;\n\n        this.selected_nodes = {};\n        this.selected_group = null;\n\n        this.visible_nodes = [];\n        this.node_dragged = null;\n        this.node_over = null;\n        this.node_capturing_input = null;\n        this.connecting_node = null;\n        this.highlighted_links = {};\n\n\t\tthis.dragging_canvas = false;\n\n        this.dirty_canvas = true;\n        this.dirty_bgcanvas = true;\n        this.dirty_area = null;\n\n        this.node_in_panel = null;\n        this.node_widget = null;\n\n        this.last_mouse = [0, 0];\n        this.last_mouseclick = 0;\n\t  \tthis.pointer_is_down = false;\n\t  \tthis.pointer_is_double = false;\n        this.visible_area.set([0, 0, 0, 0]);\n\n        if (this.onClear) {\n            this.onClear();\n        }\n    };\n\n    /**\n     * assigns a graph, you can reassign graphs to the same canvas\n     *\n     * @method setGraph\n     * @param {LGraph} graph\n     */\n    LGraphCanvas.prototype.setGraph = function(graph, skip_clear) {\n        if (this.graph == graph) {\n            return;\n        }\n\n        if (!skip_clear) {\n            this.clear();\n        }\n\n        if (!graph && this.graph) {\n            this.graph.detachCanvas(this);\n            return;\n        }\n\n        graph.attachCanvas(this);\n\n\t\t//remove the graph stack in case a subgraph was open\n\t\tif (this._graph_stack)\n\t\t\tthis._graph_stack = null;\n\n        this.setDirty(true, true);\n    };\n\n    /**\n     * returns the top level graph (in case there are subgraphs open on the canvas)\n     *\n     * @method getTopGraph\n     * @return {LGraph} graph\n     */\n\tLGraphCanvas.prototype.getTopGraph = function()\n\t{\n\t\tif(this._graph_stack.length)\n\t\t\treturn this._graph_stack[0];\n\t\treturn this.graph;\n\t}\n\n    /**\n     * opens a graph contained inside a node in the current graph\n     *\n     * @method openSubgraph\n     * @param {LGraph} graph\n     */\n    LGraphCanvas.prototype.openSubgraph = function(graph) {\n        if (!graph) {\n            throw "graph cannot be null";\n        }\n\n        if (this.graph == graph) {\n            throw "graph cannot be the same";\n        }\n\n        this.clear();\n\n        if (this.graph) {\n            if (!this._graph_stack) {\n                this._graph_stack = [];\n            }\n            this._graph_stack.push(this.graph);\n        }\n\n        graph.attachCanvas(this);\n\t\tthis.checkPanels();\n        this.setDirty(true, true);\n    };\n\n    /**\n     * closes a subgraph contained inside a node\n     *\n     * @method closeSubgraph\n     * @param {LGraph} assigns a graph\n     */\n    LGraphCanvas.prototype.closeSubgraph = function() {\n        if (!this._graph_stack || this._graph_stack.length == 0) {\n            return;\n        }\n        var subgraph_node = this.graph._subgraph_node;\n        var graph = this._graph_stack.pop();\n        this.selected_nodes = {};\n        this.highlighted_links = {};\n        graph.attachCanvas(this);\n        this.setDirty(true, true);\n        if (subgraph_node) {\n            this.centerOnNode(subgraph_node);\n            this.selectNodes([subgraph_node]);\n        }\n        // when close sub graph back to offset [0, 0] scale 1\n        this.ds.offset = [0, 0]\n        this.ds.scale = 1\n    };\n\n    /**\n     * returns the visually active graph (in case there are more in the stack)\n     * @method getCurrentGraph\n     * @return {LGraph} the active graph\n     */\n    LGraphCanvas.prototype.getCurrentGraph = function() {\n        return this.graph;\n    };\n\n    /**\n     * assigns a canvas\n     *\n     * @method setCanvas\n     * @param {Canvas} assigns a canvas (also accepts the ID of the element (not a selector)\n     */\n    LGraphCanvas.prototype.setCanvas = function(canvas, skip_events) {\n        var that = this;\n\n        if (canvas) {\n            if (canvas.constructor === String) {\n                canvas = document.getElementById(canvas);\n                if (!canvas) {\n                    throw "Error creating LiteGraph canvas: Canvas not found";\n                }\n            }\n        }\n\n        if (canvas === this.canvas) {\n            return;\n        }\n\n        if (!canvas && this.canvas) {\n            //maybe detach events from old_canvas\n            if (!skip_events) {\n                this.unbindEvents();\n            }\n        }\n\n        this.canvas = canvas;\n        this.ds.element = canvas;\n\n        if (!canvas) {\n            return;\n        }\n\n        //this.canvas.tabindex = "1000";\n        canvas.className += " lgraphcanvas";\n        canvas.data = this;\n        canvas.tabindex = "1"; //to allow key events\n\n        //bg canvas: used for non changing stuff\n        this.bgcanvas = null;\n        if (!this.bgcanvas) {\n            this.bgcanvas = document.createElement("canvas");\n            this.bgcanvas.width = this.canvas.width;\n            this.bgcanvas.height = this.canvas.height;\n        }\n\n        if (canvas.getContext == null) {\n            if (canvas.localName != "canvas") {\n                throw "Element supplied for LGraphCanvas must be a <canvas> element, you passed a " +\n                    canvas.localName;\n            }\n            throw "This browser doesn\'t support Canvas";\n        }\n\n        var ctx = (this.ctx = canvas.getContext("2d"));\n        if (ctx == null) {\n            if (!canvas.webgl_enabled) {\n                console.warn(\n                    "This canvas seems to be WebGL, enabling WebGL renderer"\n                );\n            }\n            this.enableWebGL();\n        }\n\n        //input:  (move and up could be unbinded)\n        // why here? this._mousemove_callback = this.processMouseMove.bind(this);\n        // why here? this._mouseup_callback = this.processMouseUp.bind(this);\n\n        if (!skip_events) {\n            this.bindEvents();\n        }\n    };\n\n    //used in some events to capture them\n    LGraphCanvas.prototype._doNothing = function doNothing(e) {\n    \t//console.log("pointerevents: _doNothing "+e.type);\n        e.preventDefault();\n        return false;\n    };\n    LGraphCanvas.prototype._doReturnTrue = function doNothing(e) {\n        e.preventDefault();\n        return true;\n    };\n\n    /**\n     * binds mouse, keyboard, touch and drag events to the canvas\n     * @method bindEvents\n     **/\n    LGraphCanvas.prototype.bindEvents = function() {\n        if (this._events_binded) {\n            console.warn("LGraphCanvas: events already binded");\n            return;\n        }\n\n        //console.log("pointerevents: bindEvents");\n        \n        var canvas = this.canvas;\n\n        var ref_window = this.getCanvasWindow();\n        var document = ref_window.document; //hack used when moving canvas between windows\n\n        this._mousedown_callback = this.processMouseDown.bind(this);\n        this._mousewheel_callback = this.processMouseWheel.bind(this);\n        // why mousemove and mouseup were not binded here?\n        this._mousemove_callback = this.processMouseMove.bind(this);\n        this._mouseup_callback = this.processMouseUp.bind(this);\n        \n        //touch events -- TODO IMPLEMENT\n        //this._touch_callback = this.touchHandler.bind(this);\n\n\t\tLiteGraph.pointerListenerAdd(canvas,"down", this._mousedown_callback, true); //down do not need to store the binded\n        canvas.addEventListener("mousewheel", this._mousewheel_callback, false);\n\n        LiteGraph.pointerListenerAdd(canvas,"up", this._mouseup_callback, true); // CHECK: ??? binded or not\n\t\tLiteGraph.pointerListenerAdd(canvas,"move", this._mousemove_callback);\n        \n        canvas.addEventListener("contextmenu", this._doNothing);\n        canvas.addEventListener(\n            "DOMMouseScroll",\n            this._mousewheel_callback,\n            false\n        );\n\n        //touch events -- THIS WAY DOES NOT WORK, finish implementing pointerevents, than clean the touchevents\n        /*if( \'touchstart\' in document.documentElement )\n        {\n            canvas.addEventListener("touchstart", this._touch_callback, true);\n            canvas.addEventListener("touchmove", this._touch_callback, true);\n            canvas.addEventListener("touchend", this._touch_callback, true);\n            canvas.addEventListener("touchcancel", this._touch_callback, true);\n        }*/\n\n        //Keyboard ******************\n        this._key_callback = this.processKey.bind(this);\n        canvas.setAttribute("tabindex",1); //otherwise key events are ignored\n        canvas.addEventListener("keydown", this._key_callback, true);\n        document.addEventListener("keyup", this._key_callback, true); //in document, otherwise it doesn\'t fire keyup\n\n        //Dropping Stuff over nodes ************************************\n        this._ondrop_callback = this.processDrop.bind(this);\n\n        canvas.addEventListener("dragover", this._doNothing, false);\n        canvas.addEventListener("dragend", this._doNothing, false);\n        canvas.addEventListener("drop", this._ondrop_callback, false);\n        canvas.addEventListener("dragenter", this._doReturnTrue, false);\n\n        this._events_binded = true;\n    };\n\n    /**\n     * unbinds mouse events from the canvas\n     * @method unbindEvents\n     **/\n    LGraphCanvas.prototype.unbindEvents = function() {\n        if (!this._events_binded) {\n            console.warn("LGraphCanvas: no events binded");\n            return;\n        }\n\n        //console.log("pointerevents: unbindEvents");\n        \n        var ref_window = this.getCanvasWindow();\n        var document = ref_window.document;\n\n\t\tLiteGraph.pointerListenerRemove(this.canvas,"move", this._mousedown_callback);\n        LiteGraph.pointerListenerRemove(this.canvas,"up", this._mousedown_callback);\n        LiteGraph.pointerListenerRemove(this.canvas,"down", this._mousedown_callback);\n        this.canvas.removeEventListener(\n            "mousewheel",\n            this._mousewheel_callback\n        );\n        this.canvas.removeEventListener(\n            "DOMMouseScroll",\n            this._mousewheel_callback\n        );\n        this.canvas.removeEventListener("keydown", this._key_callback);\n        document.removeEventListener("keyup", this._key_callback);\n        this.canvas.removeEventListener("contextmenu", this._doNothing);\n        this.canvas.removeEventListener("drop", this._ondrop_callback);\n        this.canvas.removeEventListener("dragenter", this._doReturnTrue);\n\n        //touch events -- THIS WAY DOES NOT WORK, finish implementing pointerevents, than clean the touchevents\n        /*this.canvas.removeEventListener("touchstart", this._touch_callback );\n        this.canvas.removeEventListener("touchmove", this._touch_callback );\n        this.canvas.removeEventListener("touchend", this._touch_callback );\n        this.canvas.removeEventListener("touchcancel", this._touch_callback );*/\n\n        this._mousedown_callback = null;\n        this._mousewheel_callback = null;\n        this._key_callback = null;\n        this._ondrop_callback = null;\n\n        this._events_binded = false;\n    };\n\n    LGraphCanvas.getFileExtension = function(url) {\n        var question = url.indexOf("?");\n        if (question != -1) {\n            url = url.substr(0, question);\n        }\n        var point = url.lastIndexOf(".");\n        if (point == -1) {\n            return "";\n        }\n        return url.substr(point + 1).toLowerCase();\n    };\n\n    /**\n     * this function allows to render the canvas using WebGL instead of Canvas2D\n     * this is useful if you plant to render 3D objects inside your nodes, it uses litegl.js for webgl and canvas2DtoWebGL to emulate the Canvas2D calls in webGL\n     * @method enableWebGL\n     **/\n    LGraphCanvas.prototype.enableWebGL = function() {\n        if (typeof GL === "undefined") {\n            throw "litegl.js must be included to use a WebGL canvas";\n        }\n        if (typeof enableWebGLCanvas === "undefined") {\n            throw "webglCanvas.js must be included to use this feature";\n        }\n\n        this.gl = this.ctx = enableWebGLCanvas(this.canvas);\n        this.ctx.webgl = true;\n        this.bgcanvas = this.canvas;\n        this.bgctx = this.gl;\n        this.canvas.webgl_enabled = true;\n\n        /*\n\tGL.create({ canvas: this.bgcanvas });\n\tthis.bgctx = enableWebGLCanvas( this.bgcanvas );\n\twindow.gl = this.gl;\n\t*/\n    };\n\n    /**\n     * marks as dirty the canvas, this way it will be rendered again\n     *\n     * @class LGraphCanvas\n     * @method setDirty\n     * @param {bool} fgcanvas if the foreground canvas is dirty (the one containing the nodes)\n     * @param {bool} bgcanvas if the background canvas is dirty (the one containing the wires)\n     */\n    LGraphCanvas.prototype.setDirty = function(fgcanvas, bgcanvas) {\n        if (fgcanvas) {\n            this.dirty_canvas = true;\n        }\n        if (bgcanvas) {\n            this.dirty_bgcanvas = true;\n        }\n    };\n\n    /**\n     * Used to attach the canvas in a popup\n     *\n     * @method getCanvasWindow\n     * @return {window} returns the window where the canvas is attached (the DOM root node)\n     */\n    LGraphCanvas.prototype.getCanvasWindow = function() {\n        if (!this.canvas) {\n            return window;\n        }\n        var doc = this.canvas.ownerDocument;\n        return doc.defaultView || doc.parentWindow;\n    };\n\n    /**\n     * starts rendering the content of the canvas when needed\n     *\n     * @method startRendering\n     */\n    LGraphCanvas.prototype.startRendering = function() {\n        if (this.is_rendering) {\n            return;\n        } //already rendering\n\n        this.is_rendering = true;\n        renderFrame.call(this);\n\n        function renderFrame() {\n            if (!this.pause_rendering) {\n                this.draw();\n            }\n\n            var window = this.getCanvasWindow();\n            if (this.is_rendering) {\n                window.requestAnimationFrame(renderFrame.bind(this));\n            }\n        }\n    };\n\n    /**\n     * stops rendering the content of the canvas (to save resources)\n     *\n     * @method stopRendering\n     */\n    LGraphCanvas.prototype.stopRendering = function() {\n        this.is_rendering = false;\n        /*\n\tif(this.rendering_timer_id)\n\t{\n\t\tclearInterval(this.rendering_timer_id);\n\t\tthis.rendering_timer_id = null;\n\t}\n\t*/\n    };\n\n    /* LiteGraphCanvas input */\n\n\t//used to block future mouse events (because of im gui)\n\tLGraphCanvas.prototype.blockClick = function()\n\t{\n\t\tthis.block_click = true;\n\t\tthis.last_mouseclick = 0;\n\t}\n\t\n    LGraphCanvas.prototype.processMouseDown = function(e) {\n    \t\n\t\tif( this.set_canvas_dirty_on_mouse_event )\n\t\t\tthis.dirty_canvas = true;\n\t\t\n\t\tif (!this.graph) {\n            return;\n        }\n\n        this.adjustMouseEvent(e);\n\n        var ref_window = this.getCanvasWindow();\n        var document = ref_window.document;\n        LGraphCanvas.active_canvas = this;\n        var that = this;\n\n\t\tvar x = e.clientX;\n\t\tvar y = e.clientY;\n\t\t//console.log(y,this.viewport);\n\t\t//console.log("pointerevents: processMouseDown pointerId:"+e.pointerId+" which:"+e.which+" isPrimary:"+e.isPrimary+" :: x y "+x+" "+y);\n\n\t\tthis.ds.viewport = this.viewport;\n\t\tvar is_inside = !this.viewport || ( this.viewport && x >= this.viewport[0] && x < (this.viewport[0] + this.viewport[2]) && y >= this.viewport[1] && y < (this.viewport[1] + this.viewport[3]) );\n\n        //move mouse move event to the window in case it drags outside of the canvas\n\t\tif(!this.options.skip_events)\n\t\t{\n\t\t\tLiteGraph.pointerListenerRemove(this.canvas,"move", this._mousemove_callback);\n\t\t\tLiteGraph.pointerListenerAdd(ref_window.document,"move", this._mousemove_callback,true); //catch for the entire window\n\t\t\tLiteGraph.pointerListenerAdd(ref_window.document,"up", this._mouseup_callback,true);\n\t\t}\n\n\t\tif(!is_inside){\n\t\t\treturn;\n\t\t}\n\n        var node = this.graph.getNodeOnPos( e.canvasX, e.canvasY, this.visible_nodes, 5 );\n        var skip_dragging = false;\n        var skip_action = false;\n        var now = LiteGraph.getTime();\n\t\tvar is_primary = (e.isPrimary === undefined || !e.isPrimary);\n        var is_double_click = (now - this.last_mouseclick < 300) && is_primary;\n\t\tthis.mouse[0] = e.clientX;\n\t\tthis.mouse[1] = e.clientY;\n        this.graph_mouse[0] = e.canvasX;\n        this.graph_mouse[1] = e.canvasY;\n\t\tthis.last_click_position = [this.mouse[0],this.mouse[1]];\n\t  \t\n\t  \tif (this.pointer_is_down && is_primary ){\n\t\t  this.pointer_is_double = true;\n\t\t  //console.log("pointerevents: pointer_is_double start");\n\t\t}else{\n\t\t  this.pointer_is_double = false;\n\t\t}\n\t  \tthis.pointer_is_down = true;\n\t  \n\t  \t\n        this.canvas.focus();\n\n        LiteGraph.closeAllContextMenus(ref_window);\n\n        if (this.onMouse)\n\t\t{\n            if (this.onMouse(e) == true)\n                return;\n        }\n\n\t\t//left button mouse / single finger\n        if (e.which == 1 && !this.pointer_is_double)\n\t\t{\n            if (e.ctrlKey)\n\t\t\t{\n                this.dragging_rectangle = new Float32Array(4);\n                this.dragging_rectangle[0] = e.canvasX;\n                this.dragging_rectangle[1] = e.canvasY;\n                this.dragging_rectangle[2] = 1;\n                this.dragging_rectangle[3] = 1;\n                skip_action = true;\n            }\n\n            // clone node ALT dragging\n            if (LiteGraph.alt_drag_do_clone_nodes && e.altKey && node && this.allow_interaction && !skip_action && !this.read_only)\n            {\n                if (cloned = node.clone()){\n                    cloned.pos[0] += 5;\n                    cloned.pos[1] += 5;\n                    this.graph.add(cloned,false,{doCalcSize: false});\n                    node = cloned;\n                    skip_action = true;\n                    if (!block_drag_node) {\n                        if (this.allow_dragnodes) {\n\t\t\t\t\t\t\tthis.graph.beforeChange();\n                            this.node_dragged = node;\n                        }\n                        if (!this.selected_nodes[node.id]) {\n                            this.processNodeSelected(node, e);\n                        }\n                    }\n                }\n            }\n            \n            var clicking_canvas_bg = false;\n\n            //when clicked on top of a node\n            //and it is not interactive\n            if (node && (this.allow_interaction || node.flags.allow_interaction) && !skip_action && !this.read_only) {\n                if (!this.live_mode && !node.flags.pinned) {\n                    this.bringToFront(node);\n                } //if it wasn\'t selected?\n\n                //not dragging mouse to connect two slots\n                if ( this.allow_interaction && !this.connecting_node && !node.flags.collapsed && !this.live_mode ) {\n                    //Search for corner for resize\n                    if ( !skip_action &&\n                        node.resizable !== false &&\n                        isInsideRectangle( e.canvasX,\n                            e.canvasY,\n                            node.pos[0] + node.size[0] - 5,\n                            node.pos[1] + node.size[1] - 5,\n                            10,\n                            10\n                        )\n                    ) {\n\t\t\t\t\t\tthis.graph.beforeChange();\n                        this.resizing_node = node;\n                        this.canvas.style.cursor = "se-resize";\n                        skip_action = true;\n                    } else {\n                        //search for outputs\n                        if (node.outputs) {\n                            for ( var i = 0, l = node.outputs.length; i < l; ++i ) {\n                                var output = node.outputs[i];\n                                var link_pos = node.getConnectionPos(false, i);\n                                if (\n                                    isInsideRectangle(\n                                        e.canvasX,\n                                        e.canvasY,\n                                        link_pos[0] - 15,\n                                        link_pos[1] - 10,\n                                        30,\n                                        20\n                                    )\n                                ) {\n                                    this.connecting_node = node;\n                                    this.connecting_output = output;\n                                    this.connecting_output.slot_index = i;\n                                    this.connecting_pos = node.getConnectionPos( false, i );\n                                    this.connecting_slot = i;\n\n                                    if (LiteGraph.shift_click_do_break_link_from){\n                                        if (e.shiftKey) {\n                                            node.disconnectOutput(i);\n                                        }\n                                    }\n\n                                    if (is_double_click) {\n                                        if (node.onOutputDblClick) {\n                                            node.onOutputDblClick(i, e);\n                                        }\n                                    } else {\n                                        if (node.onOutputClick) {\n                                            node.onOutputClick(i, e);\n                                        }\n                                    }\n\n                                    skip_action = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        //search for inputs\n                        if (node.inputs) {\n                            for ( var i = 0, l = node.inputs.length; i < l; ++i ) {\n                                var input = node.inputs[i];\n                                var link_pos = node.getConnectionPos(true, i);\n                                if (\n                                    isInsideRectangle(\n                                        e.canvasX,\n                                        e.canvasY,\n                                        link_pos[0] - 15,\n                                        link_pos[1] - 10,\n                                        30,\n                                        20\n                                    )\n                                ) {\n                                    if (is_double_click) {\n                                        if (node.onInputDblClick) {\n                                            node.onInputDblClick(i, e);\n                                        }\n                                    } else {\n                                        if (node.onInputClick) {\n                                            node.onInputClick(i, e);\n                                        }\n                                    }\n\n                                    if (input.link !== null) {\n                                        var link_info = this.graph.links[\n                                            input.link\n                                        ]; //before disconnecting\n                                        if (LiteGraph.click_do_break_link_to){\n                                            node.disconnectInput(i);\n                                            this.dirty_bgcanvas = true;\n                                            skip_action = true;\n                                        }else{\n                                            // do same action as has not node ?\n                                        }\n\n                                        if (\n                                            this.allow_reconnect_links ||\n\t\t\t\t\t\t\t\t\t\t\t//this.move_destination_link_without_shift ||\n                                            e.shiftKey\n                                        ) {\n                                            if (!LiteGraph.click_do_break_link_to){\n                                                node.disconnectInput(i);\n                                            }\n                                            this.connecting_node = this.graph._nodes_by_id[\n                                                link_info.origin_id\n                                            ];\n                                            this.connecting_slot =\n                                                link_info.origin_slot;\n                                            this.connecting_output = this.connecting_node.outputs[\n                                                this.connecting_slot\n                                            ];\n                                            this.connecting_pos = this.connecting_node.getConnectionPos( false, this.connecting_slot );\n                                            \n                                            this.dirty_bgcanvas = true;\n                                            skip_action = true;\n                                        }\n\n                                        \n                                    }else{\n                                        // has not node\n                                    }\n                                    \n                                    if (!skip_action){\n                                        // connect from in to out, from to to from\n                                        this.connecting_node = node;\n                                        this.connecting_input = input;\n                                        this.connecting_input.slot_index = i;\n                                        this.connecting_pos = node.getConnectionPos( true, i );\n                                        this.connecting_slot = i;\n                                        \n                                        this.dirty_bgcanvas = true;\n                                        skip_action = true;\n                                    }\n                                }\n                            }\n                        }\n                    } //not resizing\n                }\n\n                //it wasn\'t clicked on the links boxes\n                if (!skip_action) {\n                    var block_drag_node = false;\n\t\t\t\t\tvar pos = [e.canvasX - node.pos[0], e.canvasY - node.pos[1]];\n\n                    //widgets\n                    var widget = this.processNodeWidgets( node, this.graph_mouse, e );\n                    if (widget) {\n                        block_drag_node = true;\n                        this.node_widget = [node, widget];\n                    }\n\n                    //double clicking\n                    if (this.allow_interaction && is_double_click && this.selected_nodes[node.id]) {\n                        //double click node\n                        if (node.onDblClick) {\n                            node.onDblClick( e, pos, this );\n                        }\n                        this.processNodeDblClicked(node);\n                        block_drag_node = true;\n                    }\n\n                    //if do not capture mouse\n                    if ( node.onMouseDown && node.onMouseDown( e, pos, this ) ) {\n                        block_drag_node = true;\n                    } else {\n\t\t\t\t\t\t//open subgraph button\n\t\t\t\t\t\tif(node.subgraph && !node.skip_subgraph_button)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( !node.flags.collapsed && pos[0] > node.size[0] - LiteGraph.NODE_TITLE_HEIGHT && pos[1] < 0 ) {\n\t\t\t\t\t\t\t\tvar that = this;\n\t\t\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\t\t\tthat.openSubgraph(node.subgraph);\n\t\t\t\t\t\t\t\t}, 10);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (this.live_mode) {\n\t\t\t\t\t\t\tclicking_canvas_bg = true;\n\t                        block_drag_node = true;\n\t\t\t\t\t\t}\n                    }\n\n                    if (!block_drag_node) {\n                        if (this.allow_dragnodes) {\n\t\t\t\t\t\t\tthis.graph.beforeChange();\n                            this.node_dragged = node;\n                        }\n                        this.processNodeSelected(node, e);\n                    } else { // double-click\n                        /**\n                         * Don\'t call the function if the block is already selected.\n                         * Otherwise, it could cause the block to be unselected while its panel is open.\n                         */\n                        if (!node.is_selected) this.processNodeSelected(node, e);\n                    }\n\n                    this.dirty_canvas = true;\n                }\n            } //clicked outside of nodes\n            else {\n\t\t\t\tif (!skip_action){\n\t\t\t\t\t//search for link connector\n\t\t\t\t\tif(!this.read_only) {\n\t\t\t\t\t\tfor (var i = 0; i < this.visible_links.length; ++i) {\n\t\t\t\t\t\t\tvar link = this.visible_links[i];\n\t\t\t\t\t\t\tvar center = link._pos;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!center ||\n\t\t\t\t\t\t\t\te.canvasX < center[0] - 4 ||\n\t\t\t\t\t\t\t\te.canvasX > center[0] + 4 ||\n\t\t\t\t\t\t\t\te.canvasY < center[1] - 4 ||\n\t\t\t\t\t\t\t\te.canvasY > center[1] + 4\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//link clicked\n\t\t\t\t\t\t\tthis.showLinkMenu(link, e);\n\t\t\t\t\t\t\tthis.over_link_center = null; //clear tooltip\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.selected_group = this.graph.getGroupOnPos( e.canvasX, e.canvasY );\n\t\t\t\t\tthis.selected_group_resizing = false;\n\t\t\t\t\tif (this.selected_group && !this.read_only ) {\n\t\t\t\t\t\tif (e.ctrlKey) {\n\t\t\t\t\t\t\tthis.dragging_rectangle = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar dist = distance( [e.canvasX, e.canvasY], [ this.selected_group.pos[0] + this.selected_group.size[0], this.selected_group.pos[1] + this.selected_group.size[1] ] );\n\t\t\t\t\t\tif (dist * this.ds.scale < 10) {\n\t\t\t\t\t\t\tthis.selected_group_resizing = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.selected_group.recomputeInsideNodes();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_double_click && !this.read_only && this.allow_searchbox) {\n\t\t\t\t\t\tthis.showSearchBox(e);\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t}\n\n\t\t\t\t\tclicking_canvas_bg = true;\n\t\t\t\t}\n            }\n\n            if (!skip_action && clicking_canvas_bg && this.allow_dragcanvas) {\n            \t//console.log("pointerevents: dragging_canvas start");\n            \tthis.dragging_canvas = true;\n            }\n            \n        } else if (e.which == 2) {\n            //middle button\n        \t\n\t\t\tif (LiteGraph.middle_click_slot_add_default_node){\n\t\t\t\tif (node && this.allow_interaction && !skip_action && !this.read_only){\n\t\t\t\t\t//not dragging mouse to connect two slots\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.connecting_node &&\n\t\t\t\t\t\t!node.flags.collapsed &&\n\t\t\t\t\t\t!this.live_mode\n\t\t\t\t\t) {\n\t\t\t\t\t\tvar mClikSlot = false;\n\t\t\t\t\t\tvar mClikSlot_index = false;\n\t\t\t\t\t\tvar mClikSlot_isOut = false;\n\t\t\t\t\t\t//search for outputs\n\t\t\t\t\t\tif (node.outputs) {\n\t\t\t\t\t\t\tfor ( var i = 0, l = node.outputs.length; i < l; ++i ) {\n\t\t\t\t\t\t\t\tvar output = node.outputs[i];\n\t\t\t\t\t\t\t\tvar link_pos = node.getConnectionPos(false, i);\n\t\t\t\t\t\t\t\tif (isInsideRectangle(e.canvasX,e.canvasY,link_pos[0] - 15,link_pos[1] - 10,30,20)) {\n\t\t\t\t\t\t\t\t\tmClikSlot = output;\n\t\t\t\t\t\t\t\t\tmClikSlot_index = i;\n\t\t\t\t\t\t\t\t\tmClikSlot_isOut = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//search for inputs\n\t\t\t\t\t\tif (node.inputs) {\n\t\t\t\t\t\t\tfor ( var i = 0, l = node.inputs.length; i < l; ++i ) {\n\t\t\t\t\t\t\t\tvar input = node.inputs[i];\n\t\t\t\t\t\t\t\tvar link_pos = node.getConnectionPos(true, i);\n\t\t\t\t\t\t\t\tif (isInsideRectangle(e.canvasX,e.canvasY,link_pos[0] - 15,link_pos[1] - 10,30,20)) {\n\t\t\t\t\t\t\t\t\tmClikSlot = input;\n\t\t\t\t\t\t\t\t\tmClikSlot_index = i;\n\t\t\t\t\t\t\t\t\tmClikSlot_isOut = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//console.log("middleClickSlots? "+mClikSlot+" & "+(mClikSlot_index!==false));\n\t\t\t\t\t\tif (mClikSlot && mClikSlot_index!==false){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar alphaPosY = 0.5-((mClikSlot_index+1)/((mClikSlot_isOut?node.outputs.length:node.inputs.length)));\n\t\t\t\t\t\t\tvar node_bounding = node.getBounding();\n\t\t\t\t\t\t\t// estimate a position: this is a bad semi-bad-working mess .. REFACTOR with a correct autoplacement that knows about the others slots and nodes\n\t\t\t\t\t\t\tvar posRef = [\t(!mClikSlot_isOut?node_bounding[0]:node_bounding[0]+node_bounding[2])// + node_bounding[0]/this.canvas.width*150\n\t\t\t\t\t\t\t\t\t\t\t,e.canvasY-80// + node_bounding[0]/this.canvas.width*66 // vertical "derive"\n\t\t\t\t\t\t\t\t\t\t  ];\n\t\t\t\t\t\t\tvar nodeCreated = this.createDefaultNodeForSlot({   \tnodeFrom: !mClikSlot_isOut?null:node\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,slotFrom: !mClikSlot_isOut?null:mClikSlot_index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,nodeTo: !mClikSlot_isOut?node:null\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,slotTo: !mClikSlot_isOut?mClikSlot_index:null\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,position: posRef //,e: e\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,nodeType: "AUTO" //nodeNewType\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,posAdd:[!mClikSlot_isOut?-30:30, -alphaPosY*130] //-alphaPosY*30]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,posSizeFix:[!mClikSlot_isOut?-1:0, 0] //-alphaPosY*2*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!skip_action && this.allow_dragcanvas) {\n            \t//console.log("pointerevents: dragging_canvas start from middle button");\n            \tthis.dragging_canvas = true;\n            }\n\n        \t\n        } else if (e.which == 3 || this.pointer_is_double) {\n\t\t\t\n            //right button\n\t\t\tif (this.allow_interaction && !skip_action && !this.read_only){\n\t\t\t\t\n\t\t\t\t// is it hover a node ?\n\t\t\t\tif (node){\n\t\t\t\t\tif(Object.keys(this.selected_nodes).length\n\t\t\t\t\t   && (this.selected_nodes[node.id] || e.shiftKey || e.ctrlKey || e.metaKey)\n\t\t\t\t\t){\n\t\t\t\t\t\t// is multiselected or using shift to include the now node\n\t\t\t\t\t\tif (!this.selected_nodes[node.id]) this.selectNodes([node],true); // add this if not present\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// update selection\n\t\t\t\t\t\tthis.selectNodes([node]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// show menu on this node\n\t\t\t\tthis.processContextMenu(node, e);\n\t\t\t}\n\t\t\t\n        }\n\n        //TODO\n        //if(this.node_selected != prev_selected)\n        //\tthis.onNodeSelectionChange(this.node_selected);\n\n        this.last_mouse[0] = e.clientX;\n        this.last_mouse[1] = e.clientY;\n        this.last_mouseclick = LiteGraph.getTime();\n        this.last_mouse_dragging = true;\n\n        /*\n\tif( (this.dirty_canvas || this.dirty_bgcanvas) && this.rendering_timer_id == null)\n\t\tthis.draw();\n\t*/\n\n        this.graph.change();\n\n        //this is to ensure to defocus(blur) if a text input element is on focus\n        if (\n            !ref_window.document.activeElement ||\n            (ref_window.document.activeElement.nodeName.toLowerCase() !=\n                "input" &&\n                ref_window.document.activeElement.nodeName.toLowerCase() !=\n                    "textarea")\n        ) {\n            e.preventDefault();\n        }\n        e.stopPropagation();\n\n        if (this.onMouseDown) {\n            this.onMouseDown(e);\n        }\n\n        return false;\n    };\n\n    /**\n     * Called when a mouse move event has to be processed\n     * @method processMouseMove\n     **/\n    LGraphCanvas.prototype.processMouseMove = function(e) {\n        if (this.autoresize) {\n            this.resize();\n        }\n\n\t\tif( this.set_canvas_dirty_on_mouse_event )\n\t\t\tthis.dirty_canvas = true;\n\n        if (!this.graph) {\n            return;\n        }\n\n        LGraphCanvas.active_canvas = this;\n        this.adjustMouseEvent(e);\n        var mouse = [e.clientX, e.clientY];\n\t\tthis.mouse[0] = mouse[0];\n\t\tthis.mouse[1] = mouse[1];\n        var delta = [\n            mouse[0] - this.last_mouse[0],\n            mouse[1] - this.last_mouse[1]\n        ];\n        this.last_mouse = mouse;\n        this.graph_mouse[0] = e.canvasX;\n        this.graph_mouse[1] = e.canvasY;\n\n        //console.log("pointerevents: processMouseMove "+e.pointerId+" "+e.isPrimary);\n        \n\t\tif(this.block_click)\n\t\t{\n\t\t\t//console.log("pointerevents: processMouseMove block_click");\n\t\t\te.preventDefault();\n\t\t\treturn false;\n\t\t}\n\n        e.dragging = this.last_mouse_dragging;\n\n        if (this.node_widget) {\n            this.processNodeWidgets(\n                this.node_widget[0],\n                this.graph_mouse,\n                e,\n                this.node_widget[1]\n            );\n            this.dirty_canvas = true;\n        }\n\n        //get node over\n        var node = this.graph.getNodeOnPos(e.canvasX,e.canvasY,this.visible_nodes);\n\n        if (this.dragging_rectangle)\n\t\t{\n            this.dragging_rectangle[2] = e.canvasX - this.dragging_rectangle[0];\n            this.dragging_rectangle[3] = e.canvasY - this.dragging_rectangle[1];\n            this.dirty_canvas = true;\n        } \n\t\telse if (this.selected_group && !this.read_only)\n\t\t{\n            //moving/resizing a group\n            if (this.selected_group_resizing) {\n                this.selected_group.size = [\n                    e.canvasX - this.selected_group.pos[0],\n                    e.canvasY - this.selected_group.pos[1]\n                ];\n            } else {\n                var deltax = delta[0] / this.ds.scale;\n                var deltay = delta[1] / this.ds.scale;\n                this.selected_group.move(deltax, deltay, e.ctrlKey);\n                if (this.selected_group._nodes.length) {\n                    this.dirty_canvas = true;\n                }\n            }\n            this.dirty_bgcanvas = true;\n        } else if (this.dragging_canvas) {\n        \t////console.log("pointerevents: processMouseMove is dragging_canvas");\n            this.ds.offset[0] += delta[0] / this.ds.scale;\n            this.ds.offset[1] += delta[1] / this.ds.scale;\n            this.dirty_canvas = true;\n            this.dirty_bgcanvas = true;\n        } else if ((this.allow_interaction || (node && node.flags.allow_interaction)) && !this.read_only) {\n            if (this.connecting_node) {\n                this.dirty_canvas = true;\n            }\n\n            //remove mouseover flag\n            for (var i = 0, l = this.graph._nodes.length; i < l; ++i) {\n                if (this.graph._nodes[i].mouseOver && node != this.graph._nodes[i] ) {\n                    //mouse leave\n                    this.graph._nodes[i].mouseOver = false;\n                    if (this.node_over && this.node_over.onMouseLeave) {\n                        this.node_over.onMouseLeave(e);\n                    }\n                    this.node_over = null;\n                    this.dirty_canvas = true;\n                }\n            }\n\n            //mouse over a node\n            if (node) {\n\n\t\t\t\tif(node.redraw_on_mouse)\n                    this.dirty_canvas = true;\n\n                //this.canvas.style.cursor = "move";\n                if (!node.mouseOver) {\n                    //mouse enter\n                    node.mouseOver = true;\n                    this.node_over = node;\n                    this.dirty_canvas = true;\n\n                    if (node.onMouseEnter) {\n                        node.onMouseEnter(e);\n                    }\n                }\n\n                //in case the node wants to do something\n                if (node.onMouseMove) {\n                    node.onMouseMove( e, [e.canvasX - node.pos[0], e.canvasY - node.pos[1]], this );\n                }\n\n                //if dragging a link\n                if (this.connecting_node) {\n                    \n                    if (this.connecting_output){\n                        \n                        var pos = this._highlight_input || [0, 0]; //to store the output of isOverNodeInput\n\n                        //on top of input\n                        if (this.isOverNodeBox(node, e.canvasX, e.canvasY)) {\n                            //mouse on top of the corner box, don\'t know what to do\n                        } else {\n                            //check if I have a slot below de mouse\n                            var slot = this.isOverNodeInput( node, e.canvasX, e.canvasY, pos );\n                            if (slot != -1 && node.inputs[slot]) {\n                                var slot_type = node.inputs[slot].type;\n                                if ( LiteGraph.isValidConnection( this.connecting_output.type, slot_type ) ) {\n                                    this._highlight_input = pos;\n\t\t\t\t\t\t\t\t\tthis._highlight_input_slot = node.inputs[slot]; // XXX CHECK THIS\n                                }\n                            } else {\n                                this._highlight_input = null;\n\t\t\t\t\t\t\t\tthis._highlight_input_slot = null;  // XXX CHECK THIS\n                            }\n                        }\n                        \n                    }else if(this.connecting_input){\n                        \n                        var pos = this._highlight_output || [0, 0]; //to store the output of isOverNodeOutput\n\n                        //on top of output\n                        if (this.isOverNodeBox(node, e.canvasX, e.canvasY)) {\n                            //mouse on top of the corner box, don\'t know what to do\n                        } else {\n                            //check if I have a slot below de mouse\n                            var slot = this.isOverNodeOutput( node, e.canvasX, e.canvasY, pos );\n                            if (slot != -1 && node.outputs[slot]) {\n                                var slot_type = node.outputs[slot].type;\n                                if ( LiteGraph.isValidConnection( this.connecting_input.type, slot_type ) ) {\n                                    this._highlight_output = pos;\n                                }\n                            } else {\n                                this._highlight_output = null;\n                            }\n                        }\n                    }\n                }\n\n                //Search for corner\n                if (this.canvas) {\n                    if (\n                        isInsideRectangle(\n                            e.canvasX,\n                            e.canvasY,\n                            node.pos[0] + node.size[0] - 5,\n                            node.pos[1] + node.size[1] - 5,\n                            5,\n                            5\n                        )\n                    ) {\n                        this.canvas.style.cursor = "se-resize";\n                    } else {\n                        this.canvas.style.cursor = "crosshair";\n                    }\n                }\n            } else { //not over a node\n\n                //search for link connector\n\t\t\t\tvar over_link = null;\n\t\t\t\tfor (var i = 0; i < this.visible_links.length; ++i) {\n\t\t\t\t\tvar link = this.visible_links[i];\n\t\t\t\t\tvar center = link._pos;\n\t\t\t\t\tif (\n\t\t\t\t\t\t!center ||\n\t\t\t\t\t\te.canvasX < center[0] - 4 ||\n\t\t\t\t\t\te.canvasX > center[0] + 4 ||\n\t\t\t\t\t\te.canvasY < center[1] - 4 ||\n\t\t\t\t\t\te.canvasY > center[1] + 4\n\t\t\t\t\t) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tover_link = link;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( over_link != this.over_link_center )\n\t\t\t\t{\n\t\t\t\t\tthis.over_link_center = over_link;\n\t                this.dirty_canvas = true;\n\t\t\t\t}\n\n\t\t\t\tif (this.canvas) {\n\t                this.canvas.style.cursor = "";\n\t\t\t\t}\n\t\t\t} //end\n\n\t\t\t//send event to node if capturing input (used with widgets that allow drag outside of the area of the node)\n            if ( this.node_capturing_input && this.node_capturing_input != node && this.node_capturing_input.onMouseMove ) {\n                this.node_capturing_input.onMouseMove(e,[e.canvasX - this.node_capturing_input.pos[0],e.canvasY - this.node_capturing_input.pos[1]], this);\n            }\n\n\t\t\t//node being dragged\n            if (this.node_dragged && !this.live_mode) {\n\t\t\t\t//console.log("draggin!",this.selected_nodes);\n                for (var i in this.selected_nodes) {\n                    var n = this.selected_nodes[i];\n                    n.pos[0] += delta[0] / this.ds.scale;\n                    n.pos[1] += delta[1] / this.ds.scale;\n                    if (!n.is_selected) this.processNodeSelected(n, e); /*\n                     * Don\'t call the function if the block is already selected.\n                     * Otherwise, it could cause the block to be unselected while dragging.\n                     */\n                }\n\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n            }\n\n            if (this.resizing_node && !this.live_mode) {\n                //convert mouse to node space\n\t\t\t\tvar desired_size = [ e.canvasX - this.resizing_node.pos[0], e.canvasY - this.resizing_node.pos[1] ];\n\t\t\t\tvar min_size = this.resizing_node.computeSize();\n\t\t\t\tdesired_size[0] = Math.max( min_size[0], desired_size[0] );\n\t\t\t\tdesired_size[1] = Math.max( min_size[1], desired_size[1] );\n\t\t\t\tthis.resizing_node.setSize( desired_size );\n\n                this.canvas.style.cursor = "se-resize";\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n            }\n        }\n\n        e.preventDefault();\n        return false;\n    };\n\n    /**\n     * Called when a mouse up event has to be processed\n     * @method processMouseUp\n     **/\n    LGraphCanvas.prototype.processMouseUp = function(e) {\n\n\t\tvar is_primary = ( e.isPrimary === undefined || e.isPrimary );\n\n    \t//early exit for extra pointer\n    \tif(!is_primary){\n    \t\t/*e.stopPropagation();\n        \te.preventDefault();*/\n    \t\t//console.log("pointerevents: processMouseUp pointerN_stop "+e.pointerId+" "+e.isPrimary);\n    \t\treturn false;\n    \t}\n    \t\n    \t//console.log("pointerevents: processMouseUp "+e.pointerId+" "+e.isPrimary+" :: "+e.clientX+" "+e.clientY);\n    \t\n\t\tif( this.set_canvas_dirty_on_mouse_event )\n\t\t\tthis.dirty_canvas = true;\n\n        if (!this.graph)\n            return;\n\n        var window = this.getCanvasWindow();\n        var document = window.document;\n        LGraphCanvas.active_canvas = this;\n\n        //restore the mousemove event back to the canvas\n\t\tif(!this.options.skip_events)\n\t\t{\n\t\t\t//console.log("pointerevents: processMouseUp adjustEventListener");\n\t\t\tLiteGraph.pointerListenerRemove(document,"move", this._mousemove_callback,true);\n\t\t\tLiteGraph.pointerListenerAdd(this.canvas,"move", this._mousemove_callback,true);\n\t\t\tLiteGraph.pointerListenerRemove(document,"up", this._mouseup_callback,true);\n\t\t}\n\n        this.adjustMouseEvent(e);\n        var now = LiteGraph.getTime();\n        e.click_time = now - this.last_mouseclick;\n        this.last_mouse_dragging = false;\n\t\tthis.last_click_position = null;\n\n\t\tif(this.block_click)\n\t\t{\n\t\t\t//console.log("pointerevents: processMouseUp block_clicks");\n\t\t\tthis.block_click = false; //used to avoid sending twice a click in a immediate button\n\t\t}\n\n\t\t//console.log("pointerevents: processMouseUp which: "+e.which);\n\t\t\n        if (e.which == 1) {\n\n\t\t\tif( this.node_widget )\n\t\t\t{\n\t\t\t\tthis.processNodeWidgets( this.node_widget[0], this.graph_mouse, e );\n\t\t\t}\n\n            //left button\n            this.node_widget = null;\n\n            if (this.selected_group) {\n                var diffx =\n                    this.selected_group.pos[0] -\n                    Math.round(this.selected_group.pos[0]);\n                var diffy =\n                    this.selected_group.pos[1] -\n                    Math.round(this.selected_group.pos[1]);\n                this.selected_group.move(diffx, diffy, e.ctrlKey);\n                this.selected_group.pos[0] = Math.round(\n                    this.selected_group.pos[0]\n                );\n                this.selected_group.pos[1] = Math.round(\n                    this.selected_group.pos[1]\n                );\n                if (this.selected_group._nodes.length) {\n                    this.dirty_canvas = true;\n                }\n                this.selected_group = null;\n            }\n            this.selected_group_resizing = false;\n\n\t\t\tvar node = this.graph.getNodeOnPos(\n\t\t\t\t\t\t\te.canvasX,\n\t\t\t\t\t\t\te.canvasY,\n\t\t\t\t\t\t\tthis.visible_nodes\n\t\t\t\t\t\t);\n\t\t\t\n            if (this.dragging_rectangle) {\n                if (this.graph) {\n                    var nodes = this.graph._nodes;\n                    var node_bounding = new Float32Array(4);\n                    \n                    //compute bounding and flip if left to right\n                    var w = Math.abs(this.dragging_rectangle[2]);\n                    var h = Math.abs(this.dragging_rectangle[3]);\n                    var startx =\n                        this.dragging_rectangle[2] < 0\n                            ? this.dragging_rectangle[0] - w\n                            : this.dragging_rectangle[0];\n                    var starty =\n                        this.dragging_rectangle[3] < 0\n                            ? this.dragging_rectangle[1] - h\n                            : this.dragging_rectangle[1];\n                    this.dragging_rectangle[0] = startx;\n                    this.dragging_rectangle[1] = starty;\n                    this.dragging_rectangle[2] = w;\n                    this.dragging_rectangle[3] = h;\n\n\t\t\t\t\t// test dragging rect size, if minimun simulate a click\n\t\t\t\t\tif (!node || (w > 10 && h > 10 )){\n\t\t\t\t\t\t//test against all nodes (not visible because the rectangle maybe start outside\n\t\t\t\t\t\tvar to_select = [];\n\t\t\t\t\t\tfor (var i = 0; i < nodes.length; ++i) {\n\t\t\t\t\t\t\tvar nodeX = nodes[i];\n\t\t\t\t\t\t\tnodeX.getBounding(node_bounding);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!overlapBounding(\n\t\t\t\t\t\t\t\t\tthis.dragging_rectangle,\n\t\t\t\t\t\t\t\t\tnode_bounding\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} //out of the visible area\n\t\t\t\t\t\t\tto_select.push(nodeX);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (to_select.length) {\n\t\t\t\t\t\t\tthis.selectNodes(to_select,e.shiftKey); // add to selection with shift\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// will select of update selection\n\t\t\t\t\t\tthis.selectNodes([node],e.shiftKey||e.ctrlKey); // add to selection add to selection with ctrlKey or shiftKey\n\t\t\t\t\t}\n\t\t\t\t\t\n                }\n                this.dragging_rectangle = null;\n            } else if (this.connecting_node) {\n                //dragging a connection\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n\n                var connInOrOut = this.connecting_output || this.connecting_input;\n                var connType = connInOrOut.type;\n                \n                //node below mouse\n                if (node) {\n                    \n                    /* no need to condition on event type.. just another type\n                    if (\n                        connType == LiteGraph.EVENT &&\n                        this.isOverNodeBox(node, e.canvasX, e.canvasY)\n                    ) {\n                        \n                        this.connecting_node.connect(\n                            this.connecting_slot,\n                            node,\n                            LiteGraph.EVENT\n                        );\n                        \n                    } else {*/\n                        \n                        //slot below mouse? connect\n                        \n                        if (this.connecting_output){\n                            \n                            var slot = this.isOverNodeInput(\n                                node,\n                                e.canvasX,\n                                e.canvasY\n                            );\n                            if (slot != -1) {\n                                this.connecting_node.connect(this.connecting_slot, node, slot);\n                            } else {\n                                //not on top of an input\n                                // look for a good slot\n                                this.connecting_node.connectByType(this.connecting_slot,node,connType);\n                            }\n                            \n                        }else if (this.connecting_input){\n                            \n                            var slot = this.isOverNodeOutput(\n                                node,\n                                e.canvasX,\n                                e.canvasY\n                            );\n\n                            if (slot != -1) {\n                                node.connect(slot, this.connecting_node, this.connecting_slot); // this is inverted has output-input nature like\n                            } else {\n                                //not on top of an input\n                                // look for a good slot\n                                this.connecting_node.connectByTypeOutput(this.connecting_slot,node,connType);\n                            }\n                            \n                        }\n                        \n                        \n                    //}\n                    \n                }else{\n                    \n                    // add menu when releasing link in empty space\n                \tif (LiteGraph.release_link_on_empty_shows_menu){\n\t                    if (e.shiftKey && this.allow_searchbox){\n\t                        if(this.connecting_output){\n\t                            this.showSearchBox(e,{node_from: this.connecting_node, slot_from: this.connecting_output, type_filter_in: this.connecting_output.type});\n\t                        }else if(this.connecting_input){\n\t                            this.showSearchBox(e,{node_to: this.connecting_node, slot_from: this.connecting_input, type_filter_out: this.connecting_input.type});\n\t                        }\n\t                    }else{\n\t                        if(this.connecting_output){\n\t                            this.showConnectionMenu({nodeFrom: this.connecting_node, slotFrom: this.connecting_output, e: e});\n\t                        }else if(this.connecting_input){\n\t                            this.showConnectionMenu({nodeTo: this.connecting_node, slotTo: this.connecting_input, e: e});\n\t                        }\n\t                    }\n                \t}\n                }\n\n                this.connecting_output = null;\n                this.connecting_input = null;\n                this.connecting_pos = null;\n                this.connecting_node = null;\n                this.connecting_slot = -1;\n            } //not dragging connection\n            else if (this.resizing_node) {\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n\t\t\t\tthis.graph.afterChange(this.resizing_node);\n                this.resizing_node = null;\n            } else if (this.node_dragged) {\n                //node being dragged?\n                var node = this.node_dragged;\n                if (\n                    node &&\n                    e.click_time < 300 &&\n                    isInsideRectangle( e.canvasX, e.canvasY, node.pos[0], node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT )\n                ) {\n                    node.collapse();\n                }\n\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n                this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]);\n                this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]);\n                if (this.graph.config.align_to_grid || this.align_to_grid ) {\n                    this.node_dragged.alignToGrid();\n                }\n\t\t\t\tif( this.onNodeMoved )\n\t\t\t\t\tthis.onNodeMoved( this.node_dragged );\n\t\t\t\tthis.graph.afterChange(this.node_dragged);\n                this.node_dragged = null;\n            } //no node being dragged\n            else {\n                //get node over\n                var node = this.graph.getNodeOnPos(\n                    e.canvasX,\n                    e.canvasY,\n                    this.visible_nodes\n                );\n\n                if (!node && e.click_time < 300) {\n                    this.deselectAllNodes();\n                }\n\n                this.dirty_canvas = true;\n                this.dragging_canvas = false;\n\n                if (this.node_over && this.node_over.onMouseUp) {\n                    this.node_over.onMouseUp( e, [ e.canvasX - this.node_over.pos[0], e.canvasY - this.node_over.pos[1] ], this );\n                }\n                if (\n                    this.node_capturing_input &&\n                    this.node_capturing_input.onMouseUp\n                ) {\n                    this.node_capturing_input.onMouseUp(e, [\n                        e.canvasX - this.node_capturing_input.pos[0],\n                        e.canvasY - this.node_capturing_input.pos[1]\n                    ]);\n                }\n            }\n        } else if (e.which == 2) {\n            //middle button\n            //trace("middle");\n            this.dirty_canvas = true;\n            this.dragging_canvas = false;\n        } else if (e.which == 3) {\n            //right button\n            //trace("right");\n            this.dirty_canvas = true;\n            this.dragging_canvas = false;\n        }\n\n        /*\n\t\tif((this.dirty_canvas || this.dirty_bgcanvas) && this.rendering_timer_id == null)\n\t\t\tthis.draw();\n\t\t*/\n\n\t  \tif (is_primary)\n\t\t{\n\t\t\tthis.pointer_is_down = false;\n\t\t\tthis.pointer_is_double = false;\n\t\t}\n\t  \n        this.graph.change();\n\n        //console.log("pointerevents: processMouseUp stopPropagation");\n        e.stopPropagation();\n        e.preventDefault();\n        return false;\n    };\n\n    /**\n     * Called when a mouse wheel event has to be processed\n     * @method processMouseWheel\n     **/\n    LGraphCanvas.prototype.processMouseWheel = function(e) {\n        if (!this.graph || !this.allow_dragcanvas) {\n            return;\n        }\n\n        var delta = e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;\n\n        this.adjustMouseEvent(e);\n\n\t\tvar x = e.clientX;\n\t\tvar y = e.clientY;\n\t\tvar is_inside = !this.viewport || ( this.viewport && x >= this.viewport[0] && x < (this.viewport[0] + this.viewport[2]) && y >= this.viewport[1] && y < (this.viewport[1] + this.viewport[3]) );\n\t\tif(!is_inside)\n\t\t\treturn;\n\n        var scale = this.ds.scale;\n\n        if (delta > 0) {\n            scale *= 1.1;\n        } else if (delta < 0) {\n            scale *= 1 / 1.1;\n        }\n\n        //this.setZoom( scale, [ e.clientX, e.clientY ] );\n        this.ds.changeScale(scale, [e.clientX, e.clientY]);\n\n        this.graph.change();\n\n        e.preventDefault();\n        return false; // prevent default\n    };\n\n    /**\n     * returns true if a position (in graph space) is on top of a node little corner box\n     * @method isOverNodeBox\n     **/\n    LGraphCanvas.prototype.isOverNodeBox = function(node, canvasx, canvasy) {\n        var title_height = LiteGraph.NODE_TITLE_HEIGHT;\n        if (\n            isInsideRectangle(\n                canvasx,\n                canvasy,\n                node.pos[0] + 2,\n                node.pos[1] + 2 - title_height,\n                title_height - 4,\n                title_height - 4\n            )\n        ) {\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * returns the INDEX if a position (in graph space) is on top of a node input slot\n     * @method isOverNodeInput\n     **/\n    LGraphCanvas.prototype.isOverNodeInput = function(\n        node,\n        canvasx,\n        canvasy,\n        slot_pos\n    ) {\n        if (node.inputs) {\n            for (var i = 0, l = node.inputs.length; i < l; ++i) {\n                var input = node.inputs[i];\n                var link_pos = node.getConnectionPos(true, i);\n                var is_inside = false;\n                if (node.horizontal) {\n                    is_inside = isInsideRectangle(\n                        canvasx,\n                        canvasy,\n                        link_pos[0] - 5,\n                        link_pos[1] - 10,\n                        10,\n                        20\n                    );\n                } else {\n                    is_inside = isInsideRectangle(\n                        canvasx,\n                        canvasy,\n                        link_pos[0] - 10,\n                        link_pos[1] - 5,\n                        40,\n                        10\n                    );\n                }\n                if (is_inside) {\n                    if (slot_pos) {\n                        slot_pos[0] = link_pos[0];\n                        slot_pos[1] = link_pos[1];\n                    }\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n    \n    /**\n     * returns the INDEX if a position (in graph space) is on top of a node output slot\n     * @method isOverNodeOuput\n     **/\n    LGraphCanvas.prototype.isOverNodeOutput = function(\n        node,\n        canvasx,\n        canvasy,\n        slot_pos\n    ) {\n        if (node.outputs) {\n            for (var i = 0, l = node.outputs.length; i < l; ++i) {\n                var output = node.outputs[i];\n                var link_pos = node.getConnectionPos(false, i);\n                var is_inside = false;\n                if (node.horizontal) {\n                    is_inside = isInsideRectangle(\n                        canvasx,\n                        canvasy,\n                        link_pos[0] - 5,\n                        link_pos[1] - 10,\n                        10,\n                        20\n                    );\n                } else {\n                    is_inside = isInsideRectangle(\n                        canvasx,\n                        canvasy,\n                        link_pos[0] - 10,\n                        link_pos[1] - 5,\n                        40,\n                        10\n                    );\n                }\n                if (is_inside) {\n                    if (slot_pos) {\n                        slot_pos[0] = link_pos[0];\n                        slot_pos[1] = link_pos[1];\n                    }\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * process a key event\n     * @method processKey\n     **/\n    LGraphCanvas.prototype.processKey = function(e) {\n        if (!this.graph) {\n            return;\n        }\n\n        var block_default = false;\n        //console.log(e); //debug\n\n        if (e.target.localName == "input") {\n            return;\n        }\n\n        if (e.type == "keydown") {\n            if (e.keyCode == 32) {\n                //space\n                this.dragging_canvas = true;\n                block_default = true;\n            }\n            \n            if (e.keyCode == 27) {\n                //esc\n                if(this.node_panel) this.node_panel.close();\n                if(this.options_panel) this.options_panel.close();\n                block_default = true;\n            }\n\n            //select all Control A\n            if (e.keyCode == 65 && e.ctrlKey) {\n                this.selectNodes();\n                block_default = true;\n            }\n\n            if ((e.keyCode === 67) && (e.metaKey || e.ctrlKey) && !e.shiftKey) {\n                //copy\n                if (this.selected_nodes) {\n                    this.copyToClipboard();\n                    block_default = true;\n                }\n            }\n\n            if ((e.keyCode === 86) && (e.metaKey || e.ctrlKey)) {\n                //paste\n                this.pasteFromClipboard(e.shiftKey);\n            }\n\n            //delete or backspace\n            if (e.keyCode == 46 || e.keyCode == 8) {\n                if (\n                    e.target.localName != "input" &&\n                    e.target.localName != "textarea"\n                ) {\n                    this.deleteSelectedNodes();\n                    block_default = true;\n                }\n            }\n\n            //collapse\n            //...\n\n            //TODO\n            if (this.selected_nodes) {\n                for (var i in this.selected_nodes) {\n                    if (this.selected_nodes[i].onKeyDown) {\n                        this.selected_nodes[i].onKeyDown(e);\n                    }\n                }\n            }\n        } else if (e.type == "keyup") {\n            if (e.keyCode == 32) {\n                // space\n                this.dragging_canvas = false;\n            }\n\n            if (this.selected_nodes) {\n                for (var i in this.selected_nodes) {\n                    if (this.selected_nodes[i].onKeyUp) {\n                        this.selected_nodes[i].onKeyUp(e);\n                    }\n                }\n            }\n        }\n\n        this.graph.change();\n\n        if (block_default) {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            return false;\n        }\n    };\n\n    LGraphCanvas.prototype.copyToClipboard = function() {\n        var clipboard_info = {\n            nodes: [],\n            links: []\n        };\n        var index = 0;\n        var selected_nodes_array = [];\n        for (var i in this.selected_nodes) {\n            var node = this.selected_nodes[i];\n            if (node.clonable === false)\n                continue;\n            node._relative_id = index;\n            selected_nodes_array.push(node);\n            index += 1;\n        }\n\n        for (var i = 0; i < selected_nodes_array.length; ++i) {\n            var node = selected_nodes_array[i];\n            if(node.clonable === false)\n                continue;\n            var cloned = node.clone();\n            if(!cloned)\n            {\n                console.warn("node type not found: " + node.type );\n                continue;\n            }\n            clipboard_info.nodes.push(cloned.serialize());\n            if (node.inputs && node.inputs.length) {\n                for (var j = 0; j < node.inputs.length; ++j) {\n                    var input = node.inputs[j];\n                    if (!input || input.link == null) {\n                        continue;\n                    }\n                    var link_info = this.graph.links[input.link];\n                    if (!link_info) {\n                        continue;\n                    }\n                    var target_node = this.graph.getNodeById(\n                        link_info.origin_id\n                    );\n                    if (!target_node) {\n                        continue;\n                    }\n                    clipboard_info.links.push([\n                        target_node._relative_id,\n                        link_info.origin_slot, //j,\n                        node._relative_id,\n                        link_info.target_slot,\n                        target_node.id\n                    ]);\n                }\n            }\n        }\n        localStorage.setItem(\n            "litegrapheditor_clipboard",\n            JSON.stringify(clipboard_info)\n        );\n    };\n\n    LGraphCanvas.prototype.pasteFromClipboard = function(isConnectUnselected = false) {\n        // if ctrl + shift + v is off, return when isConnectUnselected is true (shift is pressed) to maintain old behavior\n        if (!LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && isConnectUnselected) {\n            return;\n        }\n        var data = localStorage.getItem("litegrapheditor_clipboard");\n        if (!data) {\n            return;\n        }\n\n\t\tthis.graph.beforeChange();\n\n        //create nodes\n        var clipboard_info = JSON.parse(data);\n        // calculate top-left node, could work without this processing but using diff with last node pos :: clipboard_info.nodes[clipboard_info.nodes.length-1].pos\n        var posMin = false;\n        var posMinIndexes = false;\n        for (var i = 0; i < clipboard_info.nodes.length; ++i) {\n            if (posMin){\n                if(posMin[0]>clipboard_info.nodes[i].pos[0]){\n                    posMin[0] = clipboard_info.nodes[i].pos[0];\n                    posMinIndexes[0] = i;\n                }\n                if(posMin[1]>clipboard_info.nodes[i].pos[1]){\n                    posMin[1] = clipboard_info.nodes[i].pos[1];\n                    posMinIndexes[1] = i;\n                }\n            }\n            else{\n                posMin = [clipboard_info.nodes[i].pos[0], clipboard_info.nodes[i].pos[1]];\n                posMinIndexes = [i, i];\n            }\n        }\n        var nodes = [];\n        for (var i = 0; i < clipboard_info.nodes.length; ++i) {\n            var node_data = clipboard_info.nodes[i];\n            var node = LiteGraph.createNode(node_data.type);\n            if (node) {\n                node.configure(node_data);\n        \n\t\t\t\t//paste in last known mouse position\n                node.pos[0] += this.graph_mouse[0] - posMin[0]; //+= 5;\n                node.pos[1] += this.graph_mouse[1] - posMin[1]; //+= 5;\n\n                this.graph.add(node,{doProcessChange:false});\n                \n                nodes.push(node);\n            }\n        }\n\n        //create links\n        for (var i = 0; i < clipboard_info.links.length; ++i) {\n            var link_info = clipboard_info.links[i];\n            var origin_node;\n            var origin_node_relative_id = link_info[0];\n            if (origin_node_relative_id != null) {\n                origin_node = nodes[origin_node_relative_id];\n            } else if (LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && isConnectUnselected) {\n                var origin_node_id = link_info[4];\n                if (origin_node_id) {\n                    origin_node = this.graph.getNodeById(origin_node_id);\n                }\n            }\n            var target_node = nodes[link_info[2]];\n\t\t\tif( origin_node && target_node )\n\t            origin_node.connect(link_info[1], target_node, link_info[3]);\n\t\t\telse\n\t\t\t\tconsole.warn("Warning, nodes missing on pasting");\n        }\n\n        this.selectNodes(nodes);\n\n\t\tthis.graph.afterChange();\n    };\n\n    /**\n     * process a item drop event on top the canvas\n     * @method processDrop\n     **/\n    LGraphCanvas.prototype.processDrop = function(e) {\n        e.preventDefault();\n        this.adjustMouseEvent(e);\n\t\tvar x = e.clientX;\n\t\tvar y = e.clientY;\n\t\tvar is_inside = !this.viewport || ( this.viewport && x >= this.viewport[0] && x < (this.viewport[0] + this.viewport[2]) && y >= this.viewport[1] && y < (this.viewport[1] + this.viewport[3]) );\n\t\tif(!is_inside){\n\t\t\treturn;\n\t\t\t// --- BREAK ---\n\t\t}\n\n        var pos = [e.canvasX, e.canvasY];\n\n\n        var node = this.graph ? this.graph.getNodeOnPos(pos[0], pos[1]) : null;\n\n        if (!node) {\n            var r = null;\n            if (this.onDropItem) {\n                r = this.onDropItem(event);\n            }\n            if (!r) {\n                this.checkDropItem(e);\n            }\n            return;\n        }\n\n        if (node.onDropFile || node.onDropData) {\n            var files = e.dataTransfer.files;\n            if (files && files.length) {\n                for (var i = 0; i < files.length; i++) {\n                    var file = e.dataTransfer.files[0];\n                    var filename = file.name;\n                    var ext = LGraphCanvas.getFileExtension(filename);\n                    //console.log(file);\n\n                    if (node.onDropFile) {\n                        node.onDropFile(file);\n                    }\n\n                    if (node.onDropData) {\n                        //prepare reader\n                        var reader = new FileReader();\n                        reader.onload = function(event) {\n                            //console.log(event.target);\n                            var data = event.target.result;\n                            node.onDropData(data, filename, file);\n                        };\n\n                        //read data\n                        var type = file.type.split("/")[0];\n                        if (type == "text" || type == "") {\n                            reader.readAsText(file);\n                        } else if (type == "image") {\n                            reader.readAsDataURL(file);\n                        } else {\n                            reader.readAsArrayBuffer(file);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (node.onDropItem) {\n            if (node.onDropItem(event)) {\n                return true;\n            }\n        }\n\n        if (this.onDropItem) {\n            return this.onDropItem(event);\n        }\n\n        return false;\n    };\n\n    //called if the graph doesn\'t have a default drop item behaviour\n    LGraphCanvas.prototype.checkDropItem = function(e) {\n        if (e.dataTransfer.files.length) {\n            var file = e.dataTransfer.files[0];\n            var ext = LGraphCanvas.getFileExtension(file.name).toLowerCase();\n            var nodetype = LiteGraph.node_types_by_file_extension[ext];\n            if (nodetype) {\n\t\t\t\tthis.graph.beforeChange();\n                var node = LiteGraph.createNode(nodetype.type);\n                node.pos = [e.canvasX, e.canvasY];\n                this.graph.add(node);\n                if (node.onDropFile) {\n                    node.onDropFile(file);\n                }\n\t\t\t\tthis.graph.afterChange();\n            }\n        }\n    };\n\n    LGraphCanvas.prototype.processNodeDblClicked = function(n) {\n        if (this.onShowNodePanel) {\n            this.onShowNodePanel(n);\n        }\n\t\telse\n\t\t{\n\t\t\tthis.showShowNodePanel(n);\n\t\t}\n\n        if (this.onNodeDblClicked) {\n            this.onNodeDblClicked(n);\n        }\n\n        this.setDirty(true);\n    };\n\n    LGraphCanvas.prototype.processNodeSelected = function(node, e) {\n        this.selectNode(node, e && (e.shiftKey || e.ctrlKey || this.multi_select));\n        if (this.onNodeSelected) {\n            this.onNodeSelected(node);\n        }\n    };\n\n    /**\n     * selects a given node (or adds it to the current selection)\n     * @method selectNode\n     **/\n    LGraphCanvas.prototype.selectNode = function(\n        node,\n        add_to_current_selection\n    ) {\n        if (node == null) {\n            this.deselectAllNodes();\n        } else {\n            this.selectNodes([node], add_to_current_selection);\n        }\n    };\n\n    /**\n     * selects several nodes (or adds them to the current selection)\n     * @method selectNodes\n     **/\n    LGraphCanvas.prototype.selectNodes = function( nodes, add_to_current_selection )\n\t{\n\t\tif (!add_to_current_selection) {\n            this.deselectAllNodes();\n        }\n\n        nodes = nodes || this.graph._nodes;\n\t\tif (typeof nodes == "string") nodes = [nodes];\n        for (var i in nodes) {\n            var node = nodes[i];\n            if (node.is_selected) {\n                this.deselectNode(node);\n                continue;\n            }\n\n            if (!node.is_selected && node.onSelected) {\n                node.onSelected();\n            }\n            node.is_selected = true;\n            this.selected_nodes[node.id] = node;\n\n            if (node.inputs) {\n                for (var j = 0; j < node.inputs.length; ++j) {\n                    this.highlighted_links[node.inputs[j].link] = true;\n                }\n            }\n            if (node.outputs) {\n                for (var j = 0; j < node.outputs.length; ++j) {\n                    var out = node.outputs[j];\n                    if (out.links) {\n                        for (var k = 0; k < out.links.length; ++k) {\n                            this.highlighted_links[out.links[k]] = true;\n                        }\n                    }\n                }\n            }\n        }\n\n\t\tif(\tthis.onSelectionChange )\n\t\t\tthis.onSelectionChange( this.selected_nodes );\n\n        this.setDirty(true);\n    };\n\n    /**\n     * removes a node from the current selection\n     * @method deselectNode\n     **/\n    LGraphCanvas.prototype.deselectNode = function(node) {\n        if (!node.is_selected) {\n            return;\n        }\n        if (node.onDeselected) {\n            node.onDeselected();\n        }\n        node.is_selected = false;\n\n        if (this.onNodeDeselected) {\n            this.onNodeDeselected(node);\n        }\n\n        //remove highlighted\n        if (node.inputs) {\n            for (var i = 0; i < node.inputs.length; ++i) {\n                delete this.highlighted_links[node.inputs[i].link];\n            }\n        }\n        if (node.outputs) {\n            for (var i = 0; i < node.outputs.length; ++i) {\n                var out = node.outputs[i];\n                if (out.links) {\n                    for (var j = 0; j < out.links.length; ++j) {\n                        delete this.highlighted_links[out.links[j]];\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * removes all nodes from the current selection\n     * @method deselectAllNodes\n     **/\n    LGraphCanvas.prototype.deselectAllNodes = function() {\n        if (!this.graph) {\n            return;\n        }\n        var nodes = this.graph._nodes;\n        for (var i = 0, l = nodes.length; i < l; ++i) {\n            var node = nodes[i];\n            if (!node.is_selected) {\n                continue;\n            }\n            if (node.onDeselected) {\n                node.onDeselected();\n            }\n            node.is_selected = false;\n\t\t\tif (this.onNodeDeselected) {\n\t\t\t\tthis.onNodeDeselected(node);\n\t\t\t}\n        }\n        this.selected_nodes = {};\n        this.current_node = null;\n        this.highlighted_links = {};\n\t\tif(\tthis.onSelectionChange )\n\t\t\tthis.onSelectionChange( this.selected_nodes );\n        this.setDirty(true);\n    };\n\n    /**\n     * deletes all nodes in the current selection from the graph\n     * @method deleteSelectedNodes\n     **/\n    LGraphCanvas.prototype.deleteSelectedNodes = function() {\n\n\t\tthis.graph.beforeChange();\n\n        for (var i in this.selected_nodes) {\n            var node = this.selected_nodes[i];\n\n\t\t\tif(node.block_delete)\n\t\t\t\tcontinue;\n\n\t\t\t//autoconnect when possible (very basic, only takes into account first input-output)\n\t\t\tif(node.inputs && node.inputs.length && node.outputs && node.outputs.length && LiteGraph.isValidConnection( node.inputs[0].type, node.outputs[0].type ) && node.inputs[0].link && node.outputs[0].links && node.outputs[0].links.length ) \n\t\t\t{\n\t\t\t\tvar input_link = node.graph.links[ node.inputs[0].link ];\n\t\t\t\tvar output_link = node.graph.links[ node.outputs[0].links[0] ];\n\t\t\t\tvar input_node = node.getInputNode(0);\n\t\t\t\tvar output_node = node.getOutputNodes(0)[0];\n\t\t\t\tif(input_node && output_node)\n\t\t\t\t\tinput_node.connect( input_link.origin_slot, output_node, output_link.target_slot );\n\t\t\t}\n            this.graph.remove(node);\n\t\t\tif (this.onNodeDeselected) {\n\t\t\t\tthis.onNodeDeselected(node);\n\t\t\t}\n        }\n        this.selected_nodes = {};\n        this.current_node = null;\n        this.highlighted_links = {};\n        this.setDirty(true);\n\t\tthis.graph.afterChange();\n    };\n    \n    /**\n     * centers the camera on a given node\n     * @method centerOnNode\n     **/\n    LGraphCanvas.prototype.centerOnNode = function(node) {\n        this.ds.offset[0] =\n            -node.pos[0] -\n            node.size[0] * 0.5 +\n            (this.canvas.width * 0.5) / this.ds.scale;\n        this.ds.offset[1] =\n            -node.pos[1] -\n            node.size[1] * 0.5 +\n            (this.canvas.height * 0.5) / this.ds.scale;\n        this.setDirty(true, true);\n    };\n\n    /**\n     * adds some useful properties to a mouse event, like the position in graph coordinates\n     * @method adjustMouseEvent\n     **/\n    LGraphCanvas.prototype.adjustMouseEvent = function(e) {\n\tvar clientX_rel = 0;\n        var clientY_rel = 0;\n\t    \n    \tif (this.canvas) {\n            var b = this.canvas.getBoundingClientRect();\n            clientX_rel = e.clientX - b.left;\n            clientY_rel = e.clientY - b.top;\n        } else {\n        \tclientX_rel = e.clientX;\n        \tclientY_rel = e.clientY;\n        }\n    \t\n        // e.deltaX = clientX_rel - this.last_mouse_position[0];\n        // e.deltaY = clientY_rel- this.last_mouse_position[1];\n\n        this.last_mouse_position[0] = clientX_rel;\n        this.last_mouse_position[1] = clientY_rel;\n\n        e.canvasX = clientX_rel / this.ds.scale - this.ds.offset[0];\n        e.canvasY = clientY_rel / this.ds.scale - this.ds.offset[1];\n        \n        //console.log("pointerevents: adjustMouseEvent "+e.clientX+":"+e.clientY+" "+clientX_rel+":"+clientY_rel+" "+e.canvasX+":"+e.canvasY);\n    };\n\n    /**\n     * changes the zoom level of the graph (default is 1), you can pass also a place used to pivot the zoom\n     * @method setZoom\n     **/\n    LGraphCanvas.prototype.setZoom = function(value, zooming_center) {\n        this.ds.changeScale(value, zooming_center);\n        /*\n\tif(!zooming_center && this.canvas)\n\t\tzooming_center = [this.canvas.width * 0.5,this.canvas.height * 0.5];\n\n\tvar center = this.convertOffsetToCanvas( zooming_center );\n\n\tthis.ds.scale = value;\n\n\tif(this.scale > this.max_zoom)\n\t\tthis.scale = this.max_zoom;\n\telse if(this.scale < this.min_zoom)\n\t\tthis.scale = this.min_zoom;\n\n\tvar new_center = this.convertOffsetToCanvas( zooming_center );\n\tvar delta_offset = [new_center[0] - center[0], new_center[1] - center[1]];\n\n\tthis.offset[0] += delta_offset[0];\n\tthis.offset[1] += delta_offset[1];\n\t*/\n\n        this.dirty_canvas = true;\n        this.dirty_bgcanvas = true;\n    };\n\n    /**\n     * converts a coordinate from graph coordinates to canvas2D coordinates\n     * @method convertOffsetToCanvas\n     **/\n    LGraphCanvas.prototype.convertOffsetToCanvas = function(pos, out) {\n        return this.ds.convertOffsetToCanvas(pos, out);\n    };\n\n    /**\n     * converts a coordinate from Canvas2D coordinates to graph space\n     * @method convertCanvasToOffset\n     **/\n    LGraphCanvas.prototype.convertCanvasToOffset = function(pos, out) {\n        return this.ds.convertCanvasToOffset(pos, out);\n    };\n\n    //converts event coordinates from canvas2D to graph coordinates\n    LGraphCanvas.prototype.convertEventToCanvasOffset = function(e) {\n        var rect = this.canvas.getBoundingClientRect();\n        return this.convertCanvasToOffset([\n            e.clientX - rect.left,\n            e.clientY - rect.top\n        ]);\n    };\n\n    /**\n     * brings a node to front (above all other nodes)\n     * @method bringToFront\n     **/\n    LGraphCanvas.prototype.bringToFront = function(node) {\n        var i = this.graph._nodes.indexOf(node);\n        if (i == -1) {\n            return;\n        }\n\n        this.graph._nodes.splice(i, 1);\n        this.graph._nodes.push(node);\n    };\n\n    /**\n     * sends a node to the back (below all other nodes)\n     * @method sendToBack\n     **/\n    LGraphCanvas.prototype.sendToBack = function(node) {\n        var i = this.graph._nodes.indexOf(node);\n        if (i == -1) {\n            return;\n        }\n\n        this.graph._nodes.splice(i, 1);\n        this.graph._nodes.unshift(node);\n    };\n\n    /* Interaction */\n\n    /* LGraphCanvas render */\n    var temp = new Float32Array(4);\n\n    /**\n     * checks which nodes are visible (inside the camera area)\n     * @method computeVisibleNodes\n     **/\n    LGraphCanvas.prototype.computeVisibleNodes = function(nodes, out) {\n        var visible_nodes = out || [];\n        visible_nodes.length = 0;\n        nodes = nodes || this.graph._nodes;\n        for (var i = 0, l = nodes.length; i < l; ++i) {\n            var n = nodes[i];\n\n            //skip rendering nodes in live mode\n            if (this.live_mode && !n.onDrawBackground && !n.onDrawForeground) {\n                continue;\n            }\n\n            if (!overlapBounding(this.visible_area, n.getBounding(temp, true))) {\n                continue;\n            } //out of the visible area\n\n            visible_nodes.push(n);\n        }\n        return visible_nodes;\n    };\n\n    /**\n     * renders the whole canvas content, by rendering in two separated canvas, one containing the background grid and the connections, and one containing the nodes)\n     * @method draw\n     **/\n    LGraphCanvas.prototype.draw = function(force_canvas, force_bgcanvas) {\n        if (!this.canvas || this.canvas.width == 0 || this.canvas.height == 0) {\n            return;\n        }\n\n        //fps counting\n        var now = LiteGraph.getTime();\n        this.render_time = (now - this.last_draw_time) * 0.001;\n        this.last_draw_time = now;\n\n        if (this.graph) {\n            this.ds.computeVisibleArea(this.viewport);\n        }\n\n        if (\n            this.dirty_bgcanvas ||\n            force_bgcanvas ||\n            this.always_render_background ||\n            (this.graph &&\n                this.graph._last_trigger_time &&\n                now - this.graph._last_trigger_time < 1000)\n        ) {\n            this.drawBackCanvas();\n        }\n\n        if (this.dirty_canvas || force_canvas) {\n            this.drawFrontCanvas();\n        }\n\n        this.fps = this.render_time ? 1.0 / this.render_time : 0;\n        this.frame += 1;\n    };\n\n    /**\n     * draws the front canvas (the one containing all the nodes)\n     * @method drawFrontCanvas\n     **/\n    LGraphCanvas.prototype.drawFrontCanvas = function() {\n        this.dirty_canvas = false;\n\n        if (!this.ctx) {\n            this.ctx = this.bgcanvas.getContext("2d");\n        }\n        var ctx = this.ctx;\n        if (!ctx) {\n            //maybe is using webgl...\n            return;\n        }\n\n        var canvas = this.canvas;\n        if ( ctx.start2D && !this.viewport ) {\n            ctx.start2D();\n\t\t\tctx.restore();\n\t\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n        }\n\n        //clip dirty area if there is one, otherwise work in full canvas\n\t\tvar area = this.viewport || this.dirty_area;\n        if (area) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect( area[0],area[1],area[2],area[3] );\n            ctx.clip();\n        }\n\n        //clear\n        //canvas.width = canvas.width;\n        if (this.clear_background) {\n\t\t\tif(area)\n\t            ctx.clearRect( area[0],area[1],area[2],area[3] );\n\t\t\telse\n\t            ctx.clearRect(0, 0, canvas.width, canvas.height);\n        }\n\n        //draw bg canvas\n        if (this.bgcanvas == this.canvas) {\n            this.drawBackCanvas();\n        } else {\n            ctx.drawImage( this.bgcanvas, 0, 0 );\n        }\n\n        //rendering\n        if (this.onRender) {\n            this.onRender(canvas, ctx);\n        }\n\n        //info widget\n        if (this.show_info) {\n            this.renderInfo(ctx, area ? area[0] : 0, area ? area[1] : 0 );\n        }\n\n        if (this.graph) {\n            //apply transformations\n            ctx.save();\n            this.ds.toCanvasContext(ctx);\n\n            //draw nodes\n            var drawn_nodes = 0;\n            var visible_nodes = this.computeVisibleNodes(\n                null,\n                this.visible_nodes\n            );\n\n            for (var i = 0; i < visible_nodes.length; ++i) {\n                var node = visible_nodes[i];\n\n                //transform coords system\n                ctx.save();\n                ctx.translate(node.pos[0], node.pos[1]);\n\n                //Draw\n                this.drawNode(node, ctx);\n                drawn_nodes += 1;\n\n                //Restore\n                ctx.restore();\n            }\n\n            //on top (debug)\n            if (this.render_execution_order) {\n                this.drawExecutionOrder(ctx);\n            }\n\n            //connections ontop?\n            if (this.graph.config.links_ontop) {\n                if (!this.live_mode) {\n                    this.drawConnections(ctx);\n                }\n            }\n\n            //current connection (the one being dragged by the mouse)\n            if (this.connecting_pos != null) {\n                ctx.lineWidth = this.connections_width;\n                var link_color = null;\n                \n                var connInOrOut = this.connecting_output || this.connecting_input;\n\n                var connType = connInOrOut.type;\n                var connDir = connInOrOut.dir;\n\t\t\t\tif(connDir == null)\n\t\t\t\t{\n\t\t\t\t\tif (this.connecting_output)\n\t\t\t\t\t\tconnDir = this.connecting_node.horizontal ? LiteGraph.DOWN : LiteGraph.RIGHT;\n\t\t\t\t\telse\n\t\t\t\t\t\tconnDir = this.connecting_node.horizontal ? LiteGraph.UP : LiteGraph.LEFT;\n\t\t\t\t}\n                var connShape = connInOrOut.shape;\n                \n                switch (connType) {\n                    case LiteGraph.EVENT:\n                        link_color = LiteGraph.EVENT_LINK_COLOR;\n                        break;\n                    default:\n                        link_color = LiteGraph.CONNECTING_LINK_COLOR;\n                }\n\n                //the connection being dragged by the mouse\n                this.renderLink(\n                    ctx,\n                    this.connecting_pos,\n                    [this.graph_mouse[0], this.graph_mouse[1]],\n                    null,\n                    false,\n                    null,\n                    link_color,\n                    connDir,\n                    LiteGraph.CENTER\n                );\n\n                ctx.beginPath();\n                if (\n                    connType === LiteGraph.EVENT ||\n                    connShape === LiteGraph.BOX_SHAPE\n                ) {\n                    ctx.rect(\n                        this.connecting_pos[0] - 6 + 0.5,\n                        this.connecting_pos[1] - 5 + 0.5,\n                        14,\n                        10\n                    );\n\t                ctx.fill();\n\t\t\t\t\tctx.beginPath();\n                    ctx.rect(\n                        this.graph_mouse[0] - 6 + 0.5,\n                        this.graph_mouse[1] - 5 + 0.5,\n                        14,\n                        10\n                    );\n                } else if (connShape === LiteGraph.ARROW_SHAPE) {\n                    ctx.moveTo(this.connecting_pos[0] + 8, this.connecting_pos[1] + 0.5);\n                    ctx.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] + 6 + 0.5);\n                    ctx.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] - 6 + 0.5);\n                    ctx.closePath();\n                } \n                else {\n                    ctx.arc(\n                        this.connecting_pos[0],\n                        this.connecting_pos[1],\n                        4,\n                        0,\n                        Math.PI * 2\n                    );\n\t                ctx.fill();\n\t\t\t\t\tctx.beginPath();\n                    ctx.arc(\n                        this.graph_mouse[0],\n                        this.graph_mouse[1],\n                        4,\n                        0,\n                        Math.PI * 2\n                    );\n                }\n                ctx.fill();\n\n                ctx.fillStyle = "#ffcc00";\n                if (this._highlight_input) {\n                    ctx.beginPath();\n                    var shape = this._highlight_input_slot.shape;\n                    if (shape === LiteGraph.ARROW_SHAPE) {\n                        ctx.moveTo(this._highlight_input[0] + 8, this._highlight_input[1] + 0.5);\n                        ctx.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] + 6 + 0.5);\n                        ctx.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] - 6 + 0.5);\n                        ctx.closePath();\n                    } else {\n                        ctx.arc(\n                            this._highlight_input[0],\n                            this._highlight_input[1],\n                            6,\n                            0,\n                            Math.PI * 2\n                        );\n                    }\n                    ctx.fill();\n                }\n                if (this._highlight_output) {\n                    ctx.beginPath();\n                    if (shape === LiteGraph.ARROW_SHAPE) {\n                        ctx.moveTo(this._highlight_output[0] + 8, this._highlight_output[1] + 0.5);\n                        ctx.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] + 6 + 0.5);\n                        ctx.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] - 6 + 0.5);\n                        ctx.closePath();\n                    } else {\n                        ctx.arc(\n                            this._highlight_output[0],\n                            this._highlight_output[1],\n                            6,\n                            0,\n                            Math.PI * 2\n                        );\n                    }\n                    ctx.fill();\n                }\n            }\n\n\t\t\t//the selection rectangle\n            if (this.dragging_rectangle) {\n                ctx.strokeStyle = "#FFF";\n                ctx.strokeRect(\n                    this.dragging_rectangle[0],\n                    this.dragging_rectangle[1],\n                    this.dragging_rectangle[2],\n                    this.dragging_rectangle[3]\n                );\n            }\n\n\t\t\t//on top of link center\n\t\t\tif(this.over_link_center && this.render_link_tooltip)\n\t\t\t\tthis.drawLinkTooltip( ctx, this.over_link_center );\n\t\t\telse\n\t\t\t\tif(this.onDrawLinkTooltip) //to remove\n\t\t\t\t\tthis.onDrawLinkTooltip(ctx,null);\n\n\t\t\t//custom info\n            if (this.onDrawForeground) {\n                this.onDrawForeground(ctx, this.visible_rect);\n            }\n\n            ctx.restore();\n        }\n\n\t\t//draws panel in the corner \n\t\tif (this._graph_stack && this._graph_stack.length) {\n\t\t\tthis.drawSubgraphPanel( ctx );\n\t\t}\n\n\n        if (this.onDrawOverlay) {\n            this.onDrawOverlay(ctx);\n        }\n\n        if (area){\n            ctx.restore();\n        }\n\n        if (ctx.finish2D) {\n            //this is a function I use in webgl renderer\n            ctx.finish2D();\n        }\n    };\n\n    /**\n     * draws the panel in the corner that shows subgraph properties\n     * @method drawSubgraphPanel\n     **/\n    LGraphCanvas.prototype.drawSubgraphPanel = function (ctx) {\n        var subgraph = this.graph;\n        var subnode = subgraph._subgraph_node;\n        if (!subnode) {\n            console.warn("subgraph without subnode");\n            return;\n        }\n        this.drawSubgraphPanelLeft(subgraph, subnode, ctx)\n        this.drawSubgraphPanelRight(subgraph, subnode, ctx)\n    }\n\n    LGraphCanvas.prototype.drawSubgraphPanelLeft = function (subgraph, subnode, ctx) {\n        var num = subnode.inputs ? subnode.inputs.length : 0;\n        var w = 200;\n        var h = Math.floor(LiteGraph.NODE_SLOT_HEIGHT * 1.6);\n\n        ctx.fillStyle = "#111";\n        ctx.globalAlpha = 0.8;\n        ctx.beginPath();\n        ctx.roundRect(10, 10, w, (num + 1) * h + 50, [8]);\n        ctx.fill();\n        ctx.globalAlpha = 1;\n\n        ctx.fillStyle = "#888";\n        ctx.font = "14px Arial";\n        ctx.textAlign = "left";\n        ctx.fillText("Graph Inputs", 20, 34);\n        // var pos = this.mouse;\n\n        if (this.drawButton(w - 20, 20, 20, 20, "X", "#151515")) {\n            this.closeSubgraph();\n            return;\n        }\n\n        var y = 50;\n        ctx.font = "14px Arial";\n        if (subnode.inputs)\n            for (var i = 0; i < subnode.inputs.length; ++i) {\n                var input = subnode.inputs[i];\n                if (input.not_subgraph_input)\n                    continue;\n\n                //input button clicked\n                if (this.drawButton(20, y + 2, w - 20, h - 2)) {\n                    var type = subnode.constructor.input_node_type || "graph/input";\n                    this.graph.beforeChange();\n                    var newnode = LiteGraph.createNode(type);\n                    if (newnode) {\n                        subgraph.add(newnode);\n                        this.block_click = false;\n                        this.last_click_position = null;\n                        this.selectNodes([newnode]);\n                        this.node_dragged = newnode;\n                        this.dragging_canvas = false;\n                        newnode.setProperty("name", input.name);\n                        newnode.setProperty("type", input.type);\n                        this.node_dragged.pos[0] = this.graph_mouse[0] - 5;\n                        this.node_dragged.pos[1] = this.graph_mouse[1] - 5;\n                        this.graph.afterChange();\n                    }\n                    else\n                        console.error("graph input node not found:", type);\n                }\n                ctx.fillStyle = "#9C9";\n                ctx.beginPath();\n                ctx.arc(w - 16, y + h * 0.5, 5, 0, 2 * Math.PI);\n                ctx.fill();\n                ctx.fillStyle = "#AAA";\n                ctx.fillText(input.name, 30, y + h * 0.75);\n                // var tw = ctx.measureText(input.name);\n                ctx.fillStyle = "#777";\n                ctx.fillText(input.type, 130, y + h * 0.75);\n                y += h;\n            }\n        //add + button\n        if (this.drawButton(20, y + 2, w - 20, h - 2, "+", "#151515", "#222")) {\n            this.showSubgraphPropertiesDialog(subnode);\n        }\n    }\n    LGraphCanvas.prototype.drawSubgraphPanelRight = function (subgraph, subnode, ctx) {\n        var num = subnode.outputs ? subnode.outputs.length : 0;\n        var canvas_w = this.bgcanvas.width\n        var w = 200;\n        var h = Math.floor(LiteGraph.NODE_SLOT_HEIGHT * 1.6);\n\n        ctx.fillStyle = "#111";\n        ctx.globalAlpha = 0.8;\n        ctx.beginPath();\n        ctx.roundRect(canvas_w - w - 10, 10, w, (num + 1) * h + 50, [8]);\n        ctx.fill();\n        ctx.globalAlpha = 1;\n\n        ctx.fillStyle = "#888";\n        ctx.font = "14px Arial";\n        ctx.textAlign = "left";\n        var title_text = "Graph Outputs"\n        var tw = ctx.measureText(title_text).width\n        ctx.fillText(title_text, (canvas_w - tw) - 20, 34);\n        // var pos = this.mouse;\n        if (this.drawButton(canvas_w - w, 20, 20, 20, "X", "#151515")) {\n            this.closeSubgraph();\n            return;\n        }\n\n        var y = 50;\n        ctx.font = "14px Arial";\n        if (subnode.outputs)\n            for (var i = 0; i < subnode.outputs.length; ++i) {\n                var output = subnode.outputs[i];\n                if (output.not_subgraph_input)\n                    continue;\n\n                //output button clicked\n                if (this.drawButton(canvas_w - w, y + 2, w - 20, h - 2)) {\n                    var type = subnode.constructor.output_node_type || "graph/output";\n                    this.graph.beforeChange();\n                    var newnode = LiteGraph.createNode(type);\n                    if (newnode) {\n                        subgraph.add(newnode);\n                        this.block_click = false;\n                        this.last_click_position = null;\n                        this.selectNodes([newnode]);\n                        this.node_dragged = newnode;\n                        this.dragging_canvas = false;\n                        newnode.setProperty("name", output.name);\n                        newnode.setProperty("type", output.type);\n                        this.node_dragged.pos[0] = this.graph_mouse[0] - 5;\n                        this.node_dragged.pos[1] = this.graph_mouse[1] - 5;\n                        this.graph.afterChange();\n                    }\n                    else\n                        console.error("graph input node not found:", type);\n                }\n                ctx.fillStyle = "#9C9";\n                ctx.beginPath();\n                ctx.arc(canvas_w - w + 16, y + h * 0.5, 5, 0, 2 * Math.PI);\n                ctx.fill();\n                ctx.fillStyle = "#AAA";\n                ctx.fillText(output.name, canvas_w - w + 30, y + h * 0.75);\n                // var tw = ctx.measureText(input.name);\n                ctx.fillStyle = "#777";\n                ctx.fillText(output.type, canvas_w - w + 130, y + h * 0.75);\n                y += h;\n            }\n        //add + button\n        if (this.drawButton(canvas_w - w, y + 2, w - 20, h - 2, "+", "#151515", "#222")) {\n            this.showSubgraphPropertiesDialogRight(subnode);\n        }\n    }\n\t//Draws a button into the canvas overlay and computes if it was clicked using the immediate gui paradigm\n\tLGraphCanvas.prototype.drawButton = function( x,y,w,h, text, bgcolor, hovercolor, textcolor )\n\t{\n\t\tvar ctx = this.ctx;\n\t\tbgcolor = bgcolor || LiteGraph.NODE_DEFAULT_COLOR;\n\t\thovercolor = hovercolor || "#555";\n\t\ttextcolor = textcolor || LiteGraph.NODE_TEXT_COLOR;\n\t\tvar pos = this.ds.convertOffsetToCanvas(this.graph_mouse);\n\t\tvar hover = LiteGraph.isInsideRectangle( pos[0], pos[1], x,y,w,h );\n\t\tpos = this.last_click_position ? [this.last_click_position[0], this.last_click_position[1]] : null;\n        if(pos) {\n            var rect = this.canvas.getBoundingClientRect();\n            pos[0] -= rect.left;\n            pos[1] -= rect.top;\n        }\n\t\tvar clicked = pos && LiteGraph.isInsideRectangle( pos[0], pos[1], x,y,w,h );\n\n\t\tctx.fillStyle = hover ? hovercolor : bgcolor;\n\t\tif(clicked)\n\t\t\tctx.fillStyle = "#AAA";\n\t\tctx.beginPath();\n\t\tctx.roundRect(x,y,w,h,[4] );\n\t\tctx.fill();\n\n\t\tif(text != null)\n\t\t{\n\t\t\tif(text.constructor == String)\n\t\t\t{\n\t\t\t\tctx.fillStyle = textcolor;\n\t\t\t\tctx.textAlign = "center";\n\t\t\t\tctx.font = ((h * 0.65)|0) + "px Arial";\n\t\t\t\tctx.fillText( text, x + w * 0.5,y + h * 0.75 );\n\t\t\t\tctx.textAlign = "left";\n\t\t\t}\n\t\t}\n\n\t\tvar was_clicked = clicked && !this.block_click;\n\t\tif(clicked)\n\t\t\tthis.blockClick();\n\t\treturn was_clicked;\n\t}\n\n\tLGraphCanvas.prototype.isAreaClicked = function( x,y,w,h, hold_click )\n\t{\n\t\tvar pos = this.mouse;\n\t\tvar hover = LiteGraph.isInsideRectangle( pos[0], pos[1], x,y,w,h );\n\t\tpos = this.last_click_position;\n\t\tvar clicked = pos && LiteGraph.isInsideRectangle( pos[0], pos[1], x,y,w,h );\n\t\tvar was_clicked = clicked && !this.block_click;\n\t\tif(clicked && hold_click)\n\t\t\tthis.blockClick();\n\t\treturn was_clicked;\n\t}\n\n    /**\n     * draws some useful stats in the corner of the canvas\n     * @method renderInfo\n     **/\n    LGraphCanvas.prototype.renderInfo = function(ctx, x, y) {\n        x = x || 10;\n        y = y || this.canvas.height - 80;\n\n        ctx.save();\n        ctx.translate(x, y);\n\n        ctx.font = "10px Arial";\n        ctx.fillStyle = "#888";\n\t\tctx.textAlign = "left";\n        if (this.graph) {\n            ctx.fillText( "T: " + this.graph.globaltime.toFixed(2) + "s", 5, 13 * 1 );\n            ctx.fillText("I: " + this.graph.iteration, 5, 13 * 2 );\n            ctx.fillText("N: " + this.graph._nodes.length + " [" + this.visible_nodes.length + "]", 5, 13 * 3 );\n            ctx.fillText("V: " + this.graph._version, 5, 13 * 4);\n            ctx.fillText("FPS:" + this.fps.toFixed(2), 5, 13 * 5);\n        } else {\n            ctx.fillText("No graph selected", 5, 13 * 1);\n        }\n        ctx.restore();\n    };\n\n    /**\n     * draws the back canvas (the one containing the background and the connections)\n     * @method drawBackCanvas\n     **/\n    LGraphCanvas.prototype.drawBackCanvas = function() {\n        var canvas = this.bgcanvas;\n        if (\n            canvas.width != this.canvas.width ||\n            canvas.height != this.canvas.height\n        ) {\n            canvas.width = this.canvas.width;\n            canvas.height = this.canvas.height;\n        }\n\n        if (!this.bgctx) {\n            this.bgctx = this.bgcanvas.getContext("2d");\n        }\n        var ctx = this.bgctx;\n        if (ctx.start) {\n            ctx.start();\n        }\n\n\t\tvar viewport = this.viewport || [0,0,ctx.canvas.width,ctx.canvas.height];\n\n        //clear\n        if (this.clear_background) {\n            ctx.clearRect( viewport[0], viewport[1], viewport[2], viewport[3] );\n        }\n\n\t\t//show subgraph stack header\n        if (this._graph_stack && this._graph_stack.length) {\n            ctx.save();\n            var parent_graph = this._graph_stack[this._graph_stack.length - 1];\n            var subgraph_node = this.graph._subgraph_node;\n            ctx.strokeStyle = subgraph_node.bgcolor;\n            ctx.lineWidth = 10;\n            ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);\n            ctx.lineWidth = 1;\n            ctx.font = "40px Arial";\n            ctx.textAlign = "center";\n            ctx.fillStyle = subgraph_node.bgcolor || "#AAA";\n            var title = "";\n            for (var i = 1; i < this._graph_stack.length; ++i) {\n                title +=\n                    this._graph_stack[i]._subgraph_node.getTitle() + " >> ";\n            }\n            ctx.fillText(\n                title + subgraph_node.getTitle(),\n                canvas.width * 0.5,\n                40\n            );\n            ctx.restore();\n        }\n\n        var bg_already_painted = false;\n        if (this.onRenderBackground) {\n            bg_already_painted = this.onRenderBackground(canvas, ctx);\n        }\n\n        //reset in case of error\n        if ( !this.viewport )\n\t\t{\n\t        ctx.restore();\n\t\t    ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\t}\n        this.visible_links.length = 0;\n\n        if (this.graph) {\n            //apply transformations\n            ctx.save();\n            this.ds.toCanvasContext(ctx);\n\n            //render BG\n            if ( this.ds.scale < 1.5 && !bg_already_painted && this.clear_background_color )\n            {\n                ctx.fillStyle = this.clear_background_color;\n                ctx.fillRect(\n                    this.visible_area[0],\n                    this.visible_area[1],\n                    this.visible_area[2],\n                    this.visible_area[3]\n                );\n            }\n\n            if (\n                this.background_image &&\n                this.ds.scale > 0.5 &&\n                !bg_already_painted\n            ) {\n                if (this.zoom_modify_alpha) {\n                    ctx.globalAlpha =\n                        (1.0 - 0.5 / this.ds.scale) * this.editor_alpha;\n                } else {\n                    ctx.globalAlpha = this.editor_alpha;\n                }\n                ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled = false; // ctx.mozImageSmoothingEnabled = \n                if (\n                    !this._bg_img ||\n                    this._bg_img.name != this.background_image\n                ) {\n                    this._bg_img = new Image();\n                    this._bg_img.name = this.background_image;\n                    this._bg_img.src = this.background_image;\n                    var that = this;\n                    this._bg_img.onload = function() {\n                        that.draw(true, true);\n                    };\n                }\n\n                var pattern = null;\n                if (this._pattern == null && this._bg_img.width > 0) {\n                    pattern = ctx.createPattern(this._bg_img, "repeat");\n                    this._pattern_img = this._bg_img;\n                    this._pattern = pattern;\n                } else {\n                    pattern = this._pattern;\n                }\n                if (pattern) {\n                    ctx.fillStyle = pattern;\n                    ctx.fillRect(\n                        this.visible_area[0],\n                        this.visible_area[1],\n                        this.visible_area[2],\n                        this.visible_area[3]\n                    );\n                    ctx.fillStyle = "transparent";\n                }\n\n                ctx.globalAlpha = 1.0;\n                ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled = true; //= ctx.mozImageSmoothingEnabled\n            }\n\n            //groups\n            if (this.graph._groups.length && !this.live_mode) {\n                this.drawGroups(canvas, ctx);\n            }\n\n            if (this.onDrawBackground) {\n                this.onDrawBackground(ctx, this.visible_area);\n            }\n            if (this.onBackgroundRender) {\n                //LEGACY\n                console.error(\n                    "WARNING! onBackgroundRender deprecated, now is named onDrawBackground "\n                );\n                this.onBackgroundRender = null;\n            }\n\n            //DEBUG: show clipping area\n            //ctx.fillStyle = "red";\n            //ctx.fillRect( this.visible_area[0] + 10, this.visible_area[1] + 10, this.visible_area[2] - 20, this.visible_area[3] - 20);\n\n            //bg\n            if (this.render_canvas_border) {\n                ctx.strokeStyle = "#235";\n                ctx.strokeRect(0, 0, canvas.width, canvas.height);\n            }\n\n            if (this.render_connections_shadows) {\n                ctx.shadowColor = "#000";\n                ctx.shadowOffsetX = 0;\n                ctx.shadowOffsetY = 0;\n                ctx.shadowBlur = 6;\n            } else {\n                ctx.shadowColor = "rgba(0,0,0,0)";\n            }\n\n            //draw connections\n            if (!this.live_mode) {\n                this.drawConnections(ctx);\n            }\n\n            ctx.shadowColor = "rgba(0,0,0,0)";\n\n            //restore state\n            ctx.restore();\n        }\n\n        if (ctx.finish) {\n            ctx.finish();\n        }\n\n        this.dirty_bgcanvas = false;\n        this.dirty_canvas = true; //to force to repaint the front canvas with the bgcanvas\n    };\n\n    var temp_vec2 = new Float32Array(2);\n\n    /**\n     * draws the given node inside the canvas\n     * @method drawNode\n     **/\n    LGraphCanvas.prototype.drawNode = function(node, ctx) {\n        var glow = false;\n        this.current_node = node;\n\n        var color = node.color || node.constructor.color || LiteGraph.NODE_DEFAULT_COLOR;\n        var bgcolor = node.bgcolor || node.constructor.bgcolor || LiteGraph.NODE_DEFAULT_BGCOLOR;\n\n        //shadow and glow\n        if (node.mouseOver) {\n            glow = true;\n        }\n\n        var low_quality = this.ds.scale < 0.6; //zoomed out\n\n        //only render if it forces it to do it\n        if (this.live_mode) {\n            if (!node.flags.collapsed) {\n                ctx.shadowColor = "transparent";\n                if (node.onDrawForeground) {\n                    node.onDrawForeground(ctx, this, this.canvas);\n                }\n            }\n            return;\n        }\n\n        var editor_alpha = this.editor_alpha;\n        ctx.globalAlpha = editor_alpha;\n\n        if (this.render_shadows && !low_quality) {\n            ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR;\n            ctx.shadowOffsetX = 2 * this.ds.scale;\n            ctx.shadowOffsetY = 2 * this.ds.scale;\n            ctx.shadowBlur = 3 * this.ds.scale;\n        } else {\n            ctx.shadowColor = "transparent";\n        }\n\n        //custom draw collapsed method (draw after shadows because they are affected)\n        if (\n            node.flags.collapsed &&\n            node.onDrawCollapsed &&\n            node.onDrawCollapsed(ctx, this) == true\n        ) {\n            return;\n        }\n\n        //clip if required (mask)\n        var shape = node._shape || LiteGraph.BOX_SHAPE;\n        var size = temp_vec2;\n        temp_vec2.set(node.size);\n        var horizontal = node.horizontal; // || node.flags.horizontal;\n\n        if (node.flags.collapsed) {\n            ctx.font = this.inner_text_font;\n            var title = node.getTitle ? node.getTitle() : node.title;\n            if (title != null) {\n                node._collapsed_width = Math.min(\n                    node.size[0],\n                    ctx.measureText(title).width +\n                        LiteGraph.NODE_TITLE_HEIGHT * 2\n                ); //LiteGraph.NODE_COLLAPSED_WIDTH;\n                size[0] = node._collapsed_width;\n                size[1] = 0;\n            }\n        }\n\n        if (node.clip_area) {\n            //Start clipping\n            ctx.save();\n            ctx.beginPath();\n            if (shape == LiteGraph.BOX_SHAPE) {\n                ctx.rect(0, 0, size[0], size[1]);\n            } else if (shape == LiteGraph.ROUND_SHAPE) {\n                ctx.roundRect(0, 0, size[0], size[1], [10]);\n            } else if (shape == LiteGraph.CIRCLE_SHAPE) {\n                ctx.arc(\n                    size[0] * 0.5,\n                    size[1] * 0.5,\n                    size[0] * 0.5,\n                    0,\n                    Math.PI * 2\n                );\n            }\n            ctx.clip();\n        }\n\n        //draw shape\n        if (node.has_errors) {\n            bgcolor = "red";\n        }\n        this.drawNodeShape(\n            node,\n            ctx,\n            size,\n            color,\n            bgcolor,\n            node.is_selected,\n            node.mouseOver\n        );\n        ctx.shadowColor = "transparent";\n\n        //draw foreground\n        if (node.onDrawForeground) {\n            node.onDrawForeground(ctx, this, this.canvas);\n        }\n\n        //connection slots\n        ctx.textAlign = horizontal ? "center" : "left";\n        ctx.font = this.inner_text_font;\n\n        var render_text = !low_quality;\n\n        var out_slot = this.connecting_output;\n        var in_slot = this.connecting_input;\n        ctx.lineWidth = 1;\n\n        var max_y = 0;\n        var slot_pos = new Float32Array(2); //to reuse\n\n        //render inputs and outputs\n        if (!node.flags.collapsed) {\n            //input connection slots\n            if (node.inputs) {\n                for (var i = 0; i < node.inputs.length; i++) {\n                    var slot = node.inputs[i];\n                    \n                    var slot_type = slot.type;\n                    var slot_shape = slot.shape;\n                    \n                    ctx.globalAlpha = editor_alpha;\n                    //change opacity of incompatible slots when dragging a connection\n                    if ( this.connecting_output && !LiteGraph.isValidConnection( slot.type , out_slot.type) ) {\n                        ctx.globalAlpha = 0.4 * editor_alpha;\n                    }\n\n                    ctx.fillStyle =\n                        slot.link != null\n                            ? slot.color_on ||\n                              this.default_connection_color_byType[slot_type] ||\n                              this.default_connection_color.input_on\n                            : slot.color_off ||\n                              this.default_connection_color_byTypeOff[slot_type] ||\n                              this.default_connection_color_byType[slot_type] ||\n                              this.default_connection_color.input_off;\n\n                    var pos = node.getConnectionPos(true, i, slot_pos);\n                    pos[0] -= node.pos[0];\n                    pos[1] -= node.pos[1];\n                    if (max_y < pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5) {\n                        max_y = pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5;\n                    }\n\n                    ctx.beginPath();\n\n\t\t\t\t\tif (slot_type == "array"){\n                        slot_shape = LiteGraph.GRID_SHAPE; // place in addInput? addOutput instead?\n                    }\n                    \n                    var doStroke = true;\n                    \n                    if (\n                        slot.type === LiteGraph.EVENT ||\n                        slot.shape === LiteGraph.BOX_SHAPE\n                    ) {\n                        if (horizontal) {\n                            ctx.rect(\n                                pos[0] - 5 + 0.5,\n                                pos[1] - 8 + 0.5,\n                                10,\n                                14\n                            );\n                        } else {\n                            ctx.rect(\n                                pos[0] - 6 + 0.5,\n                                pos[1] - 5 + 0.5,\n                                14,\n                                10\n                            );\n                        }\n                    } else if (slot_shape === LiteGraph.ARROW_SHAPE) {\n                        ctx.moveTo(pos[0] + 8, pos[1] + 0.5);\n                        ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);\n                        ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);\n                        ctx.closePath();\n                    } else if (slot_shape === LiteGraph.GRID_SHAPE) {\n                        ctx.rect(pos[0] - 4, pos[1] - 4, 2, 2);\n                        ctx.rect(pos[0] - 1, pos[1] - 4, 2, 2);\n                        ctx.rect(pos[0] + 2, pos[1] - 4, 2, 2);\n                        ctx.rect(pos[0] - 4, pos[1] - 1, 2, 2);\n                        ctx.rect(pos[0] - 1, pos[1] - 1, 2, 2);\n                        ctx.rect(pos[0] + 2, pos[1] - 1, 2, 2);\n                        ctx.rect(pos[0] - 4, pos[1] + 2, 2, 2);\n                        ctx.rect(pos[0] - 1, pos[1] + 2, 2, 2);\n                        ctx.rect(pos[0] + 2, pos[1] + 2, 2, 2);\n                        doStroke = false;\n                    } else {\n\t\t\t\t\t\tif(low_quality)\n\t                        ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8 ); //faster\n\t\t\t\t\t\telse\n\t                        ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);\n                    }\n                    ctx.fill();\n\n                    //render name\n                    if (render_text) {\n                        var text = slot.label != null ? slot.label : slot.name;\n                        if (text) {\n                            ctx.fillStyle = LiteGraph.NODE_TEXT_COLOR;\n                            if (horizontal || slot.dir == LiteGraph.UP) {\n                                ctx.fillText(text, pos[0], pos[1] - 10);\n                            } else {\n                                ctx.fillText(text, pos[0] + 10, pos[1] + 5);\n                            }\n                        }\n                    }\n                }\n            }\n\n            //output connection slots\n\n            ctx.textAlign = horizontal ? "center" : "right";\n            ctx.strokeStyle = "black";\n            if (node.outputs) {\n                for (var i = 0; i < node.outputs.length; i++) {\n                    var slot = node.outputs[i];\n                    \n                    var slot_type = slot.type;\n                    var slot_shape = slot.shape;\n                    \n                    //change opacity of incompatible slots when dragging a connection\n                    if (this.connecting_input && !LiteGraph.isValidConnection( slot_type , in_slot.type) ) {\n                        ctx.globalAlpha = 0.4 * editor_alpha;\n                    }\n                    \n                    var pos = node.getConnectionPos(false, i, slot_pos);\n                    pos[0] -= node.pos[0];\n                    pos[1] -= node.pos[1];\n                    if (max_y < pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5) {\n                        max_y = pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5;\n                    }\n\n                    ctx.fillStyle =\n                        slot.links && slot.links.length\n                            ? slot.color_on ||\n                              this.default_connection_color_byType[slot_type] ||\n                              this.default_connection_color.output_on\n                            : slot.color_off ||\n                              this.default_connection_color_byTypeOff[slot_type] ||\n                              this.default_connection_color_byType[slot_type] ||\n                              this.default_connection_color.output_off;\n                    ctx.beginPath();\n                    //ctx.rect( node.size[0] - 14,i*14,10,10);\n\n\t\t\t\t\tif (slot_type == "array"){\n                        slot_shape = LiteGraph.GRID_SHAPE;\n                    }\n                    \n                    var doStroke = true;\n                    \n                    if (\n                        slot_type === LiteGraph.EVENT ||\n                        slot_shape === LiteGraph.BOX_SHAPE\n                    ) {\n                        if (horizontal) {\n                            ctx.rect(\n                                pos[0] - 5 + 0.5,\n                                pos[1] - 8 + 0.5,\n                                10,\n                                14\n                            );\n                        } else {\n                            ctx.rect(\n                                pos[0] - 6 + 0.5,\n                                pos[1] - 5 + 0.5,\n                                14,\n                                10\n                            );\n                        }\n                    } else if (slot_shape === LiteGraph.ARROW_SHAPE) {\n                        ctx.moveTo(pos[0] + 8, pos[1] + 0.5);\n                        ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);\n                        ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);\n                        ctx.closePath();\n                    }  else if (slot_shape === LiteGraph.GRID_SHAPE) {\n                        ctx.rect(pos[0] - 4, pos[1] - 4, 2, 2);\n                        ctx.rect(pos[0] - 1, pos[1] - 4, 2, 2);\n                        ctx.rect(pos[0] + 2, pos[1] - 4, 2, 2);\n                        ctx.rect(pos[0] - 4, pos[1] - 1, 2, 2);\n                        ctx.rect(pos[0] - 1, pos[1] - 1, 2, 2);\n                        ctx.rect(pos[0] + 2, pos[1] - 1, 2, 2);\n                        ctx.rect(pos[0] - 4, pos[1] + 2, 2, 2);\n                        ctx.rect(pos[0] - 1, pos[1] + 2, 2, 2);\n                        ctx.rect(pos[0] + 2, pos[1] + 2, 2, 2);\n                        doStroke = false;\n                    } else {\n\t\t\t\t\t\tif(low_quality)\n\t                        ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8 );\n\t\t\t\t\t\telse\n\t                        ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);\n                    }\n\n                    //trigger\n                    //if(slot.node_id != null && slot.slot == -1)\n                    //\tctx.fillStyle = "#F85";\n\n                    //if(slot.links != null && slot.links.length)\n                    ctx.fill();\n\t\t\t\t\tif(!low_quality && doStroke)\n\t                    ctx.stroke();\n\n                    //render output name\n                    if (render_text) {\n                        var text = slot.label != null ? slot.label : slot.name;\n                        if (text) {\n                            ctx.fillStyle = LiteGraph.NODE_TEXT_COLOR;\n                            if (horizontal || slot.dir == LiteGraph.DOWN) {\n                                ctx.fillText(text, pos[0], pos[1] - 8);\n                            } else {\n                                ctx.fillText(text, pos[0] - 10, pos[1] + 5);\n                            }\n                        }\n                    }\n                }\n            }\n\n            ctx.textAlign = "left";\n            ctx.globalAlpha = 1;\n\n            if (node.widgets) {\n\t\t\t\tvar widgets_y = max_y;\n                if (horizontal || node.widgets_up) {\n                    widgets_y = 2;\n                }\n\t\t\t\tif( node.widgets_start_y != null )\n                    widgets_y = node.widgets_start_y;\n                this.drawNodeWidgets(\n                    node,\n                    widgets_y,\n                    ctx,\n                    this.node_widget && this.node_widget[0] == node\n                        ? this.node_widget[1]\n                        : null\n                );\n            }\n        } else if (this.render_collapsed_slots) {\n            //if collapsed\n            var input_slot = null;\n            var output_slot = null;\n\n            //get first connected slot to render\n            if (node.inputs) {\n                for (var i = 0; i < node.inputs.length; i++) {\n                    var slot = node.inputs[i];\n                    if (slot.link == null) {\n                        continue;\n                    }\n                    input_slot = slot;\n                    break;\n                }\n            }\n            if (node.outputs) {\n                for (var i = 0; i < node.outputs.length; i++) {\n                    var slot = node.outputs[i];\n                    if (!slot.links || !slot.links.length) {\n                        continue;\n                    }\n                    output_slot = slot;\n                }\n            }\n\n            if (input_slot) {\n                var x = 0;\n                var y = LiteGraph.NODE_TITLE_HEIGHT * -0.5; //center\n                if (horizontal) {\n                    x = node._collapsed_width * 0.5;\n                    y = -LiteGraph.NODE_TITLE_HEIGHT;\n                }\n                ctx.fillStyle = "#686";\n                ctx.beginPath();\n                if (\n                    slot.type === LiteGraph.EVENT ||\n                    slot.shape === LiteGraph.BOX_SHAPE\n                ) {\n                    ctx.rect(x - 7 + 0.5, y - 4, 14, 8);\n                } else if (slot.shape === LiteGraph.ARROW_SHAPE) {\n                    ctx.moveTo(x + 8, y);\n                    ctx.lineTo(x + -4, y - 4);\n                    ctx.lineTo(x + -4, y + 4);\n                    ctx.closePath();\n                } else {\n                    ctx.arc(x, y, 4, 0, Math.PI * 2);\n                }\n                ctx.fill();\n            }\n\n            if (output_slot) {\n                var x = node._collapsed_width;\n                var y = LiteGraph.NODE_TITLE_HEIGHT * -0.5; //center\n                if (horizontal) {\n                    x = node._collapsed_width * 0.5;\n                    y = 0;\n                }\n                ctx.fillStyle = "#686";\n                ctx.strokeStyle = "black";\n                ctx.beginPath();\n                if (\n                    slot.type === LiteGraph.EVENT ||\n                    slot.shape === LiteGraph.BOX_SHAPE\n                ) {\n                    ctx.rect(x - 7 + 0.5, y - 4, 14, 8);\n                } else if (slot.shape === LiteGraph.ARROW_SHAPE) {\n                    ctx.moveTo(x + 6, y);\n                    ctx.lineTo(x - 6, y - 4);\n                    ctx.lineTo(x - 6, y + 4);\n                    ctx.closePath();\n                } else {\n                    ctx.arc(x, y, 4, 0, Math.PI * 2);\n                }\n                ctx.fill();\n                //ctx.stroke();\n            }\n        }\n\n        if (node.clip_area) {\n            ctx.restore();\n        }\n\n        ctx.globalAlpha = 1.0;\n    };\n\n\t//used by this.over_link_center\n\tLGraphCanvas.prototype.drawLinkTooltip = function( ctx, link )\n\t{\n\t\tvar pos = link._pos;\n\t\tctx.fillStyle = "black";\n\t\tctx.beginPath();\n\t\tctx.arc( pos[0], pos[1], 3, 0, Math.PI * 2 );\n\t\tctx.fill();\n\n\t\tif(link.data == null)\n\t\t\treturn;\n\n\t\tif(this.onDrawLinkTooltip)\n\t\t\tif( this.onDrawLinkTooltip(ctx,link,this) == true )\n\t\t\t\treturn;\n\n\t\tvar data = link.data;\n\t\tvar text = null;\n\n\t\tif( data.constructor === Number )\n\t\t\ttext = data.toFixed(2);\n\t\telse if( data.constructor === String )\n\t\t\ttext = "\\"" + data + "\\"";\n\t\telse if( data.constructor === Boolean )\n\t\t\ttext = String(data);\n\t\telse if (data.toToolTip)\n\t\t\ttext = data.toToolTip();\n\t\telse\n\t\t\ttext = "[" + data.constructor.name + "]";\n\n\t\tif(text == null)\n\t\t\treturn;\n\t\ttext = text.substr(0,30); //avoid weird\n\n\t\tctx.font = "14px Courier New";\n\t\tvar info = ctx.measureText(text);\n\t\tvar w = info.width + 20;\n\t\tvar h = 24;\n\t\tctx.shadowColor = "black";\n\t\tctx.shadowOffsetX = 2;\n\t\tctx.shadowOffsetY = 2;\n\t\tctx.shadowBlur = 3;\n\t\tctx.fillStyle = "#454";\n\t\tctx.beginPath();\n\t\tctx.roundRect( pos[0] - w*0.5, pos[1] - 15 - h, w, h, [3]);\n\t\tctx.moveTo( pos[0] - 10, pos[1] - 15 );\n\t\tctx.lineTo( pos[0] + 10, pos[1] - 15 );\n\t\tctx.lineTo( pos[0], pos[1] - 5 );\n\t\tctx.fill();\n        ctx.shadowColor = "transparent";\n\t\tctx.textAlign = "center";\n\t\tctx.fillStyle = "#CEC";\n\t\tctx.fillText(text, pos[0], pos[1] - 15 - h * 0.3);\n\t}\n\n    /**\n     * draws the shape of the given node in the canvas\n     * @method drawNodeShape\n     **/\n    var tmp_area = new Float32Array(4);\n\n    LGraphCanvas.prototype.drawNodeShape = function(\n        node,\n        ctx,\n        size,\n        fgcolor,\n        bgcolor,\n        selected,\n        mouse_over\n    ) {\n        //bg rect\n        ctx.strokeStyle = fgcolor;\n        ctx.fillStyle = bgcolor;\n\n        var title_height = LiteGraph.NODE_TITLE_HEIGHT;\n        var low_quality = this.ds.scale < 0.5;\n\n        //render node area depending on shape\n        var shape =\n            node._shape || node.constructor.shape || LiteGraph.ROUND_SHAPE;\n\n        var title_mode = node.constructor.title_mode;\n\n        var render_title = true;\n        if (title_mode == LiteGraph.TRANSPARENT_TITLE || title_mode == LiteGraph.NO_TITLE) {\n            render_title = false;\n        } else if (title_mode == LiteGraph.AUTOHIDE_TITLE && mouse_over) {\n            render_title = true;\n        }\n\n        var area = tmp_area;\n        area[0] = 0; //x\n        area[1] = render_title ? -title_height : 0; //y\n        area[2] = size[0] + 1; //w\n        area[3] = render_title ? size[1] + title_height : size[1]; //h\n\n        var old_alpha = ctx.globalAlpha;\n\n        //full node shape\n        //if(node.flags.collapsed)\n        {\n            ctx.beginPath();\n            if (shape == LiteGraph.BOX_SHAPE || low_quality) {\n                ctx.fillRect(area[0], area[1], area[2], area[3]);\n            } else if (\n                shape == LiteGraph.ROUND_SHAPE ||\n                shape == LiteGraph.CARD_SHAPE\n            ) {\n                ctx.roundRect(\n                    area[0],\n                    area[1],\n                    area[2],\n                    area[3],\n                    shape == LiteGraph.CARD_SHAPE ? [this.round_radius,this.round_radius,0,0] : [this.round_radius] \n                );\n            } else if (shape == LiteGraph.CIRCLE_SHAPE) {\n                ctx.arc(\n                    size[0] * 0.5,\n                    size[1] * 0.5,\n                    size[0] * 0.5,\n                    0,\n                    Math.PI * 2\n                );\n            }\n            ctx.fill();\n\n\t\t\t//separator\n\t\t\tif(!node.flags.collapsed && render_title)\n\t\t\t{\n\t\t\t\tctx.shadowColor = "transparent";\n\t\t\t\tctx.fillStyle = "rgba(0,0,0,0.2)";\n\t\t\t\tctx.fillRect(0, -1, area[2], 2);\n\t\t\t}\n        }\n        ctx.shadowColor = "transparent";\n\n        if (node.onDrawBackground) {\n            node.onDrawBackground(ctx, this, this.canvas, this.graph_mouse );\n        }\n\n        //title bg (remember, it is rendered ABOVE the node)\n        if (render_title || title_mode == LiteGraph.TRANSPARENT_TITLE) {\n            //title bar\n            if (node.onDrawTitleBar) {\n                node.onDrawTitleBar( ctx, title_height, size, this.ds.scale, fgcolor );\n            } else if (\n                title_mode != LiteGraph.TRANSPARENT_TITLE &&\n                (node.constructor.title_color || this.render_title_colored)\n            ) {\n                var title_color = node.constructor.title_color || fgcolor;\n\n                if (node.flags.collapsed) {\n                    ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR;\n                }\n\n                //* gradient test\n                if (this.use_gradients) {\n                    var grad = LGraphCanvas.gradients[title_color];\n                    if (!grad) {\n                        grad = LGraphCanvas.gradients[ title_color ] = ctx.createLinearGradient(0, 0, 400, 0);\n                        grad.addColorStop(0, title_color); // TODO refactor: validate color !! prevent DOMException\n                        grad.addColorStop(1, "#000");\n                    }\n                    ctx.fillStyle = grad;\n                } else {\n                    ctx.fillStyle = title_color;\n                }\n\n                //ctx.globalAlpha = 0.5 * old_alpha;\n                ctx.beginPath();\n                if (shape == LiteGraph.BOX_SHAPE || low_quality) {\n                    ctx.rect(0, -title_height, size[0] + 1, title_height);\n                } else if (  shape == LiteGraph.ROUND_SHAPE || shape == LiteGraph.CARD_SHAPE ) {\n                    ctx.roundRect(\n                        0,\n                        -title_height,\n                        size[0] + 1,\n                        title_height,\n                        node.flags.collapsed ? [this.round_radius] : [this.round_radius,this.round_radius,0,0]\n                    );\n                }\n                ctx.fill();\n                ctx.shadowColor = "transparent";\n            }\n\n            var colState = false;\n            if (LiteGraph.node_box_coloured_by_mode){\n                if(LiteGraph.NODE_MODES_COLORS[node.mode]){\n                    colState = LiteGraph.NODE_MODES_COLORS[node.mode];\n                }\n            }\n            if (LiteGraph.node_box_coloured_when_on){\n                colState = node.action_triggered ? "#FFF" : (node.execute_triggered ? "#AAA" : colState);\n            }\n            \n            //title box\n            var box_size = 10;\n            if (node.onDrawTitleBox) {\n                node.onDrawTitleBox(ctx, title_height, size, this.ds.scale);\n            } else if (\n                shape == LiteGraph.ROUND_SHAPE ||\n                shape == LiteGraph.CIRCLE_SHAPE ||\n                shape == LiteGraph.CARD_SHAPE\n            ) {\n                if (low_quality) {\n                    ctx.fillStyle = "black";\n                    ctx.beginPath();\n                    ctx.arc(\n                        title_height * 0.5,\n                        title_height * -0.5,\n                        box_size * 0.5 + 1,\n                        0,\n                        Math.PI * 2\n                    );\n                    ctx.fill();\n                }\n                \n                ctx.fillStyle = node.boxcolor || colState || LiteGraph.NODE_DEFAULT_BOXCOLOR;\n\t\t\t\tif(low_quality)\n\t\t\t\t\tctx.fillRect( title_height * 0.5 - box_size *0.5, title_height * -0.5 - box_size *0.5, box_size , box_size  );\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(\n\t\t\t\t\t\ttitle_height * 0.5,\n\t\t\t\t\t\ttitle_height * -0.5,\n\t\t\t\t\t\tbox_size * 0.5,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tMath.PI * 2\n\t\t\t\t\t);\n\t\t\t\t\tctx.fill();\n\t\t\t\t}\n            } else {\n                if (low_quality) {\n                    ctx.fillStyle = "black";\n                    ctx.fillRect(\n                        (title_height - box_size) * 0.5 - 1,\n                        (title_height + box_size) * -0.5 - 1,\n                        box_size + 2,\n                        box_size + 2\n                    );\n                }\n                ctx.fillStyle = node.boxcolor || colState || LiteGraph.NODE_DEFAULT_BOXCOLOR;\n                ctx.fillRect(\n                    (title_height - box_size) * 0.5,\n                    (title_height + box_size) * -0.5,\n                    box_size,\n                    box_size\n                );\n            }\n            ctx.globalAlpha = old_alpha;\n\n            //title text\n            if (node.onDrawTitleText) {\n                node.onDrawTitleText(\n                    ctx,\n                    title_height,\n                    size,\n                    this.ds.scale,\n                    this.title_text_font,\n                    selected\n                );\n            }\n            if (!low_quality) {\n                ctx.font = this.title_text_font;\n                var title = String(node.getTitle());\n                if (title) {\n                    if (selected) {\n                        ctx.fillStyle = LiteGraph.NODE_SELECTED_TITLE_COLOR;\n                    } else {\n                        ctx.fillStyle =\n                            node.constructor.title_text_color ||\n                            this.node_title_color;\n                    }\n                    if (node.flags.collapsed) {\n                        ctx.textAlign = "left";\n                        var measure = ctx.measureText(title);\n                        ctx.fillText(\n                            title.substr(0,20), //avoid urls too long\n                            title_height,// + measure.width * 0.5,\n                            LiteGraph.NODE_TITLE_TEXT_Y - title_height\n                        );\n                        ctx.textAlign = "left";\n                    } else {\n                        ctx.textAlign = "left";\n                        ctx.fillText(\n                            title,\n                            title_height,\n                            LiteGraph.NODE_TITLE_TEXT_Y - title_height\n                        );\n                    }\n                }\n            }\n\n\t\t\t//subgraph box\n\t\t\tif (!node.flags.collapsed && node.subgraph && !node.skip_subgraph_button) {\n\t\t\t\tvar w = LiteGraph.NODE_TITLE_HEIGHT;\n\t\t\t\tvar x = node.size[0] - w;\n\t\t\t\tvar over = LiteGraph.isInsideRectangle( this.graph_mouse[0] - node.pos[0], this.graph_mouse[1] - node.pos[1], x+2, -w+2, w-4, w-4 );\n\t\t\t\tctx.fillStyle = over ? "#888" : "#555";\n\t\t\t\tif( shape == LiteGraph.BOX_SHAPE || low_quality)\n\t\t\t\t\tctx.fillRect(x+2, -w+2, w-4, w-4);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.roundRect(x+2, -w+2, w-4, w-4,[4]);\n\t\t\t\t\tctx.fill();\n\t\t\t\t}\n\t\t\t\tctx.fillStyle = "#333";\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(x + w * 0.2, -w * 0.6);\n\t\t\t\tctx.lineTo(x + w * 0.8, -w * 0.6);\n\t\t\t\tctx.lineTo(x + w * 0.5, -w * 0.3);\n\t\t\t\tctx.fill();\n\t\t\t}\n\n\t\t\t//custom title render\n            if (node.onDrawTitle) {\n                node.onDrawTitle(ctx);\n            }\n        }\n\n        //render selection marker\n        if (selected) {\n            if (node.onBounding) {\n                node.onBounding(area);\n            }\n\n            if (title_mode == LiteGraph.TRANSPARENT_TITLE) {\n                area[1] -= title_height;\n                area[3] += title_height;\n            }\n            ctx.lineWidth = 1;\n            ctx.globalAlpha = 0.8;\n            ctx.beginPath();\n            if (shape == LiteGraph.BOX_SHAPE) {\n                ctx.rect(\n                    -6 + area[0],\n                    -6 + area[1],\n                    12 + area[2],\n                    12 + area[3]\n                );\n            } else if (\n                shape == LiteGraph.ROUND_SHAPE ||\n                (shape == LiteGraph.CARD_SHAPE && node.flags.collapsed)\n            ) {\n                ctx.roundRect(\n                    -6 + area[0],\n                    -6 + area[1],\n                    12 + area[2],\n                    12 + area[3],\n                    [this.round_radius * 2]\n                );\n            } else if (shape == LiteGraph.CARD_SHAPE) {\n                ctx.roundRect(\n                    -6 + area[0],\n                    -6 + area[1],\n                    12 + area[2],\n                    12 + area[3],\n                    [this.round_radius * 2,2,this.round_radius * 2,2]\n                );\n            } else if (shape == LiteGraph.CIRCLE_SHAPE) {\n                ctx.arc(\n                    size[0] * 0.5,\n                    size[1] * 0.5,\n                    size[0] * 0.5 + 6,\n                    0,\n                    Math.PI * 2\n                );\n            }\n            ctx.strokeStyle = LiteGraph.NODE_BOX_OUTLINE_COLOR;\n            ctx.stroke();\n            ctx.strokeStyle = fgcolor;\n            ctx.globalAlpha = 1;\n        }\n        \n        // these counter helps in conditioning drawing based on if the node has been executed or an action occurred\n        if (node.execute_triggered>0) node.execute_triggered--;\n        if (node.action_triggered>0) node.action_triggered--;\n    };\n\n    var margin_area = new Float32Array(4);\n    var link_bounding = new Float32Array(4);\n    var tempA = new Float32Array(2);\n    var tempB = new Float32Array(2);\n\n    /**\n     * draws every connection visible in the canvas\n     * OPTIMIZE THIS: pre-catch connections position instead of recomputing them every time\n     * @method drawConnections\n     **/\n    LGraphCanvas.prototype.drawConnections = function(ctx) {\n        var now = LiteGraph.getTime();\n        var visible_area = this.visible_area;\n        margin_area[0] = visible_area[0] - 20;\n        margin_area[1] = visible_area[1] - 20;\n        margin_area[2] = visible_area[2] + 40;\n        margin_area[3] = visible_area[3] + 40;\n\n        //draw connections\n        ctx.lineWidth = this.connections_width;\n\n        ctx.fillStyle = "#AAA";\n        ctx.strokeStyle = "#AAA";\n        ctx.globalAlpha = this.editor_alpha;\n        //for every node\n        var nodes = this.graph._nodes;\n        for (var n = 0, l = nodes.length; n < l; ++n) {\n            var node = nodes[n];\n            //for every input (we render just inputs because it is easier as every slot can only have one input)\n            if (!node.inputs || !node.inputs.length) {\n                continue;\n            }\n\n            for (var i = 0; i < node.inputs.length; ++i) {\n                var input = node.inputs[i];\n                if (!input || input.link == null) {\n                    continue;\n                }\n                var link_id = input.link;\n                var link = this.graph.links[link_id];\n                if (!link) {\n                    continue;\n                }\n\n                //find link info\n                var start_node = this.graph.getNodeById(link.origin_id);\n                if (start_node == null) {\n                    continue;\n                }\n                var start_node_slot = link.origin_slot;\n                var start_node_slotpos = null;\n                if (start_node_slot == -1) {\n                    start_node_slotpos = [\n                        start_node.pos[0] + 10,\n                        start_node.pos[1] + 10\n                    ];\n                } else {\n                    start_node_slotpos = start_node.getConnectionPos(\n                        false,\n                        start_node_slot,\n                        tempA\n                    );\n                }\n                var end_node_slotpos = node.getConnectionPos(true, i, tempB);\n\n                //compute link bounding\n                link_bounding[0] = start_node_slotpos[0];\n                link_bounding[1] = start_node_slotpos[1];\n                link_bounding[2] = end_node_slotpos[0] - start_node_slotpos[0];\n                link_bounding[3] = end_node_slotpos[1] - start_node_slotpos[1];\n                if (link_bounding[2] < 0) {\n                    link_bounding[0] += link_bounding[2];\n                    link_bounding[2] = Math.abs(link_bounding[2]);\n                }\n                if (link_bounding[3] < 0) {\n                    link_bounding[1] += link_bounding[3];\n                    link_bounding[3] = Math.abs(link_bounding[3]);\n                }\n\n                //skip links outside of the visible area of the canvas\n                if (!overlapBounding(link_bounding, margin_area)) {\n                    continue;\n                }\n\n                var start_slot = start_node.outputs[start_node_slot];\n                var end_slot = node.inputs[i];\n                if (!start_slot || !end_slot) {\n                    continue;\n                }\n                var start_dir =\n                    start_slot.dir ||\n                    (start_node.horizontal ? LiteGraph.DOWN : LiteGraph.RIGHT);\n                var end_dir =\n                    end_slot.dir ||\n                    (node.horizontal ? LiteGraph.UP : LiteGraph.LEFT);\n\n                this.renderLink(\n                    ctx,\n                    start_node_slotpos,\n                    end_node_slotpos,\n                    link,\n                    false,\n                    0,\n                    null,\n                    start_dir,\n                    end_dir\n                );\n\n                //event triggered rendered on top\n                if (link && link._last_time && now - link._last_time < 1000) {\n                    var f = 2.0 - (now - link._last_time) * 0.002;\n                    var tmp = ctx.globalAlpha;\n                    ctx.globalAlpha = tmp * f;\n                    this.renderLink(\n                        ctx,\n                        start_node_slotpos,\n                        end_node_slotpos,\n                        link,\n                        true,\n                        f,\n                        "white",\n                        start_dir,\n                        end_dir\n                    );\n                    ctx.globalAlpha = tmp;\n                }\n            }\n        }\n        ctx.globalAlpha = 1;\n    };\n\n    /**\n     * draws a link between two points\n     * @method renderLink\n     * @param {vec2} a start pos\n     * @param {vec2} b end pos\n     * @param {Object} link the link object with all the link info\n     * @param {boolean} skip_border ignore the shadow of the link\n     * @param {boolean} flow show flow animation (for events)\n     * @param {string} color the color for the link\n     * @param {number} start_dir the direction enum\n     * @param {number} end_dir the direction enum\n     * @param {number} num_sublines number of sublines (useful to represent vec3 or rgb)\n     **/\n    LGraphCanvas.prototype.renderLink = function(\n        ctx,\n        a,\n        b,\n        link,\n        skip_border,\n        flow,\n        color,\n        start_dir,\n        end_dir,\n        num_sublines\n    ) {\n        if (link) {\n            this.visible_links.push(link);\n        }\n\n        //choose color\n        if (!color && link) {\n            color = link.color || LGraphCanvas.link_type_colors[link.type];\n        }\n        if (!color) {\n            color = this.default_link_color;\n        }\n        if (link != null && this.highlighted_links[link.id]) {\n            color = "#FFF";\n        }\n\n        start_dir = start_dir || LiteGraph.RIGHT;\n        end_dir = end_dir || LiteGraph.LEFT;\n\n        var dist = distance(a, b);\n\n        if (this.render_connections_border && this.ds.scale > 0.6) {\n            ctx.lineWidth = this.connections_width + 4;\n        }\n        ctx.lineJoin = "round";\n        num_sublines = num_sublines || 1;\n        if (num_sublines > 1) {\n            ctx.lineWidth = 0.5;\n        }\n\n        //begin line shape\n        ctx.beginPath();\n        for (var i = 0; i < num_sublines; i += 1) {\n            var offsety = (i - (num_sublines - 1) * 0.5) * 5;\n\n            if (this.links_render_mode == LiteGraph.SPLINE_LINK) {\n                ctx.moveTo(a[0], a[1] + offsety);\n                var start_offset_x = 0;\n                var start_offset_y = 0;\n                var end_offset_x = 0;\n                var end_offset_y = 0;\n                switch (start_dir) {\n                    case LiteGraph.LEFT:\n                        start_offset_x = dist * -0.25;\n                        break;\n                    case LiteGraph.RIGHT:\n                        start_offset_x = dist * 0.25;\n                        break;\n                    case LiteGraph.UP:\n                        start_offset_y = dist * -0.25;\n                        break;\n                    case LiteGraph.DOWN:\n                        start_offset_y = dist * 0.25;\n                        break;\n                }\n                switch (end_dir) {\n                    case LiteGraph.LEFT:\n                        end_offset_x = dist * -0.25;\n                        break;\n                    case LiteGraph.RIGHT:\n                        end_offset_x = dist * 0.25;\n                        break;\n                    case LiteGraph.UP:\n                        end_offset_y = dist * -0.25;\n                        break;\n                    case LiteGraph.DOWN:\n                        end_offset_y = dist * 0.25;\n                        break;\n                }\n                ctx.bezierCurveTo(\n                    a[0] + start_offset_x,\n                    a[1] + start_offset_y + offsety,\n                    b[0] + end_offset_x,\n                    b[1] + end_offset_y + offsety,\n                    b[0],\n                    b[1] + offsety\n                );\n            } else if (this.links_render_mode == LiteGraph.LINEAR_LINK) {\n                ctx.moveTo(a[0], a[1] + offsety);\n                var start_offset_x = 0;\n                var start_offset_y = 0;\n                var end_offset_x = 0;\n                var end_offset_y = 0;\n                switch (start_dir) {\n                    case LiteGraph.LEFT:\n                        start_offset_x = -1;\n                        break;\n                    case LiteGraph.RIGHT:\n                        start_offset_x = 1;\n                        break;\n                    case LiteGraph.UP:\n                        start_offset_y = -1;\n                        break;\n                    case LiteGraph.DOWN:\n                        start_offset_y = 1;\n                        break;\n                }\n                switch (end_dir) {\n                    case LiteGraph.LEFT:\n                        end_offset_x = -1;\n                        break;\n                    case LiteGraph.RIGHT:\n                        end_offset_x = 1;\n                        break;\n                    case LiteGraph.UP:\n                        end_offset_y = -1;\n                        break;\n                    case LiteGraph.DOWN:\n                        end_offset_y = 1;\n                        break;\n                }\n                var l = 15;\n                ctx.lineTo(\n                    a[0] + start_offset_x * l,\n                    a[1] + start_offset_y * l + offsety\n                );\n                ctx.lineTo(\n                    b[0] + end_offset_x * l,\n                    b[1] + end_offset_y * l + offsety\n                );\n                ctx.lineTo(b[0], b[1] + offsety);\n            } else if (this.links_render_mode == LiteGraph.STRAIGHT_LINK) {\n                ctx.moveTo(a[0], a[1]);\n                var start_x = a[0];\n                var start_y = a[1];\n                var end_x = b[0];\n                var end_y = b[1];\n                if (start_dir == LiteGraph.RIGHT) {\n                    start_x += 10;\n                } else {\n                    start_y += 10;\n                }\n                if (end_dir == LiteGraph.LEFT) {\n                    end_x -= 10;\n                } else {\n                    end_y -= 10;\n                }\n                ctx.lineTo(start_x, start_y);\n                ctx.lineTo((start_x + end_x) * 0.5, start_y);\n                ctx.lineTo((start_x + end_x) * 0.5, end_y);\n                ctx.lineTo(end_x, end_y);\n                ctx.lineTo(b[0], b[1]);\n            } else {\n                return;\n            } //unknown\n        }\n\n        //rendering the outline of the connection can be a little bit slow\n        if (\n            this.render_connections_border &&\n            this.ds.scale > 0.6 &&\n            !skip_border\n        ) {\n            ctx.strokeStyle = "rgba(0,0,0,0.5)";\n            ctx.stroke();\n        }\n\n        ctx.lineWidth = this.connections_width;\n        ctx.fillStyle = ctx.strokeStyle = color;\n        ctx.stroke();\n        //end line shape\n\n        var pos = this.computeConnectionPoint(a, b, 0.5, start_dir, end_dir);\n        if (link && link._pos) {\n            link._pos[0] = pos[0];\n            link._pos[1] = pos[1];\n        }\n\n        //render arrow in the middle\n        if (\n            this.ds.scale >= 0.6 &&\n            this.highquality_render &&\n            end_dir != LiteGraph.CENTER\n        ) {\n            //render arrow\n            if (this.render_connection_arrows) {\n                //compute two points in the connection\n                var posA = this.computeConnectionPoint(\n                    a,\n                    b,\n                    0.25,\n                    start_dir,\n                    end_dir\n                );\n                var posB = this.computeConnectionPoint(\n                    a,\n                    b,\n                    0.26,\n                    start_dir,\n                    end_dir\n                );\n                var posC = this.computeConnectionPoint(\n                    a,\n                    b,\n                    0.75,\n                    start_dir,\n                    end_dir\n                );\n                var posD = this.computeConnectionPoint(\n                    a,\n                    b,\n                    0.76,\n                    start_dir,\n                    end_dir\n                );\n\n                //compute the angle between them so the arrow points in the right direction\n                var angleA = 0;\n                var angleB = 0;\n                if (this.render_curved_connections) {\n                    angleA = -Math.atan2(posB[0] - posA[0], posB[1] - posA[1]);\n                    angleB = -Math.atan2(posD[0] - posC[0], posD[1] - posC[1]);\n                } else {\n                    angleB = angleA = b[1] > a[1] ? 0 : Math.PI;\n                }\n\n                //render arrow\n                ctx.save();\n                ctx.translate(posA[0], posA[1]);\n                ctx.rotate(angleA);\n                ctx.beginPath();\n                ctx.moveTo(-5, -3);\n                ctx.lineTo(0, +7);\n                ctx.lineTo(+5, -3);\n                ctx.fill();\n                ctx.restore();\n                ctx.save();\n                ctx.translate(posC[0], posC[1]);\n                ctx.rotate(angleB);\n                ctx.beginPath();\n                ctx.moveTo(-5, -3);\n                ctx.lineTo(0, +7);\n                ctx.lineTo(+5, -3);\n                ctx.fill();\n                ctx.restore();\n            }\n\n            //circle\n            ctx.beginPath();\n            ctx.arc(pos[0], pos[1], 5, 0, Math.PI * 2);\n            ctx.fill();\n        }\n\n        //render flowing points\n        if (flow) {\n            ctx.fillStyle = color;\n            for (var i = 0; i < 5; ++i) {\n                var f = (LiteGraph.getTime() * 0.001 + i * 0.2) % 1;\n                var pos = this.computeConnectionPoint(\n                    a,\n                    b,\n                    f,\n                    start_dir,\n                    end_dir\n                );\n                ctx.beginPath();\n                ctx.arc(pos[0], pos[1], 5, 0, 2 * Math.PI);\n                ctx.fill();\n            }\n        }\n    };\n\n    //returns the link center point based on curvature\n    LGraphCanvas.prototype.computeConnectionPoint = function(\n        a,\n        b,\n        t,\n        start_dir,\n        end_dir\n    ) {\n        start_dir = start_dir || LiteGraph.RIGHT;\n        end_dir = end_dir || LiteGraph.LEFT;\n\n        var dist = distance(a, b);\n        var p0 = a;\n        var p1 = [a[0], a[1]];\n        var p2 = [b[0], b[1]];\n        var p3 = b;\n\n        switch (start_dir) {\n            case LiteGraph.LEFT:\n                p1[0] += dist * -0.25;\n                break;\n            case LiteGraph.RIGHT:\n                p1[0] += dist * 0.25;\n                break;\n            case LiteGraph.UP:\n                p1[1] += dist * -0.25;\n                break;\n            case LiteGraph.DOWN:\n                p1[1] += dist * 0.25;\n                break;\n        }\n        switch (end_dir) {\n            case LiteGraph.LEFT:\n                p2[0] += dist * -0.25;\n                break;\n            case LiteGraph.RIGHT:\n                p2[0] += dist * 0.25;\n                break;\n            case LiteGraph.UP:\n                p2[1] += dist * -0.25;\n                break;\n            case LiteGraph.DOWN:\n                p2[1] += dist * 0.25;\n                break;\n        }\n\n        var c1 = (1 - t) * (1 - t) * (1 - t);\n        var c2 = 3 * ((1 - t) * (1 - t)) * t;\n        var c3 = 3 * (1 - t) * (t * t);\n        var c4 = t * t * t;\n\n        var x = c1 * p0[0] + c2 * p1[0] + c3 * p2[0] + c4 * p3[0];\n        var y = c1 * p0[1] + c2 * p1[1] + c3 * p2[1] + c4 * p3[1];\n        return [x, y];\n    };\n\n    LGraphCanvas.prototype.drawExecutionOrder = function(ctx) {\n        ctx.shadowColor = "transparent";\n        ctx.globalAlpha = 0.25;\n\n        ctx.textAlign = "center";\n        ctx.strokeStyle = "white";\n        ctx.globalAlpha = 0.75;\n\n        var visible_nodes = this.visible_nodes;\n        for (var i = 0; i < visible_nodes.length; ++i) {\n            var node = visible_nodes[i];\n            ctx.fillStyle = "black";\n            ctx.fillRect(\n                node.pos[0] - LiteGraph.NODE_TITLE_HEIGHT,\n                node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT,\n                LiteGraph.NODE_TITLE_HEIGHT,\n                LiteGraph.NODE_TITLE_HEIGHT\n            );\n            if (node.order == 0) {\n                ctx.strokeRect(\n                    node.pos[0] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,\n                    node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,\n                    LiteGraph.NODE_TITLE_HEIGHT,\n                    LiteGraph.NODE_TITLE_HEIGHT\n                );\n            }\n            ctx.fillStyle = "#FFF";\n            ctx.fillText(\n                node.order,\n                node.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * -0.5,\n                node.pos[1] - 6\n            );\n        }\n        ctx.globalAlpha = 1;\n    };\n\n    /**\n     * draws the widgets stored inside a node\n     * @method drawNodeWidgets\n     **/\n    LGraphCanvas.prototype.drawNodeWidgets = function(\n        node,\n        posY,\n        ctx,\n        active_widget\n    ) {\n        if (!node.widgets || !node.widgets.length) {\n            return 0;\n        }\n        var width = node.size[0];\n        var widgets = node.widgets;\n        posY += 2;\n        var H = LiteGraph.NODE_WIDGET_HEIGHT;\n        var show_text = this.ds.scale > 0.5;\n        ctx.save();\n        ctx.globalAlpha = this.editor_alpha;\n        var outline_color = LiteGraph.WIDGET_OUTLINE_COLOR;\n        var background_color = LiteGraph.WIDGET_BGCOLOR;\n        var text_color = LiteGraph.WIDGET_TEXT_COLOR;\n\t\tvar secondary_text_color = LiteGraph.WIDGET_SECONDARY_TEXT_COLOR;\n        var margin = 15;\n\n        for (var i = 0; i < widgets.length; ++i) {\n            var w = widgets[i];\n            var y = posY;\n            if (w.y) {\n                y = w.y;\n            }\n            w.last_y = y;\n            ctx.strokeStyle = outline_color;\n            ctx.fillStyle = "#222";\n            ctx.textAlign = "left";\n\t\t\t//ctx.lineWidth = 2;\n\t\t\tif(w.disabled)\n\t\t\t\tctx.globalAlpha *= 0.5;\n\t\t\tvar widget_width = w.width || width;\n\n            switch (w.type) {\n                case "button":\n                    if (w.clicked) {\n                        ctx.fillStyle = "#AAA";\n                        w.clicked = false;\n                        this.dirty_canvas = true;\n                    }\n                    ctx.fillRect(margin, y, widget_width - margin * 2, H);\n\t\t\t\t\tif(show_text && !w.disabled)\n\t                    ctx.strokeRect( margin, y, widget_width - margin * 2, H );\n                    if (show_text) {\n                        ctx.textAlign = "center";\n                        ctx.fillStyle = text_color;\n                        ctx.fillText(w.label || w.name, widget_width * 0.5, y + H * 0.7);\n                    }\n                    break;\n                case "toggle":\n                    ctx.textAlign = "left";\n                    ctx.strokeStyle = outline_color;\n                    ctx.fillStyle = background_color;\n                    ctx.beginPath();\n                    if (show_text)\n\t                    ctx.roundRect(margin, y, widget_width - margin * 2, H, [H * 0.5]);\n\t\t\t\t\telse\n\t                    ctx.rect(margin, y, widget_width - margin * 2, H );\n                    ctx.fill();\n\t\t\t\t\tif(show_text && !w.disabled)\n\t                    ctx.stroke();\n                    ctx.fillStyle = w.value ? "#89A" : "#333";\n                    ctx.beginPath();\n                    ctx.arc( widget_width - margin * 2, y + H * 0.5, H * 0.36, 0, Math.PI * 2 );\n                    ctx.fill();\n                    if (show_text) {\n                        ctx.fillStyle = secondary_text_color;\n                        const label = w.label || w.name;    \n                        if (label != null) {\n                            ctx.fillText(label, margin * 2, y + H * 0.7);\n                        }\n                        ctx.fillStyle = w.value ? text_color : secondary_text_color;\n                        ctx.textAlign = "right";\n                        ctx.fillText(\n                            w.value\n                                ? w.options.on || "true"\n                                : w.options.off || "false",\n                            widget_width - 40,\n                            y + H * 0.7\n                        );\n                    }\n                    break;\n                case "slider":\n                    ctx.fillStyle = background_color;\n                    ctx.fillRect(margin, y, widget_width - margin * 2, H);\n                    var range = w.options.max - w.options.min;\n                    var nvalue = (w.value - w.options.min) / range;\n\t\t\t\t\tif(nvalue < 0.0) nvalue = 0.0;\n\t\t\t\t\tif(nvalue > 1.0) nvalue = 1.0;\n                    ctx.fillStyle = w.options.hasOwnProperty("slider_color") ? w.options.slider_color : (active_widget == w ? "#89A" : "#678");\n                    ctx.fillRect(margin, y, nvalue * (widget_width - margin * 2), H);\n\t\t\t\t\tif(show_text && !w.disabled)\n\t                    ctx.strokeRect(margin, y, widget_width - margin * 2, H);\n                    if (w.marker) {\n                        var marker_nvalue = (w.marker - w.options.min) / range;\n\t\t\t\t\t\tif(marker_nvalue < 0.0) marker_nvalue = 0.0;\n\t\t\t\t\t\tif(marker_nvalue > 1.0) marker_nvalue = 1.0;\n                        ctx.fillStyle = w.options.hasOwnProperty("marker_color") ? w.options.marker_color : "#AA9";\n                        ctx.fillRect( margin + marker_nvalue * (widget_width - margin * 2), y, 2, H );\n                    }\n                    if (show_text) {\n                        ctx.textAlign = "center";\n                        ctx.fillStyle = text_color;\n                        ctx.fillText(\n                            w.label || w.name + "  " + Number(w.value).toFixed(\n                                                            w.options.precision != null\n                                                                ? w.options.precision\n                                                                : 3\n                                                        ),\n                            widget_width * 0.5,\n                            y + H * 0.7\n                        );\n                    }\n                    break;\n                case "number":\n                case "combo":\n                    ctx.textAlign = "left";\n                    ctx.strokeStyle = outline_color;\n                    ctx.fillStyle = background_color;\n                    ctx.beginPath();\n\t\t\t\t\tif(show_text)\n\t                    ctx.roundRect(margin, y, widget_width - margin * 2, H, [H * 0.5] );\n\t\t\t\t\telse\n\t                    ctx.rect(margin, y, widget_width - margin * 2, H );\n                    ctx.fill();\n                    if (show_text) {\n\t\t\t\t\t\tif(!w.disabled)\n\t\t                    ctx.stroke();\n                        ctx.fillStyle = text_color;\n\t\t\t\t\t\tif(!w.disabled)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\tctx.moveTo(margin + 16, y + 5);\n\t\t\t\t\t\t\tctx.lineTo(margin + 6, y + H * 0.5);\n\t\t\t\t\t\t\tctx.lineTo(margin + 16, y + H - 5);\n\t\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\tctx.moveTo(widget_width - margin - 16, y + 5);\n\t\t\t\t\t\t\tctx.lineTo(widget_width - margin - 6, y + H * 0.5);\n\t\t\t\t\t\t\tctx.lineTo(widget_width - margin - 16, y + H - 5);\n\t\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t\t}\n                        ctx.fillStyle = secondary_text_color;\n                        ctx.fillText(w.label || w.name, margin * 2 + 5, y + H * 0.7);\n                        ctx.fillStyle = text_color;\n                        ctx.textAlign = "right";\n                        if (w.type == "number") {\n                            ctx.fillText(\n                                Number(w.value).toFixed(\n                                    w.options.precision !== undefined\n                                        ? w.options.precision\n                                        : 3\n                                ),\n                                widget_width - margin * 2 - 20,\n                                y + H * 0.7\n                            );\n                        } else {\n\t\t\t\t\t\t\tvar v = w.value;\n\t\t\t\t\t\t\tif( w.options.values )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar values = w.options.values;\n\t\t\t\t\t\t\t\tif( values.constructor === Function )\n\t\t\t\t\t\t\t\t\tvalues = values();\n\t\t\t\t\t\t\t\tif(values && values.constructor !== Array)\n\t\t\t\t\t\t\t\t\tv = values[ w.value ];\n\t\t\t\t\t\t\t}\n                            ctx.fillText(\n                                v,\n                                widget_width - margin * 2 - 20,\n                                y + H * 0.7\n                            );\n                        }\n                    }\n                    break;\n                case "string":\n                case "text":\n                    ctx.textAlign = "left";\n                    ctx.strokeStyle = outline_color;\n                    ctx.fillStyle = background_color;\n                    ctx.beginPath();\n                    if (show_text)\n\t                    ctx.roundRect(margin, y, widget_width - margin * 2, H, [H * 0.5]);\n\t\t\t\t\telse\n\t                    ctx.rect( margin, y, widget_width - margin * 2, H );\n                    ctx.fill();\n\t                if (show_text) {\n\t\t\t\t\t\tif(!w.disabled)\n\t\t\t\t\t\t\tctx.stroke();\n    \t\t\t\t\tctx.save();\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.rect(margin, y, widget_width - margin * 2, H);\n\t\t\t\t\t\tctx.clip();\n\n\t                    //ctx.stroke();\n                        ctx.fillStyle = secondary_text_color;\n                        const label = w.label || w.name;\t\n                        if (label != null) {\n                            ctx.fillText(label, margin * 2, y + H * 0.7);\n                        }\n                        ctx.fillStyle = text_color;\n                        ctx.textAlign = "right";\n                        ctx.fillText(String(w.value).substr(0,30), widget_width - margin * 2, y + H * 0.7); //30 chars max\n\t\t\t\t\t\tctx.restore();\n                    }\n                    break;\n                default:\n                    if (w.draw) {\n                        w.draw(ctx, node, widget_width, y, H);\n                    }\n                    break;\n            }\n            posY += (w.computeSize ? w.computeSize(widget_width)[1] : H) + 4;\n\t\t\tctx.globalAlpha = this.editor_alpha;\n\n        }\n        ctx.restore();\n\t\tctx.textAlign = "left";\n    };\n\n    /**\n     * process an event on widgets\n     * @method processNodeWidgets\n     **/\n    LGraphCanvas.prototype.processNodeWidgets = function(\n        node,\n        pos,\n        event,\n        active_widget\n    ) {\n        if (!node.widgets || !node.widgets.length || (!this.allow_interaction && !node.flags.allow_interaction)) {\n            return null;\n        }\n\n        var x = pos[0] - node.pos[0];\n        var y = pos[1] - node.pos[1];\n        var width = node.size[0];\n        var deltaX = event.deltaX || event.deltax || 0;\n        var that = this;\n        var ref_window = this.getCanvasWindow();\n\n        for (var i = 0; i < node.widgets.length; ++i) {\n            var w = node.widgets[i];\n\t\t\tif(!w || w.disabled)\n\t\t\t\tcontinue;\n\t\t\tvar widget_height = w.computeSize ? w.computeSize(width)[1] : LiteGraph.NODE_WIDGET_HEIGHT;\n\t\t\tvar widget_width = w.width || width;\n\t\t\t//outside\n\t\t\tif ( w != active_widget && \n\t\t\t\t(x < 6 || x > widget_width - 12 || y < w.last_y || y > w.last_y + widget_height || w.last_y === undefined) ) \n\t\t\t\tcontinue;\n\n\t\t\tvar old_value = w.value;\n\n            //if ( w == active_widget || (x > 6 && x < widget_width - 12 && y > w.last_y && y < w.last_y + widget_height) ) {\n\t\t\t//inside widget\n\t\t\tswitch (w.type) {\n\t\t\t\tcase "button":\n\t\t\t\t\tif (event.type === LiteGraph.pointerevents_method+"down") {\n                        if (w.callback) {\n                            setTimeout(function() {\n                                w.callback(w, that, node, pos, event);\n                            }, 20);\n                        }\n                        w.clicked = true;\n                        this.dirty_canvas = true;\n                    }\n\t\t\t\t\tbreak;\n\t\t\t\tcase "slider":\n\t\t\t\t\tvar old_value = w.value;\n\t\t\t\t\tvar nvalue = clamp((x - 15) / (widget_width - 30), 0, 1);\n\t\t\t\t\tif(w.options.read_only) break;\n\t\t\t\t\tw.value = w.options.min + (w.options.max - w.options.min) * nvalue;\n\t\t\t\t\tif (old_value != w.value) {\n\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\tinner_value_change(w, w.value);\n\t\t\t\t\t\t}, 20);\n\t\t\t\t\t}\n\t\t\t\t\tthis.dirty_canvas = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase "number":\n\t\t\t\tcase "combo":\n\t\t\t\t\tvar old_value = w.value;\n\t\t\t\t\tif (event.type == LiteGraph.pointerevents_method+"move" && w.type == "number") {\n                        if(deltaX)\n\t\t\t\t\t\t    w.value += deltaX * 0.1 * (w.options.step || 1);\n\t\t\t\t\t\tif ( w.options.min != null && w.value < w.options.min ) {\n\t\t\t\t\t\t\tw.value = w.options.min;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( w.options.max != null && w.value > w.options.max ) {\n\t\t\t\t\t\t\tw.value = w.options.max;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (event.type == LiteGraph.pointerevents_method+"down") {\n\t\t\t\t\t\tvar values = w.options.values;\n\t\t\t\t\t\tif (values && values.constructor === Function) {\n\t\t\t\t\t\t\tvalues = w.options.values(w, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar values_list = null;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( w.type != "number")\n\t\t\t\t\t\t\tvalues_list = values.constructor === Array ? values : Object.keys(values);\n\n\t\t\t\t\t\tvar delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;\n\t\t\t\t\t\tif (w.type == "number") {\n\t\t\t\t\t\t\tw.value += delta * 0.1 * (w.options.step || 1);\n\t\t\t\t\t\t\tif ( w.options.min != null && w.value < w.options.min ) {\n\t\t\t\t\t\t\t\tw.value = w.options.min;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( w.options.max != null && w.value > w.options.max ) {\n\t\t\t\t\t\t\t\tw.value = w.options.max;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (delta) { //clicked in arrow, used for combos \n\t\t\t\t\t\t\tvar index = -1;\n\t\t\t\t\t\t\tthis.last_mouseclick = 0; //avoids dobl click event\n\t\t\t\t\t\t\tif(values.constructor === Object)\n\t\t\t\t\t\t\t\tindex = values_list.indexOf( String( w.value ) ) + delta;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tindex = values_list.indexOf( w.value ) + delta;\n\t\t\t\t\t\t\tif (index >= values_list.length) {\n\t\t\t\t\t\t\t\tindex = values_list.length - 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (index < 0) {\n\t\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( values.constructor === Array )\n\t\t\t\t\t\t\t\tw.value = values[index];\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tw.value = index;\n\t\t\t\t\t\t} else { //combo clicked \n\t\t\t\t\t\t\tvar text_values = values != values_list ? Object.values(values) : values;\n\t\t\t\t\t\t\tvar menu = new LiteGraph.ContextMenu(text_values, {\n\t\t\t\t\t\t\t\t\tscale: Math.max(1, this.ds.scale),\n\t\t\t\t\t\t\t\t\tevent: event,\n\t\t\t\t\t\t\t\t\tclassName: "dark",\n\t\t\t\t\t\t\t\t\tcallback: inner_clicked.bind(w)\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tref_window);\n\t\t\t\t\t\t\tfunction inner_clicked(v, option, event) {\n\t\t\t\t\t\t\t\tif(values != values_list)\n\t\t\t\t\t\t\t\t\tv = text_values.indexOf(v);\n\t\t\t\t\t\t\t\tthis.value = v;\n\t\t\t\t\t\t\t\tinner_value_change(this, v);\n\t\t\t\t\t\t\t\tthat.dirty_canvas = true;\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} //end mousedown\n\t\t\t\t\telse if(event.type == LiteGraph.pointerevents_method+"up" && w.type == "number")\n\t\t\t\t\t{\n\t\t\t\t\t\tvar delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;\n\t\t\t\t\t\tif (event.click_time < 200 && delta == 0) {\n\t\t\t\t\t\t\tthis.prompt("Value",w.value,function(v) {\n\t\t\t\t\t\t\t\t\t// check if v is a valid equation or a number\n\t\t\t\t\t\t\t\t\t  if (/^[0-9+\\-*/()\\s]+|\\d+\\.\\d+$/.test(v)) {\n\t\t\t\t\t\t\t\t\t\ttry {//solve the equation if possible\n\t\t\t\t\t\t\t\t\t    \t\tv = eval(v);\n\t\t\t\t\t\t\t\t\t\t} catch (e) { }\n\t\t\t\t\t\t\t\t\t}\t\n\t\t\t\t\t\t\t\t\tthis.value = Number(v);\n\t\t\t\t\t\t\t\t\tinner_value_change(this, this.value);\n\t\t\t\t\t\t\t\t}.bind(w),\n\t\t\t\t\t\t\t\tevent);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif( old_value != w.value )\n\t\t\t\t\t\tsetTimeout(\n\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\tinner_value_change(this, this.value);\n\t\t\t\t\t\t\t}.bind(w),\n\t\t\t\t\t\t\t20\n\t\t\t\t\t\t);\n\t\t\t\t\tthis.dirty_canvas = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase "toggle":\n\t\t\t\t\tif (event.type == LiteGraph.pointerevents_method+"down") {\n\t\t\t\t\t\tw.value = !w.value;\n\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\tinner_value_change(w, w.value);\n\t\t\t\t\t\t}, 20);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase "string":\n\t\t\t\tcase "text":\n\t\t\t\t\tif (event.type == LiteGraph.pointerevents_method+"down") {\n\t\t\t\t\t\tthis.prompt("Value",w.value,function(v) {\n\t\t\t\t\t\t\t\tinner_value_change(this, v);\n\t\t\t\t\t\t\t}.bind(w),\n\t\t\t\t\t\t\tevent,w.options ? w.options.multiline : false );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (w.mouse) {\n\t\t\t\t\t\tthis.dirty_canvas = w.mouse(event, [x, y], node);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t} //end switch\n\n\t\t\t//value changed\n\t\t\tif( old_value != w.value )\n\t\t\t{\n\t\t\t\tif(node.onWidgetChanged)\n\t\t\t\t\tnode.onWidgetChanged( w.name,w.value,old_value,w );\n                node.graph._version++;\n\t\t\t}\n\n\t\t\treturn w;\n        }//end for\n\n        function inner_value_change(widget, value) {\n            if(widget.type == "number"){\n                value = Number(value);\n            }\n            widget.value = value;\n            if ( widget.options && widget.options.property && node.properties[widget.options.property] !== undefined ) {\n                node.setProperty( widget.options.property, value );\n            }\n            if (widget.callback) {\n                widget.callback(widget.value, that, node, pos, event);\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * draws every group area in the background\n     * @method drawGroups\n     **/\n    LGraphCanvas.prototype.drawGroups = function(canvas, ctx) {\n        if (!this.graph) {\n            return;\n        }\n\n        var groups = this.graph._groups;\n\n        ctx.save();\n        ctx.globalAlpha = 0.5 * this.editor_alpha;\n\n        for (var i = 0; i < groups.length; ++i) {\n            var group = groups[i];\n\n            if (!overlapBounding(this.visible_area, group._bounding)) {\n                continue;\n            } //out of the visible area\n\n            ctx.fillStyle = group.color || "#335";\n            ctx.strokeStyle = group.color || "#335";\n            var pos = group._pos;\n            var size = group._size;\n            ctx.globalAlpha = 0.25 * this.editor_alpha;\n            ctx.beginPath();\n            ctx.rect(pos[0] + 0.5, pos[1] + 0.5, size[0], size[1]);\n            ctx.fill();\n            ctx.globalAlpha = this.editor_alpha;\n            ctx.stroke();\n\n            ctx.beginPath();\n            ctx.moveTo(pos[0] + size[0], pos[1] + size[1]);\n            ctx.lineTo(pos[0] + size[0] - 10, pos[1] + size[1]);\n            ctx.lineTo(pos[0] + size[0], pos[1] + size[1] - 10);\n            ctx.fill();\n\n            var font_size =\n                group.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE;\n            ctx.font = font_size + "px Arial";\n\t\t\tctx.textAlign = "left";\n            ctx.fillText(group.title, pos[0] + 4, pos[1] + font_size);\n        }\n\n        ctx.restore();\n    };\n\n    LGraphCanvas.prototype.adjustNodesSize = function() {\n        var nodes = this.graph._nodes;\n        for (var i = 0; i < nodes.length; ++i) {\n            nodes[i].size = nodes[i].computeSize();\n        }\n        this.setDirty(true, true);\n    };\n\n    /**\n     * resizes the canvas to a given size, if no size is passed, then it tries to fill the parentNode\n     * @method resize\n     **/\n    LGraphCanvas.prototype.resize = function(width, height) {\n        if (!width && !height) {\n            var parent = this.canvas.parentNode;\n            width = parent.offsetWidth;\n            height = parent.offsetHeight;\n        }\n\n        if (this.canvas.width == width && this.canvas.height == height) {\n            return;\n        }\n\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.bgcanvas.width = this.canvas.width;\n        this.bgcanvas.height = this.canvas.height;\n        this.setDirty(true, true);\n    };\n\n    /**\n     * switches to live mode (node shapes are not rendered, only the content)\n     * this feature was designed when graphs where meant to create user interfaces\n     * @method switchLiveMode\n     **/\n    LGraphCanvas.prototype.switchLiveMode = function(transition) {\n        if (!transition) {\n            this.live_mode = !this.live_mode;\n            this.dirty_canvas = true;\n            this.dirty_bgcanvas = true;\n            return;\n        }\n\n        var self = this;\n        var delta = this.live_mode ? 1.1 : 0.9;\n        if (this.live_mode) {\n            this.live_mode = false;\n            this.editor_alpha = 0.1;\n        }\n\n        var t = setInterval(function() {\n            self.editor_alpha *= delta;\n            self.dirty_canvas = true;\n            self.dirty_bgcanvas = true;\n\n            if (delta < 1 && self.editor_alpha < 0.01) {\n                clearInterval(t);\n                if (delta < 1) {\n                    self.live_mode = true;\n                }\n            }\n            if (delta > 1 && self.editor_alpha > 0.99) {\n                clearInterval(t);\n                self.editor_alpha = 1;\n            }\n        }, 1);\n    };\n\n    LGraphCanvas.prototype.onNodeSelectionChange = function(node) {\n        return; //disabled\n    };\n\n    /* this is an implementation for touch not in production and not ready\n     */\n    /*LGraphCanvas.prototype.touchHandler = function(event) {\n        //alert("foo");\n        var touches = event.changedTouches,\n            first = touches[0],\n            type = "";\n\n        switch (event.type) {\n            case "touchstart":\n                type = "mousedown";\n                break;\n            case "touchmove":\n                type = "mousemove";\n                break;\n            case "touchend":\n                type = "mouseup";\n                break;\n            default:\n                return;\n        }\n\n        //initMouseEvent(type, canBubble, cancelable, view, clickCount,\n        //           screenX, screenY, clientX, clientY, ctrlKey,\n        //           altKey, shiftKey, metaKey, button, relatedTarget);\n\n        // this is eventually a Dom object, get the LGraphCanvas back\n        if(typeof this.getCanvasWindow == "undefined"){\n            var window = this.lgraphcanvas.getCanvasWindow();\n        }else{\n            var window = this.getCanvasWindow();\n        }\n        \n        var document = window.document;\n\n        var simulatedEvent = document.createEvent("MouseEvent");\n        simulatedEvent.initMouseEvent(\n            type,\n            true,\n            true,\n            window,\n            1,\n            first.screenX,\n            first.screenY,\n            first.clientX,\n            first.clientY,\n            false,\n            false,\n            false,\n            false,\n            0, //left\n            null\n        );\n        first.target.dispatchEvent(simulatedEvent);\n        event.preventDefault();\n    };*/\n\n    /* CONTEXT MENU ********************/\n\n    LGraphCanvas.onGroupAdd = function(info, entry, mouse_event) {\n        var canvas = LGraphCanvas.active_canvas;\n        var ref_window = canvas.getCanvasWindow();\n\n        var group = new LiteGraph.LGraphGroup();\n        group.pos = canvas.convertEventToCanvasOffset(mouse_event);\n        canvas.graph.add(group);\n    };\n\n    /**\n     * Determines the furthest nodes in each direction\n     * @param nodes {LGraphNode[]} the nodes to from which boundary nodes will be extracted\n     * @return {{left: LGraphNode, top: LGraphNode, right: LGraphNode, bottom: LGraphNode}}\n     */\n    LGraphCanvas.getBoundaryNodes = function(nodes) {\n        let top = null;\n        let right = null;\n        let bottom = null;\n        let left = null;\n        for (const nID in nodes) {\n            const node = nodes[nID];\n            const [x, y] = node.pos;\n            const [width, height] = node.size;\n\n            if (top === null || y < top.pos[1]) {\n                top = node;\n            }\n            if (right === null || x + width > right.pos[0] + right.size[0]) {\n                right = node;\n            }\n            if (bottom === null || y + height > bottom.pos[1] + bottom.size[1]) {\n                bottom = node;\n            }\n            if (left === null || x < left.pos[0]) {\n                left = node;\n            }\n        }\n\n        return {\n            "top": top,\n            "right": right,\n            "bottom": bottom,\n            "left": left\n        };\n    }\n    /**\n     * Determines the furthest nodes in each direction for the currently selected nodes\n     * @return {{left: LGraphNode, top: LGraphNode, right: LGraphNode, bottom: LGraphNode}}\n     */\n    LGraphCanvas.prototype.boundaryNodesForSelection = function() {\n        return LGraphCanvas.getBoundaryNodes(Object.values(this.selected_nodes));\n    }\n\n    /**\n     *\n     * @param {LGraphNode[]} nodes a list of nodes\n     * @param {"top"|"bottom"|"left"|"right"} direction Direction to align the nodes\n     * @param {LGraphNode?} align_to Node to align to (if null, align to the furthest node in the given direction)\n     */\n    LGraphCanvas.alignNodes = function (nodes, direction, align_to) {\n        if (!nodes) {\n            return;\n        }\n\n        const canvas = LGraphCanvas.active_canvas;\n        let boundaryNodes = []\n        if (align_to === undefined) {\n            boundaryNodes = LGraphCanvas.getBoundaryNodes(nodes)\n        } else {\n            boundaryNodes = {\n                "top": align_to,\n                "right": align_to,\n                "bottom": align_to,\n                "left": align_to\n            }\n        }\n\n        for (const [_, node] of Object.entries(canvas.selected_nodes)) {\n            switch (direction) {\n                case "right":\n                    node.pos[0] = boundaryNodes["right"].pos[0] + boundaryNodes["right"].size[0] - node.size[0];\n                    break;\n                case "left":\n                    node.pos[0] = boundaryNodes["left"].pos[0];\n                    break;\n                case "top":\n                    node.pos[1] = boundaryNodes["top"].pos[1];\n                    break;\n                case "bottom":\n                    node.pos[1] = boundaryNodes["bottom"].pos[1] + boundaryNodes["bottom"].size[1] - node.size[1];\n                    break;\n            }\n        }\n\n        canvas.dirty_canvas = true;\n        canvas.dirty_bgcanvas = true;\n    };\n\n    LGraphCanvas.onNodeAlign = function(value, options, event, prev_menu, node) {\n        new LiteGraph.ContextMenu(["Top", "Bottom", "Left", "Right"], {\n            event: event,\n            callback: inner_clicked,\n            parentMenu: prev_menu,\n        });\n\n        function inner_clicked(value) {\n            LGraphCanvas.alignNodes(LGraphCanvas.active_canvas.selected_nodes, value.toLowerCase(), node);\n        }\n    }\n\n    LGraphCanvas.onGroupAlign = function(value, options, event, prev_menu) {\n        new LiteGraph.ContextMenu(["Top", "Bottom", "Left", "Right"], {\n            event: event,\n            callback: inner_clicked,\n            parentMenu: prev_menu,\n        });\n\n        function inner_clicked(value) {\n            LGraphCanvas.alignNodes(LGraphCanvas.active_canvas.selected_nodes, value.toLowerCase());\n        }\n    }\n\n    LGraphCanvas.onMenuAdd = function (node, options, e, prev_menu, callback) {\n\n        var canvas = LGraphCanvas.active_canvas;\n        var ref_window = canvas.getCanvasWindow();\n        var graph = canvas.graph;\n        if (!graph)\n            return;\n\n        function inner_onMenuAdded(base_category ,prev_menu){\n    \n            var categories  = LiteGraph.getNodeTypesCategories(canvas.filter || graph.filter).filter(function(category){return category.startsWith(base_category)});\n            var entries = [];\n    \n            categories.map(function(category){\n    \n                if (!category) \n                    return;\n    \n                var base_category_regex = new RegExp(\'^(\' + base_category + \')\');\n                var category_name = category.replace(base_category_regex,"").split(\'/\')[0];\n                var category_path = base_category  === \'\' ? category_name + \'/\' : base_category + category_name + \'/\';\n    \n                var name = category_name;\n                if(name.indexOf("::") != -1) //in case it has a namespace like "shader::math/rand" it hides the namespace\n                    name = name.split("::")[1];\n                        \n                var index = entries.findIndex(function(entry){return entry.value === category_path});\n                if (index === -1) {\n                    entries.push({ value: category_path, content: name, has_submenu: true, callback : function(value, event, mouseEvent, contextMenu){\n                        inner_onMenuAdded(value.value, contextMenu)\n                    }});\n                }\n                \n            });\n    \n            var nodes = LiteGraph.getNodeTypesInCategory(base_category.slice(0, -1), canvas.filter || graph.filter );\n            nodes.map(function(node){\n    \n                if (node.skip_list)\n                    return;\n    \n                var entry = { value: node.type, content: node.title, has_submenu: false , callback : function(value, event, mouseEvent, contextMenu){\n                    \n                        var first_event = contextMenu.getFirstEvent();\n                        canvas.graph.beforeChange();\n                        var node = LiteGraph.createNode(value.value);\n                        if (node) {\n                            node.pos = canvas.convertEventToCanvasOffset(first_event);\n                            canvas.graph.add(node);\n                        }\n                        if(callback)\n                            callback(node);\n                        canvas.graph.afterChange();\n                    \n                    }\n                }\n    \n                entries.push(entry);\n    \n            });\n    \n            new LiteGraph.ContextMenu( entries, { event: e, parentMenu: prev_menu }, ref_window );\n    \n        }\n    \n        inner_onMenuAdded(\'\',prev_menu);\n        return false;\n    \n    };\n\n    LGraphCanvas.onMenuCollapseAll = function() {};\n\n    LGraphCanvas.onMenuNodeEdit = function() {};\n\n    LGraphCanvas.showMenuNodeOptionalInputs = function(\n        v,\n        options,\n        e,\n        prev_menu,\n        node\n    ) {\n        if (!node) {\n            return;\n        }\n\n        var that = this;\n        var canvas = LGraphCanvas.active_canvas;\n        var ref_window = canvas.getCanvasWindow();\n\n        var options = node.optional_inputs;\n        if (node.onGetInputs) {\n            options = node.onGetInputs();\n        }\n\n        var entries = [];\n        if (options) {\n            for (var i=0; i < options.length; i++) {\n                var entry = options[i];\n                if (!entry) {\n                    entries.push(null);\n                    continue;\n                }\n                var label = entry[0];\n\t\t\t\tif(!entry[2])\n\t\t\t\t\tentry[2] = {};\n\n                if (entry[2].label) {\n                    label = entry[2].label;\n                }\n\n\t\t\t\tentry[2].removable = true;\n                var data = { content: label, value: entry };\n                if (entry[1] == LiteGraph.ACTION) {\n                    data.className = "event";\n                }\n                entries.push(data);\n            }\n        }\n\n        if (node.onMenuNodeInputs) {\n            var retEntries = node.onMenuNodeInputs(entries);\n            if(retEntries) entries = retEntries;\n        }\n\n        if (!entries.length) {\n\t\t\tconsole.log("no input entries");\n            return;\n        }\n\n        var menu = new LiteGraph.ContextMenu(\n            entries,\n            {\n                event: e,\n                callback: inner_clicked,\n                parentMenu: prev_menu,\n                node: node\n            },\n            ref_window\n        );\n\n        function inner_clicked(v, e, prev) {\n            if (!node) {\n                return;\n            }\n\n            if (v.callback) {\n                v.callback.call(that, node, v, e, prev);\n            }\n\n            if (v.value) {\n\t\t\t\tnode.graph.beforeChange();\n                node.addInput(v.value[0], v.value[1], v.value[2]);\n\n                if (node.onNodeInputAdd) { // callback to the node when adding a slot\n                    node.onNodeInputAdd(v.value);\n                }\n                node.setDirtyCanvas(true, true);\n\t\t\t\tnode.graph.afterChange();\n            }\n        }\n\n        return false;\n    };\n\n    LGraphCanvas.showMenuNodeOptionalOutputs = function(\n        v,\n        options,\n        e,\n        prev_menu,\n        node\n    ) {\n        if (!node) {\n            return;\n        }\n\n        var that = this;\n        var canvas = LGraphCanvas.active_canvas;\n        var ref_window = canvas.getCanvasWindow();\n\n        var options = node.optional_outputs;\n        if (node.onGetOutputs) {\n            options = node.onGetOutputs();\n        }\n\n        var entries = [];\n        if (options) {\n            for (var i=0; i < options.length; i++) {\n                var entry = options[i];\n                if (!entry) {\n                    //separator?\n                    entries.push(null);\n                    continue;\n                }\n\n                if (\n                    node.flags &&\n                    node.flags.skip_repeated_outputs &&\n                    node.findOutputSlot(entry[0]) != -1\n                ) {\n                    continue;\n                } //skip the ones already on\n                var label = entry[0];\n\t\t\t\tif(!entry[2])\n\t\t\t\t\tentry[2] = {};\n                if (entry[2].label) {\n                    label = entry[2].label;\n                }\n\t\t\t\tentry[2].removable = true;\n                var data = { content: label, value: entry };\n                if (entry[1] == LiteGraph.EVENT) {\n                    data.className = "event";\n                }\n                entries.push(data);\n            }\n        }\n\n        if (this.onMenuNodeOutputs) {\n            entries = this.onMenuNodeOutputs(entries);\n        }\n        if (LiteGraph.do_add_triggers_slots){ //canvas.allow_addOutSlot_onExecuted\n            if (node.findOutputSlot("onExecuted") == -1){\n                entries.push({content: "On Executed", value: ["onExecuted", LiteGraph.EVENT, {nameLocked: true}], className: "event"}); //, opts: {}\n            }\n        }\n        // add callback for modifing the menu elements onMenuNodeOutputs\n        if (node.onMenuNodeOutputs) {\n            var retEntries = node.onMenuNodeOutputs(entries);\n            if(retEntries) entries = retEntries;\n        }\n\n        if (!entries.length) {\n            return;\n        }\n\n        var menu = new LiteGraph.ContextMenu(\n            entries,\n            {\n                event: e,\n                callback: inner_clicked,\n                parentMenu: prev_menu,\n                node: node\n            },\n            ref_window\n        );\n\n        function inner_clicked(v, e, prev) {\n            if (!node) {\n                return;\n            }\n\n            if (v.callback) {\n                v.callback.call(that, node, v, e, prev);\n            }\n\n            if (!v.value) {\n                return;\n            }\n\n            var value = v.value[1];\n\n            if (\n                value &&\n                (value.constructor === Object || value.constructor === Array)\n            ) {\n                //submenu why?\n                var entries = [];\n                for (var i in value) {\n                    entries.push({ content: i, value: value[i] });\n                }\n                new LiteGraph.ContextMenu(entries, {\n                    event: e,\n                    callback: inner_clicked,\n                    parentMenu: prev_menu,\n                    node: node\n                });\n                return false;\n            } else {\n\t\t\t\tnode.graph.beforeChange();\n                node.addOutput(v.value[0], v.value[1], v.value[2]);\n\n                if (node.onNodeOutputAdd) { // a callback to the node when adding a slot\n                    node.onNodeOutputAdd(v.value);\n                }\n                node.setDirtyCanvas(true, true);\n\t\t\t\tnode.graph.afterChange();\n            }\n        }\n\n        return false;\n    };\n\n    LGraphCanvas.onShowMenuNodeProperties = function(\n        value,\n        options,\n        e,\n        prev_menu,\n        node\n    ) {\n        if (!node || !node.properties) {\n            return;\n        }\n\n        var that = this;\n        var canvas = LGraphCanvas.active_canvas;\n        var ref_window = canvas.getCanvasWindow();\n\n        var entries = [];\n        for (var i in node.properties) {\n            var value = node.properties[i] !== undefined ? node.properties[i] : " ";\n\t\t\tif( typeof value == "object" )\n\t\t\t\tvalue = JSON.stringify(value);\n\t\t\tvar info = node.getPropertyInfo(i);\n\t\t\tif(info.type == "enum" || info.type == "combo")\n\t\t\t\tvalue = LGraphCanvas.getPropertyPrintableValue( value, info.values );\n\n            //value could contain invalid html characters, clean that\n            value = LGraphCanvas.decodeHTML(value);\n            entries.push({\n                content:\n                    "<span class=\'property_name\'>" +\n                    (info.label ? info.label : i) +\n                    "</span>" +\n                    "<span class=\'property_value\'>" +\n                    value +\n                    "</span>",\n                value: i\n            });\n        }\n        if (!entries.length) {\n            return;\n        }\n\n        var menu = new LiteGraph.ContextMenu(\n            entries,\n            {\n                event: e,\n                callback: inner_clicked,\n                parentMenu: prev_menu,\n                allow_html: true,\n                node: node\n            },\n            ref_window\n        );\n\n        function inner_clicked(v, options, e, prev) {\n            if (!node) {\n                return;\n            }\n            var rect = this.getBoundingClientRect();\n            canvas.showEditPropertyValue(node, v.value, {\n                position: [rect.left, rect.top]\n            });\n        }\n\n        return false;\n    };\n\n    LGraphCanvas.decodeHTML = function(str) {\n        var e = document.createElement("div");\n        e.innerText = str;\n        return e.innerHTML;\n    };\n\n    LGraphCanvas.onMenuResizeNode = function(value, options, e, menu, node) {\n        if (!node) {\n            return;\n        }\n        \n\t\tvar fApplyMultiNode = function(node){\n\t\t\tnode.size = node.computeSize();\n\t\t\tif (node.onResize)\n\t\t\t\tnode.onResize(node.size);\n\t\t}\n\t\t\n\t\tvar graphcanvas = LGraphCanvas.active_canvas;\n\t\tif (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1){\n\t\t\tfApplyMultiNode(node);\n\t\t}else{\n\t\t\tfor (var i in graphcanvas.selected_nodes) {\n\t\t\t\tfApplyMultiNode(graphcanvas.selected_nodes[i]);\n\t\t\t}\n\t\t}\n\t\t\n        node.setDirtyCanvas(true, true);\n    };\n\n    LGraphCanvas.prototype.showLinkMenu = function(link, e) {\n        var that = this;\n\t\t// console.log(link);\n\t\tvar node_left = that.graph.getNodeById( link.origin_id );\n\t\tvar node_right = that.graph.getNodeById( link.target_id );\n\t\tvar fromType = false;\n\t\tif (node_left && node_left.outputs && node_left.outputs[link.origin_slot]) fromType = node_left.outputs[link.origin_slot].type;\n        var destType = false;\n\t\tif (node_right && node_right.outputs && node_right.outputs[link.target_slot]) destType = node_right.inputs[link.target_slot].type;\n\t\t\n\t\tvar options = ["Add Node",null,"Delete",null];\n\t\t\n\t\t\n        var menu = new LiteGraph.ContextMenu(options, {\n            event: e,\n\t\t\ttitle: link.data != null ? link.data.constructor.name : null,\n            callback: inner_clicked\n        });\n\n        function inner_clicked(v,options,e) {\n            switch (v) {\n                case "Add Node":\n\t\t\t\t\tLGraphCanvas.onMenuAdd(null, null, e, menu, function(node){\n\t\t\t\t\t\t// console.debug("node autoconnect");\n\t\t\t\t\t\tif(!node.inputs || !node.inputs.length || !node.outputs || !node.outputs.length){\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// leave the connection type checking inside connectByType\n\t\t\t\t\t\tif (node_left.connectByType( link.origin_slot, node, fromType )){\n                        \tnode.connectByType( link.target_slot, node_right, destType );\n                            node.pos[0] -= node.size[0] * 0.5;\n                        }\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n                case "Delete":\n                    that.graph.removeLink(link.id);\n                    break;\n                default:\n\t\t\t\t\t/*var nodeCreated = createDefaultNodeForSlot({   nodeFrom: node_left\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,slotFrom: link.origin_slot\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,nodeTo: node\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,slotTo: link.target_slot\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,e: e\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,nodeType: "AUTO"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\tif(nodeCreated) console.log("new node in beetween "+v+" created");*/\n            }\n        }\n\n        return false;\n    };\n    \n \tLGraphCanvas.prototype.createDefaultNodeForSlot = function(optPass) { // addNodeMenu for connection\n        var optPass = optPass || {};\n        var opts = Object.assign({   nodeFrom: null // input\n                                    ,slotFrom: null // input\n                                    ,nodeTo: null   // output\n                                    ,slotTo: null   // output\n                                    ,position: []\t// pass the event coords\n\t\t\t\t\t\t\t\t  \t,nodeType: null\t// choose a nodetype to add, AUTO to set at first good\n\t\t\t\t\t\t\t\t  \t,posAdd:[0,0]\t// adjust x,y\n\t\t\t\t\t\t\t\t  \t,posSizeFix:[0,0] // alpha, adjust the position x,y based on the new node size w,h\n                                }\n                                ,optPass\n                            );\n        var that = this;\n        \n        var isFrom = opts.nodeFrom && opts.slotFrom!==null;\n        var isTo = !isFrom && opts.nodeTo && opts.slotTo!==null;\n\t\n        if (!isFrom && !isTo){\n            console.warn("No data passed to createDefaultNodeForSlot "+opts.nodeFrom+" "+opts.slotFrom+" "+opts.nodeTo+" "+opts.slotTo);\n            return false;\n        }\n\t\tif (!opts.nodeType){\n            console.warn("No type to createDefaultNodeForSlot");\n            return false;\n        }\n        \n        var nodeX = isFrom ? opts.nodeFrom : opts.nodeTo;\n        var slotX = isFrom ? opts.slotFrom : opts.slotTo;\n        \n        var iSlotConn = false;\n        switch (typeof slotX){\n            case "string":\n                iSlotConn = isFrom ? nodeX.findOutputSlot(slotX,false) : nodeX.findInputSlot(slotX,false);\n                slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];\n            break;\n            case "object":\n                // ok slotX\n                iSlotConn = isFrom ? nodeX.findOutputSlot(slotX.name) : nodeX.findInputSlot(slotX.name);\n            break;\n            case "number":\n                iSlotConn = slotX;\n                slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];\n            break;\n\t\t\tcase "undefined":\n            default:\n                // bad ?\n                //iSlotConn = 0;\n                console.warn("Cant get slot information "+slotX);\n                return false;\n        }\n\t\n\t\tif (slotX===false || iSlotConn===false){\n\t\t\tconsole.warn("createDefaultNodeForSlot bad slotX "+slotX+" "+iSlotConn);\n\t\t}\n\t\t\n\t\t// check for defaults nodes for this slottype\n\t\tvar fromSlotType = slotX.type==LiteGraph.EVENT?"_event_":slotX.type;\n\t\tvar slotTypesDefault = isFrom ? LiteGraph.slot_types_default_out : LiteGraph.slot_types_default_in;\n\t\tif(slotTypesDefault && slotTypesDefault[fromSlotType]){\n\t\t\tif (slotX.link !== null) {\n\t\t\t\t// is connected\n\t\t\t}else{\n\t\t\t\t// is not not connected\n\t\t\t}\n\t\t\tnodeNewType = false;\n\t\t\tif(typeof slotTypesDefault[fromSlotType] == "object" || typeof slotTypesDefault[fromSlotType] == "array"){\n\t\t\t\tfor(var typeX in slotTypesDefault[fromSlotType]){\n\t\t\t\t\tif (opts.nodeType == slotTypesDefault[fromSlotType][typeX] || opts.nodeType == "AUTO"){\n\t\t\t\t\t\tnodeNewType = slotTypesDefault[fromSlotType][typeX];\n\t\t\t\t\t\t// console.log("opts.nodeType == slotTypesDefault[fromSlotType][typeX] :: "+opts.nodeType);\n\t\t\t\t\t\tbreak; // --------\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif (opts.nodeType == slotTypesDefault[fromSlotType] || opts.nodeType == "AUTO") nodeNewType = slotTypesDefault[fromSlotType];\n\t\t\t}\n\t\t\tif (nodeNewType) {\n\t\t\t\tvar nodeNewOpts = false;\n\t\t\t\tif (typeof nodeNewType == "object" && nodeNewType.node){\n\t\t\t\t\tnodeNewOpts = nodeNewType;\n\t\t\t\t\tnodeNewType = nodeNewType.node;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//that.graph.beforeChange();\n\t\t\t\t\n\t\t\t\tvar newNode = LiteGraph.createNode(nodeNewType);\n\t\t\t\tif(newNode){\n\t\t\t\t\t// if is object pass options\n\t\t\t\t\tif (nodeNewOpts){\n\t\t\t\t\t\tif (nodeNewOpts.properties) {\n\t\t\t\t\t\t\tfor (var i in nodeNewOpts.properties) {\n\t\t\t\t\t\t\t\tnewNode.addProperty( i, nodeNewOpts.properties[i] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nodeNewOpts.inputs) {\n\t\t\t\t\t\t\tnewNode.inputs = [];\n\t\t\t\t\t\t\tfor (var i in nodeNewOpts.inputs) {\n\t\t\t\t\t\t\t\tnewNode.addOutput(\n\t\t\t\t\t\t\t\t\tnodeNewOpts.inputs[i][0],\n\t\t\t\t\t\t\t\t\tnodeNewOpts.inputs[i][1]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nodeNewOpts.outputs) {\n\t\t\t\t\t\t\tnewNode.outputs = [];\n\t\t\t\t\t\t\tfor (var i in nodeNewOpts.outputs) {\n\t\t\t\t\t\t\t\tnewNode.addOutput(\n\t\t\t\t\t\t\t\t\tnodeNewOpts.outputs[i][0],\n\t\t\t\t\t\t\t\t\tnodeNewOpts.outputs[i][1]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nodeNewOpts.title) {\n\t\t\t\t\t\t\tnewNode.title = nodeNewOpts.title;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nodeNewOpts.json) {\n\t\t\t\t\t\t\tnewNode.configure(nodeNewOpts.json);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// add the node\n\t\t\t\t\tthat.graph.add(newNode);\n\t\t\t\t\tnewNode.pos = [\topts.position[0]+opts.posAdd[0]+(opts.posSizeFix[0]?opts.posSizeFix[0]*newNode.size[0]:0)\n\t\t\t\t\t\t\t\t   \t,opts.position[1]+opts.posAdd[1]+(opts.posSizeFix[1]?opts.posSizeFix[1]*newNode.size[1]:0)]; //that.last_click_position; //[e.canvasX+30, e.canvasX+5];*/\n\t\t\t\t\t\n\t\t\t\t\t//that.graph.afterChange();\n\t\t\t\t\t\n\t\t\t\t\t// connect the two!\n\t\t\t\t\tif (isFrom){\n\t\t\t\t\t\topts.nodeFrom.connectByType( iSlotConn, newNode, fromSlotType );\n\t\t\t\t\t}else{\n\t\t\t\t\t\topts.nodeTo.connectByTypeOutput( iSlotConn, newNode, fromSlotType );\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// if connecting in between\n\t\t\t\t\tif (isFrom && isTo){\n\t\t\t\t\t\t// TODO\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\tconsole.log("failed creating "+nodeNewType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n \n    LGraphCanvas.prototype.showConnectionMenu = function(optPass) { // addNodeMenu for connection\n        var optPass = optPass || {};\n        var opts = Object.assign({   nodeFrom: null  // input\n                                    ,slotFrom: null // input\n                                    ,nodeTo: null   // output\n                                    ,slotTo: null   // output\n                                    ,e: null\n                                }\n                                ,optPass\n                            );\n        var that = this;\n        \n        var isFrom = opts.nodeFrom && opts.slotFrom;\n        var isTo = !isFrom && opts.nodeTo && opts.slotTo;\n        \n        if (!isFrom && !isTo){\n            console.warn("No data passed to showConnectionMenu");\n            return false;\n        }\n        \n        var nodeX = isFrom ? opts.nodeFrom : opts.nodeTo;\n        var slotX = isFrom ? opts.slotFrom : opts.slotTo;\n        \n        var iSlotConn = false;\n        switch (typeof slotX){\n            case "string":\n                iSlotConn = isFrom ? nodeX.findOutputSlot(slotX,false) : nodeX.findInputSlot(slotX,false);\n                slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];\n            break;\n            case "object":\n                // ok slotX\n                iSlotConn = isFrom ? nodeX.findOutputSlot(slotX.name) : nodeX.findInputSlot(slotX.name);\n            break;\n            case "number":\n                iSlotConn = slotX;\n                slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX];\n            break;\n            default:\n                // bad ?\n                //iSlotConn = 0;\n                console.warn("Cant get slot information "+slotX);\n                return false;\n        }\n            \n\t\tvar options = ["Add Node",null];\n\t\t\n\t\tif (that.allow_searchbox){\n\t\t\toptions.push("Search");\n\t\t\toptions.push(null);\n\t\t}\n\t\t\n\t\t// get defaults nodes for this slottype\n\t\tvar fromSlotType = slotX.type==LiteGraph.EVENT?"_event_":slotX.type;\n\t\tvar slotTypesDefault = isFrom ? LiteGraph.slot_types_default_out : LiteGraph.slot_types_default_in;\n\t\tif(slotTypesDefault && slotTypesDefault[fromSlotType]){\n\t\t\tif(typeof slotTypesDefault[fromSlotType] == "object" || typeof slotTypesDefault[fromSlotType] == "array"){\n\t\t\t\tfor(var typeX in slotTypesDefault[fromSlotType]){\n\t\t\t\t\toptions.push(slotTypesDefault[fromSlotType][typeX]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\toptions.push(slotTypesDefault[fromSlotType]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// build menu\n        var menu = new LiteGraph.ContextMenu(options, {\n            event: opts.e,\n\t\t\ttitle: (slotX && slotX.name!="" ? (slotX.name + (fromSlotType?" | ":"")) : "")+(slotX && fromSlotType ? fromSlotType : ""),\n            callback: inner_clicked\n        });\n        \n\t\t// callback\n        function inner_clicked(v,options,e) {\n            //console.log("Process showConnectionMenu selection");\n            switch (v) {\n                case "Add Node":\n                    LGraphCanvas.onMenuAdd(null, null, e, menu, function(node){\n                        if (isFrom){\n                            opts.nodeFrom.connectByType( iSlotConn, node, fromSlotType );\n                        }else{\n                            opts.nodeTo.connectByTypeOutput( iSlotConn, node, fromSlotType );\n                        }\n                    });\n                    break;\n\t\t\t\tcase "Search":\n\t\t\t\t\tif(isFrom){\n\t\t\t\t\t\tthat.showSearchBox(e,{node_from: opts.nodeFrom, slot_from: slotX, type_filter_in: fromSlotType});\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthat.showSearchBox(e,{node_to: opts.nodeTo, slot_from: slotX, type_filter_out: fromSlotType});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n                default:\n\t\t\t\t\t// check for defaults nodes for this slottype\n\t\t\t\t\tvar nodeCreated = that.createDefaultNodeForSlot(Object.assign(opts,{ position: [opts.e.canvasX, opts.e.canvasY]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,nodeType: v\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}));\n\t\t\t\t\tif (nodeCreated){\n\t\t\t\t\t\t// new node created\n\t\t\t\t\t\t//console.log("node "+v+" created")\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// failed or v is not in defaults\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n            }\n        }   \n        \n        return false;\n    };\n\n    // TODO refactor :: this is used fot title but not for properties!\n    LGraphCanvas.onShowPropertyEditor = function(item, options, e, menu, node) {\n        var input_html = "";\n        var property = item.property || "title";\n        var value = node[property];\n\n        // TODO refactor :: use createDialog ?\n        \n        var dialog = document.createElement("div");\n        dialog.is_modified = false;\n        dialog.className = "graphdialog";\n        dialog.innerHTML =\n            "<span class=\'name\'></span><input autofocus type=\'text\' class=\'value\'/><button>OK</button>";\n        dialog.close = function() {\n            if (dialog.parentNode) {\n                dialog.parentNode.removeChild(dialog);\n            }\n        };\n        var title = dialog.querySelector(".name");\n        title.innerText = property;\n        var input = dialog.querySelector(".value");\n        if (input) {\n            input.value = value;\n            input.addEventListener("blur", function(e) {\n                this.focus();\n            });\n            input.addEventListener("keydown", function(e) {\n                dialog.is_modified = true;\n                if (e.keyCode == 27) {\n                    //ESC\n                    dialog.close();\n                } else if (e.keyCode == 13) {\n                    inner(); // save\n                } else if (e.keyCode != 13 && e.target.localName != "textarea") {\n                    return;\n                }\n                e.preventDefault();\n                e.stopPropagation();\n            });\n        }\n\n        var graphcanvas = LGraphCanvas.active_canvas;\n        var canvas = graphcanvas.canvas;\n\n        var rect = canvas.getBoundingClientRect();\n        var offsetx = -20;\n        var offsety = -20;\n        if (rect) {\n            offsetx -= rect.left;\n            offsety -= rect.top;\n        }\n\n        if (event) {\n            dialog.style.left = event.clientX + offsetx + "px";\n            dialog.style.top = event.clientY + offsety + "px";\n        } else {\n            dialog.style.left = canvas.width * 0.5 + offsetx + "px";\n            dialog.style.top = canvas.height * 0.5 + offsety + "px";\n        }\n\n        var button = dialog.querySelector("button");\n        button.addEventListener("click", inner);\n        canvas.parentNode.appendChild(dialog);\n\n        if(input) input.focus();\n        \n        var dialogCloseTimer = null;\n        dialog.addEventListener("mouseleave", function(e) {\n            if(LiteGraph.dialog_close_on_mouse_leave)\n                if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave)\n                    dialogCloseTimer = setTimeout(dialog.close, LiteGraph.dialog_close_on_mouse_leave_delay); //dialog.close();\n        });\n        dialog.addEventListener("mouseenter", function(e) {\n            if(LiteGraph.dialog_close_on_mouse_leave)\n                if(dialogCloseTimer) clearTimeout(dialogCloseTimer);\n        });\n        \n        function inner() {\n            if(input) setValue(input.value);\n        }\n\n        function setValue(value) {\n            if (item.type == "Number") {\n                value = Number(value);\n            } else if (item.type == "Boolean") {\n                value = Boolean(value);\n            }\n            node[property] = value;\n            if (dialog.parentNode) {\n                dialog.parentNode.removeChild(dialog);\n            }\n            node.setDirtyCanvas(true, true);\n        }\n    };\n\n    // refactor: there are different dialogs, some uses createDialog some dont\n    LGraphCanvas.prototype.prompt = function(title, value, callback, event, multiline) {\n        var that = this;\n        var input_html = "";\n        title = title || "";\n\n        var dialog = document.createElement("div");\n        dialog.is_modified = false;\n        dialog.className = "graphdialog rounded";\n        if(multiline)\n\t        dialog.innerHTML = "<span class=\'name\'></span> <textarea autofocus class=\'value\'></textarea><button class=\'rounded\'>OK</button>";\n\t\telse\n        \tdialog.innerHTML = "<span class=\'name\'></span> <input autofocus type=\'text\' class=\'value\'/><button class=\'rounded\'>OK</button>";\n        dialog.close = function() {\n            that.prompt_box = null;\n            if (dialog.parentNode) {\n                dialog.parentNode.removeChild(dialog);\n            }\n        };\n\n        var graphcanvas = LGraphCanvas.active_canvas;\n        var canvas = graphcanvas.canvas;\n        canvas.parentNode.appendChild(dialog);\n        \n        if (this.ds.scale > 1) {\n            dialog.style.transform = "scale(" + this.ds.scale + ")";\n        }\n\n        var dialogCloseTimer = null;\n        var prevent_timeout = false;\n        LiteGraph.pointerListenerAdd(dialog,"leave", function(e) {\n            if (prevent_timeout)\n                return;\n            if(LiteGraph.dialog_close_on_mouse_leave)\n                if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave)\n                    dialogCloseTimer = setTimeout(dialog.close, LiteGraph.dialog_close_on_mouse_leave_delay); //dialog.close();\n        });\n        LiteGraph.pointerListenerAdd(dialog,"enter", function(e) {\n            if(LiteGraph.dialog_close_on_mouse_leave)\n                if(dialogCloseTimer) clearTimeout(dialogCloseTimer);\n        });\n        var selInDia = dialog.querySelectorAll("select");\n        if (selInDia){\n            // if filtering, check focus changed to comboboxes and prevent closing\n            selInDia.forEach(function(selIn) {\n                selIn.addEventListener("click", function(e) {\n                    prevent_timeout++;\n                });\n                selIn.addEventListener("blur", function(e) {\n                   prevent_timeout = 0;\n                });\n                selIn.addEventListener("change", function(e) {\n                    prevent_timeout = -1;\n                });\n            });\n        }\n\n        if (that.prompt_box) {\n            that.prompt_box.close();\n        }\n        that.prompt_box = dialog;\n\n        var first = null;\n        var timeout = null;\n        var selected = null;\n\n        var name_element = dialog.querySelector(".name");\n        name_element.innerText = title;\n        var value_element = dialog.querySelector(".value");\n        value_element.value = value;\n\n        var input = value_element;\n        input.addEventListener("keydown", function(e) {\n            dialog.is_modified = true;\n            if (e.keyCode == 27) {\n                //ESC\n                dialog.close();\n            } else if (e.keyCode == 13 && e.target.localName != "textarea") {\n                if (callback) {\n                    callback(this.value);\n                }\n                dialog.close();\n            } else {\n                return;\n            }\n            e.preventDefault();\n            e.stopPropagation();\n        });\n\n        var button = dialog.querySelector("button");\n        button.addEventListener("click", function(e) {\n            if (callback) {\n                callback(input.value);\n            }\n            that.setDirty(true);\n            dialog.close();\n        });\n\n        var rect = canvas.getBoundingClientRect();\n        var offsetx = -20;\n        var offsety = -20;\n        if (rect) {\n            offsetx -= rect.left;\n            offsety -= rect.top;\n        }\n\n        if (event) {\n            dialog.style.left = event.clientX + offsetx + "px";\n            dialog.style.top = event.clientY + offsety + "px";\n        } else {\n            dialog.style.left = canvas.width * 0.5 + offsetx + "px";\n            dialog.style.top = canvas.height * 0.5 + offsety + "px";\n        }\n\n        setTimeout(function() {\n            input.focus();\n        }, 10);\n\n        return dialog;\n    };\n\n    LGraphCanvas.search_limit = -1;\n    LGraphCanvas.prototype.showSearchBox = function(event, options) {\n        // proposed defaults\n        var def_options = { slot_from: null\n                        ,node_from: null\n                        ,node_to: null\n                        ,do_type_filter: LiteGraph.search_filter_enabled // TODO check for registered_slot_[in/out]_types not empty // this will be checked for functionality enabled : filter on slot type, in and out\n                        ,type_filter_in: false                          // these are default: pass to set initially set values\n                        ,type_filter_out: false\n                        ,show_general_if_none_on_typefilter: true\n                        ,show_general_after_typefiltered: true\n                        ,hide_on_mouse_leave: LiteGraph.search_hide_on_mouse_leave\n                        ,show_all_if_empty: true\n                        ,show_all_on_open: LiteGraph.search_show_all_on_open\n                    };\n        options = Object.assign(def_options, options || {});\n        \n\t\t//console.log(options);\n\t\t\n        var that = this;\n        var input_html = "";\n        var graphcanvas = LGraphCanvas.active_canvas;\n        var canvas = graphcanvas.canvas;\n        var root_document = canvas.ownerDocument || document;\n\n        var dialog = document.createElement("div");\n        dialog.className = "litegraph litesearchbox graphdialog rounded";\n        dialog.innerHTML = "<span class=\'name\'>Search</span> <input autofocus type=\'text\' class=\'value rounded\'/>";\n        if (options.do_type_filter){\n            dialog.innerHTML += "<select class=\'slot_in_type_filter\'><option value=\'\'></option></select>";\n            dialog.innerHTML += "<select class=\'slot_out_type_filter\'><option value=\'\'></option></select>";\n        }\n        dialog.innerHTML += "<div class=\'helper\'></div>";\n        \n        if( root_document.fullscreenElement )\n\t        root_document.fullscreenElement.appendChild(dialog);\n\t\telse\n\t\t{\n\t\t    root_document.body.appendChild(dialog);\n\t\t\troot_document.body.style.overflow = "hidden";\n\t\t}\n        // dialog element has been appended\n        \n        if (options.do_type_filter){\n            var selIn = dialog.querySelector(".slot_in_type_filter");\n            var selOut = dialog.querySelector(".slot_out_type_filter");\n        }\n        \n        dialog.close = function() {\n            that.search_box = null;\n\t\t\tthis.blur();\n            canvas.focus();\n\t\t\troot_document.body.style.overflow = "";\n\n            setTimeout(function() {\n                that.canvas.focus();\n            }, 20); //important, if canvas loses focus keys wont be captured\n            if (dialog.parentNode) {\n                dialog.parentNode.removeChild(dialog);\n            }\n        };\n\n        if (this.ds.scale > 1) {\n            dialog.style.transform = "scale(" + this.ds.scale + ")";\n        }\n\n        // hide on mouse leave\n        if(options.hide_on_mouse_leave){\n            var prevent_timeout = false;\n            var timeout_close = null;\n            LiteGraph.pointerListenerAdd(dialog,"enter", function(e) {\n                if (timeout_close) {\n                    clearTimeout(timeout_close);\n                    timeout_close = null;\n                }\n            });\n            LiteGraph.pointerListenerAdd(dialog,"leave", function(e) {\n                if (prevent_timeout){\n                    return;\n                }\n                timeout_close = setTimeout(function() {\n                    dialog.close();\n                }, 500);\n            });\n            // if filtering, check focus changed to comboboxes and prevent closing\n            if (options.do_type_filter){\n                selIn.addEventListener("click", function(e) {\n                    prevent_timeout++;\n                });\n                selIn.addEventListener("blur", function(e) {\n                   prevent_timeout = 0;\n                });\n                selIn.addEventListener("change", function(e) {\n                    prevent_timeout = -1;\n                });\n                selOut.addEventListener("click", function(e) {\n                    prevent_timeout++;\n                });\n                selOut.addEventListener("blur", function(e) {\n                   prevent_timeout = 0;\n                });\n                selOut.addEventListener("change", function(e) {\n                    prevent_timeout = -1;\n                });\n            }\n        }\n\n        if (that.search_box) {\n            that.search_box.close();\n        }\n        that.search_box = dialog;\n\n        var helper = dialog.querySelector(".helper");\n\n        var first = null;\n        var timeout = null;\n        var selected = null;\n\n        var input = dialog.querySelector("input");\n        if (input) {\n            input.addEventListener("blur", function(e) {\n                if(that.search_box)\n                    this.focus();\n            });\n            input.addEventListener("keydown", function(e) {\n                if (e.keyCode == 38) {\n                    //UP\n                    changeSelection(false);\n                } else if (e.keyCode == 40) {\n                    //DOWN\n                    changeSelection(true);\n                } else if (e.keyCode == 27) {\n                    //ESC\n                    dialog.close();\n                } else if (e.keyCode == 13) {\n                    refreshHelper();\n                    if (selected) {\n                        select(selected.innerHTML);\n                    } else if (first) {\n                        select(first);\n                    } else {\n                        dialog.close();\n                    }\n                } else {\n                    if (timeout) {\n                        clearInterval(timeout);\n                    }\n                    timeout = setTimeout(refreshHelper, 250);\n                    return;\n                }\n                e.preventDefault();\n                e.stopPropagation();\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t\treturn true;\n            });\n        }\n        \n        // if should filter on type, load and fill selected and choose elements if passed\n        if (options.do_type_filter){\n            if (selIn){\n                var aSlots = LiteGraph.slot_types_in;\n                var nSlots = aSlots.length; // this for object :: Object.keys(aSlots).length;\n                \n                if (options.type_filter_in == LiteGraph.EVENT || options.type_filter_in == LiteGraph.ACTION)\n                    options.type_filter_in = "_event_";\n                /* this will filter on * .. but better do it manually in case\n                else if(options.type_filter_in === "" || options.type_filter_in === 0)\n                    options.type_filter_in = "*";*/\n                \n                for (var iK=0; iK<nSlots; iK++){\n                    var opt = document.createElement(\'option\');\n                    opt.value = aSlots[iK];\n                    opt.innerHTML = aSlots[iK];\n                    selIn.appendChild(opt);\n                    if(options.type_filter_in !==false && (options.type_filter_in+"").toLowerCase() == (aSlots[iK]+"").toLowerCase()){\n                        //selIn.selectedIndex ..\n                        opt.selected = true;\n\t\t\t\t\t\t//console.log("comparing IN "+options.type_filter_in+" :: "+aSlots[iK]);\n\t                }else{\n\t\t\t\t\t\t//console.log("comparing OUT "+options.type_filter_in+" :: "+aSlots[iK]);\n\t\t\t\t\t}\n\t\t\t\t}\n                selIn.addEventListener("change",function(){\n                    refreshHelper();\n                });\n            }\n            if (selOut){\n                var aSlots = LiteGraph.slot_types_out;\n                var nSlots = aSlots.length; // this for object :: Object.keys(aSlots).length; \n                \n                if (options.type_filter_out == LiteGraph.EVENT || options.type_filter_out == LiteGraph.ACTION)\n                    options.type_filter_out = "_event_";\n                /* this will filter on * .. but better do it manually in case\n                else if(options.type_filter_out === "" || options.type_filter_out === 0)\n                    options.type_filter_out = "*";*/\n                \n                for (var iK=0; iK<nSlots; iK++){\n                    var opt = document.createElement(\'option\');\n                    opt.value = aSlots[iK];\n                    opt.innerHTML = aSlots[iK];\n                    selOut.appendChild(opt);\n                    if(options.type_filter_out !==false && (options.type_filter_out+"").toLowerCase() == (aSlots[iK]+"").toLowerCase()){\n                        //selOut.selectedIndex ..\n                        opt.selected = true;\n                    }\n                }\n                selOut.addEventListener("change",function(){\n                    refreshHelper();\n                });\n            }\n        }\n        \n        //compute best position\n        var rect = canvas.getBoundingClientRect();\n\n        var left = ( event ? event.clientX : (rect.left + rect.width * 0.5) ) - 80;\n        var top = ( event ? event.clientY : (rect.top + rect.height * 0.5) ) - 20;\n        dialog.style.left = left + "px";\n        dialog.style.top = top + "px";\n\n\t\t//To avoid out of screen problems\n\t\tif(event.layerY > (rect.height - 200)) \n            helper.style.maxHeight = (rect.height - event.layerY - 20) + "px";\n\n\t\t/*\n        var offsetx = -20;\n        var offsety = -20;\n        if (rect) {\n            offsetx -= rect.left;\n            offsety -= rect.top;\n        }\n\n        if (event) {\n            dialog.style.left = event.clientX + offsetx + "px";\n            dialog.style.top = event.clientY + offsety + "px";\n        } else {\n            dialog.style.left = canvas.width * 0.5 + offsetx + "px";\n            dialog.style.top = canvas.height * 0.5 + offsety + "px";\n        }\n        canvas.parentNode.appendChild(dialog);\n\t\t*/\n\n        input.focus();\n        if (options.show_all_on_open) refreshHelper();\n\n        function select(name) {\n            if (name) {\n                if (that.onSearchBoxSelection) {\n                    that.onSearchBoxSelection(name, event, graphcanvas);\n                } else {\n                    var extra = LiteGraph.searchbox_extras[name.toLowerCase()];\n                    if (extra) {\n                        name = extra.type;\n                    }\n\n\t\t\t\t\tgraphcanvas.graph.beforeChange();\n                    var node = LiteGraph.createNode(name);\n                    if (node) {\n                        node.pos = graphcanvas.convertEventToCanvasOffset(\n                            event\n                        );\n                        graphcanvas.graph.add(node, false);\n                    }\n\n                    if (extra && extra.data) {\n                        if (extra.data.properties) {\n                            for (var i in extra.data.properties) {\n                                node.addProperty( i, extra.data.properties[i] );\n                            }\n                        }\n                        if (extra.data.inputs) {\n                            node.inputs = [];\n                            for (var i in extra.data.inputs) {\n                                node.addOutput(\n                                    extra.data.inputs[i][0],\n                                    extra.data.inputs[i][1]\n                                );\n                            }\n                        }\n                        if (extra.data.outputs) {\n                            node.outputs = [];\n                            for (var i in extra.data.outputs) {\n                                node.addOutput(\n                                    extra.data.outputs[i][0],\n                                    extra.data.outputs[i][1]\n                                );\n                            }\n                        }\n                        if (extra.data.title) {\n                            node.title = extra.data.title;\n                        }\n                        if (extra.data.json) {\n                            node.configure(extra.data.json);\n                        }\n\n                    }\n\n                    // join node after inserting\n                    if (options.node_from){\n                        var iS = false;\n                        switch (typeof options.slot_from){\n                            case "string":\n                                iS = options.node_from.findOutputSlot(options.slot_from);    \n                            break;\n                            case "object":\n                                if (options.slot_from.name){\n                                    iS = options.node_from.findOutputSlot(options.slot_from.name);\n                                }else{\n                                    iS = -1;\n                                }\n                                if (iS==-1 && typeof options.slot_from.slot_index !== "undefined") iS = options.slot_from.slot_index;\n                            break;\n                            case "number":\n                                iS = options.slot_from;\n                            break;\n                            default:\n                                iS = 0; // try with first if no name set\n                        }\n                        if (typeof options.node_from.outputs[iS] !== "undefined"){\n                            if (iS!==false && iS>-1){\n                                options.node_from.connectByType( iS, node, options.node_from.outputs[iS].type );\n                            }\n                        }else{\n                            // console.warn("cant find slot " + options.slot_from);\n                        }\n                    }\n                    if (options.node_to){\n                        var iS = false;\n                        switch (typeof options.slot_from){\n                            case "string":\n                                iS = options.node_to.findInputSlot(options.slot_from);    \n                            break;\n                            case "object":\n                                if (options.slot_from.name){\n                                    iS = options.node_to.findInputSlot(options.slot_from.name);\n                                }else{\n                                    iS = -1;\n                                }\n                                if (iS==-1 && typeof options.slot_from.slot_index !== "undefined") iS = options.slot_from.slot_index;\n                            break;\n                            case "number":\n                                iS = options.slot_from;\n                            break;\n                            default:\n                                iS = 0; // try with first if no name set\n                        }\n                        if (typeof options.node_to.inputs[iS] !== "undefined"){\n                            if (iS!==false && iS>-1){\n                                // try connection\n                                options.node_to.connectByTypeOutput(iS,node,options.node_to.inputs[iS].type);\n                            }\n                        }else{\n                            // console.warn("cant find slot_nodeTO " + options.slot_from);\n                        }\n                    }\n                    \n                    graphcanvas.graph.afterChange();\n                }\n            }\n\n            dialog.close();\n        }\n\n        function changeSelection(forward) {\n            var prev = selected;\n            if (selected) {\n                selected.classList.remove("selected");\n            }\n            if (!selected) {\n                selected = forward\n                    ? helper.childNodes[0]\n                    : helper.childNodes[helper.childNodes.length];\n            } else {\n                selected = forward\n                    ? selected.nextSibling\n                    : selected.previousSibling;\n                if (!selected) {\n                    selected = prev;\n                }\n            }\n            if (!selected) {\n                return;\n            }\n            selected.classList.add("selected");\n            selected.scrollIntoView({block: "end", behavior: "smooth"});\n        }\n\n        function refreshHelper() {\n            timeout = null;\n            var str = input.value;\n            first = null;\n            helper.innerHTML = "";\n            if (!str && !options.show_all_if_empty) {\n                return;\n            }\n\n            if (that.onSearchBox) {\n                var list = that.onSearchBox(helper, str, graphcanvas);\n                if (list) {\n                    for (var i = 0; i < list.length; ++i) {\n                        addResult(list[i]);\n                    }\n                }\n            } else {\n                var c = 0;\n                str = str.toLowerCase();\n\t\t\t\tvar filter = graphcanvas.filter || graphcanvas.graph.filter;\n\n                // filter by type preprocess\n                if(options.do_type_filter && that.search_box){\n                    var sIn = that.search_box.querySelector(".slot_in_type_filter");\n                    var sOut = that.search_box.querySelector(".slot_out_type_filter");\n                }else{\n                    var sIn = false;\n                    var sOut = false;\n                }\n                \n                //extras\n                for (var i in LiteGraph.searchbox_extras) {\n                    var extra = LiteGraph.searchbox_extras[i];\n                    if ((!options.show_all_if_empty || str) && extra.desc.toLowerCase().indexOf(str) === -1) {\n                        continue;\n                    }\n\t\t\t\t\tvar ctor = LiteGraph.registered_node_types[ extra.type ];\n\t\t\t\t\tif( ctor && ctor.filter != filter )\n\t\t\t\t\t\tcontinue;\n                    if( ! inner_test_filter(extra.type) )\n                        continue;\n                    addResult( extra.desc, "searchbox_extra" );\n                    if ( LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit ) {\n                        break;\n                    }\n                }\n\n\t\t\t\tvar filtered = null;\n                if (Array.prototype.filter) { //filter supported\n                    var keys = Object.keys( LiteGraph.registered_node_types ); //types\n                    var filtered = keys.filter( inner_test_filter );\n                } else {\n\t\t\t\t\tfiltered = [];\n                    for (var i in LiteGraph.registered_node_types) {\n\t\t\t\t\t\tif( inner_test_filter(i) )\n\t\t\t\t\t\t\tfiltered.push(i);\n                    }\n                }\n\n\t\t\t\tfor (var i = 0; i < filtered.length; i++) {\n\t\t\t\t\taddResult(filtered[i]);\n\t\t\t\t\tif ( LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n                \n                // add general type if filtering\n                if (options.show_general_after_typefiltered\n                    && (sIn.value || sOut.value) \n                ){\n                    filtered_extra = [];\n                    for (var i in LiteGraph.registered_node_types) {\n\t\t\t\t\t\tif( inner_test_filter(i, {inTypeOverride: sIn&&sIn.value?"*":false, outTypeOverride: sOut&&sOut.value?"*":false}) )\n\t\t\t\t\t\t\tfiltered_extra.push(i);\n                    }\n                    for (var i = 0; i < filtered_extra.length; i++) {\n                        addResult(filtered_extra[i], "generic_type");\n                        if ( LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit ) {\n                            break;\n                        }\n                    }\n                }\n                \n                // check il filtering gave no results\n                if ((sIn.value || sOut.value) && \n                    ( (helper.childNodes.length == 0 && options.show_general_if_none_on_typefilter) )\n                ){\n                    filtered_extra = [];\n                    for (var i in LiteGraph.registered_node_types) {\n\t\t\t\t\t\tif( inner_test_filter(i, {skipFilter: true}) )\n\t\t\t\t\t\t\tfiltered_extra.push(i);\n                    }\n                    for (var i = 0; i < filtered_extra.length; i++) {\n                        addResult(filtered_extra[i], "not_in_filter");\n                        if ( LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit ) {\n                            break;\n                        }\n                    }\n                }\n                \n\t\t\t\tfunction inner_test_filter( type, optsIn )\n\t\t\t\t{\n                    var optsIn = optsIn || {};\n                    var optsDef = { skipFilter: false\n                                    ,inTypeOverride: false\n                                    ,outTypeOverride: false\n                                  };\n                    var opts = Object.assign(optsDef,optsIn);\n\t\t\t\t\tvar ctor = LiteGraph.registered_node_types[ type ];\n\t\t\t\t\tif(filter && ctor.filter != filter )\n\t\t\t\t\t\treturn false;\n                    if ((!options.show_all_if_empty || str) && type.toLowerCase().indexOf(str) === -1)\n                        return false;\n                    \n                    // filter by slot IN, OUT types\n                    if(options.do_type_filter && !opts.skipFilter){\n                        var sType = type;\n                        \n                        var sV = sIn.value;\n                        if (opts.inTypeOverride!==false) sV = opts.inTypeOverride;\n\t\t\t\t\t\t//if (sV.toLowerCase() == "_event_") sV = LiteGraph.EVENT; // -1\n                        \n                        if(sIn && sV){\n                            //console.log("will check filter against "+sV);\n                            if (LiteGraph.registered_slot_in_types[sV] && LiteGraph.registered_slot_in_types[sV].nodes){ // type is stored\n                                //console.debug("check "+sType+" in "+LiteGraph.registered_slot_in_types[sV].nodes);\n                                var doesInc = LiteGraph.registered_slot_in_types[sV].nodes.includes(sType);\n                                if (doesInc!==false){\n                                    //console.log(sType+" HAS "+sV);\n                                }else{\n                                    /*console.debug(LiteGraph.registered_slot_in_types[sV]);\n                                    console.log(+" DONT includes "+type);*/\n                                    return false;\n                                }\n                            }\n                        }\n                        \n                        var sV = sOut.value;\n                        if (opts.outTypeOverride!==false) sV = opts.outTypeOverride;\n                        //if (sV.toLowerCase() == "_event_") sV = LiteGraph.EVENT; // -1\n                        \n                        if(sOut && sV){\n                            //console.log("search will check filter against "+sV);\n                            if (LiteGraph.registered_slot_out_types[sV] && LiteGraph.registered_slot_out_types[sV].nodes){ // type is stored\n                                //console.debug("check "+sType+" in "+LiteGraph.registered_slot_out_types[sV].nodes);\n                                var doesInc = LiteGraph.registered_slot_out_types[sV].nodes.includes(sType);\n                                if (doesInc!==false){\n                                    //console.log(sType+" HAS "+sV);\n                                }else{\n                                    /*console.debug(LiteGraph.registered_slot_out_types[sV]);\n                                    console.log(+" DONT includes "+type);*/\n                                    return false;\n                                }\n                            }\n                        }\n                    }\n                    return true;\n\t\t\t\t}\n            }\n\n            function addResult(type, className) {\n                var help = document.createElement("div");\n                if (!first) {\n                    first = type;\n                }\n                help.innerText = type;\n                help.dataset["type"] = escape(type);\n                help.className = "litegraph lite-search-item";\n                if (className) {\n                    help.className += " " + className;\n                }\n                help.addEventListener("click", function(e) {\n                    select(unescape(this.dataset["type"]));\n                });\n                helper.appendChild(help);\n            }\n        }\n\n        return dialog;\n    };\n\n    LGraphCanvas.prototype.showEditPropertyValue = function( node, property, options ) {\n        if (!node || node.properties[property] === undefined) {\n            return;\n        }\n\n        options = options || {};\n        var that = this;\n\n        var info = node.getPropertyInfo(property);\n\t\tvar type = info.type;\n\n        var input_html = "";\n\n        if (type == "string" || type == "number" || type == "array" || type == "object") {\n            input_html = "<input autofocus type=\'text\' class=\'value\'/>";\n        } else if ( (type == "enum" || type == "combo") && info.values) {\n            input_html = "<select autofocus type=\'text\' class=\'value\'>";\n            for (var i in info.values) {\n                var v = i;\n\t\t\t\tif( info.values.constructor === Array )\n\t\t\t\t\tv = info.values[i];\n\n                input_html +=\n                    "<option value=\'" +\n                    v +\n                    "\' " +\n                    (v == node.properties[property] ? "selected" : "") +\n                    ">" +\n                    info.values[i] +\n                    "</option>";\n            }\n            input_html += "</select>";\n        } else if (type == "boolean" || type == "toggle") {\n            input_html =\n                "<input autofocus type=\'checkbox\' class=\'value\' " +\n                (node.properties[property] ? "checked" : "") +\n                "/>";\n        } else {\n            console.warn("unknown type: " + type);\n            return;\n        }\n\n        var dialog = this.createDialog(\n            "<span class=\'name\'>" +\n                (info.label ? info.label : property) +\n                "</span>" +\n                input_html +\n                "<button>OK</button>",\n            options\n        );\n\n        var input = false;\n        if ((type == "enum" || type == "combo") && info.values) {\n            input = dialog.querySelector("select");\n            input.addEventListener("change", function(e) {\n                dialog.modified();\n                setValue(e.target.value);\n                //var index = e.target.value;\n                //setValue( e.options[e.selectedIndex].value );\n            });\n        } else if (type == "boolean" || type == "toggle") {\n            input = dialog.querySelector("input");\n            if (input) {\n                input.addEventListener("click", function(e) {\n                    dialog.modified();\n                    setValue(!!input.checked);\n                });\n            }\n        } else {\n            input = dialog.querySelector("input");\n            if (input) {\n                input.addEventListener("blur", function(e) {\n                    this.focus();\n                });\n\n\t\t\t\tvar v = node.properties[property] !== undefined ? node.properties[property] : "";\n\t\t\t\tif (type !== \'string\') {\n                    v = JSON.stringify(v);\n                }\n\n                input.value = v;\n                input.addEventListener("keydown", function(e) {\n                    if (e.keyCode == 27) {\n                        //ESC\n                        dialog.close();\n                    } else if (e.keyCode == 13) {\n                        // ENTER\n                        inner(); // save\n                    } else if (e.keyCode != 13) {\n                        dialog.modified();\n                        return;\n                    }\n                    e.preventDefault();\n                    e.stopPropagation();\n                });\n            }\n        }\n        if (input) input.focus();\n\n        var button = dialog.querySelector("button");\n        button.addEventListener("click", inner);\n\n        function inner() {\n            setValue(input.value);\n        }\n\n        function setValue(value) {\n\n\t\t\tif(info && info.values && info.values.constructor === Object && info.values[value] != undefined )\n\t\t\t\tvalue = info.values[value];\n\n            if (typeof node.properties[property] == "number") {\n                value = Number(value);\n            }\n            if (type == "array" || type == "object") {\n                value = JSON.parse(value);\n            }\n            node.properties[property] = value;\n            if (node.graph) {\n                node.graph._version++;\n            }\n            if (node.onPropertyChanged) {\n                node.onPropertyChanged(property, value);\n            }\n\t\t\tif(options.onclose)\n\t\t\t\toptions.onclose();\n            dialog.close();\n            node.setDirtyCanvas(true, true);\n        }\n\n\t\treturn dialog;\n    };\n\n    // TODO refactor, theer are different dialog, some uses createDialog, some dont\n    LGraphCanvas.prototype.createDialog = function(html, options) {\n        var def_options = { checkForInput: false, closeOnLeave: true, closeOnLeave_checkModified: true };\n        options = Object.assign(def_options, options || {});\n\n        var dialog = document.createElement("div");\n        dialog.className = "graphdialog";\n        dialog.innerHTML = html;\n        dialog.is_modified = false;\n\n        var rect = this.canvas.getBoundingClientRect();\n        var offsetx = -20;\n        var offsety = -20;\n        if (rect) {\n            offsetx -= rect.left;\n            offsety -= rect.top;\n        }\n\n        if (options.position) {\n            offsetx += options.position[0];\n            offsety += options.position[1];\n        } else if (options.event) {\n            offsetx += options.event.clientX;\n            offsety += options.event.clientY;\n        } //centered\n        else {\n            offsetx += this.canvas.width * 0.5;\n            offsety += this.canvas.height * 0.5;\n        }\n\n        dialog.style.left = offsetx + "px";\n        dialog.style.top = offsety + "px";\n\n        this.canvas.parentNode.appendChild(dialog);\n        \n        // acheck for input and use default behaviour: save on enter, close on esc\n        if (options.checkForInput){\n            var aI = [];\n            var focused = false;\n            if (aI = dialog.querySelectorAll("input")){\n                aI.forEach(function(iX) {\n                    iX.addEventListener("keydown",function(e){\n                        dialog.modified();\n                        if (e.keyCode == 27) {\n                            dialog.close();\n                        } else if (e.keyCode != 13) {\n                            return;\n                        }\n                        // set value ?\n                        e.preventDefault();\n                        e.stopPropagation();\n                    });\n                    if (!focused) iX.focus();\n                });\n            }\n        }\n        \n        dialog.modified = function(){\n            dialog.is_modified = true;\n        }\n        dialog.close = function() {\n            if (dialog.parentNode) {\n                dialog.parentNode.removeChild(dialog);\n            }\n        };\n        \n        var dialogCloseTimer = null;\n        var prevent_timeout = false;\n        dialog.addEventListener("mouseleave", function(e) {\n            if (prevent_timeout)\n                return;\n            if(options.closeOnLeave || LiteGraph.dialog_close_on_mouse_leave)\n                if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave)\n                    dialogCloseTimer = setTimeout(dialog.close, LiteGraph.dialog_close_on_mouse_leave_delay); //dialog.close();\n        });\n        dialog.addEventListener("mouseenter", function(e) {\n            if(options.closeOnLeave || LiteGraph.dialog_close_on_mouse_leave)\n                if(dialogCloseTimer) clearTimeout(dialogCloseTimer);\n        });\n        var selInDia = dialog.querySelectorAll("select");\n        if (selInDia){\n            // if filtering, check focus changed to comboboxes and prevent closing\n            selInDia.forEach(function(selIn) {\n                selIn.addEventListener("click", function(e) {\n                    prevent_timeout++;\n                });\n                selIn.addEventListener("blur", function(e) {\n                   prevent_timeout = 0;\n                });\n                selIn.addEventListener("change", function(e) {\n                    prevent_timeout = -1;\n                });\n            });\n        }\n\n        return dialog;\n    };\n\n\tLGraphCanvas.prototype.createPanel = function(title, options) {\n\t\toptions = options || {};\n\n\t\tvar ref_window = options.window || window;\n\t\tvar root = document.createElement("div");\n\t\troot.className = "litegraph dialog";\n\t\troot.innerHTML = "<div class=\'dialog-header\'><span class=\'dialog-title\'></span></div><div class=\'dialog-content\'></div><div style=\'display:none;\' class=\'dialog-alt-content\'></div><div class=\'dialog-footer\'></div>";\n\t\troot.header = root.querySelector(".dialog-header");\n\n\t\tif(options.width)\n\t\t\troot.style.width = options.width + (options.width.constructor === Number ? "px" : "");\n\t\tif(options.height)\n\t\t\troot.style.height = options.height + (options.height.constructor === Number ? "px" : "");\n\t\tif(options.closable)\n\t\t{\n\t\t\tvar close = document.createElement("span");\n\t\t\tclose.innerHTML = "&#10005;";\n\t\t\tclose.classList.add("close");\n\t\t\tclose.addEventListener("click",function(){\n\t\t\t\troot.close();\n\t\t\t});\n\t\t\troot.header.appendChild(close);\n\t\t}\n\t\troot.title_element = root.querySelector(".dialog-title");\n\t\troot.title_element.innerText = title;\n\t\troot.content = root.querySelector(".dialog-content");\n        root.alt_content = root.querySelector(".dialog-alt-content");\n\t\troot.footer = root.querySelector(".dialog-footer");\n\n\t\troot.close = function()\n\t\t{\n\t\t    if (root.onClose && typeof root.onClose == "function"){\n\t\t        root.onClose();\n\t\t    }\n            if(root.parentNode)\n\t\t        root.parentNode.removeChild(root);\n\t\t    /* XXX CHECK THIS */\n\t\t    if(this.parentNode){\n\t\t    \tthis.parentNode.removeChild(this);\n\t\t    }\n\t\t    /* XXX this was not working, was fixed with an IF, check this */\n\t\t}\n\n        // function to swap panel content\n        root.toggleAltContent = function(force){\n            if (typeof force != "undefined"){\n                var vTo = force ? "block" : "none";\n                var vAlt = force ? "none" : "block";\n            }else{\n                var vTo = root.alt_content.style.display != "block" ? "block" : "none";\n                var vAlt = root.alt_content.style.display != "block" ? "none" : "block";\n            }\n            root.alt_content.style.display = vTo;\n            root.content.style.display = vAlt;\n        }\n        \n        root.toggleFooterVisibility = function(force){\n            if (typeof force != "undefined"){\n                var vTo = force ? "block" : "none";\n            }else{\n                var vTo = root.footer.style.display != "block" ? "block" : "none";\n            }\n            root.footer.style.display = vTo;\n        }\n        \n\t\troot.clear = function()\n\t\t{\n\t\t\tthis.content.innerHTML = "";\n\t\t}\n\n\t\troot.addHTML = function(code, classname, on_footer)\n\t\t{\n\t\t\tvar elem = document.createElement("div");\n\t\t\tif(classname)\n\t\t\t\telem.className = classname;\n\t\t\telem.innerHTML = code;\n\t\t\tif(on_footer)\n\t\t\t\troot.footer.appendChild(elem);\n\t\t\telse\n\t\t\t\troot.content.appendChild(elem);\n\t\t\treturn elem;\n\t\t}\n\n\t\troot.addButton = function( name, callback, options )\n\t\t{\n\t\t\tvar elem = document.createElement("button");\n\t\t\telem.innerText = name;\n\t\t\telem.options = options;\n\t\t\telem.classList.add("btn");\n\t\t\telem.addEventListener("click",callback);\n\t\t\troot.footer.appendChild(elem);\n\t\t\treturn elem;\n\t\t}\n\n\t\troot.addSeparator = function()\n\t\t{\n\t\t\tvar elem = document.createElement("div");\n\t\t\telem.className = "separator";\n\t\t\troot.content.appendChild(elem);\n\t\t}\n\n\t\troot.addWidget = function( type, name, value, options, callback )\n\t\t{\n\t\t\toptions = options || {};\n\t\t\tvar str_value = String(value);\n\t\t\ttype = type.toLowerCase();\n\t\t\tif(type == "number")\n\t\t\t\tstr_value = value.toFixed(3);\n\n\t\t\tvar elem = document.createElement("div");\n\t\t\telem.className = "property";\n\t\t\telem.innerHTML = "<span class=\'property_name\'></span><span class=\'property_value\'></span>";\n\t\t\telem.querySelector(".property_name").innerText = options.label || name;\n\t\t\tvar value_element = elem.querySelector(".property_value");\n\t\t\tvalue_element.innerText = str_value;\n\t\t\telem.dataset["property"] = name;\n\t\t\telem.dataset["type"] = options.type || type;\n\t\t\telem.options = options;\n\t\t\telem.value = value;\n\n\t\t\tif( type == "code" )\n\t\t\t\telem.addEventListener("click", function(e){ root.inner_showCodePad( this.dataset["property"] ); });\n\t\t\telse if (type == "boolean")\n\t\t\t{\n\t\t\t\telem.classList.add("boolean");\n\t\t\t\tif(value)\n\t\t\t\t\telem.classList.add("bool-on");\n\t\t\t\telem.addEventListener("click", function(){ \n\t\t\t\t\t//var v = node.properties[this.dataset["property"]]; \n\t\t\t\t\t//node.setProperty(this.dataset["property"],!v); this.innerText = v ? "true" : "false"; \n\t\t\t\t\tvar propname = this.dataset["property"];\n\t\t\t\t\tthis.value = !this.value;\n\t\t\t\t\tthis.classList.toggle("bool-on");\n\t\t\t\t\tthis.querySelector(".property_value").innerText = this.value ? "true" : "false";\n\t\t\t\t\tinnerChange(propname, this.value );\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (type == "string" || type == "number")\n\t\t\t{\n\t\t\t\tvalue_element.setAttribute("contenteditable",true);\n\t\t\t\tvalue_element.addEventListener("keydown", function(e){ \n\t\t\t\t\tif(e.code == "Enter" && (type != "string" || !e.shiftKey)) // allow for multiline\n\t\t\t\t\t{\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tthis.blur();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tvalue_element.addEventListener("blur", function(){ \n\t\t\t\t\tvar v = this.innerText;\n\t\t\t\t\tvar propname = this.parentNode.dataset["property"];\n\t\t\t\t\tvar proptype = this.parentNode.dataset["type"];\n\t\t\t\t\tif( proptype == "number")\n\t\t\t\t\t\tv = Number(v);\n\t\t\t\t\tinnerChange(propname, v);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (type == "enum" || type == "combo") {\n\t\t\t\tvar str_value = LGraphCanvas.getPropertyPrintableValue( value, options.values );\n\t\t\t\tvalue_element.innerText = str_value;\n\n\t\t\t\tvalue_element.addEventListener("click", function(event){ \n\t\t\t\t\tvar values = options.values || [];\n\t\t\t\t\tvar propname = this.parentNode.dataset["property"];\n\t\t\t\t\tvar elem_that = this;\n\t\t\t\t\tvar menu = new LiteGraph.ContextMenu(values,{\n\t\t\t\t\t\t\tevent: event,\n\t\t\t\t\t\t\tclassName: "dark",\n\t\t\t\t\t\t\tcallback: inner_clicked\n\t\t\t\t\t\t},\n\t\t\t\t\t\tref_window);\n\t\t\t\t\tfunction inner_clicked(v, option, event) {\n\t\t\t\t\t\t//node.setProperty(propname,v); \n\t\t\t\t\t\t//graphcanvas.dirty_canvas = true;\n\t\t\t\t\t\telem_that.innerText = v;\n\t\t\t\t\t\tinnerChange(propname,v);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n            }\n\n\t\t\troot.content.appendChild(elem);\n\n\t\t\tfunction innerChange(name, value)\n\t\t\t{\n\t\t\t\t//console.log("change",name,value);\n\t\t\t\t//that.dirty_canvas = true;\n\t\t\t\tif(options.callback)\n\t\t\t\t\toptions.callback(name,value,options);\n\t\t\t\tif(callback)\n\t\t\t\t\tcallback(name,value,options);\n\t\t\t}\n\n\t\t\treturn elem;\n\t\t}\n\n        if (root.onOpen && typeof root.onOpen == "function") root.onOpen();\n        \n\t\treturn root;\n\t};\n\n\tLGraphCanvas.getPropertyPrintableValue = function(value, values)\n\t{\n\t\tif(!values)\n\t\t\treturn String(value);\n\n\t\tif(values.constructor === Array)\n\t\t{\n\t\t\treturn String(value);\t\t\t\n\t\t}\n\n\t\tif(values.constructor === Object)\n\t\t{\n\t\t\tvar desc_value = "";\n\t\t\tfor(var k in values)\n\t\t\t{\n\t\t\t\tif(values[k] != value)\n\t\t\t\t\tcontinue;\n\t\t\t\tdesc_value = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn String(value) + " ("+desc_value+")";\n\t\t}\n\t}\n\n    LGraphCanvas.prototype.closePanels = function(){\n        var panel = document.querySelector("#node-panel");\n\t\tif(panel)\n\t\t\tpanel.close();\n        var panel = document.querySelector("#option-panel");\n\t\tif(panel)\n\t\t\tpanel.close();\n    }\n    \n    LGraphCanvas.prototype.showShowGraphOptionsPanel = function(refOpts, obEv, refMenu, refMenu2){\n        if(this.constructor && this.constructor.name == "HTMLDivElement"){\n            // assume coming from the menu event click\n            if (!obEv || !obEv.event || !obEv.event.target || !obEv.event.target.lgraphcanvas){\n                console.warn("Canvas not found"); // need a ref to canvas obj\n                /*console.debug(event);\n                console.debug(event.target);*/\n                return;\n            }\n            var graphcanvas = obEv.event.target.lgraphcanvas;\n        }else{\n            // assume called internally\n            var graphcanvas = this;\n        }\n        graphcanvas.closePanels();\n        var ref_window = graphcanvas.getCanvasWindow();\n        panel = graphcanvas.createPanel("Options",{\n                                            closable: true\n                                            ,window: ref_window\n                                            ,onOpen: function(){\n                                                graphcanvas.OPTIONPANEL_IS_OPEN = true;\n                                            }\n                                            ,onClose: function(){\n                                                graphcanvas.OPTIONPANEL_IS_OPEN = false;\n                                                graphcanvas.options_panel = null;\n                                            }\n                                        });\n        graphcanvas.options_panel = panel;\n        panel.id = "option-panel";\n\t\tpanel.classList.add("settings");\n        \n        function inner_refresh(){\n            \n            panel.content.innerHTML = ""; //clear\n\n            var fUpdate = function(name, value, options){\n                switch(name){\n                    /*case "Render mode":\n                        // Case "".. \n                        if (options.values && options.key){\n                            var kV = Object.values(options.values).indexOf(value);\n                            if (kV>=0 && options.values[kV]){\n                                console.debug("update graph options: "+options.key+": "+kV);\n                                graphcanvas[options.key] = kV;\n                                //console.debug(graphcanvas);\n                                break;\n                            }\n                        }\n                        console.warn("unexpected options");\n                        console.debug(options);\n                        break;*/\n                    default:\n                        //console.debug("want to update graph options: "+name+": "+value);\n                        if (options && options.key){\n                            name = options.key;\n                        }\n                        if (options.values){\n                            value = Object.values(options.values).indexOf(value);\n                        }\n                        //console.debug("update graph option: "+name+": "+value);\n                        graphcanvas[name] = value;\n                        break;\n                }\n            };\n            \n            // panel.addWidget( "string", "Graph name", "", {}, fUpdate); // implement\n            \n            var aProps = LiteGraph.availableCanvasOptions;\n            aProps.sort();\n            for(var pI in aProps){\n                var pX = aProps[pI];\n                panel.addWidget( "boolean", pX, graphcanvas[pX], {key: pX, on: "True", off: "False"}, fUpdate);\n            }\n            \n            var aLinks = [ graphcanvas.links_render_mode ];\n            panel.addWidget( "combo", "Render mode", LiteGraph.LINK_RENDER_MODES[graphcanvas.links_render_mode], {key: "links_render_mode", values: LiteGraph.LINK_RENDER_MODES}, fUpdate);\n            \n            panel.addSeparator();\n            \n            panel.footer.innerHTML = ""; // clear\n\n\t\t}\n        inner_refresh();\n\n\t\tgraphcanvas.canvas.parentNode.appendChild( panel );\n    }\n    \n    LGraphCanvas.prototype.showShowNodePanel = function( node )\n\t{\n\t\tthis.SELECTED_NODE = node;\n\t\tthis.closePanels();\n\t\tvar ref_window = this.getCanvasWindow();\n        var that = this;\n\t\tvar graphcanvas = this;\n\t\tvar panel = this.createPanel(node.title || "",{\n                                                    closable: true\n                                                    ,window: ref_window\n                                                    ,onOpen: function(){\n                                                        graphcanvas.NODEPANEL_IS_OPEN = true;\n                                                    }\n                                                    ,onClose: function(){\n                                                        graphcanvas.NODEPANEL_IS_OPEN = false;\n                                                        graphcanvas.node_panel = null;\n                                                    }\n                                                });\n        graphcanvas.node_panel = panel;\n\t\tpanel.id = "node-panel";\n\t\tpanel.node = node;\n\t\tpanel.classList.add("settings");\n\n\t\tfunction inner_refresh()\n\t\t{\n\t\t\tpanel.content.innerHTML = ""; //clear\n\t\t\tpanel.addHTML("<span class=\'node_type\'>"+node.type+"</span><span class=\'node_desc\'>"+(node.constructor.desc || "")+"</span><span class=\'separator\'></span>");\n\n\t\t\tpanel.addHTML("<h3>Properties</h3>");\n\n            var fUpdate = function(name,value){\n                            graphcanvas.graph.beforeChange(node);\n                            switch(name){\n                                case "Title":\n                                    node.title = value;\n                                    break;\n                                case "Mode":\n                                    var kV = Object.values(LiteGraph.NODE_MODES).indexOf(value);\n                                    if (kV>=0 && LiteGraph.NODE_MODES[kV]){\n                                        node.changeMode(kV);\n                                    }else{\n                                        console.warn("unexpected mode: "+value);\n                                    }\n                                    break;\n                                case "Color":\n                                    if (LGraphCanvas.node_colors[value]){\n                                        node.color = LGraphCanvas.node_colors[value].color;\n                                        node.bgcolor = LGraphCanvas.node_colors[value].bgcolor;\n                                    }else{\n                                        console.warn("unexpected color: "+value);\n                                    }\n                                    break;\n                                default:\n                                    node.setProperty(name,value);\n                                    break;\n                            }\n                            graphcanvas.graph.afterChange();\n                            graphcanvas.dirty_canvas = true;\n                        };\n            \n            panel.addWidget( "string", "Title", node.title, {}, fUpdate);\n            \n            panel.addWidget( "combo", "Mode", LiteGraph.NODE_MODES[node.mode], {values: LiteGraph.NODE_MODES}, fUpdate);\n            \n            var nodeCol = "";\n            if (node.color !== undefined){\n                nodeCol = Object.keys(LGraphCanvas.node_colors).filter(function(nK){ return LGraphCanvas.node_colors[nK].color == node.color; });\n            }\n            \n            panel.addWidget( "combo", "Color", nodeCol, {values: Object.keys(LGraphCanvas.node_colors)}, fUpdate);\n            \n            for(var pName in node.properties)\n\t\t\t{\n\t\t\t\tvar value = node.properties[pName];\n\t\t\t\tvar info = node.getPropertyInfo(pName);\n\t\t\t\tvar type = info.type || "string";\n\n\t\t\t\t//in case the user wants control over the side panel widget\n\t\t\t\tif( node.onAddPropertyToPanel && node.onAddPropertyToPanel(pName,panel) )\n\t\t\t\t\tcontinue;\n\n\t\t\t\tpanel.addWidget( info.widget || info.type, pName, value, info, fUpdate);\n\t\t\t}\n\n\t\t\tpanel.addSeparator();\n\n\t\t\tif(node.onShowCustomPanelInfo)\n\t\t\t\tnode.onShowCustomPanelInfo(panel);\n\n            panel.footer.innerHTML = ""; // clear\n\t\t\tpanel.addButton("Delete",function(){\n\t\t\t\tif(node.block_delete)\n\t\t\t\t\treturn;\n\t\t\t\tnode.graph.remove(node);\n\t\t\t\tpanel.close();\n\t\t\t}).classList.add("delete");\n\t\t}\n\n\t\tpanel.inner_showCodePad = function( propname )\n\t\t{\n            panel.classList.remove("settings");\n            panel.classList.add("centered");\n\n            \n\t\t\t/*if(window.CodeFlask) //disabled for now\n\t\t\t{\n\t\t\t\tpanel.content.innerHTML = "<div class=\'code\'></div>";\n\t\t\t\tvar flask = new CodeFlask( "div.code", { language: \'js\' });\n\t\t\t\tflask.updateCode(node.properties[propname]);\n\t\t\t\tflask.onUpdate( function(code) {\n\t\t\t\t\tnode.setProperty(propname, code);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse\n\t\t\t{*/\n\t\t\t\tpanel.alt_content.innerHTML = "<textarea class=\'code\'></textarea>";\n\t\t\t\tvar textarea = panel.alt_content.querySelector("textarea");\n                var fDoneWith = function(){\n                    panel.toggleAltContent(false); //if(node_prop_div) node_prop_div.style.display = "block"; // panel.close();\n                    panel.toggleFooterVisibility(true);\n                    textarea.parentNode.removeChild(textarea);\n                    panel.classList.add("settings");\n                    panel.classList.remove("centered");\n                    inner_refresh();\n                }\n\t\t\t\ttextarea.value = node.properties[propname];\n\t\t\t\ttextarea.addEventListener("keydown", function(e){\n\t\t\t\t\tif(e.code == "Enter" && e.ctrlKey )\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.setProperty(propname, textarea.value);\n                        fDoneWith();\n\t\t\t\t\t}\n\t\t\t\t});\n                panel.toggleAltContent(true);\n                panel.toggleFooterVisibility(false);\n\t\t\t\ttextarea.style.height = "calc(100% - 40px)";\n\t\t\t/*}*/\n\t\t\tvar assign = panel.addButton( "Assign", function(){\n\t\t\t\tnode.setProperty(propname, textarea.value);\n                fDoneWith();\n\t\t\t});\n\t\t\tpanel.alt_content.appendChild(assign); //panel.content.appendChild(assign);\n\t\t\tvar button = panel.addButton( "Close", fDoneWith);\n\t\t\tbutton.style.float = "right";\n\t\t\tpanel.alt_content.appendChild(button); // panel.content.appendChild(button);\n\t\t}\n\n\t\tinner_refresh();\n\n\t\tthis.canvas.parentNode.appendChild( panel );\n\t}\n\t\n\tLGraphCanvas.prototype.showSubgraphPropertiesDialog = function(node)\n\t{\n\t\tconsole.log("showing subgraph properties dialog");\n\n\t\tvar old_panel = this.canvas.parentNode.querySelector(".subgraph_dialog");\n\t\tif(old_panel)\n\t\t\told_panel.close();\n\n\t\tvar panel = this.createPanel("Subgraph Inputs",{closable:true, width: 500});\n\t\tpanel.node = node;\n\t\tpanel.classList.add("subgraph_dialog");\n\n\t\tfunction inner_refresh()\n\t\t{\n\t\t\tpanel.clear();\n\n\t\t\t//show currents\n\t\t\tif(node.inputs)\n\t\t\t\tfor(var i = 0; i < node.inputs.length; ++i)\n\t\t\t\t{\n\t\t\t\t\tvar input = node.inputs[i];\n\t\t\t\t\tif(input.not_subgraph_input)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar html = "<button>&#10005;</button> <span class=\'bullet_icon\'></span><span class=\'name\'></span><span class=\'type\'></span>";\n\t\t\t\t\tvar elem = panel.addHTML(html,"subgraph_property");\n\t\t\t\t\telem.dataset["name"] = input.name;\n\t\t\t\t\telem.dataset["slot"] = i;\n\t\t\t\t\telem.querySelector(".name").innerText = input.name;\n\t\t\t\t\telem.querySelector(".type").innerText = input.type;\n\t\t\t\t\telem.querySelector("button").addEventListener("click",function(e){\n\t\t\t\t\t\tnode.removeInput( Number( this.parentNode.dataset["slot"] ) );\n\t\t\t\t\t\tinner_refresh();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t}\n\n\t\t//add extra\n\t\tvar html = " + <span class=\'label\'>Name</span><input class=\'name\'/><span class=\'label\'>Type</span><input class=\'type\'></input><button>+</button>";\n\t\tvar elem = panel.addHTML(html,"subgraph_property extra", true);\n\t\telem.querySelector("button").addEventListener("click", function(e){\n\t\t\tvar elem = this.parentNode;\n\t\t\tvar name = elem.querySelector(".name").value;\n\t\t\tvar type = elem.querySelector(".type").value;\n\t\t\tif(!name || node.findInputSlot(name) != -1)\n\t\t\t\treturn;\n\t\t\tnode.addInput(name,type);\n\t\t\telem.querySelector(".name").value = "";\n\t\t\telem.querySelector(".type").value = "";\n\t\t\tinner_refresh();\n\t\t});\n\n\t\tinner_refresh();\n\t    this.canvas.parentNode.appendChild(panel);\n\t\treturn panel;\n\t}\n    LGraphCanvas.prototype.showSubgraphPropertiesDialogRight = function (node) {\n\n        // console.log("showing subgraph properties dialog");\n        var that = this;\n        // old_panel if old_panel is exist close it\n        var old_panel = this.canvas.parentNode.querySelector(".subgraph_dialog");\n        if (old_panel)\n            old_panel.close();\n        // new panel\n        var panel = this.createPanel("Subgraph Outputs", { closable: true, width: 500 });\n        panel.node = node;\n        panel.classList.add("subgraph_dialog");\n\n        function inner_refresh() {\n            panel.clear();\n            //show currents\n            if (node.outputs)\n                for (var i = 0; i < node.outputs.length; ++i) {\n                    var input = node.outputs[i];\n                    if (input.not_subgraph_output)\n                        continue;\n                    var html = "<button>&#10005;</button> <span class=\'bullet_icon\'></span><span class=\'name\'></span><span class=\'type\'></span>";\n                    var elem = panel.addHTML(html, "subgraph_property");\n                    elem.dataset["name"] = input.name;\n                    elem.dataset["slot"] = i;\n                    elem.querySelector(".name").innerText = input.name;\n                    elem.querySelector(".type").innerText = input.type;\n                    elem.querySelector("button").addEventListener("click", function (e) {\n                        node.removeOutput(Number(this.parentNode.dataset["slot"]));\n                        inner_refresh();\n                    });\n                }\n        }\n\n        //add extra\n        var html = " + <span class=\'label\'>Name</span><input class=\'name\'/><span class=\'label\'>Type</span><input class=\'type\'></input><button>+</button>";\n        var elem = panel.addHTML(html, "subgraph_property extra", true);\n        elem.querySelector(".name").addEventListener("keydown", function (e) {\n            if (e.keyCode == 13) {\n                addOutput.apply(this)\n            }\n        })\n        elem.querySelector("button").addEventListener("click", function (e) {\n            addOutput.apply(this)\n        });\n        function addOutput() {\n            var elem = this.parentNode;\n            var name = elem.querySelector(".name").value;\n            var type = elem.querySelector(".type").value;\n            if (!name || node.findOutputSlot(name) != -1)\n                return;\n            node.addOutput(name, type);\n            elem.querySelector(".name").value = "";\n            elem.querySelector(".type").value = "";\n            inner_refresh();\n        }\n\n        inner_refresh();\n        this.canvas.parentNode.appendChild(panel);\n        return panel;\n    }\n\tLGraphCanvas.prototype.checkPanels = function()\n\t{\n\t\tif(!this.canvas)\n\t\t\treturn;\n\t\tvar panels = this.canvas.parentNode.querySelectorAll(".litegraph.dialog");\n\t\tfor(var i = 0; i < panels.length; ++i)\n\t\t{\n\t\t\tvar panel = panels[i];\n\t\t\tif( !panel.node )\n\t\t\t\tcontinue;\n\t\t\tif( !panel.node.graph || panel.graph != this.graph )\n\t\t\t\tpanel.close();\n\t\t}\n\t}\n\n    LGraphCanvas.onMenuNodeCollapse = function(value, options, e, menu, node) {\n\t\tnode.graph.beforeChange(/*?*/);\n\t\t\n\t\tvar fApplyMultiNode = function(node){\n\t\t\tnode.collapse();\n\t\t}\n\t\t\n\t\tvar graphcanvas = LGraphCanvas.active_canvas;\n\t\tif (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1){\n\t\t\tfApplyMultiNode(node);\n\t\t}else{\n\t\t\tfor (var i in graphcanvas.selected_nodes) {\n\t\t\t\tfApplyMultiNode(graphcanvas.selected_nodes[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tnode.graph.afterChange(/*?*/);\n    };\n\n    LGraphCanvas.onMenuNodePin = function(value, options, e, menu, node) {\n        node.pin();\n    };\n\n    LGraphCanvas.onMenuNodeMode = function(value, options, e, menu, node) {\n        new LiteGraph.ContextMenu(\n            LiteGraph.NODE_MODES,\n            { event: e, callback: inner_clicked, parentMenu: menu, node: node }\n        );\n\n        function inner_clicked(v) {\n            if (!node) {\n                return;\n            }\n            var kV = Object.values(LiteGraph.NODE_MODES).indexOf(v);\n            var fApplyMultiNode = function(node){\n\t\t\t\tif (kV>=0 && LiteGraph.NODE_MODES[kV])\n\t\t\t\t\tnode.changeMode(kV);\n\t\t\t\telse{\n\t\t\t\t\tconsole.warn("unexpected mode: "+v);\n\t\t\t\t\tnode.changeMode(LiteGraph.ALWAYS);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar graphcanvas = LGraphCanvas.active_canvas;\n\t\t\tif (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1){\n\t\t\t\tfApplyMultiNode(node);\n\t\t\t}else{\n\t\t\t\tfor (var i in graphcanvas.selected_nodes) {\n\t\t\t\t\tfApplyMultiNode(graphcanvas.selected_nodes[i]);\n\t\t\t\t}\n\t\t\t}\n        }\n\n        return false;\n    };\n\n    LGraphCanvas.onMenuNodeColors = function(value, options, e, menu, node) {\n        if (!node) {\n            throw "no node for color";\n        }\n\n        var values = [];\n        values.push({\n            value: null,\n            content:\n                "<span style=\'display: block; padding-left: 4px;\'>No color</span>"\n        });\n\n        for (var i in LGraphCanvas.node_colors) {\n            var color = LGraphCanvas.node_colors[i];\n            var value = {\n                value: i,\n                content:\n                    "<span style=\'display: block; color: #999; padding-left: 4px; border-left: 8px solid " +\n                    color.color +\n                    "; background-color:" +\n                    color.bgcolor +\n                    "\'>" +\n                    i +\n                    "</span>"\n            };\n            values.push(value);\n        }\n        new LiteGraph.ContextMenu(values, {\n            event: e,\n            callback: inner_clicked,\n            parentMenu: menu,\n            node: node\n        });\n\n        function inner_clicked(v) {\n            if (!node) {\n                return;\n            }\n\n            var color = v.value ? LGraphCanvas.node_colors[v.value] : null;\n\t\t\t\n\t\t\tvar fApplyColor = function(node){\n\t\t\t\tif (color) {\n\t\t\t\t\tif (node.constructor === LiteGraph.LGraphGroup) {\n\t\t\t\t\t\tnode.color = color.groupcolor;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.color = color.color;\n\t\t\t\t\t\tnode.bgcolor = color.bgcolor;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdelete node.color;\n\t\t\t\t\tdelete node.bgcolor;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar graphcanvas = LGraphCanvas.active_canvas;\n\t\t\tif (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1){\n\t\t\t\tfApplyColor(node);\n\t\t\t}else{\n\t\t\t\tfor (var i in graphcanvas.selected_nodes) {\n\t\t\t\t\tfApplyColor(graphcanvas.selected_nodes[i]);\n\t\t\t\t}\n\t\t\t}\n            node.setDirtyCanvas(true, true);\n        }\n\n        return false;\n    };\n\n    LGraphCanvas.onMenuNodeShapes = function(value, options, e, menu, node) {\n        if (!node) {\n            throw "no node passed";\n        }\n\n        new LiteGraph.ContextMenu(LiteGraph.VALID_SHAPES, {\n            event: e,\n            callback: inner_clicked,\n            parentMenu: menu,\n            node: node\n        });\n\n        function inner_clicked(v) {\n            if (!node) {\n                return;\n            }\n\t\t\tnode.graph.beforeChange(/*?*/); //node\n            \n\t\t\tvar fApplyMultiNode = function(node){\n\t\t\t\tnode.shape = v;\n\t\t\t}\n\n\t\t\tvar graphcanvas = LGraphCanvas.active_canvas;\n\t\t\tif (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1){\n\t\t\t\tfApplyMultiNode(node);\n\t\t\t}else{\n\t\t\t\tfor (var i in graphcanvas.selected_nodes) {\n\t\t\t\t\tfApplyMultiNode(graphcanvas.selected_nodes[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tnode.graph.afterChange(/*?*/); //node\n            node.setDirtyCanvas(true);\n        }\n\n        return false;\n    };\n\n    LGraphCanvas.onMenuNodeRemove = function(value, options, e, menu, node) {\n        if (!node) {\n            throw "no node passed";\n        }\n\n\t\tvar graph = node.graph;\n\t\tgraph.beforeChange();\n        \n\t\t\n\t\tvar fApplyMultiNode = function(node){\n\t\t\tif (node.removable === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgraph.remove(node);\n\t\t}\n\n\t\tvar graphcanvas = LGraphCanvas.active_canvas;\n\t\tif (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1){\n\t\t\tfApplyMultiNode(node);\n\t\t}else{\n\t\t\tfor (var i in graphcanvas.selected_nodes) {\n\t\t\t\tfApplyMultiNode(graphcanvas.selected_nodes[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tgraph.afterChange();\n        node.setDirtyCanvas(true, true);\n    };\n\n    LGraphCanvas.onMenuNodeToSubgraph = function(value, options, e, menu, node) {\n\t\tvar graph = node.graph;\n\t\tvar graphcanvas = LGraphCanvas.active_canvas;\n\t\tif(!graphcanvas) //??\n\t\t\treturn;\n\n\t\tvar nodes_list = Object.values( graphcanvas.selected_nodes || {} );\n\t\tif( !nodes_list.length )\n\t\t\tnodes_list = [ node ];\n\n\t\tvar subgraph_node = LiteGraph.createNode("graph/subgraph");\n\t\tsubgraph_node.pos = node.pos.concat();\n\t\tgraph.add(subgraph_node);\n\n\t\tsubgraph_node.buildFromNodes( nodes_list );\n\n\t\tgraphcanvas.deselectAllNodes();\n        node.setDirtyCanvas(true, true);\n    };\n\n    LGraphCanvas.onMenuNodeClone = function(value, options, e, menu, node) {\n        \n\t\tnode.graph.beforeChange();\n        \n\t\tvar newSelected = {};\n\t\t\n\t\tvar fApplyMultiNode = function(node){\n\t\t\tif (node.clonable === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar newnode = node.clone();\n\t\t\tif (!newnode) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnewnode.pos = [node.pos[0] + 5, node.pos[1] + 5];\n\t\t\tnode.graph.add(newnode);\n\t\t\tnewSelected[newnode.id] = newnode;\n\t\t}\n\n\t\tvar graphcanvas = LGraphCanvas.active_canvas;\n\t\tif (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1){\n\t\t\tfApplyMultiNode(node);\n\t\t}else{\n\t\t\tfor (var i in graphcanvas.selected_nodes) {\n\t\t\t\tfApplyMultiNode(graphcanvas.selected_nodes[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(Object.keys(newSelected).length){\n\t\t\tgraphcanvas.selectNodes(newSelected);\n\t\t}\n\t\t\n\t\tnode.graph.afterChange();\n\n        node.setDirtyCanvas(true, true);\n    };\n\n    LGraphCanvas.node_colors = {\n        red: { color: "#322", bgcolor: "#533", groupcolor: "#A88" },\n        brown: { color: "#332922", bgcolor: "#593930", groupcolor: "#b06634" },\n        green: { color: "#232", bgcolor: "#353", groupcolor: "#8A8" },\n        blue: { color: "#223", bgcolor: "#335", groupcolor: "#88A" },\n        pale_blue: {\n            color: "#2a363b",\n            bgcolor: "#3f5159",\n            groupcolor: "#3f789e"\n        },\n        cyan: { color: "#233", bgcolor: "#355", groupcolor: "#8AA" },\n        purple: { color: "#323", bgcolor: "#535", groupcolor: "#a1309b" },\n        yellow: { color: "#432", bgcolor: "#653", groupcolor: "#b58b2a" },\n        black: { color: "#222", bgcolor: "#000", groupcolor: "#444" }\n    };\n\n    LGraphCanvas.prototype.getCanvasMenuOptions = function() {\n        var options = null;\n\t\tvar that = this;\n        if (this.getMenuOptions) {\n            options = this.getMenuOptions();\n        } else {\n            options = [\n                {\n                    content: "Add Node",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onMenuAdd\n                },\n                { content: "Add Group", callback: LGraphCanvas.onGroupAdd },\n\t\t\t\t//{ content: "Arrange", callback: that.graph.arrange },\n                //{content:"Collapse All", callback: LGraphCanvas.onMenuCollapseAll }\n            ];\n            /*if (LiteGraph.showCanvasOptions){\n                options.push({ content: "Options", callback: that.showShowGraphOptionsPanel });\n            }*/\n\n            if (Object.keys(this.selected_nodes).length > 1) {\n                options.push({\n                    content: "Align",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onGroupAlign,\n                })\n            }\n\n            if (this._graph_stack && this._graph_stack.length > 0) {\n                options.push(null, {\n                    content: "Close subgraph",\n                    callback: this.closeSubgraph.bind(this)\n                });\n            }\n        }\n\n        if (this.getExtraMenuOptions) {\n            var extra = this.getExtraMenuOptions(this, options);\n            if (extra) {\n                options = options.concat(extra);\n            }\n        }\n\n        return options;\n    };\n\n    //called by processContextMenu to extract the menu list\n    LGraphCanvas.prototype.getNodeMenuOptions = function(node) {\n        var options = null;\n\n        if (node.getMenuOptions) {\n            options = node.getMenuOptions(this);\n        } else {\n            options = [\n                {\n                    content: "Inputs",\n                    has_submenu: true,\n                    disabled: true,\n                    callback: LGraphCanvas.showMenuNodeOptionalInputs\n                },\n                {\n                    content: "Outputs",\n                    has_submenu: true,\n                    disabled: true,\n                    callback: LGraphCanvas.showMenuNodeOptionalOutputs\n                },\n                null,\n                {\n                    content: "Properties",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onShowMenuNodeProperties\n                },\n                null,\n                {\n                    content: "Title",\n                    callback: LGraphCanvas.onShowPropertyEditor\n                },\n                {\n                    content: "Mode",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onMenuNodeMode\n                }];\n            if(node.resizable !== false){\n                options.push({\n                    content: "Resize", callback: LGraphCanvas.onMenuResizeNode\n                });\n            }\n            options.push(\n                {\n                    content: "Collapse",\n                    callback: LGraphCanvas.onMenuNodeCollapse\n                },\n                { content: "Pin", callback: LGraphCanvas.onMenuNodePin },\n                {\n                    content: "Colors",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onMenuNodeColors\n                },\n                {\n                    content: "Shapes",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onMenuNodeShapes\n                },\n                null\n            );\n        }\n\n        if (node.onGetInputs) {\n            var inputs = node.onGetInputs();\n            if (inputs && inputs.length) {\n                options[0].disabled = false;\n            }\n        }\n\n        if (node.onGetOutputs) {\n            var outputs = node.onGetOutputs();\n            if (outputs && outputs.length) {\n                options[1].disabled = false;\n            }\n        }\n\n        if (node.getExtraMenuOptions) {\n            var extra = node.getExtraMenuOptions(this, options);\n            if (extra) {\n                extra.push(null);\n                options = extra.concat(options);\n            }\n        }\n\n        if (node.clonable !== false) {\n            options.push({\n                content: "Clone",\n                callback: LGraphCanvas.onMenuNodeClone\n            });\n        }\n\n\t\tif(false) //TODO\n\t\t{}\n\n        if (Object.keys(this.selected_nodes).length > 1) {\n            options.push({\n                content: "Align Selected To",\n                has_submenu: true,\n                callback: LGraphCanvas.onNodeAlign,\n            })\n        }\n\n\t\toptions.push(null, {\n\t\t\tcontent: "Remove",\n\t\t\tdisabled: !(node.removable !== false && !node.block_delete ),\n\t\t\tcallback: LGraphCanvas.onMenuNodeRemove\n\t\t});\n\n        if (node.graph && node.graph.onGetNodeMenuOptions) {\n            node.graph.onGetNodeMenuOptions(options, node);\n        }\n\n        return options;\n    };\n\n    LGraphCanvas.prototype.getGroupMenuOptions = function(node) {\n        var o = [\n            { content: "Title", callback: LGraphCanvas.onShowPropertyEditor },\n            {\n                content: "Color",\n                has_submenu: true,\n                callback: LGraphCanvas.onMenuNodeColors\n            },\n            {\n                content: "Font size",\n                property: "font_size",\n                type: "Number",\n                callback: LGraphCanvas.onShowPropertyEditor\n            },\n            null,\n            { content: "Remove", callback: LGraphCanvas.onMenuNodeRemove }\n        ];\n\n        return o;\n    };\n\n    LGraphCanvas.prototype.processContextMenu = function(node, event) {\n        var that = this;\n        var canvas = LGraphCanvas.active_canvas;\n        var ref_window = canvas.getCanvasWindow();\n\n        var menu_info = null;\n        var options = {\n            event: event,\n            callback: inner_option_clicked,\n            extra: node\n        };\n\n\t\tif(node)\n\t\t\toptions.title = node.type;\n\n        //check if mouse is in input\n        var slot = null;\n        if (node) {\n            slot = node.getSlotInPosition(event.canvasX, event.canvasY);\n            LGraphCanvas.active_node = node;\n        }\n\n        if (slot) {\n            //on slot\n            menu_info = [];\n            if (node.getSlotMenuOptions) {\n                menu_info = node.getSlotMenuOptions(slot);\n            } else {\n                if (\n                    slot &&\n                    slot.output &&\n                    slot.output.links &&\n                    slot.output.links.length\n                ) {\n                    menu_info.push({ content: "Disconnect Links", slot: slot });\n                }\n                var _slot = slot.input || slot.output;\n                if (_slot.removable){\n                \tmenu_info.push(\n\t                    _slot.locked\n\t                        ? "Cannot remove"\n\t                        : { content: "Remove Slot", slot: slot }\n\t                );\n            \t}\n                if (!_slot.nameLocked){\n\t                menu_info.push({ content: "Rename Slot", slot: slot });\n                }\n    \n            }\n            options.title =\n                (slot.input ? slot.input.type : slot.output.type) || "*";\n            if (slot.input && slot.input.type == LiteGraph.ACTION) {\n                options.title = "Action";\n            }\n            if (slot.output && slot.output.type == LiteGraph.EVENT) {\n                options.title = "Event";\n            }\n        } else {\n            if (node) {\n                //on node\n                menu_info = this.getNodeMenuOptions(node);\n            } else {\n                menu_info = this.getCanvasMenuOptions();\n                var group = this.graph.getGroupOnPos(\n                    event.canvasX,\n                    event.canvasY\n                );\n                if (group) {\n                    //on group\n                    menu_info.push(null, {\n                        content: "Edit Group",\n                        has_submenu: true,\n                        submenu: {\n                            title: "Group",\n                            extra: group,\n                            options: this.getGroupMenuOptions(group)\n                        }\n                    });\n                }\n            }\n        }\n\n        //show menu\n        if (!menu_info) {\n            return;\n        }\n\n        var menu = new LiteGraph.ContextMenu(menu_info, options, ref_window);\n\n        function inner_option_clicked(v, options, e) {\n            if (!v) {\n                return;\n            }\n\n            if (v.content == "Remove Slot") {\n                var info = v.slot;\n                node.graph.beforeChange();\n                if (info.input) {\n                    node.removeInput(info.slot);\n                } else if (info.output) {\n                    node.removeOutput(info.slot);\n                }\n                node.graph.afterChange();\n                return;\n            } else if (v.content == "Disconnect Links") {\n                var info = v.slot;\n                node.graph.beforeChange();\n                if (info.output) {\n                    node.disconnectOutput(info.slot);\n                } else if (info.input) {\n                    node.disconnectInput(info.slot);\n                }\n                node.graph.afterChange();\n                return;\n            } else if (v.content == "Rename Slot") {\n                var info = v.slot;\n                var slot_info = info.input\n                    ? node.getInputInfo(info.slot)\n                    : node.getOutputInfo(info.slot);\n                var dialog = that.createDialog(\n                    "<span class=\'name\'>Name</span><input autofocus type=\'text\'/><button>OK</button>",\n                    options\n                );\n                var input = dialog.querySelector("input");\n                if (input && slot_info) {\n                    input.value = slot_info.label || "";\n                }\n                var inner = function(){\n                \tnode.graph.beforeChange();\n                    if (input.value) {\n                        if (slot_info) {\n                            slot_info.label = input.value;\n                        }\n                        that.setDirty(true);\n                    }\n                    dialog.close();\n                    node.graph.afterChange();\n                }\n                dialog.querySelector("button").addEventListener("click", inner);\n                input.addEventListener("keydown", function(e) {\n                    dialog.is_modified = true;\n                    if (e.keyCode == 27) {\n                        //ESC\n                        dialog.close();\n                    } else if (e.keyCode == 13) {\n                        inner(); // save\n                    } else if (e.keyCode != 13 && e.target.localName != "textarea") {\n                        return;\n                    }\n                    e.preventDefault();\n                    e.stopPropagation();\n                });\n                input.focus();\n            }\n\n            //if(v.callback)\n            //\treturn v.callback.call(that, node, options, e, menu, that, event );\n        }\n    };\n\n    //API *************************************************\n    function compareObjects(a, b) {\n        for (var i in a) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    LiteGraph.compareObjects = compareObjects;\n\n    function distance(a, b) {\n        return Math.sqrt(\n            (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])\n        );\n    }\n    LiteGraph.distance = distance;\n\n    function colorToString(c) {\n        return (\n            "rgba(" +\n            Math.round(c[0] * 255).toFixed() +\n            "," +\n            Math.round(c[1] * 255).toFixed() +\n            "," +\n            Math.round(c[2] * 255).toFixed() +\n            "," +\n            (c.length == 4 ? c[3].toFixed(2) : "1.0") +\n            ")"\n        );\n    }\n    LiteGraph.colorToString = colorToString;\n\n    function isInsideRectangle(x, y, left, top, width, height) {\n        if (left < x && left + width > x && top < y && top + height > y) {\n            return true;\n        }\n        return false;\n    }\n    LiteGraph.isInsideRectangle = isInsideRectangle;\n\n    //[minx,miny,maxx,maxy]\n    function growBounding(bounding, x, y) {\n        if (x < bounding[0]) {\n            bounding[0] = x;\n        } else if (x > bounding[2]) {\n            bounding[2] = x;\n        }\n\n        if (y < bounding[1]) {\n            bounding[1] = y;\n        } else if (y > bounding[3]) {\n            bounding[3] = y;\n        }\n    }\n    LiteGraph.growBounding = growBounding;\n\n    //point inside bounding box\n    function isInsideBounding(p, bb) {\n        if (\n            p[0] < bb[0][0] ||\n            p[1] < bb[0][1] ||\n            p[0] > bb[1][0] ||\n            p[1] > bb[1][1]\n        ) {\n            return false;\n        }\n        return true;\n    }\n    LiteGraph.isInsideBounding = isInsideBounding;\n\n    //bounding overlap, format: [ startx, starty, width, height ]\n    function overlapBounding(a, b) {\n        var A_end_x = a[0] + a[2];\n        var A_end_y = a[1] + a[3];\n        var B_end_x = b[0] + b[2];\n        var B_end_y = b[1] + b[3];\n\n        if (\n            a[0] > B_end_x ||\n            a[1] > B_end_y ||\n            A_end_x < b[0] ||\n            A_end_y < b[1]\n        ) {\n            return false;\n        }\n        return true;\n    }\n    LiteGraph.overlapBounding = overlapBounding;\n\n    //Convert a hex value to its decimal value - the inputted hex must be in the\n    //\tformat of a hex triplet - the kind we use for HTML colours. The function\n    //\twill return an array with three values.\n    function hex2num(hex) {\n        if (hex.charAt(0) == "#") {\n            hex = hex.slice(1);\n        } //Remove the \'#\' char - if there is one.\n        hex = hex.toUpperCase();\n        var hex_alphabets = "0123456789ABCDEF";\n        var value = new Array(3);\n        var k = 0;\n        var int1, int2;\n        for (var i = 0; i < 6; i += 2) {\n            int1 = hex_alphabets.indexOf(hex.charAt(i));\n            int2 = hex_alphabets.indexOf(hex.charAt(i + 1));\n            value[k] = int1 * 16 + int2;\n            k++;\n        }\n        return value;\n    }\n\n    LiteGraph.hex2num = hex2num;\n\n    //Give a array with three values as the argument and the function will return\n    //\tthe corresponding hex triplet.\n    function num2hex(triplet) {\n        var hex_alphabets = "0123456789ABCDEF";\n        var hex = "#";\n        var int1, int2;\n        for (var i = 0; i < 3; i++) {\n            int1 = triplet[i] / 16;\n            int2 = triplet[i] % 16;\n\n            hex += hex_alphabets.charAt(int1) + hex_alphabets.charAt(int2);\n        }\n        return hex;\n    }\n\n    LiteGraph.num2hex = num2hex;\n\n    /* LiteGraph GUI elements used for canvas editing *************************************/\n\n    /**\n     * ContextMenu from LiteGUI\n     *\n     * @class ContextMenu\n     * @constructor\n     * @param {Array} values (allows object { title: "Nice text", callback: function ... })\n     * @param {Object} options [optional] Some options:\\\n     * - title: title to show on top of the menu\n     * - callback: function to call when an option is clicked, it receives the item information\n     * - ignore_item_callbacks: ignores the callback inside the item, it just calls the options.callback\n     * - event: you can pass a MouseEvent, this way the ContextMenu appears in that position\n     */\n    function ContextMenu(values, options) {\n        options = options || {};\n        this.options = options;\n        var that = this;\n\n        //to link a menu with its parent\n        if (options.parentMenu) {\n            if (options.parentMenu.constructor !== this.constructor) {\n                console.error(\n                    "parentMenu must be of class ContextMenu, ignoring it"\n                );\n                options.parentMenu = null;\n            } else {\n                this.parentMenu = options.parentMenu;\n                this.parentMenu.lock = true;\n                this.parentMenu.current_submenu = this;\n            }\n        }\n\n\t\tvar eventClass = null;\n\t\tif(options.event) //use strings because comparing classes between windows doesnt work\n\t\t\teventClass = options.event.constructor.name;\n        if ( eventClass !== "MouseEvent" &&\n            eventClass !== "CustomEvent" &&\n\t\t\teventClass !== "PointerEvent"\n        ) {\n            console.error(\n                "Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it. ("+eventClass+")"\n            );\n            options.event = null;\n        }\n\n        var root = document.createElement("div");\n        root.className = "litegraph litecontextmenu litemenubar-panel";\n        if (options.className) {\n            root.className += " " + options.className;\n        }\n        root.style.minWidth = 100;\n        root.style.minHeight = 100;\n        root.style.pointerEvents = "none";\n        setTimeout(function() {\n            root.style.pointerEvents = "auto";\n        }, 100); //delay so the mouse up event is not caught by this element\n\n        //this prevents the default context browser menu to open in case this menu was created when pressing right button\n\t\tLiteGraph.pointerListenerAdd(root,"up",\n            function(e) {\n\t\t\t  \t//console.log("pointerevents: ContextMenu up root prevent");\n                e.preventDefault();\n                return true;\n            },\n            true\n        );\n        root.addEventListener(\n            "contextmenu",\n            function(e) {\n                if (e.button != 2) {\n                    //right button\n                    return false;\n                }\n                e.preventDefault();\n                return false;\n            },\n            true\n        );\n\n        LiteGraph.pointerListenerAdd(root,"down",\n            function(e) {\n\t\t\t  \t//console.log("pointerevents: ContextMenu down");\n                if (e.button == 2) {\n                    that.close();\n                    e.preventDefault();\n                    return true;\n                }\n            },\n            true\n        );\n\n        function on_mouse_wheel(e) {\n            var pos = parseInt(root.style.top);\n            root.style.top =\n                (pos + e.deltaY * options.scroll_speed).toFixed() + "px";\n            e.preventDefault();\n            return true;\n        }\n\n        if (!options.scroll_speed) {\n            options.scroll_speed = 0.1;\n        }\n\n        root.addEventListener("wheel", on_mouse_wheel, true);\n        root.addEventListener("mousewheel", on_mouse_wheel, true);\n\n        this.root = root;\n\n        //title\n        if (options.title) {\n            var element = document.createElement("div");\n            element.className = "litemenu-title";\n            element.innerHTML = options.title;\n            root.appendChild(element);\n        }\n\n        //entries\n        var num = 0;\n        for (var i=0; i < values.length; i++) {\n            var name = values.constructor == Array ? values[i] : i;\n            if (name != null && name.constructor !== String) {\n                name = name.content === undefined ? String(name) : name.content;\n            }\n            var value = values[i];\n            this.addItem(name, value, options);\n            num++;\n        }\n\n        //close on leave? touch enabled devices won\'t work TODO use a global device detector and condition on that\n        /*LiteGraph.pointerListenerAdd(root,"leave", function(e) {\n\t\t  \tconsole.log("pointerevents: ContextMenu leave");\n            if (that.lock) {\n                return;\n            }\n            if (root.closing_timer) {\n                clearTimeout(root.closing_timer);\n            }\n            root.closing_timer = setTimeout(that.close.bind(that, e), 500);\n            //that.close(e);\n        });*/\n\n\t\tLiteGraph.pointerListenerAdd(root,"enter", function(e) {\n\t\t  \t//console.log("pointerevents: ContextMenu enter");\n            if (root.closing_timer) {\n                clearTimeout(root.closing_timer);\n            }\n        });\n\n        //insert before checking position\n        var root_document = document;\n        if (options.event) {\n            root_document = options.event.target.ownerDocument;\n        }\n\n        if (!root_document) {\n            root_document = document;\n        }\n\n\t\tif( root_document.fullscreenElement )\n\t        root_document.fullscreenElement.appendChild(root);\n\t\telse\n\t\t    root_document.body.appendChild(root);\n\n        //compute best position\n        var left = options.left || 0;\n        var top = options.top || 0;\n        if (options.event) {\n            left = options.event.clientX - 10;\n            top = options.event.clientY - 10;\n            if (options.title) {\n                top -= 20;\n            }\n\n            if (options.parentMenu) {\n                var rect = options.parentMenu.root.getBoundingClientRect();\n                left = rect.left + rect.width;\n            }\n\n            var body_rect = document.body.getBoundingClientRect();\n            var root_rect = root.getBoundingClientRect();\n\t\t\tif(body_rect.height == 0)\n\t\t\t\tconsole.error("document.body height is 0. That is dangerous, set html,body { height: 100%; }");\n\n            if (body_rect.width && left > body_rect.width - root_rect.width - 10) {\n                left = body_rect.width - root_rect.width - 10;\n            }\n            if (body_rect.height && top > body_rect.height - root_rect.height - 10) {\n                top = body_rect.height - root_rect.height - 10;\n            }\n        }\n\n        root.style.left = left + "px";\n        root.style.top = top + "px";\n\n        if (options.scale) {\n            root.style.transform = "scale(" + options.scale + ")";\n        }\n    }\n\n    ContextMenu.prototype.addItem = function(name, value, options) {\n        var that = this;\n        options = options || {};\n\n        var element = document.createElement("div");\n        element.className = "litemenu-entry submenu";\n\n        var disabled = false;\n\n        if (value === null) {\n            element.classList.add("separator");\n            //element.innerHTML = "<hr/>"\n            //continue;\n        } else {\n            element.innerHTML = value && value.title ? value.title : name;\n            element.value = value;\n\n            if (value) {\n                if (value.disabled) {\n                    disabled = true;\n                    element.classList.add("disabled");\n                }\n                if (value.submenu || value.has_submenu) {\n                    element.classList.add("has_submenu");\n                }\n            }\n\n            if (typeof value == "function") {\n                element.dataset["value"] = name;\n                element.onclick_callback = value;\n            } else {\n                element.dataset["value"] = value;\n            }\n\n            if (value.className) {\n                element.className += " " + value.className;\n            }\n        }\n\n        this.root.appendChild(element);\n        if (!disabled) {\n            element.addEventListener("click", inner_onclick);\n        }\n        if (!disabled && options.autoopen) {\n\t\t\tLiteGraph.pointerListenerAdd(element,"enter",inner_over);\n        }\n\n        function inner_over(e) {\n            var value = this.value;\n            if (!value || !value.has_submenu) {\n                return;\n            }\n            //if it is a submenu, autoopen like the item was clicked\n            inner_onclick.call(this, e);\n        }\n\n        //menu option clicked\n        function inner_onclick(e) {\n            var value = this.value;\n            var close_parent = true;\n\n            if (that.current_submenu) {\n                that.current_submenu.close(e);\n            }\n\n            //global callback\n            if (options.callback) {\n                var r = options.callback.call(\n                    this,\n                    value,\n                    options,\n                    e,\n                    that,\n                    options.node\n                );\n                if (r === true) {\n                    close_parent = false;\n                }\n            }\n\n            //special cases\n            if (value) {\n                if (\n                    value.callback &&\n                    !options.ignore_item_callbacks &&\n                    value.disabled !== true\n                ) {\n                    //item callback\n                    var r = value.callback.call(\n                        this,\n                        value,\n                        options,\n                        e,\n                        that,\n                        options.extra\n                    );\n                    if (r === true) {\n                        close_parent = false;\n                    }\n                }\n                if (value.submenu) {\n                    if (!value.submenu.options) {\n                        throw "ContextMenu submenu needs options";\n                    }\n                    var submenu = new that.constructor(value.submenu.options, {\n                        callback: value.submenu.callback,\n                        event: e,\n                        parentMenu: that,\n                        ignore_item_callbacks:\n                            value.submenu.ignore_item_callbacks,\n                        title: value.submenu.title,\n                        extra: value.submenu.extra,\n                        autoopen: options.autoopen\n                    });\n                    close_parent = false;\n                }\n            }\n\n            if (close_parent && !that.lock) {\n                that.close();\n            }\n        }\n\n        return element;\n    };\n\n    ContextMenu.prototype.close = function(e, ignore_parent_menu) {\n        if (this.root.parentNode) {\n            this.root.parentNode.removeChild(this.root);\n        }\n        if (this.parentMenu && !ignore_parent_menu) {\n            this.parentMenu.lock = false;\n            this.parentMenu.current_submenu = null;\n            if (e === undefined) {\n                this.parentMenu.close();\n            } else if (\n                e &&\n                !ContextMenu.isCursorOverElement(e, this.parentMenu.root)\n            ) {\n                ContextMenu.trigger(this.parentMenu.root, LiteGraph.pointerevents_method+"leave", e);\n            }\n        }\n        if (this.current_submenu) {\n            this.current_submenu.close(e, true);\n        }\n\n        if (this.root.closing_timer) {\n            clearTimeout(this.root.closing_timer);\n        }\n        \n        // TODO implement : LiteGraph.contextMenuClosed(); :: keep track of opened / closed / current ContextMenu\n        // on key press, allow filtering/selecting the context menu elements\n    };\n\n    //this code is used to trigger events easily (used in the context menu mouseleave\n    ContextMenu.trigger = function(element, event_name, params, origin) {\n        var evt = document.createEvent("CustomEvent");\n        evt.initCustomEvent(event_name, true, true, params); //canBubble, cancelable, detail\n        evt.srcElement = origin;\n        if (element.dispatchEvent) {\n            element.dispatchEvent(evt);\n        } else if (element.__events) {\n            element.__events.dispatchEvent(evt);\n        }\n        //else nothing seems binded here so nothing to do\n        return evt;\n    };\n\n    //returns the top most menu\n    ContextMenu.prototype.getTopMenu = function() {\n        if (this.options.parentMenu) {\n            return this.options.parentMenu.getTopMenu();\n        }\n        return this;\n    };\n\n    ContextMenu.prototype.getFirstEvent = function() {\n        if (this.options.parentMenu) {\n            return this.options.parentMenu.getFirstEvent();\n        }\n        return this.options.event;\n    };\n\n    ContextMenu.isCursorOverElement = function(event, element) {\n        var left = event.clientX;\n        var top = event.clientY;\n        var rect = element.getBoundingClientRect();\n        if (!rect) {\n            return false;\n        }\n        if (\n            top > rect.top &&\n            top < rect.top + rect.height &&\n            left > rect.left &&\n            left < rect.left + rect.width\n        ) {\n            return true;\n        }\n        return false;\n    };\n\n    LiteGraph.ContextMenu = ContextMenu;\n\n    LiteGraph.closeAllContextMenus = function(ref_window) {\n        ref_window = ref_window || window;\n\n        var elements = ref_window.document.querySelectorAll(".litecontextmenu");\n        if (!elements.length) {\n            return;\n        }\n\n        var result = [];\n        for (var i = 0; i < elements.length; i++) {\n            result.push(elements[i]);\n        }\n\n        for (var i=0; i < result.length; i++) {\n            if (result[i].close) {\n                result[i].close();\n            } else if (result[i].parentNode) {\n                result[i].parentNode.removeChild(result[i]);\n            }\n        }\n    };\n\n    LiteGraph.extendClass = function(target, origin) {\n        for (var i in origin) {\n            //copy class properties\n            if (target.hasOwnProperty(i)) {\n                continue;\n            }\n            target[i] = origin[i];\n        }\n\n        if (origin.prototype) {\n            //copy prototype properties\n            for (var i in origin.prototype) {\n                //only enumerable\n                if (!origin.prototype.hasOwnProperty(i)) {\n                    continue;\n                }\n\n                if (target.prototype.hasOwnProperty(i)) {\n                    //avoid overwriting existing ones\n                    continue;\n                }\n\n                //copy getters\n                if (origin.prototype.__lookupGetter__(i)) {\n                    target.prototype.__defineGetter__(\n                        i,\n                        origin.prototype.__lookupGetter__(i)\n                    );\n                } else {\n                    target.prototype[i] = origin.prototype[i];\n                }\n\n                //and setters\n                if (origin.prototype.__lookupSetter__(i)) {\n                    target.prototype.__defineSetter__(\n                        i,\n                        origin.prototype.__lookupSetter__(i)\n                    );\n                }\n            }\n        }\n    };\n\n\t//used by some widgets to render a curve editor\n\tfunction CurveEditor( points )\n\t{\n\t\tthis.points = points;\n\t\tthis.selected = -1;\n\t\tthis.nearest = -1;\n\t\tthis.size = null; //stores last size used\n\t\tthis.must_update = true;\n\t\tthis.margin = 5;\n\t}\n\n\tCurveEditor.sampleCurve = function(f,points)\n\t{\n\t\tif(!points)\n\t\t\treturn;\n\t\tfor(var i = 0; i < points.length - 1; ++i)\n\t\t{\n\t\t\tvar p = points[i];\n\t\t\tvar pn = points[i+1];\n\t\t\tif(pn[0] < f)\n\t\t\t\tcontinue;\n\t\t\tvar r = (pn[0] - p[0]);\n\t\t\tif( Math.abs(r) < 0.00001 )\n\t\t\t\treturn p[1];\n\t\t\tvar local_f = (f - p[0]) / r;\n\t\t\treturn p[1] * (1.0 - local_f) + pn[1] * local_f;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tCurveEditor.prototype.draw = function( ctx, size, graphcanvas, background_color, line_color, inactive )\n\t{\n\t\tvar points = this.points;\n\t\tif(!points)\n\t\t\treturn;\n\t\tthis.size = size;\n\t\tvar w = size[0] - this.margin * 2;\n\t\tvar h = size[1] - this.margin * 2;\n\n\t\tline_color = line_color || "#666";\n\n\t\tctx.save();\n\t\tctx.translate(this.margin,this.margin);\n\n\t\tif(background_color)\n\t\t{\n\t\t\tctx.fillStyle = "#111";\n\t\t\tctx.fillRect(0,0,w,h);\n\t\t\tctx.fillStyle = "#222";\n\t\t\tctx.fillRect(w*0.5,0,1,h);\n\t\t\tctx.strokeStyle = "#333";\n\t\t\tctx.strokeRect(0,0,w,h);\n\t\t}\n\t\tctx.strokeStyle = line_color;\n\t\tif(inactive)\n\t\t\tctx.globalAlpha = 0.5;\n\t\tctx.beginPath();\n\t\tfor(var i = 0; i < points.length; ++i)\n\t\t{\n\t\t\tvar p = points[i];\n\t\t\tctx.lineTo( p[0] * w, (1.0 - p[1]) * h );\n\t\t}\n\t\tctx.stroke();\n\t\tctx.globalAlpha = 1;\n\t\tif(!inactive)\n\t\t\tfor(var i = 0; i < points.length; ++i)\n\t\t\t{\n\t\t\t\tvar p = points[i];\n\t\t\t\tctx.fillStyle = this.selected == i ? "#FFF" : (this.nearest == i ? "#DDD" : "#AAA");\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc( p[0] * w, (1.0 - p[1]) * h, 2, 0, Math.PI * 2 );\n\t\t\t\tctx.fill();\n\t\t\t}\n\t\tctx.restore();\n\t}\n\n\t//localpos is mouse in curve editor space\n\tCurveEditor.prototype.onMouseDown = function( localpos, graphcanvas )\n\t{\n\t\tvar points = this.points;\n\t\tif(!points)\n\t\t\treturn;\n\t\tif( localpos[1] < 0 )\n\t\t\treturn;\n\n\t\t//this.captureInput(true);\n\t\tvar w = this.size[0] - this.margin * 2;\n\t\tvar h = this.size[1] - this.margin * 2;\n\t\tvar x = localpos[0] - this.margin;\n\t\tvar y = localpos[1] - this.margin;\n\t\tvar pos = [x,y];\n\t\tvar max_dist = 30 / graphcanvas.ds.scale;\n\t\t//search closer one\n\t\tthis.selected = this.getCloserPoint(pos, max_dist);\n\t\t//create one\n\t\tif(this.selected == -1)\n\t\t{\n\t\t\tvar point = [x / w, 1 - y / h];\n\t\t\tpoints.push(point);\n\t\t\tpoints.sort(function(a,b){ return a[0] - b[0]; });\n\t\t\tthis.selected = points.indexOf(point);\n\t\t\tthis.must_update = true;\n\t\t}\n\t\tif(this.selected != -1)\n\t\t\treturn true;\n\t}\n\n\tCurveEditor.prototype.onMouseMove = function( localpos, graphcanvas )\n\t{\n\t\tvar points = this.points;\n\t\tif(!points)\n\t\t\treturn;\n\t\tvar s = this.selected;\n\t\tif(s < 0)\n\t\t\treturn;\n\t\tvar x = (localpos[0] - this.margin) / (this.size[0] - this.margin * 2 );\n\t\tvar y = (localpos[1] - this.margin) / (this.size[1] - this.margin * 2 );\n\t\tvar curvepos = [(localpos[0] - this.margin),(localpos[1] - this.margin)];\n\t\tvar max_dist = 30 / graphcanvas.ds.scale;\n\t\tthis._nearest = this.getCloserPoint(curvepos, max_dist);\n\t\tvar point = points[s];\n\t\tif(point)\n\t\t{\n\t\t\tvar is_edge_point = s == 0 || s == points.length - 1;\n\t\t\tif( !is_edge_point && (localpos[0] < -10 || localpos[0] > this.size[0] + 10 || localpos[1] < -10 || localpos[1] > this.size[1] + 10) )\n\t\t\t{\n\t\t\t\tpoints.splice(s,1);\n\t\t\t\tthis.selected = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif( !is_edge_point ) //not edges\n\t\t\t\tpoint[0] = clamp(x, 0, 1);\n\t\t\telse\n\t\t\t\tpoint[0] = s == 0 ? 0 : 1;\n\t\t\tpoint[1] = 1.0 - clamp(y, 0, 1);\n\t\t\tpoints.sort(function(a,b){ return a[0] - b[0]; });\n\t\t\tthis.selected = points.indexOf(point);\n\t\t\tthis.must_update = true;\n\t\t}\n\t}\n\n\tCurveEditor.prototype.onMouseUp = function( localpos, graphcanvas )\n\t{\n\t\tthis.selected = -1;\n\t\treturn false;\n\t}\n\n\tCurveEditor.prototype.getCloserPoint = function(pos, max_dist)\n\t{\n\t\tvar points = this.points;\n\t\tif(!points)\n\t\t\treturn -1;\n\t\tmax_dist = max_dist || 30;\n\t\tvar w = (this.size[0] - this.margin * 2);\n\t\tvar h = (this.size[1] - this.margin * 2);\n\t\tvar num = points.length;\n\t\tvar p2 = [0,0];\n\t\tvar min_dist = 1000000;\n\t\tvar closest = -1;\n\t\tvar last_valid = -1;\n\t\tfor(var i = 0; i < num; ++i)\n\t\t{\n\t\t\tvar p = points[i];\n\t\t\tp2[0] = p[0] * w;\n\t\t\tp2[1] = (1.0 - p[1]) * h;\n\t\t\tif(p2[0] < pos[0])\n\t\t\t\tlast_valid = i;\n\t\t\tvar dist = vec2.distance(pos,p2);\n\t\t\tif(dist > min_dist || dist > max_dist)\n\t\t\t\tcontinue;\n\t\t\tclosest = i;\n\t\t\tmin_dist = dist;\n\t\t}\n\t\treturn closest;\n\t}\n\n\tLiteGraph.CurveEditor = CurveEditor;\n\n    //used to create nodes from wrapping functions\n    LiteGraph.getParameterNames = function(func) {\n        return (func + "")\n            .replace(/[/][/].*$/gm, "") // strip single-line comments\n            .replace(/\\s+/g, "") // strip white space\n            .replace(/[/][*][^/*]*[*][/]/g, "") // strip multi-line comments  /**/\n            .split("){", 1)[0]\n            .replace(/^[^(]*[(]/, "") // extract the parameters\n            .replace(/=[^,]+/g, "") // strip any ES6 defaults\n            .split(",")\n            .filter(Boolean); // split & filter [""]\n    };\n\n\t/* helper for interaction: pointer, touch, mouse Listeners\n\tused by LGraphCanvas DragAndScale ContextMenu*/\n\tLiteGraph.pointerListenerAdd = function(oDOM, sEvIn, fCall, capture=false) {\n\t\tif (!oDOM || !oDOM.addEventListener || !sEvIn || typeof fCall!=="function"){\n\t\t\t//console.log("cant pointerListenerAdd "+oDOM+", "+sEvent+", "+fCall);\n\t\t\treturn; // -- break --\n\t\t}\n\t\t\n\t\tvar sMethod = LiteGraph.pointerevents_method;\n\t\tvar sEvent = sEvIn;\n\t\t\n\t\t// UNDER CONSTRUCTION\n\t\t// convert pointerevents to touch event when not available\n\t\tif (sMethod=="pointer" && !window.PointerEvent){ \n\t\t\tconsole.warn("sMethod==\'pointer\' && !window.PointerEvent");\n\t\t\tconsole.log("Converting pointer["+sEvent+"] : down move up cancel enter TO touchstart touchmove touchend, etc ..");\n\t\t\tswitch(sEvent){\n\t\t\t\tcase "down":{\n\t\t\t\t\tsMethod = "touch";\n\t\t\t\t\tsEvent = "start";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase "move":{\n\t\t\t\t\tsMethod = "touch";\n\t\t\t\t\t//sEvent = "move";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase "up":{\n\t\t\t\t\tsMethod = "touch";\n\t\t\t\t\tsEvent = "end";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase "cancel":{\n\t\t\t\t\tsMethod = "touch";\n\t\t\t\t\t//sEvent = "cancel";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase "enter":{\n\t\t\t\t\tconsole.log("debug: Should I send a move event?"); // ???\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// case "over": case "out": not used at now\n\t\t\t\tdefault:{\n\t\t\t\t\tconsole.warn("PointerEvent not available in this browser ? The event "+sEvent+" would not be called");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch(sEvent){\n\t\t\t//both pointer and move events\n\t\t\tcase "down": case "up": case "move": case "over": case "out": case "enter":\n\t\t\t{\n\t\t\t\toDOM.addEventListener(sMethod+sEvent, fCall, capture);\n\t\t\t}\n\t\t\t// only pointerevents\n\t\t\tcase "leave": case "cancel": case "gotpointercapture": case "lostpointercapture":\n\t\t\t{\n\t\t\t\tif (sMethod!="mouse"){\n\t\t\t\t\treturn oDOM.addEventListener(sMethod+sEvent, fCall, capture);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// not "pointer" || "mouse"\n\t\t\tdefault:\n\t\t\t\treturn oDOM.addEventListener(sEvent, fCall, capture);\n\t\t}\n\t}\n\tLiteGraph.pointerListenerRemove = function(oDOM, sEvent, fCall, capture=false) {\n\t\tif (!oDOM || !oDOM.removeEventListener || !sEvent || typeof fCall!=="function"){\n\t\t\t//console.log("cant pointerListenerRemove "+oDOM+", "+sEvent+", "+fCall);\n\t\t\treturn; // -- break --\n\t\t}\n\t\tswitch(sEvent){\n\t\t\t//both pointer and move events\n\t\t\tcase "down": case "up": case "move": case "over": case "out": case "enter":\n\t\t\t{\n\t\t\t\tif (LiteGraph.pointerevents_method=="pointer" || LiteGraph.pointerevents_method=="mouse"){\n\t\t\t\t\toDOM.removeEventListener(LiteGraph.pointerevents_method+sEvent, fCall, capture);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// only pointerevents\n\t\t\tcase "leave": case "cancel": case "gotpointercapture": case "lostpointercapture":\n\t\t\t{\n\t\t\t\tif (LiteGraph.pointerevents_method=="pointer"){\n\t\t\t\t\treturn oDOM.removeEventListener(LiteGraph.pointerevents_method+sEvent, fCall, capture);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// not "pointer" || "mouse"\n\t\t\tdefault:\n\t\t\t\treturn oDOM.removeEventListener(sEvent, fCall, capture);\n\t\t}\n\t}\n\n    function clamp(v, a, b) {\n        return a > v ? a : b < v ? b : v;\n    };\n    global.clamp = clamp;\n\n    if (typeof window != "undefined" && !window["requestAnimationFrame"]) {\n        window.requestAnimationFrame =\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            function(callback) {\n                window.setTimeout(callback, 1000 / 60);\n            };\n    }\n})(this);\n\nif (true) {\n    exports.LiteGraph = this.LiteGraph;\n    exports.LGraph = this.LGraph;\n    exports.LLink = this.LLink;\n    exports.LGraphNode = this.LGraphNode;\n    exports.LGraphGroup = this.LGraphGroup;\n    exports.DragAndScale = this.DragAndScale;\n    exports.LGraphCanvas = this.LGraphCanvas;\n    exports.ContextMenu = this.ContextMenu;\n}\n\n\n//basic nodes\r\n(function(global) {\r\n    var LiteGraph = global.LiteGraph;\r\n\r\n    //Constant\r\n    function Time() {\r\n        this.addOutput("in ms", "number");\r\n        this.addOutput("in sec", "number");\r\n    }\r\n\r\n    Time.title = "Time";\r\n    Time.desc = "Time";\r\n\r\n    Time.prototype.onExecute = function() {\r\n        this.setOutputData(0, this.graph.globaltime * 1000);\r\n        this.setOutputData(1, this.graph.globaltime);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("basic/time", Time);\r\n\r\n    //Subgraph: a node that contains a graph\r\n    function Subgraph() {\r\n        var that = this;\r\n        this.size = [140, 80];\r\n        this.properties = { enabled: true };\r\n        this.enabled = true;\r\n\r\n        //create inner graph\r\n        this.subgraph = new LiteGraph.LGraph();\r\n        this.subgraph._subgraph_node = this;\r\n        this.subgraph._is_subgraph = true;\r\n\r\n        this.subgraph.onTrigger = this.onSubgraphTrigger.bind(this);\r\n\r\n\t\t//nodes input node added inside\r\n        this.subgraph.onInputAdded = this.onSubgraphNewInput.bind(this);\r\n        this.subgraph.onInputRenamed = this.onSubgraphRenamedInput.bind(this);\r\n        this.subgraph.onInputTypeChanged = this.onSubgraphTypeChangeInput.bind(this);\r\n        this.subgraph.onInputRemoved = this.onSubgraphRemovedInput.bind(this);\r\n\r\n        this.subgraph.onOutputAdded = this.onSubgraphNewOutput.bind(this);\r\n        this.subgraph.onOutputRenamed = this.onSubgraphRenamedOutput.bind(this);\r\n        this.subgraph.onOutputTypeChanged = this.onSubgraphTypeChangeOutput.bind(this);\r\n        this.subgraph.onOutputRemoved = this.onSubgraphRemovedOutput.bind(this);\r\n    }\r\n\r\n    Subgraph.title = "Subgraph";\r\n    Subgraph.desc = "Graph inside a node";\r\n    Subgraph.title_color = "#334";\r\n\r\n    Subgraph.prototype.onGetInputs = function() {\r\n        return [["enabled", "boolean"]];\r\n    };\r\n\r\n\t/*\r\n    Subgraph.prototype.onDrawTitle = function(ctx) {\r\n        if (this.flags.collapsed) {\r\n            return;\r\n        }\r\n\r\n        ctx.fillStyle = "#555";\r\n        var w = LiteGraph.NODE_TITLE_HEIGHT;\r\n        var x = this.size[0] - w;\r\n        ctx.fillRect(x, -w, w, w);\r\n        ctx.fillStyle = "#333";\r\n        ctx.beginPath();\r\n        ctx.moveTo(x + w * 0.2, -w * 0.6);\r\n        ctx.lineTo(x + w * 0.8, -w * 0.6);\r\n        ctx.lineTo(x + w * 0.5, -w * 0.3);\r\n        ctx.fill();\r\n    };\r\n\t*/\r\n\r\n    Subgraph.prototype.onDblClick = function(e, pos, graphcanvas) {\r\n        var that = this;\r\n        setTimeout(function() {\r\n            graphcanvas.openSubgraph(that.subgraph);\r\n        }, 10);\r\n    };\r\n\r\n\t/*\r\n    Subgraph.prototype.onMouseDown = function(e, pos, graphcanvas) {\r\n        if (\r\n            !this.flags.collapsed &&\r\n            pos[0] > this.size[0] - LiteGraph.NODE_TITLE_HEIGHT &&\r\n            pos[1] < 0\r\n        ) {\r\n            var that = this;\r\n            setTimeout(function() {\r\n                graphcanvas.openSubgraph(that.subgraph);\r\n            }, 10);\r\n        }\r\n    };\r\n\t*/\r\n\r\n    Subgraph.prototype.onAction = function(action, param) {\r\n        this.subgraph.onAction(action, param);\r\n    };\r\n\r\n    Subgraph.prototype.onExecute = function() {\r\n        this.enabled = this.getInputOrProperty("enabled");\r\n        if (!this.enabled) {\r\n            return;\r\n        }\r\n\r\n        //send inputs to subgraph global inputs\r\n        if (this.inputs) {\r\n            for (var i = 0; i < this.inputs.length; i++) {\r\n                var input = this.inputs[i];\r\n                var value = this.getInputData(i);\r\n                this.subgraph.setInputData(input.name, value);\r\n            }\r\n        }\r\n\r\n        //execute\r\n        this.subgraph.runStep();\r\n\r\n        //send subgraph global outputs to outputs\r\n        if (this.outputs) {\r\n            for (var i = 0; i < this.outputs.length; i++) {\r\n                var output = this.outputs[i];\r\n                var value = this.subgraph.getOutputData(output.name);\r\n                this.setOutputData(i, value);\r\n            }\r\n        }\r\n    };\r\n\r\n    Subgraph.prototype.sendEventToAllNodes = function(eventname, param, mode) {\r\n        if (this.enabled) {\r\n            this.subgraph.sendEventToAllNodes(eventname, param, mode);\r\n        }\r\n    };\r\n\r\n    Subgraph.prototype.onDrawBackground = function (ctx, graphcanvas, canvas, pos) {\r\n        if (this.flags.collapsed)\r\n            return;\r\n        var y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;\r\n        // button\r\n        var over = LiteGraph.isInsideRectangle(pos[0], pos[1], this.pos[0], this.pos[1] + y, this.size[0], LiteGraph.NODE_TITLE_HEIGHT);\r\n        let overleft = LiteGraph.isInsideRectangle(pos[0], pos[1], this.pos[0], this.pos[1] + y, this.size[0] / 2, LiteGraph.NODE_TITLE_HEIGHT)\r\n        ctx.fillStyle = over ? "#555" : "#222";\r\n        ctx.beginPath();\r\n        if (this._shape == LiteGraph.BOX_SHAPE) {\r\n            if (overleft) {\r\n                ctx.rect(0, y, this.size[0] / 2 + 1, LiteGraph.NODE_TITLE_HEIGHT);\r\n            } else {\r\n                ctx.rect(this.size[0] / 2, y, this.size[0] / 2 + 1, LiteGraph.NODE_TITLE_HEIGHT);\r\n            }\r\n        }\r\n        else {\r\n            if (overleft) {\r\n                ctx.roundRect(0, y, this.size[0] / 2 + 1, LiteGraph.NODE_TITLE_HEIGHT, [0,0, 8,8]);\r\n            } else {\r\n                ctx.roundRect(this.size[0] / 2, y, this.size[0] / 2 + 1, LiteGraph.NODE_TITLE_HEIGHT, [0,0, 8,8]);\r\n            }\r\n        }\r\n        if (over) {\r\n            ctx.fill();\r\n        } else {\r\n            ctx.fillRect(0, y, this.size[0] + 1, LiteGraph.NODE_TITLE_HEIGHT);\r\n        }\r\n        // button\r\n        ctx.textAlign = "center";\r\n        ctx.font = "24px Arial";\r\n        ctx.fillStyle = over ? "#DDD" : "#999";\r\n        ctx.fillText("+", this.size[0] * 0.25, y + 24);\r\n        ctx.fillText("+", this.size[0] * 0.75, y + 24);\r\n    }\r\n\r\n    // Subgraph.prototype.onMouseDown = function(e, localpos, graphcanvas)\r\n    // {\r\n    // \tvar y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;\r\n    // \tif(localpos[1] > y)\r\n    // \t{\r\n    // \t\tgraphcanvas.showSubgraphPropertiesDialog(this);\r\n    // \t}\r\n    // }\r\n    Subgraph.prototype.onMouseDown = function (e, localpos, graphcanvas) {\r\n        var y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;\r\n        console.log(0)\r\n        if (localpos[1] > y) {\r\n            if (localpos[0] < this.size[0] / 2) {\r\n                console.log(1)\r\n                graphcanvas.showSubgraphPropertiesDialog(this);\r\n            } else {\r\n                console.log(2)\r\n                graphcanvas.showSubgraphPropertiesDialogRight(this);\r\n            }\r\n        }\r\n    }\r\n\tSubgraph.prototype.computeSize = function()\r\n\t{\r\n\t\tvar num_inputs = this.inputs ? this.inputs.length : 0;\r\n\t\tvar num_outputs = this.outputs ? this.outputs.length : 0;\r\n\t\treturn [ 200, Math.max(num_inputs,num_outputs) * LiteGraph.NODE_SLOT_HEIGHT + LiteGraph.NODE_TITLE_HEIGHT ];\r\n\t}\r\n\r\n    //**** INPUTS ***********************************\r\n    Subgraph.prototype.onSubgraphTrigger = function(event, param) {\r\n        var slot = this.findOutputSlot(event);\r\n        if (slot != -1) {\r\n            this.triggerSlot(slot);\r\n        }\r\n    };\r\n\r\n    Subgraph.prototype.onSubgraphNewInput = function(name, type) {\r\n        var slot = this.findInputSlot(name);\r\n        if (slot == -1) {\r\n            //add input to the node\r\n            this.addInput(name, type);\r\n        }\r\n    };\r\n\r\n    Subgraph.prototype.onSubgraphRenamedInput = function(oldname, name) {\r\n        var slot = this.findInputSlot(oldname);\r\n        if (slot == -1) {\r\n            return;\r\n        }\r\n        var info = this.getInputInfo(slot);\r\n        info.name = name;\r\n    };\r\n\r\n    Subgraph.prototype.onSubgraphTypeChangeInput = function(name, type) {\r\n        var slot = this.findInputSlot(name);\r\n        if (slot == -1) {\r\n            return;\r\n        }\r\n        var info = this.getInputInfo(slot);\r\n        info.type = type;\r\n    };\r\n\r\n    Subgraph.prototype.onSubgraphRemovedInput = function(name) {\r\n        var slot = this.findInputSlot(name);\r\n        if (slot == -1) {\r\n            return;\r\n        }\r\n        this.removeInput(slot);\r\n    };\r\n\r\n    //**** OUTPUTS ***********************************\r\n    Subgraph.prototype.onSubgraphNewOutput = function(name, type) {\r\n        var slot = this.findOutputSlot(name);\r\n        if (slot == -1) {\r\n            this.addOutput(name, type);\r\n        }\r\n    };\r\n\r\n    Subgraph.prototype.onSubgraphRenamedOutput = function(oldname, name) {\r\n        var slot = this.findOutputSlot(oldname);\r\n        if (slot == -1) {\r\n            return;\r\n        }\r\n        var info = this.getOutputInfo(slot);\r\n        info.name = name;\r\n    };\r\n\r\n    Subgraph.prototype.onSubgraphTypeChangeOutput = function(name, type) {\r\n        var slot = this.findOutputSlot(name);\r\n        if (slot == -1) {\r\n            return;\r\n        }\r\n        var info = this.getOutputInfo(slot);\r\n        info.type = type;\r\n    };\r\n\r\n    Subgraph.prototype.onSubgraphRemovedOutput = function(name) {\r\n        var slot = this.findOutputSlot(name);\r\n        if (slot == -1) {\r\n            return;\r\n        }\r\n        this.removeOutput(slot);\r\n    };\r\n    // *****************************************************\r\n\r\n    Subgraph.prototype.getExtraMenuOptions = function(graphcanvas) {\r\n        var that = this;\r\n        return [\r\n            {\r\n                content: "Open",\r\n                callback: function() {\r\n                    graphcanvas.openSubgraph(that.subgraph);\r\n                }\r\n            }\r\n        ];\r\n    };\r\n\r\n    Subgraph.prototype.onResize = function(size) {\r\n        size[1] += 20;\r\n    };\r\n\r\n    Subgraph.prototype.serialize = function() {\r\n        var data = LiteGraph.LGraphNode.prototype.serialize.call(this);\r\n        data.subgraph = this.subgraph.serialize();\r\n        return data;\r\n    };\r\n    //no need to define node.configure, the default method detects node.subgraph and passes the object to node.subgraph.configure()\r\n\r\n    Subgraph.prototype.reassignSubgraphUUIDs = function(graph) {\r\n        const idMap = { nodeIDs: {}, linkIDs: {} }\r\n\r\n        for (const node of graph.nodes) {\r\n            const oldID = node.id\r\n            const newID = LiteGraph.uuidv4()\r\n            node.id = newID\r\n\r\n            if (idMap.nodeIDs[oldID] || idMap.nodeIDs[newID]) {\r\n                throw new Error(`New/old node UUID wasn\'t unique in changed map! ${oldID} ${newID}`)\r\n            }\r\n\r\n            idMap.nodeIDs[oldID] = newID\r\n            idMap.nodeIDs[newID] = oldID\r\n        }\r\n\r\n        for (const link of graph.links) {\r\n            const oldID = link[0]\r\n            const newID = LiteGraph.uuidv4();\r\n            link[0] = newID\r\n\r\n            if (idMap.linkIDs[oldID] || idMap.linkIDs[newID]) {\r\n                throw new Error(`New/old link UUID wasn\'t unique in changed map! ${oldID} ${newID}`)\r\n            }\r\n\r\n            idMap.linkIDs[oldID] = newID\r\n            idMap.linkIDs[newID] = oldID\r\n\r\n            const nodeFrom = link[1]\r\n            const nodeTo = link[3]\r\n\r\n            if (!idMap.nodeIDs[nodeFrom]) {\r\n                throw new Error(`Old node UUID not found in mapping! ${nodeFrom}`)\r\n            }\r\n\r\n            link[1] = idMap.nodeIDs[nodeFrom]\r\n\r\n            if (!idMap.nodeIDs[nodeTo]) {\r\n                throw new Error(`Old node UUID not found in mapping! ${nodeTo}`)\r\n            }\r\n\r\n            link[3] = idMap.nodeIDs[nodeTo]\r\n        }\r\n\r\n        // Reconnect links\r\n        for (const node of graph.nodes) {\r\n            if (node.inputs) {\r\n                for (const input of node.inputs) {\r\n                    if (input.link) {\r\n                        input.link = idMap.linkIDs[input.link]\r\n                    }\r\n                }\r\n            }\r\n            if (node.outputs) {\r\n                for (const output of node.outputs) {\r\n                    if (output.links) {\r\n                        output.links = output.links.map(l => idMap.linkIDs[l]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Recurse!\r\n        for (const node of graph.nodes) {\r\n            if (node.type === "graph/subgraph") {\r\n                const merge = reassignGraphUUIDs(node.subgraph);\r\n                idMap.nodeIDs.assign(merge.nodeIDs)\r\n                idMap.linkIDs.assign(merge.linkIDs)\r\n            }\r\n        }\r\n    };\r\n\r\n    Subgraph.prototype.clone = function() {\r\n        var node = LiteGraph.createNode(this.type);\r\n        var data = this.serialize();\r\n\r\n        if (LiteGraph.use_uuids) {\r\n            // LGraph.serialize() seems to reuse objects in the original graph. But we\r\n            // need to change node IDs here, so clone it first.\r\n            const subgraph = LiteGraph.cloneObject(data.subgraph)\r\n\r\n            this.reassignSubgraphUUIDs(subgraph);\r\n\r\n            data.subgraph = subgraph;\r\n        }\r\n\r\n        delete data["id"];\r\n        delete data["inputs"];\r\n        delete data["outputs"];\r\n        node.configure(data);\r\n        return node;\r\n    };\r\n\r\n\tSubgraph.prototype.buildFromNodes = function(nodes)\r\n\t{\r\n\t\t//clear all?\r\n\t\t//TODO\r\n\r\n\t\t//nodes that connect data between parent graph and subgraph\r\n\t\tvar subgraph_inputs = [];\r\n\t\tvar subgraph_outputs = [];\r\n\r\n\t\t//mark inner nodes\r\n\t\tvar ids = {};\r\n\t\tvar min_x = 0;\r\n\t\tvar max_x = 0;\r\n\t\tfor(var i = 0; i < nodes.length; ++i)\r\n\t\t{\r\n\t\t\tvar node = nodes[i];\r\n\t\t\tids[ node.id ] = node;\r\n\t\t\tmin_x = Math.min( node.pos[0], min_x );\r\n\t\t\tmax_x = Math.max( node.pos[0], min_x );\r\n\t\t}\r\n\t\t\r\n\t\tvar last_input_y = 0;\r\n\t\tvar last_output_y = 0;\r\n\r\n\t\tfor(var i = 0; i < nodes.length; ++i)\r\n\t\t{\r\n\t\t\tvar node = nodes[i];\r\n\t\t\t//check inputs\r\n\t\t\tif( node.inputs )\r\n\t\t\t\tfor(var j = 0; j < node.inputs.length; ++j)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar input = node.inputs[j];\r\n\t\t\t\t\tif( !input || !input.link )\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tvar link = node.graph.links[ input.link ];\r\n\t\t\t\t\tif(!link)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tif( ids[ link.origin_id ] )\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t//this.addInput(input.name,link.type);\r\n\t\t\t\t\tthis.subgraph.addInput(input.name,link.type);\r\n\t\t\t\t\t/*\r\n\t\t\t\t\tvar input_node = LiteGraph.createNode("graph/input");\r\n\t\t\t\t\tthis.subgraph.add( input_node );\r\n\t\t\t\t\tinput_node.pos = [min_x - 200, last_input_y ];\r\n\t\t\t\t\tlast_input_y += 100;\r\n\t\t\t\t\t*/\r\n\t\t\t\t}\r\n\r\n\t\t\t//check outputs\r\n\t\t\tif( node.outputs )\r\n\t\t\t\tfor(var j = 0; j < node.outputs.length; ++j)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar output = node.outputs[j];\r\n\t\t\t\t\tif( !output || !output.links || !output.links.length )\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tvar is_external = false;\r\n\t\t\t\t\tfor(var k = 0; k < output.links.length; ++k)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar link = node.graph.links[ output.links[k] ];\r\n\t\t\t\t\t\tif(!link)\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tif( ids[ link.target_id ] )\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tis_external = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(!is_external)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t//this.addOutput(output.name,output.type);\r\n\t\t\t\t\t/*\r\n\t\t\t\t\tvar output_node = LiteGraph.createNode("graph/output");\r\n\t\t\t\t\tthis.subgraph.add( output_node );\r\n\t\t\t\t\toutput_node.pos = [max_x + 50, last_output_y ];\r\n\t\t\t\t\tlast_output_y += 100;\r\n\t\t\t\t\t*/\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\t//detect inputs and outputs\r\n\t\t\t//split every connection in two data_connection nodes\r\n\t\t\t//keep track of internal connections\r\n\t\t\t//connect external connections\r\n\r\n\t\t//clone nodes inside subgraph and try to reconnect them\r\n\r\n\t\t//connect edge subgraph nodes to extarnal connections nodes\r\n\t}\r\n\r\n    LiteGraph.Subgraph = Subgraph;\r\n    LiteGraph.registerNodeType("graph/subgraph", Subgraph);\r\n\r\n    //Input for a subgraph\r\n    function GraphInput() {\r\n        this.addOutput("", "number");\r\n\r\n        this.name_in_graph = "";\r\n        this.properties = {\r\n\t\t\tname: "",\r\n\t\t\ttype: "number",\r\n\t\t\tvalue: 0\r\n\t\t}; \r\n\r\n        var that = this;\r\n\r\n        this.name_widget = this.addWidget(\r\n            "text",\r\n            "Name",\r\n            this.properties.name,\r\n            function(v) {\r\n                if (!v) {\r\n                    return;\r\n                }\r\n                that.setProperty("name",v);\r\n            }\r\n        );\r\n        this.type_widget = this.addWidget(\r\n            "text",\r\n            "Type",\r\n            this.properties.type,\r\n            function(v) {\r\n\t\t\t\tthat.setProperty("type",v);\r\n            }\r\n        );\r\n\r\n        this.value_widget = this.addWidget(\r\n            "number",\r\n            "Value",\r\n            this.properties.value,\r\n            function(v) {\r\n                that.setProperty("value",v);\r\n            }\r\n        );\r\n\r\n        this.widgets_up = true;\r\n        this.size = [180, 90];\r\n    }\r\n\r\n    GraphInput.title = "Input";\r\n    GraphInput.desc = "Input of the graph";\r\n\r\n\tGraphInput.prototype.onConfigure = function()\r\n\r\n\t{\r\n\t\tthis.updateType();\r\n\t}\r\n\r\n\t//ensures the type in the node output and the type in the associated graph input are the same\r\n\tGraphInput.prototype.updateType = function()\r\n\t{\r\n\t\tvar type = this.properties.type;\r\n\t\tthis.type_widget.value = type;\r\n\r\n\t\t//update output\r\n\t\tif(this.outputs[0].type != type)\r\n\t\t{\r\n\t        if (!LiteGraph.isValidConnection(this.outputs[0].type,type))\r\n\t\t\t\tthis.disconnectOutput(0);\r\n\t\t\tthis.outputs[0].type = type;\r\n\t\t}\r\n\r\n\t\t//update widget\r\n\t\tif(type == "number")\r\n\t\t{\r\n\t\t\tthis.value_widget.type = "number";\r\n\t\t\tthis.value_widget.value = 0;\r\n\t\t}\r\n\t\telse if(type == "boolean")\r\n\t\t{\r\n\t\t\tthis.value_widget.type = "toggle";\r\n\t\t\tthis.value_widget.value = true;\r\n\t\t}\r\n\t\telse if(type == "string")\r\n\t\t{\r\n\t\t\tthis.value_widget.type = "text";\r\n\t\t\tthis.value_widget.value = "";\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.value_widget.type = null;\r\n\t\t\tthis.value_widget.value = null;\r\n\t\t}\r\n\t\tthis.properties.value = this.value_widget.value;\r\n\r\n\t\t//update graph\r\n\t\tif (this.graph && this.name_in_graph) {\r\n\t\t\tthis.graph.changeInputType(this.name_in_graph, type);\r\n\t\t}\r\n\t}\r\n\r\n\t//this is executed AFTER the property has changed\r\n\tGraphInput.prototype.onPropertyChanged = function(name,v)\r\n\t{\r\n\t\tif( name == "name" )\r\n\t\t{\r\n\t\t\tif (v == "" || v == this.name_in_graph || v == "enabled") {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif(this.graph)\r\n\t\t\t{\r\n\t\t\t\tif (this.name_in_graph) {\r\n\t\t\t\t\t//already added\r\n\t\t\t\t\tthis.graph.renameInput( this.name_in_graph, v );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.graph.addInput( v, this.properties.type );\r\n\t\t\t\t}\r\n\t\t\t} //what if not?!\r\n\t\t\tthis.name_widget.value = v;\r\n\t\t\tthis.name_in_graph = v;\r\n\t\t}\r\n\t\telse if( name == "type" )\r\n\t\t{\r\n\t\t\tthis.updateType();\r\n\t\t}\r\n\t\telse if( name == "value" )\r\n\t\t{\r\n\t\t}\r\n\t}\r\n\r\n    GraphInput.prototype.getTitle = function() {\r\n        if (this.flags.collapsed) {\r\n            return this.properties.name;\r\n        }\r\n        return this.title;\r\n    };\r\n\r\n    GraphInput.prototype.onAction = function(action, param) {\r\n        if (this.properties.type == LiteGraph.EVENT) {\r\n            this.triggerSlot(0, param);\r\n        }\r\n    };\r\n\r\n    GraphInput.prototype.onExecute = function() {\r\n        var name = this.properties.name;\r\n        //read from global input\r\n        var data = this.graph.inputs[name];\r\n        if (!data) {\r\n            this.setOutputData(0, this.properties.value );\r\n\t\t\treturn;\r\n        }\r\n\r\n        this.setOutputData(0, data.value !== undefined ? data.value : this.properties.value );\r\n    };\r\n\r\n    GraphInput.prototype.onRemoved = function() {\r\n        if (this.name_in_graph) {\r\n            this.graph.removeInput(this.name_in_graph);\r\n        }\r\n    };\r\n\r\n    LiteGraph.GraphInput = GraphInput;\r\n    LiteGraph.registerNodeType("graph/input", GraphInput);\r\n\r\n    //Output for a subgraph\r\n    function GraphOutput() {\r\n        this.addInput("", "");\r\n\r\n        this.name_in_graph = "";\r\n        this.properties = { name: "", type: "" };\r\n        var that = this;\r\n\r\n        // Object.defineProperty(this.properties, "name", {\r\n        //     get: function() {\r\n        //         return that.name_in_graph;\r\n        //     },\r\n        //     set: function(v) {\r\n        //         if (v == "" || v == that.name_in_graph) {\r\n        //             return;\r\n        //         }\r\n        //         if (that.name_in_graph) {\r\n        //             //already added\r\n        //             that.graph.renameOutput(that.name_in_graph, v);\r\n        //         } else {\r\n        //             that.graph.addOutput(v, that.properties.type);\r\n        //         }\r\n        //         that.name_widget.value = v;\r\n        //         that.name_in_graph = v;\r\n        //     },\r\n        //     enumerable: true\r\n        // });\r\n\r\n        // Object.defineProperty(this.properties, "type", {\r\n        //     get: function() {\r\n        //         return that.inputs[0].type;\r\n        //     },\r\n        //     set: function(v) {\r\n        //         if (v == "action" || v == "event") {\r\n        //             v = LiteGraph.ACTION;\r\n        //         }\r\n\t\t//         if (!LiteGraph.isValidConnection(that.inputs[0].type,v))\r\n\t\t// \t\t\tthat.disconnectInput(0);\r\n        //         that.inputs[0].type = v;\r\n        //         if (that.name_in_graph) {\r\n        //             //already added\r\n        //             that.graph.changeOutputType(\r\n        //                 that.name_in_graph,\r\n        //                 that.inputs[0].type\r\n        //             );\r\n        //         }\r\n        //         that.type_widget.value = v || "";\r\n        //     },\r\n        //     enumerable: true\r\n        // });\r\n\r\n        this.name_widget = this.addWidget("text","Name",this.properties.name,"name");\r\n        this.type_widget = this.addWidget("text","Type",this.properties.type,"type");\r\n        this.widgets_up = true;\r\n        this.size = [180, 60];\r\n    }\r\n\r\n    GraphOutput.title = "Output";\r\n    GraphOutput.desc = "Output of the graph";\r\n\r\n    GraphOutput.prototype.onPropertyChanged = function (name, v) {\r\n        if (name == "name") {\r\n            if (v == "" || v == this.name_in_graph || v == "enabled") {\r\n                return false;\r\n            }\r\n            if (this.graph) {\r\n                if (this.name_in_graph) {\r\n                    //already added\r\n                    this.graph.renameOutput(this.name_in_graph, v);\r\n                } else {\r\n                    this.graph.addOutput(v, this.properties.type);\r\n                }\r\n            } //what if not?!\r\n            this.name_widget.value = v;\r\n            this.name_in_graph = v;\r\n        }\r\n        else if (name == "type") {\r\n            this.updateType();\r\n        }\r\n        else if (name == "value") {\r\n        }\r\n    }\r\n     \r\n    GraphOutput.prototype.updateType = function () {\r\n        var type = this.properties.type;\r\n        if (this.type_widget)\r\n            this.type_widget.value = type;\r\n\r\n        //update output\r\n        if (this.inputs[0].type != type) {\r\n\r\n\t\t\tif ( type == "action" || type == "event")\r\n\t            type = LiteGraph.EVENT;\r\n\t\t\tif (!LiteGraph.isValidConnection(this.inputs[0].type, type))\r\n\t\t\t\tthis.disconnectInput(0);\r\n\t\t\tthis.inputs[0].type = type;\r\n        }\r\n\r\n        //update graph\r\n        if (this.graph && this.name_in_graph) {\r\n            this.graph.changeOutputType(this.name_in_graph, type);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    GraphOutput.prototype.onExecute = function() {\r\n        this._value = this.getInputData(0);\r\n        this.graph.setOutputData(this.properties.name, this._value);\r\n    };\r\n\r\n    GraphOutput.prototype.onAction = function(action, param) {\r\n        if (this.properties.type == LiteGraph.ACTION) {\r\n            this.graph.trigger( this.properties.name, param );\r\n        }\r\n    };\r\n\r\n    GraphOutput.prototype.onRemoved = function() {\r\n        if (this.name_in_graph) {\r\n            this.graph.removeOutput(this.name_in_graph);\r\n        }\r\n    };\r\n\r\n    GraphOutput.prototype.getTitle = function() {\r\n        if (this.flags.collapsed) {\r\n            return this.properties.name;\r\n        }\r\n        return this.title;\r\n    };\r\n\r\n    LiteGraph.GraphOutput = GraphOutput;\r\n    LiteGraph.registerNodeType("graph/output", GraphOutput);\r\n\r\n    //Constant\r\n    function ConstantNumber() {\r\n        this.addOutput("value", "number");\r\n        this.addProperty("value", 1.0);\r\n        this.widget = this.addWidget("number","value",1,"value");\r\n        this.widgets_up = true;\r\n        this.size = [180, 30];\r\n    }\r\n\r\n    ConstantNumber.title = "Const Number";\r\n    ConstantNumber.desc = "Constant number";\r\n\r\n    ConstantNumber.prototype.onExecute = function() {\r\n        this.setOutputData(0, parseFloat(this.properties["value"]));\r\n    };\r\n\r\n    ConstantNumber.prototype.getTitle = function() {\r\n        if (this.flags.collapsed) {\r\n            return this.properties.value;\r\n        }\r\n        return this.title;\r\n    };\r\n\r\n\tConstantNumber.prototype.setValue = function(v)\r\n\t{\r\n\t\tthis.setProperty("value",v);\r\n\t}\r\n\r\n    ConstantNumber.prototype.onDrawBackground = function(ctx) {\r\n        //show the current value\r\n        this.outputs[0].label = this.properties["value"].toFixed(3);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("basic/const", ConstantNumber);\r\n\r\n    function ConstantBoolean() {\r\n        this.addOutput("bool", "boolean");\r\n        this.addProperty("value", true);\r\n        this.widget = this.addWidget("toggle","value",true,"value");\r\n        this.serialize_widgets = true;\r\n        this.widgets_up = true;\r\n        this.size = [140, 30];\r\n    }\r\n\r\n    ConstantBoolean.title = "Const Boolean";\r\n    ConstantBoolean.desc = "Constant boolean";\r\n    ConstantBoolean.prototype.getTitle = ConstantNumber.prototype.getTitle;\r\n\r\n    ConstantBoolean.prototype.onExecute = function() {\r\n        this.setOutputData(0, this.properties["value"]);\r\n    };\r\n\r\n\tConstantBoolean.prototype.setValue = ConstantNumber.prototype.setValue;\r\n\r\n\tConstantBoolean.prototype.onGetInputs = function() {\r\n\t\treturn [["toggle", LiteGraph.ACTION]];\r\n\t};\r\n\r\n\tConstantBoolean.prototype.onAction = function(action)\r\n\t{\r\n\t\tthis.setValue( !this.properties.value );\r\n\t}\r\n\r\n    LiteGraph.registerNodeType("basic/boolean", ConstantBoolean);\r\n\r\n    function ConstantString() {\r\n        this.addOutput("string", "string");\r\n        this.addProperty("value", "");\r\n        this.widget = this.addWidget("text","value","","value");  //link to property value\r\n        this.widgets_up = true;\r\n        this.size = [180, 30];\r\n    }\r\n\r\n    ConstantString.title = "Const String";\r\n    ConstantString.desc = "Constant string";\r\n\r\n    ConstantString.prototype.getTitle = ConstantNumber.prototype.getTitle;\r\n\r\n    ConstantString.prototype.onExecute = function() {\r\n        this.setOutputData(0, this.properties["value"]);\r\n    };\r\n\r\n\tConstantString.prototype.setValue = ConstantNumber.prototype.setValue;\r\n\r\n\tConstantString.prototype.onDropFile = function(file)\r\n\t{\r\n\t\tvar that = this;\r\n\t\tvar reader = new FileReader();\r\n\t\treader.onload = function(e)\r\n\t\t{\r\n\t\t\tthat.setProperty("value",e.target.result);\r\n\t\t}\r\n\t\treader.readAsText(file);\r\n\t}\r\n\r\n    LiteGraph.registerNodeType("basic/string", ConstantString);\r\n\r\n    function ConstantObject() {\r\n        this.addOutput("obj", "object");\r\n        this.size = [120, 30];\r\n\t\tthis._object = {};\r\n    }\r\n\r\n    ConstantObject.title = "Const Object";\r\n    ConstantObject.desc = "Constant Object";\r\n\r\n    ConstantObject.prototype.onExecute = function() {\r\n        this.setOutputData(0, this._object);\r\n    };\r\n\r\n    LiteGraph.registerNodeType( "basic/object", ConstantObject );\r\n\r\n    function ConstantFile() {\r\n        this.addInput("url", "string");\r\n        this.addOutput("file", "string");\r\n        this.addProperty("url", "");\r\n        this.addProperty("type", "text");\r\n        this.widget = this.addWidget("text","url","","url");\r\n        this._data = null;\r\n    }\r\n\r\n    ConstantFile.title = "Const File";\r\n    ConstantFile.desc = "Fetches a file from an url";\r\n    ConstantFile["@type"] = { type: "enum", values: ["text","arraybuffer","blob","json"] };\r\n\r\n    ConstantFile.prototype.onPropertyChanged = function(name, value) {\r\n        if (name == "url")\r\n\t\t{\r\n\t\t\tif( value == null || value == "")\r\n\t\t\t\tthis._data = null;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis.fetchFile(value);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n    ConstantFile.prototype.onExecute = function() {\r\n\t\tvar url = this.getInputData(0) || this.properties.url;\r\n\t\tif(url && (url != this._url || this._type != this.properties.type))\r\n\t\t\tthis.fetchFile(url);\r\n        this.setOutputData(0, this._data );\r\n    };\r\n\r\n\tConstantFile.prototype.setValue = ConstantNumber.prototype.setValue;\r\n\r\n    ConstantFile.prototype.fetchFile = function(url) {\r\n\t\tvar that = this;\r\n\t\tif(!url || url.constructor !== String)\r\n\t\t{\r\n\t\t\tthat._data = null;\r\n            that.boxcolor = null;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._url = url;\r\n\t\tthis._type = this.properties.type;\r\n        if (url.substr(0, 4) == "http" && LiteGraph.proxy) {\r\n            url = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);\r\n        }\r\n\t\tfetch(url)\r\n\t\t.then(function(response) {\r\n\t\t\tif(!response.ok)\r\n\t\t\t\t throw new Error("File not found");\r\n\r\n\t\t\tif(that.properties.type == "arraybuffer")\r\n\t\t\t\treturn response.arrayBuffer();\r\n\t\t\telse if(that.properties.type == "text")\r\n\t\t\t\treturn response.text();\r\n\t\t\telse if(that.properties.type == "json")\r\n\t\t\t\treturn response.json();\r\n\t\t\telse if(that.properties.type == "blob")\r\n\t\t\t\treturn response.blob();\r\n\t\t})\r\n\t\t.then(function(data) {\r\n\t\t\tthat._data = data;\r\n            that.boxcolor = "#AEA";\r\n\t\t})\r\n\t\t.catch(function(error) {\r\n\t\t\tthat._data = null;\r\n            that.boxcolor = "red";\r\n\t\t\tconsole.error("error fetching file:",url);\r\n\t\t});\r\n    };\r\n\r\n\tConstantFile.prototype.onDropFile = function(file)\r\n\t{\r\n\t\tvar that = this;\r\n\t\tthis._url = file.name;\r\n\t\tthis._type = this.properties.type;\r\n\t\tthis.properties.url = file.name;\r\n\t\tvar reader = new FileReader();\r\n\t\treader.onload = function(e)\r\n\t\t{\r\n            that.boxcolor = "#AEA";\r\n\t\t\tvar v = e.target.result;\r\n\t\t\tif( that.properties.type == "json" )\r\n\t\t\t\tv = JSON.parse(v);\r\n\t\t\tthat._data = v;\r\n\t\t}\r\n\t\tif(that.properties.type == "arraybuffer")\r\n\t\t\treader.readAsArrayBuffer(file);\r\n\t\telse if(that.properties.type == "text" || that.properties.type == "json")\r\n\t\t\treader.readAsText(file);\r\n\t\telse if(that.properties.type == "blob")\r\n\t\t\treturn reader.readAsBinaryString(file);\r\n\t}\r\n\r\n    LiteGraph.registerNodeType("basic/file", ConstantFile);\r\n\r\n\r\n//to store json objects\r\nfunction JSONParse() {\r\n\tthis.addInput("parse", LiteGraph.ACTION);\r\n\tthis.addInput("json", "string");\r\n\tthis.addOutput("done", LiteGraph.EVENT);\r\n\tthis.addOutput("object", "object");\r\n\tthis.widget = this.addWidget("button","parse","",this.parse.bind(this));\r\n\tthis._str = null;\r\n\tthis._obj = null;\r\n}\r\n\r\nJSONParse.title = "JSON Parse";\r\nJSONParse.desc = "Parses JSON String into object";\r\n\r\nJSONParse.prototype.parse = function()\r\n{\r\n\tif(!this._str)\r\n\t\treturn;\r\n\r\n\ttry {\r\n\t\tthis._str = this.getInputData(1);\r\n\t\tthis._obj = JSON.parse(this._str);\r\n\t\tthis.boxcolor = "#AEA";\r\n\t\tthis.triggerSlot(0);\r\n\t} catch (err) {\r\n\t\tthis.boxcolor = "red";\r\n\t}\r\n}\r\n\r\nJSONParse.prototype.onExecute = function() {\r\n\tthis._str = this.getInputData(1);\r\n\tthis.setOutputData(1, this._obj);\r\n};\r\n\r\nJSONParse.prototype.onAction = function(name) {\r\n\tif(name == "parse")\r\n\t\tthis.parse();\r\n}\r\n\r\nLiteGraph.registerNodeType("basic/jsonparse", JSONParse);\t\r\n\r\n\t//to store json objects\r\n    function ConstantData() {\r\n        this.addOutput("data", "object");\r\n        this.addProperty("value", "");\r\n        this.widget = this.addWidget("text","json","","value");\r\n        this.widgets_up = true;\r\n        this.size = [140, 30];\r\n        this._value = null;\r\n    }\r\n\r\n    ConstantData.title = "Const Data";\r\n    ConstantData.desc = "Constant Data";\r\n\r\n    ConstantData.prototype.onPropertyChanged = function(name, value) {\r\n        this.widget.value = value;\r\n        if (value == null || value == "") {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            this._value = JSON.parse(value);\r\n            this.boxcolor = "#AEA";\r\n        } catch (err) {\r\n            this.boxcolor = "red";\r\n        }\r\n    };\r\n\r\n    ConstantData.prototype.onExecute = function() {\r\n        this.setOutputData(0, this._value);\r\n    };\r\n\r\n\tConstantData.prototype.setValue = ConstantNumber.prototype.setValue;\r\n\r\n    LiteGraph.registerNodeType("basic/data", ConstantData);\r\n\r\n\t//to store json objects\r\n    function ConstantArray() {\r\n\t\tthis._value = [];\r\n        this.addInput("json", "");\r\n        this.addOutput("arrayOut", "array");\r\n\t\tthis.addOutput("length", "number");\r\n        this.addProperty("value", "[]");\r\n        this.widget = this.addWidget("text","array",this.properties.value,"value");\r\n        this.widgets_up = true;\r\n        this.size = [140, 50];\r\n    }\r\n\r\n    ConstantArray.title = "Const Array";\r\n    ConstantArray.desc = "Constant Array";\r\n\r\n    ConstantArray.prototype.onPropertyChanged = function(name, value) {\r\n        this.widget.value = value;\r\n        if (value == null || value == "") {\r\n            return;\r\n        }\r\n\r\n        try {\r\n\t\t\tif(value[0] != "[")\r\n\t            this._value = JSON.parse("[" + value + "]");\r\n\t\t\telse\r\n\t            this._value = JSON.parse(value);\r\n            this.boxcolor = "#AEA";\r\n        } catch (err) {\r\n            this.boxcolor = "red";\r\n        }\r\n    };\r\n\r\n    ConstantArray.prototype.onExecute = function() {\r\n        var v = this.getInputData(0);\r\n\t\tif(v && v.length) //clone\r\n\t\t{\r\n\t\t\tif(!this._value)\r\n\t\t\t\tthis._value = new Array();\r\n\t\t\tthis._value.length = v.length;\r\n\t\t\tfor(var i = 0; i < v.length; ++i)\r\n\t\t\t\tthis._value[i] = v[i];\r\n\t\t}\r\n\t\tthis.setOutputData(0, this._value);\r\n\t\tthis.setOutputData(1, this._value ? ( this._value.length || 0) : 0 );\r\n    };\r\n\r\n\tConstantArray.prototype.setValue = ConstantNumber.prototype.setValue;\r\n\r\n    LiteGraph.registerNodeType("basic/array", ConstantArray);\r\n\r\n\tfunction SetArray()\r\n\t{\r\n        this.addInput("arr", "array");\r\n        this.addInput("value", "");\r\n        this.addOutput("arr", "array");\r\n\t\tthis.properties = { index: 0 };\r\n        this.widget = this.addWidget("number","i",this.properties.index,"index",{precision: 0, step: 10, min: 0});\r\n\t}\r\n\r\n    SetArray.title = "Set Array";\r\n    SetArray.desc = "Sets index of array";\r\n\r\n    SetArray.prototype.onExecute = function() {\r\n        var arr = this.getInputData(0);\r\n\t\tif(!arr)\r\n\t\t\treturn;\r\n        var v = this.getInputData(1);\r\n\t\tif(v === undefined )\r\n\t\t\treturn;\r\n\t\tif(this.properties.index)\r\n\t\t\tarr[ Math.floor(this.properties.index) ] = v;\r\n\t\tthis.setOutputData(0,arr);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("basic/set_array", SetArray );\r\n\r\n    function ArrayElement() {\r\n        this.addInput("array", "array,table,string");\r\n        this.addInput("index", "number");\r\n        this.addOutput("value", "");\r\n\t\tthis.addProperty("index",0);\r\n    }\r\n\r\n    ArrayElement.title = "Array[i]";\r\n    ArrayElement.desc = "Returns an element from an array";\r\n\r\n    ArrayElement.prototype.onExecute = function() {\r\n        var array = this.getInputData(0);\r\n        var index = this.getInputData(1);\r\n\t\tif(index == null)\r\n\t\t\tindex = this.properties.index;\r\n\t\tif(array == null || index == null )\r\n\t\t\treturn;\r\n        this.setOutputData(0, array[Math.floor(Number(index))] );\r\n    };\r\n\r\n    LiteGraph.registerNodeType("basic/array[]", ArrayElement);\r\n\r\n    function TableElement() {\r\n        this.addInput("table", "table");\r\n        this.addInput("row", "number");\r\n        this.addInput("col", "number");\r\n        this.addOutput("value", "");\r\n\t\tthis.addProperty("row",0);\r\n\t\tthis.addProperty("column",0);\r\n    }\r\n\r\n    TableElement.title = "Table[row][col]";\r\n    TableElement.desc = "Returns an element from a table";\r\n\r\n    TableElement.prototype.onExecute = function() {\r\n        var table = this.getInputData(0);\r\n        var row = this.getInputData(1);\r\n        var col = this.getInputData(2);\r\n\t\tif(row == null)\r\n\t\t\trow = this.properties.row;\r\n\t\tif(col == null)\r\n\t\t\tcol = this.properties.column;\r\n\t\tif(table == null || row == null || col == null)\r\n\t\t\treturn;\r\n\t\tvar row = table[Math.floor(Number(row))];\r\n\t\tif(row)\r\n\t        this.setOutputData(0, row[Math.floor(Number(col))] );\r\n\t\telse\r\n\t        this.setOutputData(0, null );\r\n    };\r\n\r\n    LiteGraph.registerNodeType("basic/table[][]", TableElement);\r\n\r\n    function ObjectProperty() {\r\n        this.addInput("obj", "object");\r\n        this.addOutput("property", 0);\r\n        this.addProperty("value", 0);\r\n        this.widget = this.addWidget("text","prop.","",this.setValue.bind(this) );\r\n        this.widgets_up = true;\r\n        this.size = [140, 30];\r\n        this._value = null;\r\n    }\r\n\r\n    ObjectProperty.title = "Object property";\r\n    ObjectProperty.desc = "Outputs the property of an object";\r\n\r\n    ObjectProperty.prototype.setValue = function(v) {\r\n        this.properties.value = v;\r\n        this.widget.value = v;\r\n    };\r\n\r\n    ObjectProperty.prototype.getTitle = function() {\r\n        if (this.flags.collapsed) {\r\n            return "in." + this.properties.value;\r\n        }\r\n        return this.title;\r\n    };\r\n\r\n    ObjectProperty.prototype.onPropertyChanged = function(name, value) {\r\n        this.widget.value = value;\r\n    };\r\n\r\n    ObjectProperty.prototype.onExecute = function() {\r\n        var data = this.getInputData(0);\r\n        if (data != null) {\r\n            this.setOutputData(0, data[this.properties.value]);\r\n        }\r\n    };\r\n\r\n    LiteGraph.registerNodeType("basic/object_property", ObjectProperty);\r\n\r\n    function ObjectKeys() {\r\n        this.addInput("obj", "");\r\n        this.addOutput("keys", "array");\r\n        this.size = [140, 30];\r\n    }\r\n\r\n    ObjectKeys.title = "Object keys";\r\n    ObjectKeys.desc = "Outputs an array with the keys of an object";\r\n\r\n    ObjectKeys.prototype.onExecute = function() {\r\n        var data = this.getInputData(0);\r\n        if (data != null) {\r\n            this.setOutputData(0, Object.keys(data) );\r\n        }\r\n    };\r\n\r\n    LiteGraph.registerNodeType("basic/object_keys", ObjectKeys);\r\n\r\n\r\n\tfunction SetObject()\r\n\t{\r\n        this.addInput("obj", "");\r\n        this.addInput("value", "");\r\n        this.addOutput("obj", "");\r\n\t\tthis.properties = { property: "" };\r\n        this.name_widget = this.addWidget("text","prop.",this.properties.property,"property");\r\n\t}\r\n\r\n    SetObject.title = "Set Object";\r\n    SetObject.desc = "Adds propertiesrty to object";\r\n\r\n    SetObject.prototype.onExecute = function() {\r\n        var obj = this.getInputData(0);\r\n\t\tif(!obj)\r\n\t\t\treturn;\r\n        var v = this.getInputData(1);\r\n\t\tif(v === undefined )\r\n\t\t\treturn;\r\n\t\tif(this.properties.property)\r\n\t\t\tobj[ this.properties.property ] = v;\r\n\t\tthis.setOutputData(0,obj);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("basic/set_object", SetObject );\r\n\r\n\r\n    function MergeObjects() {\r\n        this.addInput("A", "object");\r\n        this.addInput("B", "object");\r\n        this.addOutput("out", "object");\r\n\t\tthis._result = {};\r\n\t\tvar that = this;\r\n\t\tthis.addWidget("button","clear","",function(){\r\n\t\t\tthat._result = {};\r\n\t\t});\r\n\t\tthis.size = this.computeSize();\r\n    }\r\n\r\n    MergeObjects.title = "Merge Objects";\r\n    MergeObjects.desc = "Creates an object copying properties from others";\r\n\r\n    MergeObjects.prototype.onExecute = function() {\r\n        var A = this.getInputData(0);\r\n        var B = this.getInputData(1);\r\n\t\tvar C = this._result;\r\n\t\tif(A)\r\n\t\t\tfor(var i in A)\r\n\t\t\t\tC[i] = A[i];\r\n\t\tif(B)\r\n\t\t\tfor(var i in B)\r\n\t\t\t\tC[i] = B[i];\r\n\t\tthis.setOutputData(0,C);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("basic/merge_objects", MergeObjects );\r\n\r\n    //Store as variable\r\n    function Variable() {\r\n        this.size = [60, 30];\r\n        this.addInput("in");\r\n        this.addOutput("out");\r\n\t\tthis.properties = { varname: "myname", container: Variable.LITEGRAPH };\r\n        this.value = null;\r\n    }\r\n\r\n    Variable.title = "Variable";\r\n    Variable.desc = "store/read variable value";\r\n\r\n\tVariable.LITEGRAPH = 0; //between all graphs\r\n\tVariable.GRAPH = 1;\t//only inside this graph\r\n\tVariable.GLOBALSCOPE = 2;\t//attached to Window\r\n\r\n    Variable["@container"] = { type: "enum", values: {"litegraph":Variable.LITEGRAPH, "graph":Variable.GRAPH,"global": Variable.GLOBALSCOPE} };\r\n\r\n    Variable.prototype.onExecute = function() {\r\n\t\tvar container = this.getContainer();\r\n\r\n\t\tif(this.isInputConnected(0))\r\n\t\t{\r\n\t\t\tthis.value = this.getInputData(0);\r\n\t\t\tcontainer[ this.properties.varname ] = this.value;\r\n\t\t\tthis.setOutputData(0, this.value );\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.setOutputData( 0, container[ this.properties.varname ] );\r\n    };\r\n\r\n\tVariable.prototype.getContainer = function()\r\n\t{\r\n\t\tswitch(this.properties.container)\r\n\t\t{\r\n\t\t\tcase Variable.GRAPH:\r\n\t\t\t\tif(this.graph)\r\n\t\t\t\t\treturn this.graph.vars;\r\n\t\t\t\treturn {};\r\n\t\t\t\tbreak;\r\n\t\t\tcase Variable.GLOBALSCOPE:\r\n\t\t\t\treturn global;\r\n\t\t\t\tbreak;\r\n\t\t\tcase Variable.LITEGRAPH:\r\n\t\t\tdefault:\r\n\t\t\t\treturn LiteGraph.Globals;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n    Variable.prototype.getTitle = function() {\r\n        return this.properties.varname;\r\n    };\r\n\r\n    LiteGraph.registerNodeType("basic/variable", Variable);\r\n\r\n    function length(v) {\r\n        if(v && v.length != null)\r\n\t\t\treturn Number(v.length);\r\n\t\treturn 0;\r\n    }\r\n\r\n    LiteGraph.wrapFunctionAsNode(\r\n        "basic/length",\r\n        length,\r\n        [""],\r\n        "number"\r\n    );\r\n\r\n    function length(v) {\r\n        if(v && v.length != null)\r\n\t\t\treturn Number(v.length);\r\n\t\treturn 0;\r\n    }\r\n\r\n    LiteGraph.wrapFunctionAsNode(\r\n        "basic/not",\r\n        function(a){ return !a; },\r\n        [""],\r\n        "boolean"\r\n    );\r\n\r\n\tfunction DownloadData() {\r\n        this.size = [60, 30];\r\n        this.addInput("data", 0 );\r\n        this.addInput("download", LiteGraph.ACTION );\r\n\t\tthis.properties = { filename: "data.json" };\r\n        this.value = null;\r\n\t\tvar that = this;\r\n\t\tthis.addWidget("button","Download","", function(v){\r\n\t\t\tif(!that.value)\r\n\t\t\t\treturn;\r\n\t\t\tthat.downloadAsFile();\r\n\t\t});\r\n    }\r\n\r\n    DownloadData.title = "Download";\r\n    DownloadData.desc = "Download some data";\r\n\r\n\tDownloadData.prototype.downloadAsFile = function()\r\n\t{\r\n\t\tif(this.value == null)\r\n\t\t\treturn;\r\n\r\n\t\tvar str = null;\r\n\t\tif(this.value.constructor === String)\r\n\t\t\tstr = this.value;\r\n\t\telse\r\n\t\t\tstr = JSON.stringify(this.value);\r\n\r\n\t\tvar file = new Blob([str]);\r\n\t\tvar url = URL.createObjectURL( file );\r\n\t\tvar element = document.createElement("a");\r\n\t\telement.setAttribute(\'href\', url);\r\n\t\telement.setAttribute(\'download\', this.properties.filename );\r\n\t\telement.style.display = \'none\';\r\n\t\tdocument.body.appendChild(element);\r\n\t\telement.click();\r\n\t\tdocument.body.removeChild(element);\r\n\t\tsetTimeout( function(){ URL.revokeObjectURL( url ); }, 1000*60 ); //wait one minute to revoke url\r\n\t}\r\n\r\n    DownloadData.prototype.onAction = function(action, param) {\r\n\t\tvar that = this;\r\n\t\tsetTimeout( function(){ that.downloadAsFile(); }, 100); //deferred to avoid blocking the renderer with the popup\r\n\t}\r\n\r\n    DownloadData.prototype.onExecute = function() {\r\n        if (this.inputs[0]) {\r\n            this.value = this.getInputData(0);\r\n        }\r\n    };\r\n\r\n    DownloadData.prototype.getTitle = function() {\r\n        if (this.flags.collapsed) {\r\n            return this.properties.filename;\r\n        }\r\n        return this.title;\r\n    };\r\n\r\n    LiteGraph.registerNodeType("basic/download", DownloadData);\r\n\r\n\r\n\r\n    //Watch a value in the editor\r\n    function Watch() {\r\n        this.size = [60, 30];\r\n        this.addInput("value", 0, { label: "" });\r\n        this.value = 0;\r\n    }\r\n\r\n    Watch.title = "Watch";\r\n    Watch.desc = "Show value of input";\r\n\r\n    Watch.prototype.onExecute = function() {\r\n        if (this.inputs[0]) {\r\n            this.value = this.getInputData(0);\r\n        }\r\n    };\r\n\r\n    Watch.prototype.getTitle = function() {\r\n        if (this.flags.collapsed) {\r\n            return this.inputs[0].label;\r\n        }\r\n        return this.title;\r\n    };\r\n\r\n    Watch.toString = function(o) {\r\n        if (o == null) {\r\n            return "null";\r\n        } else if (o.constructor === Number) {\r\n            return o.toFixed(3);\r\n        } else if (o.constructor === Array) {\r\n            var str = "[";\r\n            for (var i = 0; i < o.length; ++i) {\r\n                str += Watch.toString(o[i]) + (i + 1 != o.length ? "," : "");\r\n            }\r\n            str += "]";\r\n            return str;\r\n        } else {\r\n            return String(o);\r\n        }\r\n    };\r\n\r\n    Watch.prototype.onDrawBackground = function(ctx) {\r\n        //show the current value\r\n        this.inputs[0].label = Watch.toString(this.value);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("basic/watch", Watch);\r\n\r\n    //in case one type doesnt match other type but you want to connect them anyway\r\n    function Cast() {\r\n        this.addInput("in", 0);\r\n        this.addOutput("out", 0);\r\n        this.size = [40, 30];\r\n    }\r\n\r\n    Cast.title = "Cast";\r\n    Cast.desc = "Allows to connect different types";\r\n\r\n    Cast.prototype.onExecute = function() {\r\n        this.setOutputData(0, this.getInputData(0));\r\n    };\r\n\r\n    LiteGraph.registerNodeType("basic/cast", Cast);\r\n\r\n    //Show value inside the debug console\r\n    function Console() {\r\n        this.mode = LiteGraph.ON_EVENT;\r\n        this.size = [80, 30];\r\n        this.addProperty("msg", "");\r\n        this.addInput("log", LiteGraph.EVENT);\r\n        this.addInput("msg", 0);\r\n    }\r\n\r\n    Console.title = "Console";\r\n    Console.desc = "Show value inside the console";\r\n\r\n    Console.prototype.onAction = function(action, param) {\r\n        // param is the action\r\n        var msg = this.getInputData(1); //getInputDataByName("msg");\r\n        //if (msg == null || typeof msg == "undefined") return;\r\n        if (!msg) msg = this.properties.msg;\r\n        if (!msg) msg = "Event: "+param; // msg is undefined if the slot is lost?\r\n        if (action == "log") {\r\n            console.log(msg);\r\n        } else if (action == "warn") {\r\n            console.warn(msg);\r\n        } else if (action == "error") {\r\n            console.error(msg);\r\n        }\r\n    };\r\n\r\n    Console.prototype.onExecute = function() {\r\n        var msg = this.getInputData(1); //getInputDataByName("msg");\r\n        if (!msg) msg = this.properties.msg;\r\n        if (msg != null && typeof msg != "undefined") {\r\n            this.properties.msg = msg;\r\n            console.log(msg);\r\n        }\r\n    };\r\n\r\n    Console.prototype.onGetInputs = function() {\r\n        return [\r\n            ["log", LiteGraph.ACTION],\r\n            ["warn", LiteGraph.ACTION],\r\n            ["error", LiteGraph.ACTION]\r\n        ];\r\n    };\r\n\r\n    LiteGraph.registerNodeType("basic/console", Console);\r\n\r\n    //Show value inside the debug console\r\n    function Alert() {\r\n        this.mode = LiteGraph.ON_EVENT;\r\n        this.addProperty("msg", "");\r\n        this.addInput("", LiteGraph.EVENT);\r\n        var that = this;\r\n        this.widget = this.addWidget("text", "Text", "", "msg");\r\n        this.widgets_up = true;\r\n        this.size = [200, 30];\r\n    }\r\n\r\n    Alert.title = "Alert";\r\n    Alert.desc = "Show an alert window";\r\n    Alert.color = "#510";\r\n\r\n    Alert.prototype.onConfigure = function(o) {\r\n        this.widget.value = o.properties.msg;\r\n    };\r\n\r\n    Alert.prototype.onAction = function(action, param) {\r\n        var msg = this.properties.msg;\r\n        setTimeout(function() {\r\n            alert(msg);\r\n        }, 10);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("basic/alert", Alert);\r\n\r\n    //Execites simple code\r\n    function NodeScript() {\r\n        this.size = [60, 30];\r\n        this.addProperty("onExecute", "return A;");\r\n        this.addInput("A", 0);\r\n        this.addInput("B", 0);\r\n        this.addOutput("out", 0);\r\n\r\n        this._func = null;\r\n        this.data = {};\r\n    }\r\n\r\n    NodeScript.prototype.onConfigure = function(o) {\r\n        if (o.properties.onExecute && LiteGraph.allow_scripts)\r\n            this.compileCode(o.properties.onExecute);\r\n\t\telse\r\n\t\t\tconsole.warn("Script not compiled, LiteGraph.allow_scripts is false");\r\n    };\r\n\r\n    NodeScript.title = "Script";\r\n    NodeScript.desc = "executes a code (max 256 characters)";\r\n\r\n    NodeScript.widgets_info = {\r\n        onExecute: { type: "code" }\r\n    };\r\n\r\n    NodeScript.prototype.onPropertyChanged = function(name, value) {\r\n        if (name == "onExecute" && LiteGraph.allow_scripts)\r\n            this.compileCode(value);\r\n\t\telse\r\n\t\t\tconsole.warn("Script not compiled, LiteGraph.allow_scripts is false");\r\n    };\r\n\r\n    NodeScript.prototype.compileCode = function(code) {\r\n        this._func = null;\r\n        if (code.length > 256) {\r\n            console.warn("Script too long, max 256 chars");\r\n        } else {\r\n            var code_low = code.toLowerCase();\r\n            var forbidden_words = [\r\n                "script",\r\n                "body",\r\n                "document",\r\n                "eval",\r\n                "nodescript",\r\n                "function"\r\n            ]; //bad security solution\r\n            for (var i = 0; i < forbidden_words.length; ++i) {\r\n                if (code_low.indexOf(forbidden_words[i]) != -1) {\r\n                    console.warn("invalid script");\r\n                    return;\r\n                }\r\n            }\r\n            try {\r\n                this._func = new Function("A", "B", "C", "DATA", "node", code);\r\n            } catch (err) {\r\n                console.error("Error parsing script");\r\n                console.error(err);\r\n            }\r\n        }\r\n    };\r\n\r\n    NodeScript.prototype.onExecute = function() {\r\n        if (!this._func) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            var A = this.getInputData(0);\r\n            var B = this.getInputData(1);\r\n            var C = this.getInputData(2);\r\n            this.setOutputData(0, this._func(A, B, C, this.data, this));\r\n        } catch (err) {\r\n            console.error("Error in script");\r\n            console.error(err);\r\n        }\r\n    };\r\n\r\n    NodeScript.prototype.onGetOutputs = function() {\r\n        return [["C", ""]];\r\n    };\r\n\r\n    LiteGraph.registerNodeType("basic/script", NodeScript);\r\n    \r\n    \r\n    function GenericCompare() {\r\n        this.addInput("A", 0);\r\n        this.addInput("B", 0);\r\n        this.addOutput("true", "boolean");\r\n        this.addOutput("false", "boolean");\r\n        this.addProperty("A", 1);\r\n        this.addProperty("B", 1);\r\n        this.addProperty("OP", "==", "enum", { values: GenericCompare.values });\r\n\t\tthis.addWidget("combo","Op.",this.properties.OP,{ property: "OP", values: GenericCompare.values } );\r\n\r\n        this.size = [80, 60];\r\n    }\r\n\r\n    GenericCompare.values = ["==", "!="]; //[">", "<", "==", "!=", "<=", ">=", "||", "&&" ];\r\n    GenericCompare["@OP"] = {\r\n        type: "enum",\r\n        title: "operation",\r\n        values: GenericCompare.values\r\n    };\r\n\r\n    GenericCompare.title = "Compare *";\r\n    GenericCompare.desc = "evaluates condition between A and B";\r\n\r\n    GenericCompare.prototype.getTitle = function() {\r\n        return "*A " + this.properties.OP + " *B";\r\n    };\r\n\r\n    GenericCompare.prototype.onExecute = function() {\r\n        var A = this.getInputData(0);\r\n        if (A === undefined) {\r\n            A = this.properties.A;\r\n        } else {\r\n            this.properties.A = A;\r\n        }\r\n\r\n        var B = this.getInputData(1);\r\n        if (B === undefined) {\r\n            B = this.properties.B;\r\n        } else {\r\n            this.properties.B = B;\r\n        }\r\n\r\n        var result = false;\r\n        if (typeof A == typeof B){\r\n            switch (this.properties.OP) {\r\n                case "==":\r\n                case "!=":\r\n                    // traverse both objects.. consider that this is not a true deep check! consider underscore or other library for thath :: _isEqual()\r\n                    result = true;\r\n                    switch(typeof A){\r\n                        case "object":\r\n                            var aProps = Object.getOwnPropertyNames(A);\r\n                            var bProps = Object.getOwnPropertyNames(B);\r\n                            if (aProps.length != bProps.length){\r\n                                result = false;\r\n                                break;\r\n                            }\r\n                            for (var i = 0; i < aProps.length; i++) {\r\n                                var propName = aProps[i];\r\n                                if (A[propName] !== B[propName]) {\r\n                                    result = false;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        break;\r\n                        default:\r\n                            result = A == B;\r\n                    }\r\n                    if (this.properties.OP == "!=") result = !result;\r\n                    break;\r\n                /*case ">":\r\n                    result = A > B;\r\n                    break;\r\n                case "<":\r\n                    result = A < B;\r\n                    break;\r\n                case "<=":\r\n                    result = A <= B;\r\n                    break;\r\n                case ">=":\r\n                    result = A >= B;\r\n                    break;\r\n                case "||":\r\n                    result = A || B;\r\n                    break;\r\n                case "&&":\r\n                    result = A && B;\r\n                    break;*/\r\n            }\r\n        }\r\n        this.setOutputData(0, result);\r\n        this.setOutputData(1, !result);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("basic/CompareValues", GenericCompare);\r\n    \r\n})(this);\r\n\n//event related nodes\r\n(function(global) {\r\n    var LiteGraph = global.LiteGraph;\r\n\r\n    //Show value inside the debug console\r\n    function LogEvent() {\r\n        this.size = [60, 30];\r\n        this.addInput("event", LiteGraph.ACTION);\r\n    }\r\n\r\n    LogEvent.title = "Log Event";\r\n    LogEvent.desc = "Log event in console";\r\n\r\n    LogEvent.prototype.onAction = function(action, param, options) {\r\n        console.log(action, param);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("events/log", LogEvent);\r\n\r\n    //convert to Event if the value is true\r\n    function TriggerEvent() {\r\n        this.size = [60, 30];\r\n        this.addInput("if", "");\r\n        this.addOutput("true", LiteGraph.EVENT);\r\n        this.addOutput("change", LiteGraph.EVENT);\r\n        this.addOutput("false", LiteGraph.EVENT);\r\n\t\tthis.properties = { only_on_change: true };\r\n\t\tthis.prev = 0;\r\n    }\r\n\r\n    TriggerEvent.title = "TriggerEvent";\r\n    TriggerEvent.desc = "Triggers event if input evaluates to true";\r\n\r\n    TriggerEvent.prototype.onExecute = function( param, options) {\r\n\t\tvar v = this.getInputData(0);\r\n\t\tvar changed = (v != this.prev);\r\n\t\tif(this.prev === 0)\r\n\t\t\tchanged = false;\r\n\t\tvar must_resend = (changed && this.properties.only_on_change) || (!changed && !this.properties.only_on_change);\r\n\t\tif(v && must_resend )\r\n\t        this.triggerSlot(0, param, null, options);\r\n\t\tif(!v && must_resend)\r\n\t        this.triggerSlot(2, param, null, options);\r\n\t\tif(changed)\r\n\t        this.triggerSlot(1, param, null, options);\r\n\t\tthis.prev = v;\r\n    };\r\n\r\n    LiteGraph.registerNodeType("events/trigger", TriggerEvent);\r\n\r\n    //Sequence of events\r\n    function Sequence() {\r\n\t\tvar that = this;\r\n        this.addInput("", LiteGraph.ACTION);\r\n        this.addInput("", LiteGraph.ACTION);\r\n        this.addInput("", LiteGraph.ACTION);\r\n        this.addOutput("", LiteGraph.EVENT);\r\n        this.addOutput("", LiteGraph.EVENT);\r\n        this.addOutput("", LiteGraph.EVENT);\r\n        this.addWidget("button","+",null,function(){\r\n\t        that.addInput("", LiteGraph.ACTION);\r\n\t        that.addOutput("", LiteGraph.EVENT);\r\n        });\r\n        this.size = [90, 70];\r\n        this.flags = { horizontal: true, render_box: false };\r\n    }\r\n\r\n    Sequence.title = "Sequence";\r\n    Sequence.desc = "Triggers a sequence of events when an event arrives";\r\n\r\n    Sequence.prototype.getTitle = function() {\r\n        return "";\r\n    };\r\n\r\n    Sequence.prototype.onAction = function(action, param, options) {\r\n        if (this.outputs) {\r\n            options = options || {};\r\n            for (var i = 0; i < this.outputs.length; ++i) {\r\n\t\t\t\tvar output = this.outputs[i];\r\n\t\t\t\t//needs more info about this...\r\n\t\t\t\tif( options.action_call ) // CREATE A NEW ID FOR THE ACTION\r\n\t                options.action_call = options.action_call + "_seq_" + i;\r\n\t\t\t\telse\r\n\t\t\t\t\toptions.action_call = this.id + "_" + (action ? action : "action")+"_seq_"+i+"_"+Math.floor(Math.random()*9999);\r\n                this.triggerSlot(i, param, null, options);\r\n            }\r\n        }\r\n    };\r\n\r\n    LiteGraph.registerNodeType("events/sequence", Sequence);\r\n\r\n\r\n   //Sequence of events\r\n   function WaitAll() {\r\n    var that = this;\r\n    this.addInput("", LiteGraph.ACTION);\r\n    this.addInput("", LiteGraph.ACTION);\r\n    this.addOutput("", LiteGraph.EVENT);\r\n    this.addWidget("button","+",null,function(){\r\n        that.addInput("", LiteGraph.ACTION);\r\n        that.size[0] = 90;\r\n    });\r\n    this.size = [90, 70];\r\n    this.ready = [];\r\n}\r\n\r\nWaitAll.title = "WaitAll";\r\nWaitAll.desc = "Wait until all input events arrive then triggers output";\r\n\r\nWaitAll.prototype.getTitle = function() {\r\n    return "";\r\n};\r\n\r\nWaitAll.prototype.onDrawBackground = function(ctx)\r\n{\r\n    if (this.flags.collapsed) {\r\n        return;\r\n    }\r\n    for(var i = 0; i < this.inputs.length; ++i)\r\n    {\r\n        var y = i * LiteGraph.NODE_SLOT_HEIGHT + 10;\r\n        ctx.fillStyle = this.ready[i] ? "#AFB" : "#000";\r\n        ctx.fillRect(20, y, 10, 10);\r\n    }\r\n}\r\n\r\nWaitAll.prototype.onAction = function(action, param, options, slot_index) {\r\n    if(slot_index == null)\r\n        return;\r\n\r\n    //check all\r\n    this.ready.length = this.outputs.length;\r\n    this.ready[slot_index] = true;\r\n    for(var i = 0; i < this.ready.length;++i)\r\n        if(!this.ready[i])\r\n            return;\r\n    //pass\r\n    this.reset();\r\n    this.triggerSlot(0);\r\n};\r\n\r\nWaitAll.prototype.reset = function()\r\n{\r\n    this.ready.length = 0;\r\n}\r\n\r\nLiteGraph.registerNodeType("events/waitAll", WaitAll);    \r\n\r\n\r\n    //Sequencer for events\r\n    function Stepper() {\r\n\t\tvar that = this;\r\n\t\tthis.properties = { index: 0 };\r\n        this.addInput("index", "number");\r\n        this.addInput("step", LiteGraph.ACTION);\r\n        this.addInput("reset", LiteGraph.ACTION);\r\n        this.addOutput("index", "number");\r\n        this.addOutput("", LiteGraph.EVENT);\r\n        this.addOutput("", LiteGraph.EVENT);\r\n        this.addOutput("", LiteGraph.EVENT,{removable:true});\r\n        this.addWidget("button","+",null,function(){\r\n\t        that.addOutput("", LiteGraph.EVENT, {removable:true});\r\n        });\r\n        this.size = [120, 120];\r\n        this.flags = { render_box: false };\r\n    }\r\n\r\n    Stepper.title = "Stepper";\r\n    Stepper.desc = "Trigger events sequentially when an tick arrives";\r\n\r\n\tStepper.prototype.onDrawBackground = function(ctx)\r\n\t{\r\n        if (this.flags.collapsed) {\r\n            return;\r\n        }\r\n\t\tvar index = this.properties.index || 0;\r\n        ctx.fillStyle = "#AFB";\r\n\t\tvar w = this.size[0];\r\n        var y = (index + 1)* LiteGraph.NODE_SLOT_HEIGHT + 4;\r\n        ctx.beginPath();\r\n        ctx.moveTo(w - 30, y);\r\n        ctx.lineTo(w - 30, y + LiteGraph.NODE_SLOT_HEIGHT);\r\n        ctx.lineTo(w - 15, y + LiteGraph.NODE_SLOT_HEIGHT * 0.5);\r\n        ctx.fill();\r\n\t}\r\n\r\n\tStepper.prototype.onExecute = function()\r\n\t{\r\n\t\tvar index = this.getInputData(0);\r\n\t\tif(index != null)\r\n\t\t{\r\n\t\t\tindex = Math.floor(index);\r\n\t\t\tindex = clamp( index, 0, this.outputs ? (this.outputs.length - 2) : 0 );\r\n\t\t\tif( index != this.properties.index )\r\n\t\t\t{\r\n\t\t\t\tthis.properties.index = index;\r\n\t\t\t    this.triggerSlot( index+1 );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.setOutputData(0, this.properties.index );\r\n\t}\r\n\r\n    Stepper.prototype.onAction = function(action, param) {\r\n\t\tif(action == "reset")\r\n\t\t\tthis.properties.index = 0;\r\n\t\telse if(action == "step")\r\n\t\t{\r\n            this.triggerSlot(this.properties.index+1, param);\r\n\t\t\tvar n = this.outputs ? this.outputs.length - 1 : 0;\r\n\t\t\tthis.properties.index = (this.properties.index + 1) % n;\r\n        }\r\n    };\r\n\r\n    LiteGraph.registerNodeType("events/stepper", Stepper);\r\n\r\n    //Filter events\r\n    function FilterEvent() {\r\n        this.size = [60, 30];\r\n        this.addInput("event", LiteGraph.ACTION);\r\n        this.addOutput("event", LiteGraph.EVENT);\r\n        this.properties = {\r\n            equal_to: "",\r\n            has_property: "",\r\n            property_equal_to: ""\r\n        };\r\n    }\r\n\r\n    FilterEvent.title = "Filter Event";\r\n    FilterEvent.desc = "Blocks events that do not match the filter";\r\n\r\n    FilterEvent.prototype.onAction = function(action, param, options) {\r\n        if (param == null) {\r\n            return;\r\n        }\r\n\r\n        if (this.properties.equal_to && this.properties.equal_to != param) {\r\n            return;\r\n        }\r\n\r\n        if (this.properties.has_property) {\r\n            var prop = param[this.properties.has_property];\r\n            if (prop == null) {\r\n                return;\r\n            }\r\n\r\n            if (\r\n                this.properties.property_equal_to &&\r\n                this.properties.property_equal_to != prop\r\n            ) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.triggerSlot(0, param, null, options);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("events/filter", FilterEvent);\r\n\r\n\r\n    function EventBranch() {\r\n        this.addInput("in", LiteGraph.ACTION);\r\n        this.addInput("cond", "boolean");\r\n        this.addOutput("true", LiteGraph.EVENT);\r\n        this.addOutput("false", LiteGraph.EVENT);\r\n        this.size = [120, 60];\r\n\t\tthis._value = false;\r\n    }\r\n\r\n    EventBranch.title = "Branch";\r\n    EventBranch.desc = "If condition is true, outputs triggers true, otherwise false";\r\n\r\n    EventBranch.prototype.onExecute = function() {\r\n\t\tthis._value = this.getInputData(1);\r\n\t}\r\n\r\n    EventBranch.prototype.onAction = function(action, param, options) {\r\n        this._value = this.getInputData(1);\r\n\t\tthis.triggerSlot(this._value ? 0 : 1, param, null, options);\r\n\t}\r\n\r\n    LiteGraph.registerNodeType("events/branch", EventBranch);\r\n\r\n    //Show value inside the debug console\r\n    function EventCounter() {\r\n        this.addInput("inc", LiteGraph.ACTION);\r\n        this.addInput("dec", LiteGraph.ACTION);\r\n        this.addInput("reset", LiteGraph.ACTION);\r\n        this.addOutput("change", LiteGraph.EVENT);\r\n        this.addOutput("num", "number");\r\n        this.addProperty("doCountExecution", false, "boolean", {name: "Count Executions"});\r\n        this.addWidget("toggle","Count Exec.",this.properties.doCountExecution,"doCountExecution");\r\n        this.num = 0;\r\n    }\r\n\r\n    EventCounter.title = "Counter";\r\n    EventCounter.desc = "Counts events";\r\n\r\n    EventCounter.prototype.getTitle = function() {\r\n        if (this.flags.collapsed) {\r\n            return String(this.num);\r\n        }\r\n        return this.title;\r\n    };\r\n\r\n    EventCounter.prototype.onAction = function(action, param, options) {\r\n        var v = this.num;\r\n        if (action == "inc") {\r\n            this.num += 1;\r\n        } else if (action == "dec") {\r\n            this.num -= 1;\r\n        } else if (action == "reset") {\r\n            this.num = 0;\r\n        }\r\n        if (this.num != v) {\r\n            this.trigger("change", this.num);\r\n        }\r\n    };\r\n\r\n    EventCounter.prototype.onDrawBackground = function(ctx) {\r\n        if (this.flags.collapsed) {\r\n            return;\r\n        }\r\n        ctx.fillStyle = "#AAA";\r\n        ctx.font = "20px Arial";\r\n        ctx.textAlign = "center";\r\n        ctx.fillText(this.num, this.size[0] * 0.5, this.size[1] * 0.5);\r\n    };\r\n\r\n    EventCounter.prototype.onExecute = function() {\r\n        if(this.properties.doCountExecution){\r\n            this.num += 1;\r\n        }\r\n        this.setOutputData(1, this.num);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("events/counter", EventCounter);\r\n\r\n    //Show value inside the debug console\r\n    function DelayEvent() {\r\n        this.size = [60, 30];\r\n        this.addProperty("time_in_ms", 1000);\r\n        this.addInput("event", LiteGraph.ACTION);\r\n        this.addOutput("on_time", LiteGraph.EVENT);\r\n\r\n        this._pending = [];\r\n    }\r\n\r\n    DelayEvent.title = "Delay";\r\n    DelayEvent.desc = "Delays one event";\r\n\r\n    DelayEvent.prototype.onAction = function(action, param, options) {\r\n        var time = this.properties.time_in_ms;\r\n        if (time <= 0) {\r\n            this.trigger(null, param, options);\r\n        } else {\r\n            this._pending.push([time, param]);\r\n        }\r\n    };\r\n\r\n    DelayEvent.prototype.onExecute = function(param, options) {\r\n        var dt = this.graph.elapsed_time * 1000; //in ms\r\n\r\n        if (this.isInputConnected(1)) {\r\n            this.properties.time_in_ms = this.getInputData(1);\r\n        }\r\n\r\n        for (var i = 0; i < this._pending.length; ++i) {\r\n            var actionPass = this._pending[i];\r\n            actionPass[0] -= dt;\r\n            if (actionPass[0] > 0) {\r\n                continue;\r\n            }\r\n\r\n            //remove\r\n            this._pending.splice(i, 1);\r\n            --i;\r\n\r\n            //trigger\r\n            this.trigger(null, actionPass[1], options);\r\n        }\r\n    };\r\n\r\n    DelayEvent.prototype.onGetInputs = function() {\r\n        return [["event", LiteGraph.ACTION], ["time_in_ms", "number"]];\r\n    };\r\n\r\n    LiteGraph.registerNodeType("events/delay", DelayEvent);\r\n\r\n    //Show value inside the debug console\r\n    function TimerEvent() {\r\n        this.addProperty("interval", 1000);\r\n        this.addProperty("event", "tick");\r\n        this.addOutput("on_tick", LiteGraph.EVENT);\r\n        this.time = 0;\r\n        this.last_interval = 1000;\r\n        this.triggered = false;\r\n    }\r\n\r\n    TimerEvent.title = "Timer";\r\n    TimerEvent.desc = "Sends an event every N milliseconds";\r\n\r\n    TimerEvent.prototype.onStart = function() {\r\n        this.time = 0;\r\n    };\r\n\r\n    TimerEvent.prototype.getTitle = function() {\r\n        return "Timer: " + this.last_interval.toString() + "ms";\r\n    };\r\n\r\n    TimerEvent.on_color = "#AAA";\r\n    TimerEvent.off_color = "#222";\r\n\r\n    TimerEvent.prototype.onDrawBackground = function() {\r\n        this.boxcolor = this.triggered\r\n            ? TimerEvent.on_color\r\n            : TimerEvent.off_color;\r\n        this.triggered = false;\r\n    };\r\n\r\n    TimerEvent.prototype.onExecute = function() {\r\n        var dt = this.graph.elapsed_time * 1000; //in ms\r\n\r\n        var trigger = this.time == 0;\r\n\r\n        this.time += dt;\r\n        this.last_interval = Math.max(\r\n            1,\r\n            this.getInputOrProperty("interval") | 0\r\n        );\r\n\r\n        if (\r\n            !trigger &&\r\n            (this.time < this.last_interval || isNaN(this.last_interval))\r\n        ) {\r\n            if (this.inputs && this.inputs.length > 1 && this.inputs[1]) {\r\n                this.setOutputData(1, false);\r\n            }\r\n            return;\r\n        }\r\n\r\n        this.triggered = true;\r\n        this.time = this.time % this.last_interval;\r\n        this.trigger("on_tick", this.properties.event);\r\n        if (this.inputs && this.inputs.length > 1 && this.inputs[1]) {\r\n            this.setOutputData(1, true);\r\n        }\r\n    };\r\n\r\n    TimerEvent.prototype.onGetInputs = function() {\r\n        return [["interval", "number"]];\r\n    };\r\n\r\n    TimerEvent.prototype.onGetOutputs = function() {\r\n        return [["tick", "boolean"]];\r\n    };\r\n\r\n    LiteGraph.registerNodeType("events/timer", TimerEvent);\r\n\r\n\r\n\r\n    function SemaphoreEvent() {\r\n        this.addInput("go", LiteGraph.ACTION );\r\n        this.addInput("green", LiteGraph.ACTION );\r\n        this.addInput("red", LiteGraph.ACTION );\r\n        this.addOutput("continue", LiteGraph.EVENT );\r\n        this.addOutput("blocked", LiteGraph.EVENT );\r\n        this.addOutput("is_green", "boolean" );\r\n\t\tthis._ready = false;\r\n\t\tthis.properties = {};\r\n\t\tvar that = this;\r\n\t\tthis.addWidget("button","reset","",function(){\r\n\t\t\tthat._ready = false;\r\n\t\t});\r\n    }\r\n\r\n    SemaphoreEvent.title = "Semaphore Event";\r\n    SemaphoreEvent.desc = "Until both events are not triggered, it doesnt continue.";\r\n\r\n\tSemaphoreEvent.prototype.onExecute = function()\r\n\t{\r\n\t\tthis.setOutputData(1,this._ready);\r\n\t\tthis.boxcolor = this._ready ? "#9F9" : "#FA5";\r\n\t}\r\n\r\n    SemaphoreEvent.prototype.onAction = function(action, param) {\r\n\t\tif( action == "go" )\r\n\t\t\tthis.triggerSlot( this._ready ? 0 : 1 );\r\n\t\telse if( action == "green" )\r\n\t\t\tthis._ready = true;\r\n\t\telse if( action == "red" )\r\n\t\t\tthis._ready = false;\r\n    };\r\n\r\n    LiteGraph.registerNodeType("events/semaphore", SemaphoreEvent);\r\n\r\n    function OnceEvent() {\r\n        this.addInput("in", LiteGraph.ACTION );\r\n        this.addInput("reset", LiteGraph.ACTION );\r\n        this.addOutput("out", LiteGraph.EVENT );\r\n\t\tthis._once = false;\r\n\t\tthis.properties = {};\r\n\t\tvar that = this;\r\n\t\tthis.addWidget("button","reset","",function(){\r\n\t\t\tthat._once = false;\r\n\t\t});\r\n    }\r\n\r\n    OnceEvent.title = "Once";\r\n    OnceEvent.desc = "Only passes an event once, then gets locked";\r\n\r\n    OnceEvent.prototype.onAction = function(action, param) {\r\n\t\tif( action == "in" && !this._once )\r\n\t\t{\r\n\t\t\tthis._once = true;\r\n\t\t\tthis.triggerSlot( 0, param );\r\n\t\t}\r\n\t\telse if( action == "reset" )\r\n\t\t\tthis._once = false;\r\n    };\r\n\r\n    LiteGraph.registerNodeType("events/once", OnceEvent);\r\n\r\n    function DataStore() {\r\n        this.addInput("data", 0);\r\n        this.addInput("assign", LiteGraph.ACTION);\r\n        this.addOutput("data", 0);\r\n\t\tthis._last_value = null;\r\n\t\tthis.properties = { data: null, serialize: true };\r\n\t\tvar that = this;\r\n\t\tthis.addWidget("button","store","",function(){\r\n\t\t\tthat.properties.data = that._last_value;\r\n\t\t});\r\n    }\r\n\r\n    DataStore.title = "Data Store";\r\n    DataStore.desc = "Stores data and only changes when event is received";\r\n\r\n\tDataStore.prototype.onExecute = function()\r\n\t{\r\n\t\tthis._last_value = this.getInputData(0);\r\n\t\tthis.setOutputData(0, this.properties.data );\r\n\t}\r\n\r\n    DataStore.prototype.onAction = function(action, param, options) {\r\n\t\tthis.properties.data = this._last_value;\r\n    };\r\n\r\n\tDataStore.prototype.onSerialize = function(o)\r\n\t{\r\n\t\tif(o.data == null)\r\n\t\t\treturn;\r\n\t\tif(this.properties.serialize == false || (o.data.constructor !== String && o.data.constructor !== Number && o.data.constructor !== Boolean && o.data.constructor !== Array && o.data.constructor !== Object ))\r\n\t\t\to.data = null;\r\n\t}\r\n\r\n    LiteGraph.registerNodeType("basic/data_store", DataStore);\r\n\r\n\r\n\r\n})(this);\r\n\n//widgets\n(function(global) {\n    var LiteGraph = global.LiteGraph;\n\n    /* Button ****************/\n\n    function WidgetButton() {\n        this.addOutput("", LiteGraph.EVENT);\n        this.addOutput("", "boolean");\n        this.addProperty("text", "click me");\n        this.addProperty("font_size", 30);\n        this.addProperty("message", "");\n        this.size = [164, 84];\n        this.clicked = false;\n    }\n\n    WidgetButton.title = "Button";\n    WidgetButton.desc = "Triggers an event";\n\n    WidgetButton.font = "Arial";\n    WidgetButton.prototype.onDrawForeground = function(ctx) {\n        if (this.flags.collapsed) {\n            return;\n        }\n        var margin = 10;\n        ctx.fillStyle = "black";\n        ctx.fillRect(\n            margin + 1,\n            margin + 1,\n            this.size[0] - margin * 2,\n            this.size[1] - margin * 2\n        );\n        ctx.fillStyle = "#AAF";\n        ctx.fillRect(\n            margin - 1,\n            margin - 1,\n            this.size[0] - margin * 2,\n            this.size[1] - margin * 2\n        );\n        ctx.fillStyle = this.clicked\n            ? "white"\n            : this.mouseOver\n            ? "#668"\n            : "#334";\n        ctx.fillRect(\n            margin,\n            margin,\n            this.size[0] - margin * 2,\n            this.size[1] - margin * 2\n        );\n\n        if (this.properties.text || this.properties.text === 0) {\n            var font_size = this.properties.font_size || 30;\n            ctx.textAlign = "center";\n            ctx.fillStyle = this.clicked ? "black" : "white";\n            ctx.font = font_size + "px " + WidgetButton.font;\n            ctx.fillText(\n                this.properties.text,\n                this.size[0] * 0.5,\n                this.size[1] * 0.5 + font_size * 0.3\n            );\n            ctx.textAlign = "left";\n        }\n    };\n\n    WidgetButton.prototype.onMouseDown = function(e, local_pos) {\n        if (\n            local_pos[0] > 1 &&\n            local_pos[1] > 1 &&\n            local_pos[0] < this.size[0] - 2 &&\n            local_pos[1] < this.size[1] - 2\n        ) {\n            this.clicked = true;\n            this.setOutputData(1, this.clicked);\n            this.triggerSlot(0, this.properties.message);\n            return true;\n        }\n    };\n\n    WidgetButton.prototype.onExecute = function() {\n        this.setOutputData(1, this.clicked);\n    };\n\n    WidgetButton.prototype.onMouseUp = function(e) {\n        this.clicked = false;\n    };\n\n    LiteGraph.registerNodeType("widget/button", WidgetButton);\n\n    function WidgetToggle() {\n        this.addInput("", "boolean");\n        this.addInput("e", LiteGraph.ACTION);\n        this.addOutput("v", "boolean");\n        this.addOutput("e", LiteGraph.EVENT);\n        this.properties = { font: "", value: false };\n        this.size = [160, 44];\n    }\n\n    WidgetToggle.title = "Toggle";\n    WidgetToggle.desc = "Toggles between true or false";\n\n    WidgetToggle.prototype.onDrawForeground = function(ctx) {\n        if (this.flags.collapsed) {\n            return;\n        }\n\n        var size = this.size[1] * 0.5;\n        var margin = 0.25;\n        var h = this.size[1] * 0.8;\n        ctx.font = this.properties.font || (size * 0.8).toFixed(0) + "px Arial";\n        var w = ctx.measureText(this.title).width;\n        var x = (this.size[0] - (w + size)) * 0.5;\n\n        ctx.fillStyle = "#AAA";\n        ctx.fillRect(x, h - size, size, size);\n\n        ctx.fillStyle = this.properties.value ? "#AEF" : "#000";\n        ctx.fillRect(\n            x + size * margin,\n            h - size + size * margin,\n            size * (1 - margin * 2),\n            size * (1 - margin * 2)\n        );\n\n        ctx.textAlign = "left";\n        ctx.fillStyle = "#AAA";\n        ctx.fillText(this.title, size * 1.2 + x, h * 0.85);\n        ctx.textAlign = "left";\n    };\n\n    WidgetToggle.prototype.onAction = function(action) {\n        this.properties.value = !this.properties.value;\n        this.trigger("e", this.properties.value);\n    };\n\n    WidgetToggle.prototype.onExecute = function() {\n        var v = this.getInputData(0);\n        if (v != null) {\n            this.properties.value = v;\n        }\n        this.setOutputData(0, this.properties.value);\n    };\n\n    WidgetToggle.prototype.onMouseDown = function(e, local_pos) {\n        if (\n            local_pos[0] > 1 &&\n            local_pos[1] > 1 &&\n            local_pos[0] < this.size[0] - 2 &&\n            local_pos[1] < this.size[1] - 2\n        ) {\n            this.properties.value = !this.properties.value;\n            this.graph._version++;\n            this.trigger("e", this.properties.value);\n            return true;\n        }\n    };\n\n    LiteGraph.registerNodeType("widget/toggle", WidgetToggle);\n\n    /* Number ****************/\n\n    function WidgetNumber() {\n        this.addOutput("", "number");\n        this.size = [80, 60];\n        this.properties = { min: -1000, max: 1000, value: 1, step: 1 };\n        this.old_y = -1;\n        this._remainder = 0;\n        this._precision = 0;\n        this.mouse_captured = false;\n    }\n\n    WidgetNumber.title = "Number";\n    WidgetNumber.desc = "Widget to select number value";\n\n    WidgetNumber.pixels_threshold = 10;\n    WidgetNumber.markers_color = "#666";\n\n    WidgetNumber.prototype.onDrawForeground = function(ctx) {\n        var x = this.size[0] * 0.5;\n        var h = this.size[1];\n        if (h > 30) {\n            ctx.fillStyle = WidgetNumber.markers_color;\n            ctx.beginPath();\n            ctx.moveTo(x, h * 0.1);\n            ctx.lineTo(x + h * 0.1, h * 0.2);\n            ctx.lineTo(x + h * -0.1, h * 0.2);\n            ctx.fill();\n            ctx.beginPath();\n            ctx.moveTo(x, h * 0.9);\n            ctx.lineTo(x + h * 0.1, h * 0.8);\n            ctx.lineTo(x + h * -0.1, h * 0.8);\n            ctx.fill();\n            ctx.font = (h * 0.7).toFixed(1) + "px Arial";\n        } else {\n            ctx.font = (h * 0.8).toFixed(1) + "px Arial";\n        }\n\n        ctx.textAlign = "center";\n        ctx.font = (h * 0.7).toFixed(1) + "px Arial";\n        ctx.fillStyle = "#EEE";\n        ctx.fillText(\n            this.properties.value.toFixed(this._precision),\n            x,\n            h * 0.75\n        );\n    };\n\n    WidgetNumber.prototype.onExecute = function() {\n        this.setOutputData(0, this.properties.value);\n    };\n\n    WidgetNumber.prototype.onPropertyChanged = function(name, value) {\n        var t = (this.properties.step + "").split(".");\n        this._precision = t.length > 1 ? t[1].length : 0;\n    };\n\n    WidgetNumber.prototype.onMouseDown = function(e, pos) {\n        if (pos[1] < 0) {\n            return;\n        }\n\n        this.old_y = e.canvasY;\n        this.captureInput(true);\n        this.mouse_captured = true;\n\n        return true;\n    };\n\n    WidgetNumber.prototype.onMouseMove = function(e) {\n        if (!this.mouse_captured) {\n            return;\n        }\n\n        var delta = this.old_y - e.canvasY;\n        if (e.shiftKey) {\n            delta *= 10;\n        }\n        if (e.metaKey || e.altKey) {\n            delta *= 0.1;\n        }\n        this.old_y = e.canvasY;\n\n        var steps = this._remainder + delta / WidgetNumber.pixels_threshold;\n        this._remainder = steps % 1;\n        steps = steps | 0;\n\n        var v = clamp(\n            this.properties.value + steps * this.properties.step,\n            this.properties.min,\n            this.properties.max\n        );\n        this.properties.value = v;\n        this.graph._version++;\n        this.setDirtyCanvas(true);\n    };\n\n    WidgetNumber.prototype.onMouseUp = function(e, pos) {\n        if (e.click_time < 200) {\n            var steps = pos[1] > this.size[1] * 0.5 ? -1 : 1;\n            this.properties.value = clamp(\n                this.properties.value + steps * this.properties.step,\n                this.properties.min,\n                this.properties.max\n            );\n            this.graph._version++;\n            this.setDirtyCanvas(true);\n        }\n\n        if (this.mouse_captured) {\n            this.mouse_captured = false;\n            this.captureInput(false);\n        }\n    };\n\n    LiteGraph.registerNodeType("widget/number", WidgetNumber);\n\n\n    /* Combo ****************/\n\n    function WidgetCombo() {\n        this.addOutput("", "string");\n        this.addOutput("change", LiteGraph.EVENT);\n        this.size = [80, 60];\n        this.properties = { value: "A", values:"A;B;C" };\n        this.old_y = -1;\n        this.mouse_captured = false;\n\t\tthis._values = this.properties.values.split(";");\n\t\tvar that = this;\n        this.widgets_up = true;\n\t\tthis.widget = this.addWidget("combo","", this.properties.value, function(v){\n\t\t\tthat.properties.value = v;\n            that.triggerSlot(1, v);\n\t\t}, { property: "value", values: this._values } );\n    }\n\n    WidgetCombo.title = "Combo";\n    WidgetCombo.desc = "Widget to select from a list";\n\n    WidgetCombo.prototype.onExecute = function() {\n        this.setOutputData( 0, this.properties.value );\n    };\n\n    WidgetCombo.prototype.onPropertyChanged = function(name, value) {\n\t\tif(name == "values")\n\t\t{\n\t\t\tthis._values = value.split(";");\n\t\t\tthis.widget.options.values = this._values;\n\t\t}\n\t\telse if(name == "value")\n\t\t{\n\t\t\tthis.widget.value = value;\n\t\t}\n\t};\n\n    LiteGraph.registerNodeType("widget/combo", WidgetCombo);\n\n\n    /* Knob ****************/\n\n    function WidgetKnob() {\n        this.addOutput("", "number");\n        this.size = [64, 84];\n        this.properties = {\n            min: 0,\n            max: 1,\n            value: 0.5,\n            color: "#7AF",\n            precision: 2\n        };\n        this.value = -1;\n    }\n\n    WidgetKnob.title = "Knob";\n    WidgetKnob.desc = "Circular controller";\n    WidgetKnob.size = [80, 100];\n\n    WidgetKnob.prototype.onDrawForeground = function(ctx) {\n        if (this.flags.collapsed) {\n            return;\n        }\n\n        if (this.value == -1) {\n            this.value =\n                (this.properties.value - this.properties.min) /\n                (this.properties.max - this.properties.min);\n        }\n\n        var center_x = this.size[0] * 0.5;\n        var center_y = this.size[1] * 0.5;\n        var radius = Math.min(this.size[0], this.size[1]) * 0.5 - 5;\n        var w = Math.floor(radius * 0.05);\n\n        ctx.globalAlpha = 1;\n        ctx.save();\n        ctx.translate(center_x, center_y);\n        ctx.rotate(Math.PI * 0.75);\n\n        //bg\n        ctx.fillStyle = "rgba(0,0,0,0.5)";\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.arc(0, 0, radius, 0, Math.PI * 1.5);\n        ctx.fill();\n\n        //value\n        ctx.strokeStyle = "black";\n        ctx.fillStyle = this.properties.color;\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.arc(\n            0,\n            0,\n            radius - 4,\n            0,\n            Math.PI * 1.5 * Math.max(0.01, this.value)\n        );\n        ctx.closePath();\n        ctx.fill();\n        //ctx.stroke();\n        ctx.lineWidth = 1;\n        ctx.globalAlpha = 1;\n        ctx.restore();\n\n        //inner\n        ctx.fillStyle = "black";\n        ctx.beginPath();\n        ctx.arc(center_x, center_y, radius * 0.75, 0, Math.PI * 2, true);\n        ctx.fill();\n\n        //miniball\n        ctx.fillStyle = this.mouseOver ? "white" : this.properties.color;\n        ctx.beginPath();\n        var angle = this.value * Math.PI * 1.5 + Math.PI * 0.75;\n        ctx.arc(\n            center_x + Math.cos(angle) * radius * 0.65,\n            center_y + Math.sin(angle) * radius * 0.65,\n            radius * 0.05,\n            0,\n            Math.PI * 2,\n            true\n        );\n        ctx.fill();\n\n        //text\n        ctx.fillStyle = this.mouseOver ? "white" : "#AAA";\n        ctx.font = Math.floor(radius * 0.5) + "px Arial";\n        ctx.textAlign = "center";\n        ctx.fillText(\n            this.properties.value.toFixed(this.properties.precision),\n            center_x,\n            center_y + radius * 0.15\n        );\n    };\n\n    WidgetKnob.prototype.onExecute = function() {\n        this.setOutputData(0, this.properties.value);\n        this.boxcolor = LiteGraph.colorToString([\n            this.value,\n            this.value,\n            this.value\n        ]);\n    };\n\n    WidgetKnob.prototype.onMouseDown = function(e) {\n        this.center = [this.size[0] * 0.5, this.size[1] * 0.5 + 20];\n        this.radius = this.size[0] * 0.5;\n        if (\n            e.canvasY - this.pos[1] < 20 ||\n            LiteGraph.distance(\n                [e.canvasX, e.canvasY],\n                [this.pos[0] + this.center[0], this.pos[1] + this.center[1]]\n            ) > this.radius\n        ) {\n            return false;\n        }\n        this.oldmouse = [e.canvasX - this.pos[0], e.canvasY - this.pos[1]];\n        this.captureInput(true);\n        return true;\n    };\n\n    WidgetKnob.prototype.onMouseMove = function(e) {\n        if (!this.oldmouse) {\n            return;\n        }\n\n        var m = [e.canvasX - this.pos[0], e.canvasY - this.pos[1]];\n\n        var v = this.value;\n        v -= (m[1] - this.oldmouse[1]) * 0.01;\n        if (v > 1.0) {\n            v = 1.0;\n        } else if (v < 0.0) {\n            v = 0.0;\n        }\n        this.value = v;\n        this.properties.value =\n            this.properties.min +\n            (this.properties.max - this.properties.min) * this.value;\n        this.oldmouse = m;\n        this.setDirtyCanvas(true);\n    };\n\n    WidgetKnob.prototype.onMouseUp = function(e) {\n        if (this.oldmouse) {\n            this.oldmouse = null;\n            this.captureInput(false);\n        }\n    };\n\n    WidgetKnob.prototype.onPropertyChanged = function(name, value) {\n        if (name == "min" || name == "max" || name == "value") {\n            this.properties[name] = parseFloat(value);\n            return true; //block\n        }\n    };\n\n    LiteGraph.registerNodeType("widget/knob", WidgetKnob);\n\n    //Show value inside the debug console\n    function WidgetSliderGUI() {\n        this.addOutput("", "number");\n        this.properties = {\n            value: 0.5,\n            min: 0,\n            max: 1,\n            text: "V"\n        };\n        var that = this;\n        this.size = [140, 40];\n        this.slider = this.addWidget(\n            "slider",\n            "V",\n            this.properties.value,\n            function(v) {\n                that.properties.value = v;\n            },\n            this.properties\n        );\n        this.widgets_up = true;\n    }\n\n    WidgetSliderGUI.title = "Inner Slider";\n\n    WidgetSliderGUI.prototype.onPropertyChanged = function(name, value) {\n        if (name == "value") {\n            this.slider.value = value;\n        }\n    };\n\n    WidgetSliderGUI.prototype.onExecute = function() {\n        this.setOutputData(0, this.properties.value);\n    };\n\n    LiteGraph.registerNodeType("widget/internal_slider", WidgetSliderGUI);\n\n    //Widget H SLIDER\n    function WidgetHSlider() {\n        this.size = [160, 26];\n        this.addOutput("", "number");\n        this.properties = { color: "#7AF", min: 0, max: 1, value: 0.5 };\n        this.value = -1;\n    }\n\n    WidgetHSlider.title = "H.Slider";\n    WidgetHSlider.desc = "Linear slider controller";\n\n    WidgetHSlider.prototype.onDrawForeground = function(ctx) {\n        if (this.value == -1) {\n            this.value =\n                (this.properties.value - this.properties.min) /\n                (this.properties.max - this.properties.min);\n        }\n\n        //border\n        ctx.globalAlpha = 1;\n        ctx.lineWidth = 1;\n        ctx.fillStyle = "#000";\n        ctx.fillRect(2, 2, this.size[0] - 4, this.size[1] - 4);\n\n        ctx.fillStyle = this.properties.color;\n        ctx.beginPath();\n        ctx.rect(4, 4, (this.size[0] - 8) * this.value, this.size[1] - 8);\n        ctx.fill();\n    };\n\n    WidgetHSlider.prototype.onExecute = function() {\n        this.properties.value =\n            this.properties.min +\n            (this.properties.max - this.properties.min) * this.value;\n        this.setOutputData(0, this.properties.value);\n        this.boxcolor = LiteGraph.colorToString([\n            this.value,\n            this.value,\n            this.value\n        ]);\n    };\n\n    WidgetHSlider.prototype.onMouseDown = function(e) {\n        if (e.canvasY - this.pos[1] < 0) {\n            return false;\n        }\n\n        this.oldmouse = [e.canvasX - this.pos[0], e.canvasY - this.pos[1]];\n        this.captureInput(true);\n        return true;\n    };\n\n    WidgetHSlider.prototype.onMouseMove = function(e) {\n        if (!this.oldmouse) {\n            return;\n        }\n\n        var m = [e.canvasX - this.pos[0], e.canvasY - this.pos[1]];\n\n        var v = this.value;\n        var delta = m[0] - this.oldmouse[0];\n        v += delta / this.size[0];\n        if (v > 1.0) {\n            v = 1.0;\n        } else if (v < 0.0) {\n            v = 0.0;\n        }\n\n        this.value = v;\n\n        this.oldmouse = m;\n        this.setDirtyCanvas(true);\n    };\n\n    WidgetHSlider.prototype.onMouseUp = function(e) {\n        this.oldmouse = null;\n        this.captureInput(false);\n    };\n\n    WidgetHSlider.prototype.onMouseLeave = function(e) {\n        //this.oldmouse = null;\n    };\n\n    LiteGraph.registerNodeType("widget/hslider", WidgetHSlider);\n\n    function WidgetProgress() {\n        this.size = [160, 26];\n        this.addInput("", "number");\n        this.properties = { min: 0, max: 1, value: 0, color: "#AAF" };\n    }\n\n    WidgetProgress.title = "Progress";\n    WidgetProgress.desc = "Shows data in linear progress";\n\n    WidgetProgress.prototype.onExecute = function() {\n        var v = this.getInputData(0);\n        if (v != undefined) {\n            this.properties["value"] = v;\n        }\n    };\n\n    WidgetProgress.prototype.onDrawForeground = function(ctx) {\n        //border\n        ctx.lineWidth = 1;\n        ctx.fillStyle = this.properties.color;\n        var v =\n            (this.properties.value - this.properties.min) /\n            (this.properties.max - this.properties.min);\n        v = Math.min(1, v);\n        v = Math.max(0, v);\n        ctx.fillRect(2, 2, (this.size[0] - 4) * v, this.size[1] - 4);\n    };\n\n    LiteGraph.registerNodeType("widget/progress", WidgetProgress);\n\n    function WidgetText() {\n        this.addInputs("", 0);\n        this.properties = {\n            value: "...",\n            font: "Arial",\n            fontsize: 18,\n            color: "#AAA",\n            align: "left",\n            glowSize: 0,\n            decimals: 1\n        };\n    }\n\n    WidgetText.title = "Text";\n    WidgetText.desc = "Shows the input value";\n    WidgetText.widgets = [\n        { name: "resize", text: "Resize box", type: "button" },\n        { name: "led_text", text: "LED", type: "minibutton" },\n        { name: "normal_text", text: "Normal", type: "minibutton" }\n    ];\n\n    WidgetText.prototype.onDrawForeground = function(ctx) {\n        //ctx.fillStyle="#000";\n        //ctx.fillRect(0,0,100,60);\n        ctx.fillStyle = this.properties["color"];\n        var v = this.properties["value"];\n\n        if (this.properties["glowSize"]) {\n            ctx.shadowColor = this.properties.color;\n            ctx.shadowOffsetX = 0;\n            ctx.shadowOffsetY = 0;\n            ctx.shadowBlur = this.properties["glowSize"];\n        } else {\n            ctx.shadowColor = "transparent";\n        }\n\n        var fontsize = this.properties["fontsize"];\n\n        ctx.textAlign = this.properties["align"];\n        ctx.font = fontsize.toString() + "px " + this.properties["font"];\n        this.str =\n            typeof v == "number" ? v.toFixed(this.properties["decimals"]) : v;\n\n        if (typeof this.str == "string") {\n            var lines = this.str.replace(/[\\r\\n]/g, "\\\\n").split("\\\\n");\n            for (var i=0; i < lines.length; i++) {\n                ctx.fillText(\n                    lines[i],\n                    this.properties["align"] == "left" ? 15 : this.size[0] - 15,\n                    fontsize * -0.15 + fontsize * (parseInt(i) + 1)\n                );\n            }\n        }\n\n        ctx.shadowColor = "transparent";\n        this.last_ctx = ctx;\n        ctx.textAlign = "left";\n    };\n\n    WidgetText.prototype.onExecute = function() {\n        var v = this.getInputData(0);\n        if (v != null) {\n            this.properties["value"] = v;\n        }\n        //this.setDirtyCanvas(true);\n    };\n\n    WidgetText.prototype.resize = function() {\n        if (!this.last_ctx) {\n            return;\n        }\n\n        var lines = this.str.split("\\\\n");\n        this.last_ctx.font =\n            this.properties["fontsize"] + "px " + this.properties["font"];\n        var max = 0;\n        for (var i=0; i < lines.length; i++) {\n            var w = this.last_ctx.measureText(lines[i]).width;\n            if (max < w) {\n                max = w;\n            }\n        }\n        this.size[0] = max + 20;\n        this.size[1] = 4 + lines.length * this.properties["fontsize"];\n\n        this.setDirtyCanvas(true);\n    };\n\n    WidgetText.prototype.onPropertyChanged = function(name, value) {\n        this.properties[name] = value;\n        this.str = typeof value == "number" ? value.toFixed(3) : value;\n        //this.resize();\n        return true;\n    };\n\n    LiteGraph.registerNodeType("widget/text", WidgetText);\n\n    function WidgetPanel() {\n        this.size = [200, 100];\n        this.properties = {\n            borderColor: "#ffffff",\n            bgcolorTop: "#f0f0f0",\n            bgcolorBottom: "#e0e0e0",\n            shadowSize: 2,\n            borderRadius: 3\n        };\n    }\n\n    WidgetPanel.title = "Panel";\n    WidgetPanel.desc = "Non interactive panel";\n    WidgetPanel.widgets = [{ name: "update", text: "Update", type: "button" }];\n\n    WidgetPanel.prototype.createGradient = function(ctx) {\n        if (\n            this.properties["bgcolorTop"] == "" ||\n            this.properties["bgcolorBottom"] == ""\n        ) {\n            this.lineargradient = 0;\n            return;\n        }\n\n        this.lineargradient = ctx.createLinearGradient(0, 0, 0, this.size[1]);\n        this.lineargradient.addColorStop(0, this.properties["bgcolorTop"]);\n        this.lineargradient.addColorStop(1, this.properties["bgcolorBottom"]);\n    };\n\n    WidgetPanel.prototype.onDrawForeground = function(ctx) {\n        if (this.flags.collapsed) {\n            return;\n        }\n\n        if (this.lineargradient == null) {\n            this.createGradient(ctx);\n        }\n\n        if (!this.lineargradient) {\n            return;\n        }\n\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = this.properties["borderColor"];\n        //ctx.fillStyle = "#ebebeb";\n        ctx.fillStyle = this.lineargradient;\n\n        if (this.properties["shadowSize"]) {\n            ctx.shadowColor = "#000";\n            ctx.shadowOffsetX = 0;\n            ctx.shadowOffsetY = 0;\n            ctx.shadowBlur = this.properties["shadowSize"];\n        } else {\n            ctx.shadowColor = "transparent";\n        }\n\n        ctx.roundRect(\n            0,\n            0,\n            this.size[0] - 1,\n            this.size[1] - 1,\n            this.properties["shadowSize"]\n        );\n        ctx.fill();\n        ctx.shadowColor = "transparent";\n        ctx.stroke();\n    };\n\n    LiteGraph.registerNodeType("widget/panel", WidgetPanel);\n})(this);\n\n(function(global) {\r\n    var LiteGraph = global.LiteGraph;\r\n\r\n    function GamepadInput() {\r\n        this.addOutput("left_x_axis", "number");\r\n        this.addOutput("left_y_axis", "number");\r\n        this.addOutput("button_pressed", LiteGraph.EVENT);\r\n        this.properties = { gamepad_index: 0, threshold: 0.1 };\r\n\r\n        this._left_axis = new Float32Array(2);\r\n        this._right_axis = new Float32Array(2);\r\n        this._triggers = new Float32Array(2);\r\n        this._previous_buttons = new Uint8Array(17);\r\n        this._current_buttons = new Uint8Array(17);\r\n    }\r\n\r\n    GamepadInput.title = "Gamepad";\r\n    GamepadInput.desc = "gets the input of the gamepad";\r\n\r\n    GamepadInput.CENTER = 0;\r\n    GamepadInput.LEFT = 1;\r\n    GamepadInput.RIGHT = 2;\r\n    GamepadInput.UP = 4;\r\n    GamepadInput.DOWN = 8;\r\n\r\n    GamepadInput.zero = new Float32Array(2);\r\n    GamepadInput.buttons = [\r\n        "a",\r\n        "b",\r\n        "x",\r\n        "y",\r\n        "lb",\r\n        "rb",\r\n        "lt",\r\n        "rt",\r\n        "back",\r\n        "start",\r\n        "ls",\r\n        "rs",\r\n        "home"\r\n    ];\r\n\r\n    GamepadInput.prototype.onExecute = function() {\r\n        //get gamepad\r\n        var gamepad = this.getGamepad();\r\n        var threshold = this.properties.threshold || 0.0;\r\n\r\n        if (gamepad) {\r\n            this._left_axis[0] =\r\n                Math.abs(gamepad.xbox.axes["lx"]) > threshold\r\n                    ? gamepad.xbox.axes["lx"]\r\n                    : 0;\r\n            this._left_axis[1] =\r\n                Math.abs(gamepad.xbox.axes["ly"]) > threshold\r\n                    ? gamepad.xbox.axes["ly"]\r\n                    : 0;\r\n            this._right_axis[0] =\r\n                Math.abs(gamepad.xbox.axes["rx"]) > threshold\r\n                    ? gamepad.xbox.axes["rx"]\r\n                    : 0;\r\n            this._right_axis[1] =\r\n                Math.abs(gamepad.xbox.axes["ry"]) > threshold\r\n                    ? gamepad.xbox.axes["ry"]\r\n                    : 0;\r\n            this._triggers[0] =\r\n                Math.abs(gamepad.xbox.axes["ltrigger"]) > threshold\r\n                    ? gamepad.xbox.axes["ltrigger"]\r\n                    : 0;\r\n            this._triggers[1] =\r\n                Math.abs(gamepad.xbox.axes["rtrigger"]) > threshold\r\n                    ? gamepad.xbox.axes["rtrigger"]\r\n                    : 0;\r\n        }\r\n\r\n        if (this.outputs) {\r\n            for (var i = 0; i < this.outputs.length; i++) {\r\n                var output = this.outputs[i];\r\n                if (!output.links || !output.links.length) {\r\n                    continue;\r\n                }\r\n                var v = null;\r\n\r\n                if (gamepad) {\r\n                    switch (output.name) {\r\n                        case "left_axis":\r\n                            v = this._left_axis;\r\n                            break;\r\n                        case "right_axis":\r\n                            v = this._right_axis;\r\n                            break;\r\n                        case "left_x_axis":\r\n                            v = this._left_axis[0];\r\n                            break;\r\n                        case "left_y_axis":\r\n                            v = this._left_axis[1];\r\n                            break;\r\n                        case "right_x_axis":\r\n                            v = this._right_axis[0];\r\n                            break;\r\n                        case "right_y_axis":\r\n                            v = this._right_axis[1];\r\n                            break;\r\n                        case "trigger_left":\r\n                            v = this._triggers[0];\r\n                            break;\r\n                        case "trigger_right":\r\n                            v = this._triggers[1];\r\n                            break;\r\n                        case "a_button":\r\n                            v = gamepad.xbox.buttons["a"] ? 1 : 0;\r\n                            break;\r\n                        case "b_button":\r\n                            v = gamepad.xbox.buttons["b"] ? 1 : 0;\r\n                            break;\r\n                        case "x_button":\r\n                            v = gamepad.xbox.buttons["x"] ? 1 : 0;\r\n                            break;\r\n                        case "y_button":\r\n                            v = gamepad.xbox.buttons["y"] ? 1 : 0;\r\n                            break;\r\n                        case "lb_button":\r\n                            v = gamepad.xbox.buttons["lb"] ? 1 : 0;\r\n                            break;\r\n                        case "rb_button":\r\n                            v = gamepad.xbox.buttons["rb"] ? 1 : 0;\r\n                            break;\r\n                        case "ls_button":\r\n                            v = gamepad.xbox.buttons["ls"] ? 1 : 0;\r\n                            break;\r\n                        case "rs_button":\r\n                            v = gamepad.xbox.buttons["rs"] ? 1 : 0;\r\n                            break;\r\n                        case "hat_left":\r\n                            v = gamepad.xbox.hatmap & GamepadInput.LEFT;\r\n                            break;\r\n                        case "hat_right":\r\n                            v = gamepad.xbox.hatmap & GamepadInput.RIGHT;\r\n                            break;\r\n                        case "hat_up":\r\n                            v = gamepad.xbox.hatmap & GamepadInput.UP;\r\n                            break;\r\n                        case "hat_down":\r\n                            v = gamepad.xbox.hatmap & GamepadInput.DOWN;\r\n                            break;\r\n                        case "hat":\r\n                            v = gamepad.xbox.hatmap;\r\n                            break;\r\n                        case "start_button":\r\n                            v = gamepad.xbox.buttons["start"] ? 1 : 0;\r\n                            break;\r\n                        case "back_button":\r\n                            v = gamepad.xbox.buttons["back"] ? 1 : 0;\r\n                            break;\r\n                        case "button_pressed":\r\n                            for (\r\n                                var j = 0;\r\n                                j < this._current_buttons.length;\r\n                                ++j\r\n                            ) {\r\n                                if (\r\n                                    this._current_buttons[j] &&\r\n                                    !this._previous_buttons[j]\r\n                                ) {\r\n                                    this.triggerSlot(\r\n                                        i,\r\n                                        GamepadInput.buttons[j]\r\n                                    );\r\n                                }\r\n                            }\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                } else {\r\n                    //if no gamepad is connected, output 0\r\n                    switch (output.name) {\r\n                        case "button_pressed":\r\n                            break;\r\n                        case "left_axis":\r\n                        case "right_axis":\r\n                            v = GamepadInput.zero;\r\n                            break;\r\n                        default:\r\n                            v = 0;\r\n                    }\r\n                }\r\n                this.setOutputData(i, v);\r\n            }\r\n        }\r\n    };\r\n\r\n\tGamepadInput.mapping = {a:0,b:1,x:2,y:3,lb:4,rb:5,lt:6,rt:7,back:8,start:9,ls:10,rs:11 };\r\n\tGamepadInput.mapping_array = ["a","b","x","y","lb","rb","lt","rt","back","start","ls","rs"];\r\n\r\n    GamepadInput.prototype.getGamepad = function() {\r\n        var getGamepads =\r\n            navigator.getGamepads ||\r\n            navigator.webkitGetGamepads ||\r\n            navigator.mozGetGamepads;\r\n        if (!getGamepads) {\r\n            return null;\r\n        }\r\n        var gamepads = getGamepads.call(navigator);\r\n        var gamepad = null;\r\n\r\n        this._previous_buttons.set(this._current_buttons);\r\n\r\n        //pick the first connected\r\n        for (var i = this.properties.gamepad_index; i < 4; i++) {\r\n            if (!gamepads[i]) {\r\n                continue;\r\n            }\r\n            gamepad = gamepads[i];\r\n\r\n            //xbox controller mapping\r\n            var xbox = this.xbox_mapping;\r\n            if (!xbox) {\r\n                xbox = this.xbox_mapping = {\r\n                    axes: [],\r\n                    buttons: {},\r\n                    hat: "",\r\n                    hatmap: GamepadInput.CENTER\r\n                };\r\n            }\r\n\r\n            xbox.axes["lx"] = gamepad.axes[0];\r\n            xbox.axes["ly"] = gamepad.axes[1];\r\n            xbox.axes["rx"] = gamepad.axes[2];\r\n            xbox.axes["ry"] = gamepad.axes[3];\r\n            xbox.axes["ltrigger"] = gamepad.buttons[6].value;\r\n            xbox.axes["rtrigger"] = gamepad.buttons[7].value;\r\n            xbox.hat = "";\r\n            xbox.hatmap = GamepadInput.CENTER;\r\n\r\n            for (var j = 0; j < gamepad.buttons.length; j++) {\r\n                this._current_buttons[j] = gamepad.buttons[j].pressed;\r\n\r\n\t\t\t\tif(j < 12)\r\n\t\t\t\t{\r\n\t\t\t\t\txbox.buttons[ GamepadInput.mapping_array[j] ] = gamepad.buttons[j].pressed;\r\n\t\t\t\t\tif(gamepad.buttons[j].was_pressed)\r\n\t\t\t\t\t\tthis.trigger( GamepadInput.mapping_array[j] + "_button_event" );\r\n\t\t\t\t}\r\n\t\t\t\telse //mapping of XBOX\r\n\t\t\t\t\tswitch ( j ) //I use a switch to ensure that a player with another gamepad could play\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcase 12:\r\n\t\t\t\t\t\t\tif (gamepad.buttons[j].pressed) {\r\n\t\t\t\t\t\t\t\txbox.hat += "up";\r\n\t\t\t\t\t\t\t\txbox.hatmap |= GamepadInput.UP;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 13:\r\n\t\t\t\t\t\t\tif (gamepad.buttons[j].pressed) {\r\n\t\t\t\t\t\t\t\txbox.hat += "down";\r\n\t\t\t\t\t\t\t\txbox.hatmap |= GamepadInput.DOWN;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 14:\r\n\t\t\t\t\t\t\tif (gamepad.buttons[j].pressed) {\r\n\t\t\t\t\t\t\t\txbox.hat += "left";\r\n\t\t\t\t\t\t\t\txbox.hatmap |= GamepadInput.LEFT;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 15:\r\n\t\t\t\t\t\t\tif (gamepad.buttons[j].pressed) {\r\n\t\t\t\t\t\t\t\txbox.hat += "right";\r\n\t\t\t\t\t\t\t\txbox.hatmap |= GamepadInput.RIGHT;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 16:\r\n\t\t\t\t\t\t\txbox.buttons["home"] = gamepad.buttons[j].pressed;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t}\r\n            }\r\n            gamepad.xbox = xbox;\r\n            return gamepad;\r\n        }\r\n    };\r\n\r\n    GamepadInput.prototype.onDrawBackground = function(ctx) {\r\n        if (this.flags.collapsed) {\r\n            return;\r\n        }\r\n\r\n        //render gamepad state?\r\n        var la = this._left_axis;\r\n        var ra = this._right_axis;\r\n        ctx.strokeStyle = "#88A";\r\n        ctx.strokeRect(\r\n            (la[0] + 1) * 0.5 * this.size[0] - 4,\r\n            (la[1] + 1) * 0.5 * this.size[1] - 4,\r\n            8,\r\n            8\r\n        );\r\n        ctx.strokeStyle = "#8A8";\r\n        ctx.strokeRect(\r\n            (ra[0] + 1) * 0.5 * this.size[0] - 4,\r\n            (ra[1] + 1) * 0.5 * this.size[1] - 4,\r\n            8,\r\n            8\r\n        );\r\n        var h = this.size[1] / this._current_buttons.length;\r\n        ctx.fillStyle = "#AEB";\r\n        for (var i = 0; i < this._current_buttons.length; ++i) {\r\n            if (this._current_buttons[i]) {\r\n                ctx.fillRect(0, h * i, 6, h);\r\n            }\r\n        }\r\n    };\r\n\r\n    GamepadInput.prototype.onGetOutputs = function() {\r\n        return [\r\n            ["left_axis", "vec2"],\r\n            ["right_axis", "vec2"],\r\n            ["left_x_axis", "number"],\r\n            ["left_y_axis", "number"],\r\n            ["right_x_axis", "number"],\r\n            ["right_y_axis", "number"],\r\n            ["trigger_left", "number"],\r\n            ["trigger_right", "number"],\r\n            ["a_button", "number"],\r\n            ["b_button", "number"],\r\n            ["x_button", "number"],\r\n            ["y_button", "number"],\r\n            ["lb_button", "number"],\r\n            ["rb_button", "number"],\r\n            ["ls_button", "number"],\r\n            ["rs_button", "number"],\r\n            ["start_button", "number"],\r\n            ["back_button", "number"],\r\n            ["a_button_event", LiteGraph.EVENT ],\r\n            ["b_button_event", LiteGraph.EVENT ],\r\n            ["x_button_event", LiteGraph.EVENT ],\r\n            ["y_button_event", LiteGraph.EVENT ],\r\n            ["lb_button_event", LiteGraph.EVENT ],\r\n            ["rb_button_event", LiteGraph.EVENT ],\r\n            ["ls_button_event", LiteGraph.EVENT ],\r\n            ["rs_button_event", LiteGraph.EVENT ],\r\n            ["start_button_event", LiteGraph.EVENT ],\r\n            ["back_button_event", LiteGraph.EVENT ],\r\n            ["hat_left", "number"],\r\n            ["hat_right", "number"],\r\n            ["hat_up", "number"],\r\n            ["hat_down", "number"],\r\n            ["hat", "number"],\r\n            ["button_pressed", LiteGraph.EVENT]\r\n        ];\r\n    };\r\n\r\n    LiteGraph.registerNodeType("input/gamepad", GamepadInput);\r\n\r\n})(this);\r\n\n(function(global) {\n    var LiteGraph = global.LiteGraph;\n\n    //Converter\n    function Converter() {\n        this.addInput("in", 0);\n\t\tthis.addOutput("out", 0);\n        this.size = [80, 30];\n    }\n\n    Converter.title = "Converter";\n    Converter.desc = "type A to type B";\n\n    Converter.prototype.onExecute = function() {\n        var v = this.getInputData(0);\n        if (v == null) {\n            return;\n        }\n\n        if (this.outputs) {\n            for (var i = 0; i < this.outputs.length; i++) {\n                var output = this.outputs[i];\n                if (!output.links || !output.links.length) {\n                    continue;\n                }\n\n                var result = null;\n                switch (output.name) {\n                    case "number":\n                        result = v.length ? v[0] : parseFloat(v);\n                        break;\n                    case "vec2":\n                    case "vec3":\n                    case "vec4":\n                        var result = null;\n                        var count = 1;\n                        switch (output.name) {\n                            case "vec2":\n                                count = 2;\n                                break;\n                            case "vec3":\n                                count = 3;\n                                break;\n                            case "vec4":\n                                count = 4;\n                                break;\n                        }\n\n                        var result = new Float32Array(count);\n                        if (v.length) {\n                            for (\n                                var j = 0;\n                                j < v.length && j < result.length;\n                                j++\n                            ) {\n                                result[j] = v[j];\n                            }\n                        } else {\n                            result[0] = parseFloat(v);\n                        }\n                        break;\n                }\n                this.setOutputData(i, result);\n            }\n        }\n    };\n\n    Converter.prototype.onGetOutputs = function() {\n        return [\n            ["number", "number"],\n            ["vec2", "vec2"],\n            ["vec3", "vec3"],\n            ["vec4", "vec4"]\n        ];\n    };\n\n    LiteGraph.registerNodeType("math/converter", Converter);\n\n    //Bypass\n    function Bypass() {\n        this.addInput("in");\n        this.addOutput("out");\n        this.size = [80, 30];\n    }\n\n    Bypass.title = "Bypass";\n    Bypass.desc = "removes the type";\n\n    Bypass.prototype.onExecute = function() {\n        var v = this.getInputData(0);\n        this.setOutputData(0, v);\n    };\n\n    LiteGraph.registerNodeType("math/bypass", Bypass);\n\n    function ToNumber() {\n        this.addInput("in");\n        this.addOutput("out");\n    }\n\n    ToNumber.title = "to Number";\n    ToNumber.desc = "Cast to number";\n\n    ToNumber.prototype.onExecute = function() {\n        var v = this.getInputData(0);\n        this.setOutputData(0, Number(v));\n    };\n\n    LiteGraph.registerNodeType("math/to_number", ToNumber);\n\n    function MathRange() {\n        this.addInput("in", "number", { locked: true });\n        this.addOutput("out", "number", { locked: true });\n        this.addOutput("clamped", "number", { locked: true });\n\n        this.addProperty("in", 0);\n        this.addProperty("in_min", 0);\n        this.addProperty("in_max", 1);\n        this.addProperty("out_min", 0);\n        this.addProperty("out_max", 1);\n\n        this.size = [120, 50];\n    }\n\n    MathRange.title = "Range";\n    MathRange.desc = "Convert a number from one range to another";\n\n    MathRange.prototype.getTitle = function() {\n        if (this.flags.collapsed) {\n            return (this._last_v || 0).toFixed(2);\n        }\n        return this.title;\n    };\n\n    MathRange.prototype.onExecute = function() {\n        if (this.inputs) {\n            for (var i = 0; i < this.inputs.length; i++) {\n                var input = this.inputs[i];\n                var v = this.getInputData(i);\n                if (v === undefined) {\n                    continue;\n                }\n                this.properties[input.name] = v;\n            }\n        }\n\n        var v = this.properties["in"];\n        if (v === undefined || v === null || v.constructor !== Number) {\n            v = 0;\n        }\n\n        var in_min = this.properties.in_min;\n        var in_max = this.properties.in_max;\n        var out_min = this.properties.out_min;\n        var out_max = this.properties.out_max;\n\t\t/*\n\t\tif( in_min > in_max )\n\t\t{\n\t\t\tin_min = in_max;\n\t\t\tin_max = this.properties.in_min;\n\t\t}\n\t\tif( out_min > out_max )\n\t\t{\n\t\t\tout_min = out_max;\n\t\t\tout_max = this.properties.out_min;\n\t\t}\n\t\t*/\n\n        this._last_v = ((v - in_min) / (in_max - in_min)) * (out_max - out_min) + out_min;\n        this.setOutputData(0, this._last_v);\n        this.setOutputData(1, clamp( this._last_v, out_min, out_max ));\n    };\n\n    MathRange.prototype.onDrawBackground = function(ctx) {\n        //show the current value\n        if (this._last_v) {\n            this.outputs[0].label = this._last_v.toFixed(3);\n        } else {\n            this.outputs[0].label = "?";\n        }\n    };\n\n    MathRange.prototype.onGetInputs = function() {\n        return [\n            ["in_min", "number"],\n            ["in_max", "number"],\n            ["out_min", "number"],\n            ["out_max", "number"]\n        ];\n    };\n\n    LiteGraph.registerNodeType("math/range", MathRange);\n\n    function MathRand() {\n        this.addOutput("value", "number");\n        this.addProperty("min", 0);\n        this.addProperty("max", 1);\n        this.size = [80, 30];\n    }\n\n    MathRand.title = "Rand";\n    MathRand.desc = "Random number";\n\n    MathRand.prototype.onExecute = function() {\n        if (this.inputs) {\n            for (var i = 0; i < this.inputs.length; i++) {\n                var input = this.inputs[i];\n                var v = this.getInputData(i);\n                if (v === undefined) {\n                    continue;\n                }\n                this.properties[input.name] = v;\n            }\n        }\n\n        var min = this.properties.min;\n        var max = this.properties.max;\n        this._last_v = Math.random() * (max - min) + min;\n        this.setOutputData(0, this._last_v);\n    };\n\n    MathRand.prototype.onDrawBackground = function(ctx) {\n        //show the current value\n        this.outputs[0].label = (this._last_v || 0).toFixed(3);\n    };\n\n    MathRand.prototype.onGetInputs = function() {\n        return [["min", "number"], ["max", "number"]];\n    };\n\n    LiteGraph.registerNodeType("math/rand", MathRand);\n\n    //basic continuous noise\n    function MathNoise() {\n        this.addInput("in", "number");\n        this.addOutput("out", "number");\n        this.addProperty("min", 0);\n        this.addProperty("max", 1);\n        this.addProperty("smooth", true);\n        this.addProperty("seed", 0);\n        this.addProperty("octaves", 1);\n        this.addProperty("persistence", 0.8);\n        this.addProperty("speed", 1);\n        this.size = [90, 30];\n    }\n\n    MathNoise.title = "Noise";\n    MathNoise.desc = "Random number with temporal continuity";\n    MathNoise.data = null;\n\n    MathNoise.getValue = function(f, smooth) {\n        if (!MathNoise.data) {\n            MathNoise.data = new Float32Array(1024);\n            for (var i = 0; i < MathNoise.data.length; ++i) {\n                MathNoise.data[i] = Math.random();\n            }\n        }\n        f = f % 1024;\n        if (f < 0) {\n            f += 1024;\n        }\n        var f_min = Math.floor(f);\n        var f = f - f_min;\n        var r1 = MathNoise.data[f_min];\n        var r2 = MathNoise.data[f_min == 1023 ? 0 : f_min + 1];\n        if (smooth) {\n            f = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n        }\n        return r1 * (1 - f) + r2 * f;\n    };\n\n    MathNoise.prototype.onExecute = function() {\n        var f = this.getInputData(0) || 0;\n\t\tvar iterations = this.properties.octaves || 1;\n\t\tvar r = 0;\n\t\tvar amp = 1;\n\t\tvar seed = this.properties.seed || 0;\n\t\tf += seed;\n\t\tvar speed = this.properties.speed || 1;\n\t\tvar total_amp = 0;\n\t\tfor(var i = 0; i < iterations; ++i)\n\t\t{\n\t\t\tr += MathNoise.getValue(f * (1+i) * speed, this.properties.smooth) * amp;\n\t\t\ttotal_amp += amp;\n\t\t\tamp *= this.properties.persistence;\n\t\t\tif(amp < 0.001)\n\t\t\t\tbreak;\n\t\t}\n\t\tr /= total_amp;\n        var min = this.properties.min;\n        var max = this.properties.max;\n        this._last_v = r * (max - min) + min;\n        this.setOutputData(0, this._last_v);\n    };\n\n    MathNoise.prototype.onDrawBackground = function(ctx) {\n        //show the current value\n        this.outputs[0].label = (this._last_v || 0).toFixed(3);\n    };\n\n    LiteGraph.registerNodeType("math/noise", MathNoise);\n\n    //generates spikes every random time\n    function MathSpikes() {\n        this.addOutput("out", "number");\n        this.addProperty("min_time", 1);\n        this.addProperty("max_time", 2);\n        this.addProperty("duration", 0.2);\n        this.size = [90, 30];\n        this._remaining_time = 0;\n        this._blink_time = 0;\n    }\n\n    MathSpikes.title = "Spikes";\n    MathSpikes.desc = "spike every random time";\n\n    MathSpikes.prototype.onExecute = function() {\n        var dt = this.graph.elapsed_time; //in secs\n\n        this._remaining_time -= dt;\n        this._blink_time -= dt;\n\n        var v = 0;\n        if (this._blink_time > 0) {\n            var f = this._blink_time / this.properties.duration;\n            v = 1 / (Math.pow(f * 8 - 4, 4) + 1);\n        }\n\n        if (this._remaining_time < 0) {\n            this._remaining_time =\n                Math.random() *\n                    (this.properties.max_time - this.properties.min_time) +\n                this.properties.min_time;\n            this._blink_time = this.properties.duration;\n            this.boxcolor = "#FFF";\n        } else {\n            this.boxcolor = "#000";\n        }\n        this.setOutputData(0, v);\n    };\n\n    LiteGraph.registerNodeType("math/spikes", MathSpikes);\n\n    //Math clamp\n    function MathClamp() {\n        this.addInput("in", "number");\n        this.addOutput("out", "number");\n        this.size = [80, 30];\n        this.addProperty("min", 0);\n        this.addProperty("max", 1);\n    }\n\n    MathClamp.title = "Clamp";\n    MathClamp.desc = "Clamp number between min and max";\n    //MathClamp.filter = "shader";\n\n    MathClamp.prototype.onExecute = function() {\n        var v = this.getInputData(0);\n        if (v == null) {\n            return;\n        }\n        v = Math.max(this.properties.min, v);\n        v = Math.min(this.properties.max, v);\n        this.setOutputData(0, v);\n    };\n\n    MathClamp.prototype.getCode = function(lang) {\n        var code = "";\n        if (this.isInputConnected(0)) {\n            code +=\n                "clamp({{0}}," +\n                this.properties.min +\n                "," +\n                this.properties.max +\n                ")";\n        }\n        return code;\n    };\n\n    LiteGraph.registerNodeType("math/clamp", MathClamp);\n\n    //Math ABS\n    function MathLerp() {\n        this.properties = { f: 0.5 };\n        this.addInput("A", "number");\n        this.addInput("B", "number");\n\n        this.addOutput("out", "number");\n    }\n\n    MathLerp.title = "Lerp";\n    MathLerp.desc = "Linear Interpolation";\n\n    MathLerp.prototype.onExecute = function() {\n        var v1 = this.getInputData(0);\n        if (v1 == null) {\n            v1 = 0;\n        }\n        var v2 = this.getInputData(1);\n        if (v2 == null) {\n            v2 = 0;\n        }\n\n        var f = this.properties.f;\n\n        var _f = this.getInputData(2);\n        if (_f !== undefined) {\n            f = _f;\n        }\n\n        this.setOutputData(0, v1 * (1 - f) + v2 * f);\n    };\n\n    MathLerp.prototype.onGetInputs = function() {\n        return [["f", "number"]];\n    };\n\n    LiteGraph.registerNodeType("math/lerp", MathLerp);\n\n    //Math ABS\n    function MathAbs() {\n        this.addInput("in", "number");\n        this.addOutput("out", "number");\n        this.size = [80, 30];\n    }\n\n    MathAbs.title = "Abs";\n    MathAbs.desc = "Absolute";\n\n    MathAbs.prototype.onExecute = function() {\n        var v = this.getInputData(0);\n        if (v == null) {\n            return;\n        }\n        this.setOutputData(0, Math.abs(v));\n    };\n\n    LiteGraph.registerNodeType("math/abs", MathAbs);\n\n    //Math Floor\n    function MathFloor() {\n        this.addInput("in", "number");\n        this.addOutput("out", "number");\n        this.size = [80, 30];\n    }\n\n    MathFloor.title = "Floor";\n    MathFloor.desc = "Floor number to remove fractional part";\n\n    MathFloor.prototype.onExecute = function() {\n        var v = this.getInputData(0);\n        if (v == null) {\n            return;\n        }\n        this.setOutputData(0, Math.floor(v));\n    };\n\n    LiteGraph.registerNodeType("math/floor", MathFloor);\n\n    //Math frac\n    function MathFrac() {\n        this.addInput("in", "number");\n        this.addOutput("out", "number");\n        this.size = [80, 30];\n    }\n\n    MathFrac.title = "Frac";\n    MathFrac.desc = "Returns fractional part";\n\n    MathFrac.prototype.onExecute = function() {\n        var v = this.getInputData(0);\n        if (v == null) {\n            return;\n        }\n        this.setOutputData(0, v % 1);\n    };\n\n    LiteGraph.registerNodeType("math/frac", MathFrac);\n\n    //Math Floor\n    function MathSmoothStep() {\n        this.addInput("in", "number");\n        this.addOutput("out", "number");\n        this.size = [80, 30];\n        this.properties = { A: 0, B: 1 };\n    }\n\n    MathSmoothStep.title = "Smoothstep";\n    MathSmoothStep.desc = "Smoothstep";\n\n    MathSmoothStep.prototype.onExecute = function() {\n        var v = this.getInputData(0);\n        if (v === undefined) {\n            return;\n        }\n\n        var edge0 = this.properties.A;\n        var edge1 = this.properties.B;\n\n        // Scale, bias and saturate x to 0..1 range\n        v = clamp((v - edge0) / (edge1 - edge0), 0.0, 1.0);\n        // Evaluate polynomial\n        v = v * v * (3 - 2 * v);\n\n        this.setOutputData(0, v);\n    };\n\n    LiteGraph.registerNodeType("math/smoothstep", MathSmoothStep);\n\n    //Math scale\n    function MathScale() {\n        this.addInput("in", "number", { label: "" });\n        this.addOutput("out", "number", { label: "" });\n        this.size = [80, 30];\n        this.addProperty("factor", 1);\n    }\n\n    MathScale.title = "Scale";\n    MathScale.desc = "v * factor";\n\n    MathScale.prototype.onExecute = function() {\n        var value = this.getInputData(0);\n        if (value != null) {\n            this.setOutputData(0, value * this.properties.factor);\n        }\n    };\n\n    LiteGraph.registerNodeType("math/scale", MathScale);\n\n\t//Gate\n\tfunction Gate() {\n\t\tthis.addInput("v","boolean");\n\t\tthis.addInput("A");\n\t\tthis.addInput("B");\n\t\tthis.addOutput("out");\n\t}\n\n\tGate.title = "Gate";\n\tGate.desc = "if v is true, then outputs A, otherwise B";\n\n\tGate.prototype.onExecute = function() {\n\t\tvar v = this.getInputData(0);\n\t\tthis.setOutputData(0, this.getInputData( v ? 1 : 2 ));\n\t};\n\n\tLiteGraph.registerNodeType("math/gate", Gate);\n\n\n    //Math Average\n    function MathAverageFilter() {\n        this.addInput("in", "number");\n        this.addOutput("out", "number");\n        this.size = [80, 30];\n        this.addProperty("samples", 10);\n        this._values = new Float32Array(10);\n        this._current = 0;\n    }\n\n    MathAverageFilter.title = "Average";\n    MathAverageFilter.desc = "Average Filter";\n\n    MathAverageFilter.prototype.onExecute = function() {\n        var v = this.getInputData(0);\n        if (v == null) {\n            v = 0;\n        }\n\n        var num_samples = this._values.length;\n\n        this._values[this._current % num_samples] = v;\n        this._current += 1;\n        if (this._current > num_samples) {\n            this._current = 0;\n        }\n\n        var avr = 0;\n        for (var i = 0; i < num_samples; ++i) {\n            avr += this._values[i];\n        }\n\n        this.setOutputData(0, avr / num_samples);\n    };\n\n    MathAverageFilter.prototype.onPropertyChanged = function(name, value) {\n        if (value < 1) {\n            value = 1;\n        }\n        this.properties.samples = Math.round(value);\n        var old = this._values;\n\n        this._values = new Float32Array(this.properties.samples);\n        if (old.length <= this._values.length) {\n            this._values.set(old);\n        } else {\n            this._values.set(old.subarray(0, this._values.length));\n        }\n    };\n\n    LiteGraph.registerNodeType("math/average", MathAverageFilter);\n\n    //Math\n    function MathTendTo() {\n        this.addInput("in", "number");\n        this.addOutput("out", "number");\n        this.addProperty("factor", 0.1);\n        this.size = [80, 30];\n        this._value = null;\n    }\n\n    MathTendTo.title = "TendTo";\n    MathTendTo.desc = "moves the output value always closer to the input";\n\n    MathTendTo.prototype.onExecute = function() {\n        var v = this.getInputData(0);\n        if (v == null) {\n            v = 0;\n        }\n        var f = this.properties.factor;\n        if (this._value == null) {\n            this._value = v;\n        } else {\n            this._value = this._value * (1 - f) + v * f;\n        }\n        this.setOutputData(0, this._value);\n    };\n\n    LiteGraph.registerNodeType("math/tendTo", MathTendTo);\n\n    //Math operation\n    function MathOperation() {\n        this.addInput("A", "number,array,object");\n        this.addInput("B", "number");\n        this.addOutput("=", "number");\n        this.addProperty("A", 1);\n        this.addProperty("B", 1);\n        this.addProperty("OP", "+", "enum", { values: MathOperation.values });\n\t\tthis._func = MathOperation.funcs[this.properties.OP];\n\t\tthis._result = []; //only used for arrays\n    }\n\n    MathOperation.values = ["+", "-", "*", "/", "%", "^", "max", "min"];\n    MathOperation.funcs = {\n        "+": function(A,B) { return A + B; },\n        "-": function(A,B) { return A - B; },\n        "x": function(A,B) { return A * B; },\n        "X": function(A,B) { return A * B; },\n        "*": function(A,B) { return A * B; },\n        "/": function(A,B) { return A / B; },\n        "%": function(A,B) { return A % B; },\n        "^": function(A,B) { return Math.pow(A, B); },\n        "max": function(A,B) { return Math.max(A, B); },\n        "min": function(A,B) { return Math.min(A, B); }\n    };\n\n\tMathOperation.title = "Operation";\n    MathOperation.desc = "Easy math operators";\n    MathOperation["@OP"] = {\n        type: "enum",\n        title: "operation",\n        values: MathOperation.values\n    };\n    MathOperation.size = [100, 60];\n\n    MathOperation.prototype.getTitle = function() {\n\t\tif(this.properties.OP == "max" || this.properties.OP == "min")\n\t\t\treturn this.properties.OP + "(A,B)";\n        return "A " + this.properties.OP + " B";\n    };\n\n    MathOperation.prototype.setValue = function(v) {\n        if (typeof v == "string") {\n            v = parseFloat(v);\n        }\n        this.properties["value"] = v;\n    };\n\n    MathOperation.prototype.onPropertyChanged = function(name, value)\n\t{\n\t\tif (name != "OP")\n\t\t\treturn;\n        this._func = MathOperation.funcs[this.properties.OP];\n        if(!this._func)\n        {\n            console.warn("Unknown operation: " + this.properties.OP);\n            this._func = function(A) { return A; };\n        }\n\t}\n\n    MathOperation.prototype.onExecute = function() {\n        var A = this.getInputData(0);\n        var B = this.getInputData(1);\n        if ( A != null ) {\n\t\t\tif( A.constructor === Number )\n\t            this.properties["A"] = A;\n        } else {\n            A = this.properties["A"];\n        }\n\n        if (B != null) {\n            this.properties["B"] = B;\n        } else {\n            B = this.properties["B"];\n        }\n\n        var func = MathOperation.funcs[this.properties.OP];\n\n\t\tvar result;\n\t\tif(A.constructor === Number)\n\t\t{\n\t        result = 0;\n\t\t\tresult = func(A,B);\n\t\t}\n\t\telse if(A.constructor === Array)\n\t\t{\n\t\t\tresult = this._result;\n\t\t\tresult.length = A.length;\n\t\t\tfor(var i = 0; i < A.length; ++i)\n\t\t\t\tresult[i] = func(A[i],B);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = {};\n\t\t\tfor(var i in A)\n\t\t\t\tresult[i] = func(A[i],B);\n\t\t}\n\t    this.setOutputData(0, result);\n    };\n\n    MathOperation.prototype.onDrawBackground = function(ctx) {\n        if (this.flags.collapsed) {\n            return;\n        }\n\n        ctx.font = "40px Arial";\n        ctx.fillStyle = "#666";\n        ctx.textAlign = "center";\n        ctx.fillText(\n            this.properties.OP,\n            this.size[0] * 0.5,\n            (this.size[1] + LiteGraph.NODE_TITLE_HEIGHT) * 0.5\n        );\n        ctx.textAlign = "left";\n    };\n\n    LiteGraph.registerNodeType("math/operation", MathOperation);\n\n    LiteGraph.registerSearchboxExtra("math/operation", "MAX", {\n        properties: {OP:"max"},\n        title: "MAX()"\n    });\n\n    LiteGraph.registerSearchboxExtra("math/operation", "MIN", {\n        properties: {OP:"min"},\n        title: "MIN()"\n    });\n\n\n    //Math compare\n    function MathCompare() {\n        this.addInput("A", "number");\n        this.addInput("B", "number");\n        this.addOutput("A==B", "boolean");\n        this.addOutput("A!=B", "boolean");\n        this.addProperty("A", 0);\n        this.addProperty("B", 0);\n    }\n\n    MathCompare.title = "Compare";\n    MathCompare.desc = "compares between two values";\n\n    MathCompare.prototype.onExecute = function() {\n        var A = this.getInputData(0);\n        var B = this.getInputData(1);\n        if (A !== undefined) {\n            this.properties["A"] = A;\n        } else {\n            A = this.properties["A"];\n        }\n\n        if (B !== undefined) {\n            this.properties["B"] = B;\n        } else {\n            B = this.properties["B"];\n        }\n\n        for (var i = 0, l = this.outputs.length; i < l; ++i) {\n            var output = this.outputs[i];\n            if (!output.links || !output.links.length) {\n                continue;\n            }\n            var value;\n            switch (output.name) {\n                case "A==B":\n                    value = A == B;\n                    break;\n                case "A!=B":\n                    value = A != B;\n                    break;\n                case "A>B":\n                    value = A > B;\n                    break;\n                case "A<B":\n                    value = A < B;\n                    break;\n                case "A<=B":\n                    value = A <= B;\n                    break;\n                case "A>=B":\n                    value = A >= B;\n                    break;\n            }\n            this.setOutputData(i, value);\n        }\n    };\n\n    MathCompare.prototype.onGetOutputs = function() {\n        return [\n            ["A==B", "boolean"],\n            ["A!=B", "boolean"],\n            ["A>B", "boolean"],\n            ["A<B", "boolean"],\n            ["A>=B", "boolean"],\n            ["A<=B", "boolean"]\n        ];\n    };\n\n    LiteGraph.registerNodeType("math/compare", MathCompare);\n\n    LiteGraph.registerSearchboxExtra("math/compare", "==", {\n        outputs: [["A==B", "boolean"]],\n        title: "A==B"\n    });\n    LiteGraph.registerSearchboxExtra("math/compare", "!=", {\n        outputs: [["A!=B", "boolean"]],\n        title: "A!=B"\n    });\n    LiteGraph.registerSearchboxExtra("math/compare", ">", {\n        outputs: [["A>B", "boolean"]],\n        title: "A>B"\n    });\n    LiteGraph.registerSearchboxExtra("math/compare", "<", {\n        outputs: [["A<B", "boolean"]],\n        title: "A<B"\n    });\n    LiteGraph.registerSearchboxExtra("math/compare", ">=", {\n        outputs: [["A>=B", "boolean"]],\n        title: "A>=B"\n    });\n    LiteGraph.registerSearchboxExtra("math/compare", "<=", {\n        outputs: [["A<=B", "boolean"]],\n        title: "A<=B"\n    });\n\n    function MathCondition() {\n        this.addInput("A", "number");\n        this.addInput("B", "number");\n        this.addOutput("true", "boolean");\n        this.addOutput("false", "boolean");\n        this.addProperty("A", 1);\n        this.addProperty("B", 1);\n        this.addProperty("OP", ">", "enum", { values: MathCondition.values });\n\t\tthis.addWidget("combo","Cond.",this.properties.OP,{ property: "OP", values: MathCondition.values } );\n\n        this.size = [80, 60];\n    }\n\n    MathCondition.values = [">", "<", "==", "!=", "<=", ">=", "||", "&&" ];\n    MathCondition["@OP"] = {\n        type: "enum",\n        title: "operation",\n        values: MathCondition.values\n    };\n\n    MathCondition.title = "Condition";\n    MathCondition.desc = "evaluates condition between A and B";\n\n    MathCondition.prototype.getTitle = function() {\n        return "A " + this.properties.OP + " B";\n    };\n\n    MathCondition.prototype.onExecute = function() {\n        var A = this.getInputData(0);\n        if (A === undefined) {\n            A = this.properties.A;\n        } else {\n            this.properties.A = A;\n        }\n\n        var B = this.getInputData(1);\n        if (B === undefined) {\n            B = this.properties.B;\n        } else {\n            this.properties.B = B;\n        }\n\n        var result = true;\n        switch (this.properties.OP) {\n            case ">":\n                result = A > B;\n                break;\n            case "<":\n                result = A < B;\n                break;\n            case "==":\n                result = A == B;\n                break;\n            case "!=":\n                result = A != B;\n                break;\n            case "<=":\n                result = A <= B;\n                break;\n            case ">=":\n                result = A >= B;\n                break;\n            case "||":\n                result = A || B;\n                break;\n            case "&&":\n                result = A && B;\n                break;\n        }\n\n        this.setOutputData(0, result);\n        this.setOutputData(1, !result);\n    };\n\n    LiteGraph.registerNodeType("math/condition", MathCondition);\n\n\n    function MathBranch() {\n        this.addInput("in", 0);\n        this.addInput("cond", "boolean");\n        this.addOutput("true", 0);\n        this.addOutput("false", 0);\n        this.size = [80, 60];\n    }\n\n    MathBranch.title = "Branch";\n    MathBranch.desc = "If condition is true, outputs IN in true, otherwise in false";\n\n    MathBranch.prototype.onExecute = function() {\n        var V = this.getInputData(0);\n        var cond = this.getInputData(1);\n\n\t\tif(cond)\n\t\t{\n\t\t\tthis.setOutputData(0, V);\n\t\t\tthis.setOutputData(1, null);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.setOutputData(0, null);\n\t\t\tthis.setOutputData(1, V);\n\t\t}\n\t}\n\n    LiteGraph.registerNodeType("math/branch", MathBranch);\n\n\n    function MathAccumulate() {\n        this.addInput("inc", "number");\n        this.addOutput("total", "number");\n        this.addProperty("increment", 1);\n        this.addProperty("value", 0);\n    }\n\n    MathAccumulate.title = "Accumulate";\n    MathAccumulate.desc = "Increments a value every time";\n\n    MathAccumulate.prototype.onExecute = function() {\n        if (this.properties.value === null) {\n            this.properties.value = 0;\n        }\n\n        var inc = this.getInputData(0);\n        if (inc !== null) {\n            this.properties.value += inc;\n        } else {\n            this.properties.value += this.properties.increment;\n        }\n        this.setOutputData(0, this.properties.value);\n    };\n\n    LiteGraph.registerNodeType("math/accumulate", MathAccumulate);\n\n    //Math Trigonometry\n    function MathTrigonometry() {\n        this.addInput("v", "number");\n        this.addOutput("sin", "number");\n\n        this.addProperty("amplitude", 1);\n        this.addProperty("offset", 0);\n        this.bgImageUrl = "nodes/imgs/icon-sin.png";\n    }\n\n    MathTrigonometry.title = "Trigonometry";\n    MathTrigonometry.desc = "Sin Cos Tan";\n    //MathTrigonometry.filter = "shader";\n\n    MathTrigonometry.prototype.onExecute = function() {\n        var v = this.getInputData(0);\n        if (v == null) {\n            v = 0;\n        }\n        var amplitude = this.properties["amplitude"];\n        var slot = this.findInputSlot("amplitude");\n        if (slot != -1) {\n            amplitude = this.getInputData(slot);\n        }\n        var offset = this.properties["offset"];\n        slot = this.findInputSlot("offset");\n        if (slot != -1) {\n            offset = this.getInputData(slot);\n        }\n\n        for (var i = 0, l = this.outputs.length; i < l; ++i) {\n            var output = this.outputs[i];\n            var value;\n            switch (output.name) {\n                case "sin":\n                    value = Math.sin(v);\n                    break;\n                case "cos":\n                    value = Math.cos(v);\n                    break;\n                case "tan":\n                    value = Math.tan(v);\n                    break;\n                case "asin":\n                    value = Math.asin(v);\n                    break;\n                case "acos":\n                    value = Math.acos(v);\n                    break;\n                case "atan":\n                    value = Math.atan(v);\n                    break;\n            }\n            this.setOutputData(i, amplitude * value + offset);\n        }\n    };\n\n    MathTrigonometry.prototype.onGetInputs = function() {\n        return [["v", "number"], ["amplitude", "number"], ["offset", "number"]];\n    };\n\n    MathTrigonometry.prototype.onGetOutputs = function() {\n        return [\n            ["sin", "number"],\n            ["cos", "number"],\n            ["tan", "number"],\n            ["asin", "number"],\n            ["acos", "number"],\n            ["atan", "number"]\n        ];\n    };\n\n    LiteGraph.registerNodeType("math/trigonometry", MathTrigonometry);\n\n    LiteGraph.registerSearchboxExtra("math/trigonometry", "SIN()", {\n        outputs: [["sin", "number"]],\n        title: "SIN()"\n    });\n    LiteGraph.registerSearchboxExtra("math/trigonometry", "COS()", {\n        outputs: [["cos", "number"]],\n        title: "COS()"\n    });\n    LiteGraph.registerSearchboxExtra("math/trigonometry", "TAN()", {\n        outputs: [["tan", "number"]],\n        title: "TAN()"\n    });\n\n    //math library for safe math operations without eval\n    function MathFormula() {\n        this.addInput("x", "number");\n        this.addInput("y", "number");\n        this.addOutput("", "number");\n        this.properties = { x: 1.0, y: 1.0, formula: "x+y" };\n        this.code_widget = this.addWidget(\n            "text",\n            "F(x,y)",\n            this.properties.formula,\n            function(v, canvas, node) {\n                node.properties.formula = v;\n            }\n        );\n        this.addWidget("toggle", "allow", LiteGraph.allow_scripts, function(v) {\n            LiteGraph.allow_scripts = v;\n        });\n        this._func = null;\n    }\n\n    MathFormula.title = "Formula";\n    MathFormula.desc = "Compute formula";\n    MathFormula.size = [160, 100];\n\n    MathAverageFilter.prototype.onPropertyChanged = function(name, value) {\n        if (name == "formula") {\n            this.code_widget.value = value;\n        }\n    };\n\n    MathFormula.prototype.onExecute = function() {\n        if (!LiteGraph.allow_scripts) {\n            return;\n        }\n\n        var x = this.getInputData(0);\n        var y = this.getInputData(1);\n        if (x != null) {\n            this.properties["x"] = x;\n        } else {\n            x = this.properties["x"];\n        }\n\n        if (y != null) {\n            this.properties["y"] = y;\n        } else {\n            y = this.properties["y"];\n        }\n\n        var f = this.properties["formula"];\n\n        var value;\n        try {\n            if (!this._func || this._func_code != this.properties.formula) {\n                this._func = new Function(\n                    "x",\n                    "y",\n                    "TIME",\n                    "return " + this.properties.formula\n                );\n                this._func_code = this.properties.formula;\n            }\n            value = this._func(x, y, this.graph.globaltime);\n            this.boxcolor = null;\n        } catch (err) {\n            this.boxcolor = "red";\n        }\n        this.setOutputData(0, value);\n    };\n\n    MathFormula.prototype.getTitle = function() {\n        return this._func_code || "Formula";\n    };\n\n    MathFormula.prototype.onDrawBackground = function() {\n        var f = this.properties["formula"];\n        if (this.outputs && this.outputs.length) {\n            this.outputs[0].label = f;\n        }\n    };\n\n    LiteGraph.registerNodeType("math/formula", MathFormula);\n\n    function Math3DVec2ToXY() {\n        this.addInput("vec2", "vec2");\n        this.addOutput("x", "number");\n        this.addOutput("y", "number");\n    }\n\n    Math3DVec2ToXY.title = "Vec2->XY";\n    Math3DVec2ToXY.desc = "vector 2 to components";\n\n    Math3DVec2ToXY.prototype.onExecute = function() {\n        var v = this.getInputData(0);\n        if (v == null) {\n            return;\n        }\n\n        this.setOutputData(0, v[0]);\n        this.setOutputData(1, v[1]);\n    };\n\n    LiteGraph.registerNodeType("math3d/vec2-to-xy", Math3DVec2ToXY);\n\n    function Math3DXYToVec2() {\n        this.addInputs([["x", "number"], ["y", "number"]]);\n        this.addOutput("vec2", "vec2");\n        this.properties = { x: 0, y: 0 };\n        this._data = new Float32Array(2);\n    }\n\n    Math3DXYToVec2.title = "XY->Vec2";\n    Math3DXYToVec2.desc = "components to vector2";\n\n    Math3DXYToVec2.prototype.onExecute = function() {\n        var x = this.getInputData(0);\n        if (x == null) {\n            x = this.properties.x;\n        }\n        var y = this.getInputData(1);\n        if (y == null) {\n            y = this.properties.y;\n        }\n\n        var data = this._data;\n        data[0] = x;\n        data[1] = y;\n\n        this.setOutputData(0, data);\n    };\n\n    LiteGraph.registerNodeType("math3d/xy-to-vec2", Math3DXYToVec2);\n\n    function Math3DVec3ToXYZ() {\n        this.addInput("vec3", "vec3");\n        this.addOutput("x", "number");\n        this.addOutput("y", "number");\n        this.addOutput("z", "number");\n    }\n\n    Math3DVec3ToXYZ.title = "Vec3->XYZ";\n    Math3DVec3ToXYZ.desc = "vector 3 to components";\n\n    Math3DVec3ToXYZ.prototype.onExecute = function() {\n        var v = this.getInputData(0);\n        if (v == null) {\n            return;\n        }\n\n        this.setOutputData(0, v[0]);\n        this.setOutputData(1, v[1]);\n        this.setOutputData(2, v[2]);\n    };\n\n    LiteGraph.registerNodeType("math3d/vec3-to-xyz", Math3DVec3ToXYZ);\n\n    function Math3DXYZToVec3() {\n        this.addInputs([["x", "number"], ["y", "number"], ["z", "number"]]);\n        this.addOutput("vec3", "vec3");\n        this.properties = { x: 0, y: 0, z: 0 };\n        this._data = new Float32Array(3);\n    }\n\n    Math3DXYZToVec3.title = "XYZ->Vec3";\n    Math3DXYZToVec3.desc = "components to vector3";\n\n    Math3DXYZToVec3.prototype.onExecute = function() {\n        var x = this.getInputData(0);\n        if (x == null) {\n            x = this.properties.x;\n        }\n        var y = this.getInputData(1);\n        if (y == null) {\n            y = this.properties.y;\n        }\n        var z = this.getInputData(2);\n        if (z == null) {\n            z = this.properties.z;\n        }\n\n        var data = this._data;\n        data[0] = x;\n        data[1] = y;\n        data[2] = z;\n\n        this.setOutputData(0, data);\n    };\n\n    LiteGraph.registerNodeType("math3d/xyz-to-vec3", Math3DXYZToVec3);\n\n    function Math3DVec4ToXYZW() {\n        this.addInput("vec4", "vec4");\n        this.addOutput("x", "number");\n        this.addOutput("y", "number");\n        this.addOutput("z", "number");\n        this.addOutput("w", "number");\n    }\n\n    Math3DVec4ToXYZW.title = "Vec4->XYZW";\n    Math3DVec4ToXYZW.desc = "vector 4 to components";\n\n    Math3DVec4ToXYZW.prototype.onExecute = function() {\n        var v = this.getInputData(0);\n        if (v == null) {\n            return;\n        }\n\n        this.setOutputData(0, v[0]);\n        this.setOutputData(1, v[1]);\n        this.setOutputData(2, v[2]);\n        this.setOutputData(3, v[3]);\n    };\n\n    LiteGraph.registerNodeType("math3d/vec4-to-xyzw", Math3DVec4ToXYZW);\n\n    function Math3DXYZWToVec4() {\n        this.addInputs([\n            ["x", "number"],\n            ["y", "number"],\n            ["z", "number"],\n            ["w", "number"]\n        ]);\n        this.addOutput("vec4", "vec4");\n        this.properties = { x: 0, y: 0, z: 0, w: 0 };\n        this._data = new Float32Array(4);\n    }\n\n    Math3DXYZWToVec4.title = "XYZW->Vec4";\n    Math3DXYZWToVec4.desc = "components to vector4";\n\n    Math3DXYZWToVec4.prototype.onExecute = function() {\n        var x = this.getInputData(0);\n        if (x == null) {\n            x = this.properties.x;\n        }\n        var y = this.getInputData(1);\n        if (y == null) {\n            y = this.properties.y;\n        }\n        var z = this.getInputData(2);\n        if (z == null) {\n            z = this.properties.z;\n        }\n        var w = this.getInputData(3);\n        if (w == null) {\n            w = this.properties.w;\n        }\n\n        var data = this._data;\n        data[0] = x;\n        data[1] = y;\n        data[2] = z;\n        data[3] = w;\n\n        this.setOutputData(0, data);\n    };\n\n    LiteGraph.registerNodeType("math3d/xyzw-to-vec4", Math3DXYZWToVec4);\n\n})(this);\n\n(function(global) {\r\n    var LiteGraph = global.LiteGraph;\r\n\r\n\r\n\tfunction Math3DMat4()\r\n\t{\r\n        this.addInput("T", "vec3");\r\n        this.addInput("R", "vec3");\r\n        this.addInput("S", "vec3");\r\n        this.addOutput("mat4", "mat4");\r\n\t\tthis.properties = {\r\n\t\t\t"T":[0,0,0],\r\n\t\t\t"R":[0,0,0],\r\n\t\t\t"S":[1,1,1],\r\n\t\t\tR_in_degrees: true\r\n\t\t};\r\n\t\tthis._result = mat4.create();\r\n\t\tthis._must_update = true;\r\n\t}\r\n\r\n\tMath3DMat4.title = "mat4";\r\n\tMath3DMat4.temp_quat = new Float32Array([0,0,0,1]);\r\n\tMath3DMat4.temp_mat4 = new Float32Array(16);\r\n\tMath3DMat4.temp_vec3 = new Float32Array(3);\r\n\r\n\tMath3DMat4.prototype.onPropertyChanged = function(name, value)\r\n\t{\r\n\t\tthis._must_update = true;\r\n\t}\r\n\r\n\tMath3DMat4.prototype.onExecute = function()\r\n\t{\r\n\t\tvar M = this._result;\r\n\t\tvar Q = Math3DMat4.temp_quat;\r\n\t\tvar temp_mat4 = Math3DMat4.temp_mat4;\r\n\t\tvar temp_vec3 = Math3DMat4.temp_vec3;\r\n\r\n\t\tvar T = this.getInputData(0);\r\n\t\tvar R = this.getInputData(1);\r\n\t\tvar S = this.getInputData(2);\r\n\r\n\t\tif( this._must_update || T || R || S )\r\n\t\t{\r\n\t\t\tT = T || this.properties.T;\r\n\t\t\tR = R || this.properties.R;\r\n\t\t\tS = S || this.properties.S;\r\n\t\t\tmat4.identity( M );\r\n\t\t\tmat4.translate( M, M, T );\r\n\t\t\tif(this.properties.R_in_degrees)\r\n\t\t\t{\r\n\t\t\t\ttemp_vec3.set( R );\r\n\t\t\t\tvec3.scale(temp_vec3,temp_vec3,DEG2RAD);\r\n\t\t\t\tquat.fromEuler( Q, temp_vec3 );\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tquat.fromEuler( Q, R );\r\n\t\t\tmat4.fromQuat( temp_mat4, Q );\r\n\t\t\tmat4.multiply( M, M, temp_mat4 );\r\n\t\t\tmat4.scale( M, M, S );\r\n\t\t}\r\n\r\n\t\tthis.setOutputData(0, M);\t\t\r\n\t}\r\n\r\n    LiteGraph.registerNodeType("math3d/mat4", Math3DMat4);\r\n\r\n    //Math 3D operation\r\n    function Math3DOperation() {\r\n        this.addInput("A", "number,vec3");\r\n        this.addInput("B", "number,vec3");\r\n        this.addOutput("=", "number,vec3");\r\n        this.addProperty("OP", "+", "enum", { values: Math3DOperation.values });\r\n\t\tthis._result = vec3.create();\r\n    }\r\n\r\n    Math3DOperation.values = ["+", "-", "*", "/", "%", "^", "max", "min","dot","cross"];\r\n\r\n    LiteGraph.registerSearchboxExtra("math3d/operation", "CROSS()", {\r\n        properties: {"OP":"cross"},\r\n        title: "CROSS()"\r\n    });\r\n\r\n    LiteGraph.registerSearchboxExtra("math3d/operation", "DOT()", {\r\n        properties: {"OP":"dot"},\r\n        title: "DOT()"\r\n    });\r\n\r\n\tMath3DOperation.title = "Operation";\r\n    Math3DOperation.desc = "Easy math 3D operators";\r\n    Math3DOperation["@OP"] = {\r\n        type: "enum",\r\n        title: "operation",\r\n        values: Math3DOperation.values\r\n    };\r\n    Math3DOperation.size = [100, 60];\r\n\r\n    Math3DOperation.prototype.getTitle = function() {\r\n\t\tif(this.properties.OP == "max" || this.properties.OP == "min" )\r\n\t\t\treturn this.properties.OP + "(A,B)";\r\n        return "A " + this.properties.OP + " B";\r\n    };\r\n\r\n    Math3DOperation.prototype.onExecute = function() {\r\n        var A = this.getInputData(0);\r\n        var B = this.getInputData(1);\r\n\t\tif(A == null || B == null)\r\n\t\t\treturn;\r\n\t\tif(A.constructor === Number)\r\n\t\t\tA = [A,A,A];\r\n\t\tif(B.constructor === Number)\r\n\t\t\tB = [B,B,B];\r\n\r\n        var result = this._result;\r\n        switch (this.properties.OP) {\r\n            case "+":\r\n                result = vec3.add(result,A,B);\r\n                break;\r\n            case "-":\r\n                result = vec3.sub(result,A,B);\r\n                break;\r\n            case "x":\r\n            case "X":\r\n            case "*":\r\n                result = vec3.mul(result,A,B);\r\n                break;\r\n            case "/":\r\n                result = vec3.div(result,A,B);\r\n                break;\r\n            case "%":\r\n                result[0] = A[0]%B[0];\r\n                result[1] = A[1]%B[1];\r\n                result[2] = A[2]%B[2];\r\n                break;\r\n            case "^":\r\n                result[0] = Math.pow(A[0],B[0]);\r\n                result[1] = Math.pow(A[1],B[1]);\r\n                result[2] = Math.pow(A[2],B[2]);\r\n                break;\r\n            case "max":\r\n                result[0] = Math.max(A[0],B[0]);\r\n                result[1] = Math.max(A[1],B[1]);\r\n                result[2] = Math.max(A[2],B[2]);\r\n                break;\r\n            case "min":\r\n                result[0] = Math.min(A[0],B[0]);\r\n                result[1] = Math.min(A[1],B[1]);\r\n                result[2] = Math.min(A[2],B[2]);\r\n            case "dot":\r\n                result = vec3.dot(A,B);\r\n                break;\r\n            case "cross":\r\n                vec3.cross(result,A,B);\r\n                break;\r\n            default:\r\n                console.warn("Unknown operation: " + this.properties.OP);\r\n        }\r\n        this.setOutputData(0, result);\r\n    };\r\n\r\n    Math3DOperation.prototype.onDrawBackground = function(ctx) {\r\n        if (this.flags.collapsed) {\r\n            return;\r\n        }\r\n\r\n        ctx.font = "40px Arial";\r\n        ctx.fillStyle = "#666";\r\n        ctx.textAlign = "center";\r\n        ctx.fillText(\r\n            this.properties.OP,\r\n            this.size[0] * 0.5,\r\n            (this.size[1] + LiteGraph.NODE_TITLE_HEIGHT) * 0.5\r\n        );\r\n        ctx.textAlign = "left";\r\n    };\r\n\r\n    LiteGraph.registerNodeType("math3d/operation", Math3DOperation);\r\n\r\n    function Math3DVec3Scale() {\r\n        this.addInput("in", "vec3");\r\n        this.addInput("f", "number");\r\n        this.addOutput("out", "vec3");\r\n        this.properties = { f: 1 };\r\n        this._data = new Float32Array(3);\r\n    }\r\n\r\n    Math3DVec3Scale.title = "vec3_scale";\r\n    Math3DVec3Scale.desc = "scales the components of a vec3";\r\n\r\n    Math3DVec3Scale.prototype.onExecute = function() {\r\n        var v = this.getInputData(0);\r\n        if (v == null) {\r\n            return;\r\n        }\r\n        var f = this.getInputData(1);\r\n        if (f == null) {\r\n            f = this.properties.f;\r\n        }\r\n\r\n        var data = this._data;\r\n        data[0] = v[0] * f;\r\n        data[1] = v[1] * f;\r\n        data[2] = v[2] * f;\r\n        this.setOutputData(0, data);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("math3d/vec3-scale", Math3DVec3Scale);\r\n\r\n    function Math3DVec3Length() {\r\n        this.addInput("in", "vec3");\r\n        this.addOutput("out", "number");\r\n    }\r\n\r\n    Math3DVec3Length.title = "vec3_length";\r\n    Math3DVec3Length.desc = "returns the module of a vector";\r\n\r\n    Math3DVec3Length.prototype.onExecute = function() {\r\n        var v = this.getInputData(0);\r\n        if (v == null) {\r\n            return;\r\n        }\r\n        var dist = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\r\n        this.setOutputData(0, dist);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("math3d/vec3-length", Math3DVec3Length);\r\n\r\n    function Math3DVec3Normalize() {\r\n        this.addInput("in", "vec3");\r\n        this.addOutput("out", "vec3");\r\n        this._data = new Float32Array(3);\r\n    }\r\n\r\n    Math3DVec3Normalize.title = "vec3_normalize";\r\n    Math3DVec3Normalize.desc = "returns the vector normalized";\r\n\r\n    Math3DVec3Normalize.prototype.onExecute = function() {\r\n        var v = this.getInputData(0);\r\n        if (v == null) {\r\n            return;\r\n        }\r\n        var dist = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\r\n        var data = this._data;\r\n        data[0] = v[0] / dist;\r\n        data[1] = v[1] / dist;\r\n        data[2] = v[2] / dist;\r\n\r\n        this.setOutputData(0, data);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("math3d/vec3-normalize", Math3DVec3Normalize);\r\n\r\n    function Math3DVec3Lerp() {\r\n        this.addInput("A", "vec3");\r\n        this.addInput("B", "vec3");\r\n        this.addInput("f", "vec3");\r\n        this.addOutput("out", "vec3");\r\n        this.properties = { f: 0.5 };\r\n        this._data = new Float32Array(3);\r\n    }\r\n\r\n    Math3DVec3Lerp.title = "vec3_lerp";\r\n    Math3DVec3Lerp.desc = "returns the interpolated vector";\r\n\r\n    Math3DVec3Lerp.prototype.onExecute = function() {\r\n        var A = this.getInputData(0);\r\n        if (A == null) {\r\n            return;\r\n        }\r\n        var B = this.getInputData(1);\r\n        if (B == null) {\r\n            return;\r\n        }\r\n        var f = this.getInputOrProperty("f");\r\n\r\n        var data = this._data;\r\n        data[0] = A[0] * (1 - f) + B[0] * f;\r\n        data[1] = A[1] * (1 - f) + B[1] * f;\r\n        data[2] = A[2] * (1 - f) + B[2] * f;\r\n\r\n        this.setOutputData(0, data);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("math3d/vec3-lerp", Math3DVec3Lerp);\r\n\r\n    function Math3DVec3Dot() {\r\n        this.addInput("A", "vec3");\r\n        this.addInput("B", "vec3");\r\n        this.addOutput("out", "number");\r\n    }\r\n\r\n    Math3DVec3Dot.title = "vec3_dot";\r\n    Math3DVec3Dot.desc = "returns the dot product";\r\n\r\n    Math3DVec3Dot.prototype.onExecute = function() {\r\n        var A = this.getInputData(0);\r\n        if (A == null) {\r\n            return;\r\n        }\r\n        var B = this.getInputData(1);\r\n        if (B == null) {\r\n            return;\r\n        }\r\n\r\n        var dot = A[0] * B[0] + A[1] * B[1] + A[2] * B[2];\r\n        this.setOutputData(0, dot);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("math3d/vec3-dot", Math3DVec3Dot);\r\n\r\n    //if glMatrix is installed...\r\n    if (global.glMatrix) {\r\n        function Math3DQuaternion() {\r\n            this.addOutput("quat", "quat");\r\n            this.properties = { x: 0, y: 0, z: 0, w: 1, normalize: false };\r\n            this._value = quat.create();\r\n        }\r\n\r\n        Math3DQuaternion.title = "Quaternion";\r\n        Math3DQuaternion.desc = "quaternion";\r\n\r\n        Math3DQuaternion.prototype.onExecute = function() {\r\n            this._value[0] = this.getInputOrProperty("x");\r\n            this._value[1] = this.getInputOrProperty("y");\r\n            this._value[2] = this.getInputOrProperty("z");\r\n            this._value[3] = this.getInputOrProperty("w");\r\n            if (this.properties.normalize) {\r\n                quat.normalize(this._value, this._value);\r\n            }\r\n            this.setOutputData(0, this._value);\r\n        };\r\n\r\n        Math3DQuaternion.prototype.onGetInputs = function() {\r\n            return [\r\n                ["x", "number"],\r\n                ["y", "number"],\r\n                ["z", "number"],\r\n                ["w", "number"]\r\n            ];\r\n        };\r\n\r\n        LiteGraph.registerNodeType("math3d/quaternion", Math3DQuaternion);\r\n\r\n        function Math3DRotation() {\r\n            this.addInputs([["degrees", "number"], ["axis", "vec3"]]);\r\n            this.addOutput("quat", "quat");\r\n            this.properties = { angle: 90.0, axis: vec3.fromValues(0, 1, 0) };\r\n\r\n            this._value = quat.create();\r\n        }\r\n\r\n        Math3DRotation.title = "Rotation";\r\n        Math3DRotation.desc = "quaternion rotation";\r\n\r\n        Math3DRotation.prototype.onExecute = function() {\r\n            var angle = this.getInputData(0);\r\n            if (angle == null) {\r\n                angle = this.properties.angle;\r\n            }\r\n            var axis = this.getInputData(1);\r\n            if (axis == null) {\r\n                axis = this.properties.axis;\r\n            }\r\n\r\n            var R = quat.setAxisAngle(this._value, axis, angle * 0.0174532925);\r\n            this.setOutputData(0, R);\r\n        };\r\n\r\n        LiteGraph.registerNodeType("math3d/rotation", Math3DRotation);\r\n\r\n\r\n        function MathEulerToQuat() {\r\n            this.addInput("euler", "vec3");\r\n            this.addOutput("quat", "quat");\r\n            this.properties = { euler:[0,0,0], use_yaw_pitch_roll: false };\r\n\t\t\tthis._degs = vec3.create();\r\n            this._value = quat.create();\r\n        }\r\n\r\n        MathEulerToQuat.title = "Euler->Quat";\r\n        MathEulerToQuat.desc = "Converts euler angles (in degrees) to quaternion";\r\n\r\n        MathEulerToQuat.prototype.onExecute = function() {\r\n            var euler = this.getInputData(0);\r\n            if (euler == null) {\r\n                euler = this.properties.euler;\r\n            }\r\n\t\t\tvec3.scale( this._degs, euler, DEG2RAD );\r\n\t\t\tif(this.properties.use_yaw_pitch_roll)\r\n\t\t\t\tthis._degs = [this._degs[2],this._degs[0],this._degs[1]];\r\n            var R = quat.fromEuler(this._value, this._degs);\r\n            this.setOutputData(0, R);\r\n        };\r\n\r\n        LiteGraph.registerNodeType("math3d/euler_to_quat", MathEulerToQuat);\r\n\r\n        function MathQuatToEuler() {\r\n            this.addInput(["quat", "quat"]);\r\n            this.addOutput("euler", "vec3");\r\n\t\t\tthis._value = vec3.create();\r\n        }\r\n\r\n        MathQuatToEuler.title = "Euler->Quat";\r\n        MathQuatToEuler.desc = "Converts rotX,rotY,rotZ in degrees to quat";\r\n\r\n        MathQuatToEuler.prototype.onExecute = function() {\r\n            var q = this.getInputData(0);\r\n\t\t\tif(!q)\r\n\t\t\t\treturn;\r\n            var R = quat.toEuler(this._value, q);\r\n\t\t\tvec3.scale( this._value, this._value, DEG2RAD );\r\n            this.setOutputData(0, this._value);\r\n        };\r\n\r\n        LiteGraph.registerNodeType("math3d/quat_to_euler", MathQuatToEuler);\r\n\r\n\r\n        //Math3D rotate vec3\r\n        function Math3DRotateVec3() {\r\n            this.addInputs([["vec3", "vec3"], ["quat", "quat"]]);\r\n            this.addOutput("result", "vec3");\r\n            this.properties = { vec: [0, 0, 1] };\r\n        }\r\n\r\n        Math3DRotateVec3.title = "Rot. Vec3";\r\n        Math3DRotateVec3.desc = "rotate a point";\r\n\r\n        Math3DRotateVec3.prototype.onExecute = function() {\r\n            var vec = this.getInputData(0);\r\n            if (vec == null) {\r\n                vec = this.properties.vec;\r\n            }\r\n            var quat = this.getInputData(1);\r\n            if (quat == null) {\r\n                this.setOutputData(vec);\r\n            } else {\r\n                this.setOutputData(\r\n                    0,\r\n                    vec3.transformQuat(vec3.create(), vec, quat)\r\n                );\r\n            }\r\n        };\r\n\r\n        LiteGraph.registerNodeType("math3d/rotate_vec3", Math3DRotateVec3);\r\n\r\n        function Math3DMultQuat() {\r\n            this.addInputs([["A", "quat"], ["B", "quat"]]);\r\n            this.addOutput("A*B", "quat");\r\n\r\n            this._value = quat.create();\r\n        }\r\n\r\n        Math3DMultQuat.title = "Mult. Quat";\r\n        Math3DMultQuat.desc = "rotate quaternion";\r\n\r\n        Math3DMultQuat.prototype.onExecute = function() {\r\n            var A = this.getInputData(0);\r\n            if (A == null) {\r\n                return;\r\n            }\r\n            var B = this.getInputData(1);\r\n            if (B == null) {\r\n                return;\r\n            }\r\n\r\n            var R = quat.multiply(this._value, A, B);\r\n            this.setOutputData(0, R);\r\n        };\r\n\r\n        LiteGraph.registerNodeType("math3d/mult-quat", Math3DMultQuat);\r\n\r\n        function Math3DQuatSlerp() {\r\n            this.addInputs([\r\n                ["A", "quat"],\r\n                ["B", "quat"],\r\n                ["factor", "number"]\r\n            ]);\r\n            this.addOutput("slerp", "quat");\r\n            this.addProperty("factor", 0.5);\r\n\r\n            this._value = quat.create();\r\n        }\r\n\r\n        Math3DQuatSlerp.title = "Quat Slerp";\r\n        Math3DQuatSlerp.desc = "quaternion spherical interpolation";\r\n\r\n        Math3DQuatSlerp.prototype.onExecute = function() {\r\n            var A = this.getInputData(0);\r\n            if (A == null) {\r\n                return;\r\n            }\r\n            var B = this.getInputData(1);\r\n            if (B == null) {\r\n                return;\r\n            }\r\n            var factor = this.properties.factor;\r\n            if (this.getInputData(2) != null) {\r\n                factor = this.getInputData(2);\r\n            }\r\n\r\n            var R = quat.slerp(this._value, A, B, factor);\r\n            this.setOutputData(0, R);\r\n        };\r\n\r\n        LiteGraph.registerNodeType("math3d/quat-slerp", Math3DQuatSlerp);\r\n\r\n\r\n        //Math3D rotate vec3\r\n        function Math3DRemapRange() {\r\n            this.addInput("vec3", "vec3");\r\n            this.addOutput("remap", "vec3");\r\n\t\t\tthis.addOutput("clamped", "vec3");\r\n            this.properties = { clamp: true, range_min: [-1, -1, 0], range_max: [1, 1, 0], target_min: [-1,-1,0], target_max:[1,1,0] };\r\n\t\t\tthis._value = vec3.create();\r\n\t\t\tthis._clamped = vec3.create();\r\n        }\r\n\r\n        Math3DRemapRange.title = "Remap Range";\r\n        Math3DRemapRange.desc = "remap a 3D range";\r\n\r\n        Math3DRemapRange.prototype.onExecute = function() {\r\n            var vec = this.getInputData(0);\r\n\t\t\tif(vec)\r\n\t\t\t\tthis._value.set(vec);\r\n\t\t\tvar range_min = this.properties.range_min;\r\n\t\t\tvar range_max = this.properties.range_max;\r\n\t\t\tvar target_min = this.properties.target_min;\r\n\t\t\tvar target_max = this.properties.target_max;\r\n\r\n\t\t\t//swap to avoid errors\r\n\t\t\t/*\r\n\t\t\tif(range_min > range_max)\r\n\t\t\t{\r\n\t\t\t\trange_min = range_max;\r\n\t\t\t\trange_max = this.properties.range_min;\r\n\t\t\t}\r\n\r\n\t\t\tif(target_min > target_max)\r\n\t\t\t{\r\n\t\t\t\ttarget_min = target_max;\r\n\t\t\t\ttarget_max = this.properties.target_min;\r\n\t\t\t}\r\n\t\t\t*/\r\n\r\n\t\t\tfor(var i = 0; i < 3; ++i)\r\n\t\t\t{\r\n\t\t\t\tvar r = range_max[i] - range_min[i];\r\n\t\t\t\tthis._clamped[i] = clamp( this._value[i], range_min[i], range_max[i] );\r\n\t\t\t\tif(r == 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis._value[i] = (target_min[i] + target_max[i]) * 0.5;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar n = (this._value[i] - range_min[i]) / r;\r\n\t\t\t\tif(this.properties.clamp)\r\n\t\t\t\t\tn = clamp(n,0,1);\r\n\t\t\t\tvar t = target_max[i] - target_min[i];\r\n\t\t\t\tthis._value[i] = target_min[i] + n * t;\r\n\t\t\t}\r\n\r\n\t\t\tthis.setOutputData(0,this._value);\r\n\t\t\tthis.setOutputData(1,this._clamped);\r\n        };\r\n\r\n        LiteGraph.registerNodeType("math3d/remap_range", Math3DRemapRange);\r\n\r\n\r\n\r\n    } //glMatrix\r\n\telse if (LiteGraph.debug)\r\n\t\tconsole.warn("No glmatrix found, some Math3D nodes may not work");\r\n\r\n})(this);\r\n\n//basic nodes\r\n(function(global) {\r\n    var LiteGraph = global.LiteGraph;\r\n\r\n    function toString(a) {\r\n\t\tif(a && a.constructor === Object)\r\n\t\t{\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\treturn JSON.stringify(a);\r\n\t\t\t}\r\n\t\t\tcatch (err)\r\n\t\t\t{\r\n\t\t\t\treturn String(a);\r\n\t\t\t}\r\n\t\t}\r\n        return String(a);\r\n    }\r\n\r\n    LiteGraph.wrapFunctionAsNode("string/toString", toString, [""], "string");\r\n\r\n    function compare(a, b) {\r\n        return a == b;\r\n    }\r\n\r\n    LiteGraph.wrapFunctionAsNode(\r\n        "string/compare",\r\n        compare,\r\n        ["string", "string"],\r\n        "boolean"\r\n    );\r\n\r\n    function concatenate(a, b) {\r\n        if (a === undefined) {\r\n            return b;\r\n        }\r\n        if (b === undefined) {\r\n            return a;\r\n        }\r\n        return a + b;\r\n    }\r\n\r\n    LiteGraph.wrapFunctionAsNode(\r\n        "string/concatenate",\r\n        concatenate,\r\n        ["string", "string"],\r\n        "string"\r\n    );\r\n\r\n    function contains(a, b) {\r\n        if (a === undefined || b === undefined) {\r\n            return false;\r\n        }\r\n        return a.indexOf(b) != -1;\r\n    }\r\n\r\n    LiteGraph.wrapFunctionAsNode(\r\n        "string/contains",\r\n        contains,\r\n        ["string", "string"],\r\n        "boolean"\r\n    );\r\n\r\n    function toUpperCase(a) {\r\n        if (a != null && a.constructor === String) {\r\n            return a.toUpperCase();\r\n        }\r\n        return a;\r\n    }\r\n\r\n    LiteGraph.wrapFunctionAsNode(\r\n        "string/toUpperCase",\r\n        toUpperCase,\r\n        ["string"],\r\n        "string"\r\n    );\r\n\r\n    function split(str, separator) {\r\n\t\tif(separator == null)\r\n\t\t\tseparator = this.properties.separator;\r\n        if (str == null )\r\n\t        return [];\r\n\t\tif( str.constructor === String )\r\n\t\t\treturn str.split(separator || " ");\r\n\t\telse if( str.constructor === Array )\r\n\t\t{\r\n\t\t\tvar r = [];\r\n\t\t\tfor(var i = 0; i < str.length; ++i){\r\n                if (typeof str[i] == "string")\r\n\t\t\t\t    r[i] = str[i].split(separator || " ");\r\n            }\r\n\t\t\treturn r;\r\n\t\t}\r\n        return null;\r\n    }\r\n\r\n    LiteGraph.wrapFunctionAsNode(\r\n        "string/split",\r\n        split,\r\n        ["string,array", "string"],\r\n        "array",\r\n\t\t{ separator: "," }\r\n    );\r\n\r\n    function toFixed(a) {\r\n        if (a != null && a.constructor === Number) {\r\n            return a.toFixed(this.properties.precision);\r\n        }\r\n        return a;\r\n    }\r\n\r\n    LiteGraph.wrapFunctionAsNode(\r\n        "string/toFixed",\r\n        toFixed,\r\n        ["number"],\r\n        "string",\r\n        { precision: 0 }\r\n    );\r\n\r\n\r\n    function StringToTable() {\r\n        this.addInput("", "string");\r\n        this.addOutput("table", "table");\r\n        this.addOutput("rows", "number");\r\n        this.addProperty("value", "");\r\n        this.addProperty("separator", ",");\r\n\t\tthis._table = null;\r\n    }\r\n\r\n    StringToTable.title = "toTable";\r\n    StringToTable.desc = "Splits a string to table";\r\n\r\n    StringToTable.prototype.onExecute = function() {\r\n        var input = this.getInputData(0);\r\n\t\tif(!input)\r\n\t\t\treturn;\r\n\t\tvar separator = this.properties.separator || ",";\r\n\t\tif(input != this._str || separator != this._last_separator )\r\n\t\t{\r\n\t\t\tthis._last_separator = separator;\r\n\t\t\tthis._str = input;\r\n\t\t\tthis._table = input.split("\\n").map(function(a){ return a.trim().split(separator)});\r\n\t\t}\r\n        this.setOutputData(0, this._table );\r\n        this.setOutputData(1, this._table ? this._table.length : 0 );\r\n    };\r\n\r\n    LiteGraph.registerNodeType("string/toTable", StringToTable);\r\n\r\n})(this);\r\n\n(function(global) {\n    var LiteGraph = global.LiteGraph;\n\n    function Selector() {\n        this.addInput("sel", "number");\n        this.addInput("A");\n        this.addInput("B");\n        this.addInput("C");\n        this.addInput("D");\n        this.addOutput("out");\n\n        this.selected = 0;\n    }\n\n    Selector.title = "Selector";\n    Selector.desc = "selects an output";\n\n    Selector.prototype.onDrawBackground = function(ctx) {\n        if (this.flags.collapsed) {\n            return;\n        }\n        ctx.fillStyle = "#AFB";\n        var y = (this.selected + 1) * LiteGraph.NODE_SLOT_HEIGHT + 6;\n        ctx.beginPath();\n        ctx.moveTo(50, y);\n        ctx.lineTo(50, y + LiteGraph.NODE_SLOT_HEIGHT);\n        ctx.lineTo(34, y + LiteGraph.NODE_SLOT_HEIGHT * 0.5);\n        ctx.fill();\n    };\n\n    Selector.prototype.onExecute = function() {\n        var sel = this.getInputData(0);\n        if (sel == null || sel.constructor !== Number)\n            sel = 0;\n        this.selected = sel = Math.round(sel) % (this.inputs.length - 1);\n        var v = this.getInputData(sel + 1);\n        if (v !== undefined) {\n            this.setOutputData(0, v);\n        }\n    };\n\n    Selector.prototype.onGetInputs = function() {\n        return [["E", 0], ["F", 0], ["G", 0], ["H", 0]];\n    };\n\n    LiteGraph.registerNodeType("logic/selector", Selector);\n\n    function Sequence() {\n        this.properties = {\n            sequence: "A,B,C"\n        };\n        this.addInput("index", "number");\n        this.addInput("seq");\n        this.addOutput("out");\n\n        this.index = 0;\n        this.values = this.properties.sequence.split(",");\n    }\n\n    Sequence.title = "Sequence";\n    Sequence.desc = "select one element from a sequence from a string";\n\n    Sequence.prototype.onPropertyChanged = function(name, value) {\n        if (name == "sequence") {\n            this.values = value.split(",");\n        }\n    };\n\n    Sequence.prototype.onExecute = function() {\n        var seq = this.getInputData(1);\n        if (seq && seq != this.current_sequence) {\n            this.values = seq.split(",");\n            this.current_sequence = seq;\n        }\n        var index = this.getInputData(0);\n        if (index == null) {\n            index = 0;\n        }\n        this.index = index = Math.round(index) % this.values.length;\n\n        this.setOutputData(0, this.values[index]);\n    };\n\n    LiteGraph.registerNodeType("logic/sequence", Sequence);\n\t\n    \n    function logicAnd(){\n        this.properties = { };\n        this.addInput("a", "boolean");\n        this.addInput("b", "boolean");\n        this.addOutput("out", "boolean");\n    }\n    logicAnd.title = "AND";\n    logicAnd.desc = "Return true if all inputs are true";\n    logicAnd.prototype.onExecute = function() {\n        var ret = true;\n        for (var inX in this.inputs){\n            if (!this.getInputData(inX)){\n                var ret = false;\n                break;\n            }\n        }\n        this.setOutputData(0, ret);\n    };\n    logicAnd.prototype.onGetInputs = function() {\n        return [\n            ["and", "boolean"]\n        ];\n    };\n    LiteGraph.registerNodeType("logic/AND", logicAnd);\n    \n    \n    function logicOr(){\n        this.properties = { };\n        this.addInput("a", "boolean");\n        this.addInput("b", "boolean");\n        this.addOutput("out", "boolean");\n    }\n    logicOr.title = "OR";\n    logicOr.desc = "Return true if at least one input is true";\n    logicOr.prototype.onExecute = function() {\n        var ret = false;\n        for (var inX in this.inputs){\n            if (this.getInputData(inX)){\n                ret = true;\n                break;\n            }\n        }\n        this.setOutputData(0, ret);\n    };\n    logicOr.prototype.onGetInputs = function() {\n        return [\n            ["or", "boolean"]\n        ];\n    };\n    LiteGraph.registerNodeType("logic/OR", logicOr);\n    \n    \n    function logicNot(){\n        this.properties = { };\n        this.addInput("in", "boolean");\n        this.addOutput("out", "boolean");\n    }\n    logicNot.title = "NOT";\n    logicNot.desc = "Return the logical negation";\n    logicNot.prototype.onExecute = function() {\n        var ret = !this.getInputData(0);\n        this.setOutputData(0, ret);\n    };\n    LiteGraph.registerNodeType("logic/NOT", logicNot);\n    \n    \n    function logicCompare(){\n        this.properties = { };\n        this.addInput("a", "boolean");\n        this.addInput("b", "boolean");\n        this.addOutput("out", "boolean");\n    }\n    logicCompare.title = "bool == bool";\n    logicCompare.desc = "Compare for logical equality";\n    logicCompare.prototype.onExecute = function() {\n        var last = null;\n        var ret = true;\n        for (var inX in this.inputs){\n            if (last === null) last = this.getInputData(inX);\n            else\n                if (last != this.getInputData(inX)){\n                    ret = false;\n                    break;\n                }\n        }\n        this.setOutputData(0, ret);\n    };\n    logicCompare.prototype.onGetInputs = function() {\n        return [\n            ["bool", "boolean"]\n        ];\n    };\n    LiteGraph.registerNodeType("logic/CompareBool", logicCompare);\n    \n    \n    function logicBranch(){\n        this.properties = { };\n        this.addInput("onTrigger", LiteGraph.ACTION);\n        this.addInput("condition", "boolean");\n        this.addOutput("true", LiteGraph.EVENT);\n        this.addOutput("false", LiteGraph.EVENT);\n        this.mode = LiteGraph.ON_TRIGGER;\n    }\n    logicBranch.title = "Branch";\n    logicBranch.desc = "Branch execution on condition";\n    logicBranch.prototype.onExecute = function(param, options) {\n        var condtition = this.getInputData(1);\n        if (condtition){\n            this.triggerSlot(0);\n        }else{\n            this.triggerSlot(1);\n        }\n    };\n    LiteGraph.registerNodeType("logic/IF", logicBranch);\n})(this);\n\n(function(global) {\n    var LiteGraph = global.LiteGraph;\n\n    function GraphicsPlot() {\n        this.addInput("A", "Number");\n        this.addInput("B", "Number");\n        this.addInput("C", "Number");\n        this.addInput("D", "Number");\n\n        this.values = [[], [], [], []];\n        this.properties = { scale: 2 };\n    }\n\n    GraphicsPlot.title = "Plot";\n    GraphicsPlot.desc = "Plots data over time";\n    GraphicsPlot.colors = ["#FFF", "#F99", "#9F9", "#99F"];\n\n    GraphicsPlot.prototype.onExecute = function(ctx) {\n        if (this.flags.collapsed) {\n            return;\n        }\n\n        var size = this.size;\n\n        for (var i = 0; i < 4; ++i) {\n            var v = this.getInputData(i);\n            if (v == null) {\n                continue;\n            }\n            var values = this.values[i];\n            values.push(v);\n            if (values.length > size[0]) {\n                values.shift();\n            }\n        }\n    };\n\n    GraphicsPlot.prototype.onDrawBackground = function(ctx) {\n        if (this.flags.collapsed) {\n            return;\n        }\n\n        var size = this.size;\n\n        var scale = (0.5 * size[1]) / this.properties.scale;\n        var colors = GraphicsPlot.colors;\n        var offset = size[1] * 0.5;\n\n        ctx.fillStyle = "#000";\n        ctx.fillRect(0, 0, size[0], size[1]);\n        ctx.strokeStyle = "#555";\n        ctx.beginPath();\n        ctx.moveTo(0, offset);\n        ctx.lineTo(size[0], offset);\n        ctx.stroke();\n\n        if (this.inputs) {\n            for (var i = 0; i < 4; ++i) {\n                var values = this.values[i];\n                if (!this.inputs[i] || !this.inputs[i].link) {\n                    continue;\n                }\n                ctx.strokeStyle = colors[i];\n                ctx.beginPath();\n                var v = values[0] * scale * -1 + offset;\n                ctx.moveTo(0, clamp(v, 0, size[1]));\n                for (var j = 1; j < values.length && j < size[0]; ++j) {\n                    var v = values[j] * scale * -1 + offset;\n                    ctx.lineTo(j, clamp(v, 0, size[1]));\n                }\n                ctx.stroke();\n            }\n        }\n    };\n\n    LiteGraph.registerNodeType("graphics/plot", GraphicsPlot);\n\n    function GraphicsImage() {\n        this.addOutput("frame", "image");\n        this.properties = { url: "" };\n    }\n\n    GraphicsImage.title = "Image";\n    GraphicsImage.desc = "Image loader";\n    GraphicsImage.widgets = [{ name: "load", text: "Load", type: "button" }];\n\n    GraphicsImage.supported_extensions = ["jpg", "jpeg", "png", "gif"];\n\n    GraphicsImage.prototype.onAdded = function() {\n        if (this.properties["url"] != "" && this.img == null) {\n            this.loadImage(this.properties["url"]);\n        }\n    };\n\n    GraphicsImage.prototype.onDrawBackground = function(ctx) {\n        if (this.flags.collapsed) {\n            return;\n        }\n        if (this.img && this.size[0] > 5 && this.size[1] > 5 && this.img.width) {\n            ctx.drawImage(this.img, 0, 0, this.size[0], this.size[1]);\n        }\n    };\n\n    GraphicsImage.prototype.onExecute = function() {\n        if (!this.img) {\n            this.boxcolor = "#000";\n        }\n        if (this.img && this.img.width) {\n            this.setOutputData(0, this.img);\n        } else {\n            this.setOutputData(0, null);\n        }\n        if (this.img && this.img.dirty) {\n            this.img.dirty = false;\n        }\n    };\n\n    GraphicsImage.prototype.onPropertyChanged = function(name, value) {\n        this.properties[name] = value;\n        if (name == "url" && value != "") {\n            this.loadImage(value);\n        }\n\n        return true;\n    };\n\n    GraphicsImage.prototype.loadImage = function(url, callback) {\n        if (url == "") {\n            this.img = null;\n            return;\n        }\n\n        this.img = document.createElement("img");\n\n        if (url.substr(0, 4) == "http" && LiteGraph.proxy) {\n            url = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);\n        }\n\n        this.img.src = url;\n        this.boxcolor = "#F95";\n        var that = this;\n        this.img.onload = function() {\n            if (callback) {\n                callback(this);\n            }\n            console.log( "Image loaded, size: " + that.img.width + "x" + that.img.height );\n            this.dirty = true;\n            that.boxcolor = "#9F9";\n            that.setDirtyCanvas(true);\n        };\n        this.img.onerror = function() {\n\t\t\tconsole.log("error loading the image:" + url);\n\t\t}\n    };\n\n    GraphicsImage.prototype.onWidget = function(e, widget) {\n        if (widget.name == "load") {\n            this.loadImage(this.properties["url"]);\n        }\n    };\n\n    GraphicsImage.prototype.onDropFile = function(file) {\n        var that = this;\n        if (this._url) {\n            URL.revokeObjectURL(this._url);\n        }\n        this._url = URL.createObjectURL(file);\n        this.properties.url = this._url;\n        this.loadImage(this._url, function(img) {\n            that.size[1] = (img.height / img.width) * that.size[0];\n        });\n    };\n\n    LiteGraph.registerNodeType("graphics/image", GraphicsImage);\n\n    function ColorPalette() {\n        this.addInput("f", "number");\n        this.addOutput("Color", "color");\n        this.properties = {\n            colorA: "#444444",\n            colorB: "#44AAFF",\n            colorC: "#44FFAA",\n            colorD: "#FFFFFF"\n        };\n    }\n\n    ColorPalette.title = "Palette";\n    ColorPalette.desc = "Generates a color";\n\n    ColorPalette.prototype.onExecute = function() {\n        var c = [];\n\n        if (this.properties.colorA != null) {\n            c.push(hex2num(this.properties.colorA));\n        }\n        if (this.properties.colorB != null) {\n            c.push(hex2num(this.properties.colorB));\n        }\n        if (this.properties.colorC != null) {\n            c.push(hex2num(this.properties.colorC));\n        }\n        if (this.properties.colorD != null) {\n            c.push(hex2num(this.properties.colorD));\n        }\n\n        var f = this.getInputData(0);\n        if (f == null) {\n            f = 0.5;\n        }\n        if (f > 1.0) {\n            f = 1.0;\n        } else if (f < 0.0) {\n            f = 0.0;\n        }\n\n        if (c.length == 0) {\n            return;\n        }\n\n        var result = [0, 0, 0];\n        if (f == 0) {\n            result = c[0];\n        } else if (f == 1) {\n            result = c[c.length - 1];\n        } else {\n            var pos = (c.length - 1) * f;\n            var c1 = c[Math.floor(pos)];\n            var c2 = c[Math.floor(pos) + 1];\n            var t = pos - Math.floor(pos);\n            result[0] = c1[0] * (1 - t) + c2[0] * t;\n            result[1] = c1[1] * (1 - t) + c2[1] * t;\n            result[2] = c1[2] * (1 - t) + c2[2] * t;\n        }\n\n        /*\n\tc[0] = 1.0 - Math.abs( Math.sin( 0.1 * reModular.getTime() * Math.PI) );\n\tc[1] = Math.abs( Math.sin( 0.07 * reModular.getTime() * Math.PI) );\n\tc[2] = Math.abs( Math.sin( 0.01 * reModular.getTime() * Math.PI) );\n\t*/\n\n        for (var i=0; i < result.length; i++) {\n            result[i] /= 255;\n        }\n\n        this.boxcolor = colorToString(result);\n        this.setOutputData(0, result);\n    };\n\n    LiteGraph.registerNodeType("color/palette", ColorPalette);\n\n    function ImageFrame() {\n        this.addInput("", "image,canvas");\n        this.size = [200, 200];\n    }\n\n    ImageFrame.title = "Frame";\n    ImageFrame.desc = "Frame viewerew";\n    ImageFrame.widgets = [\n        { name: "resize", text: "Resize box", type: "button" },\n        { name: "view", text: "View Image", type: "button" }\n    ];\n\n    ImageFrame.prototype.onDrawBackground = function(ctx) {\n        if (this.frame && !this.flags.collapsed) {\n            ctx.drawImage(this.frame, 0, 0, this.size[0], this.size[1]);\n        }\n    };\n\n    ImageFrame.prototype.onExecute = function() {\n        this.frame = this.getInputData(0);\n        this.setDirtyCanvas(true);\n    };\n\n    ImageFrame.prototype.onWidget = function(e, widget) {\n        if (widget.name == "resize" && this.frame) {\n            var width = this.frame.width;\n            var height = this.frame.height;\n\n            if (!width && this.frame.videoWidth != null) {\n                width = this.frame.videoWidth;\n                height = this.frame.videoHeight;\n            }\n\n            if (width && height) {\n                this.size = [width, height];\n            }\n            this.setDirtyCanvas(true, true);\n        } else if (widget.name == "view") {\n            this.show();\n        }\n    };\n\n    ImageFrame.prototype.show = function() {\n        //var str = this.canvas.toDataURL("image/png");\n        if (showElement && this.frame) {\n            showElement(this.frame);\n        }\n    };\n\n    LiteGraph.registerNodeType("graphics/frame", ImageFrame);\n\n    function ImageFade() {\n        this.addInputs([\n            ["img1", "image"],\n            ["img2", "image"],\n            ["fade", "number"]\n        ]);\n        this.addOutput("", "image");\n        this.properties = { fade: 0.5, width: 512, height: 512 };\n    }\n\n    ImageFade.title = "Image fade";\n    ImageFade.desc = "Fades between images";\n    ImageFade.widgets = [\n        { name: "resizeA", text: "Resize to A", type: "button" },\n        { name: "resizeB", text: "Resize to B", type: "button" }\n    ];\n\n    ImageFade.prototype.onAdded = function() {\n        this.createCanvas();\n        var ctx = this.canvas.getContext("2d");\n        ctx.fillStyle = "#000";\n        ctx.fillRect(0, 0, this.properties["width"], this.properties["height"]);\n    };\n\n    ImageFade.prototype.createCanvas = function() {\n        this.canvas = document.createElement("canvas");\n        this.canvas.width = this.properties["width"];\n        this.canvas.height = this.properties["height"];\n    };\n\n    ImageFade.prototype.onExecute = function() {\n        var ctx = this.canvas.getContext("2d");\n        this.canvas.width = this.canvas.width;\n\n        var A = this.getInputData(0);\n        if (A != null) {\n            ctx.drawImage(A, 0, 0, this.canvas.width, this.canvas.height);\n        }\n\n        var fade = this.getInputData(2);\n        if (fade == null) {\n            fade = this.properties["fade"];\n        } else {\n            this.properties["fade"] = fade;\n        }\n\n        ctx.globalAlpha = fade;\n        var B = this.getInputData(1);\n        if (B != null) {\n            ctx.drawImage(B, 0, 0, this.canvas.width, this.canvas.height);\n        }\n        ctx.globalAlpha = 1.0;\n\n        this.setOutputData(0, this.canvas);\n        this.setDirtyCanvas(true);\n    };\n\n    LiteGraph.registerNodeType("graphics/imagefade", ImageFade);\n\n    function ImageCrop() {\n        this.addInput("", "image");\n        this.addOutput("", "image");\n        this.properties = { width: 256, height: 256, x: 0, y: 0, scale: 1.0 };\n        this.size = [50, 20];\n    }\n\n    ImageCrop.title = "Crop";\n    ImageCrop.desc = "Crop Image";\n\n    ImageCrop.prototype.onAdded = function() {\n        this.createCanvas();\n    };\n\n    ImageCrop.prototype.createCanvas = function() {\n        this.canvas = document.createElement("canvas");\n        this.canvas.width = this.properties["width"];\n        this.canvas.height = this.properties["height"];\n    };\n\n    ImageCrop.prototype.onExecute = function() {\n        var input = this.getInputData(0);\n        if (!input) {\n            return;\n        }\n\n        if (input.width) {\n            var ctx = this.canvas.getContext("2d");\n\n            ctx.drawImage(\n                input,\n                -this.properties["x"],\n                -this.properties["y"],\n                input.width * this.properties["scale"],\n                input.height * this.properties["scale"]\n            );\n            this.setOutputData(0, this.canvas);\n        } else {\n            this.setOutputData(0, null);\n        }\n    };\n\n    ImageCrop.prototype.onDrawBackground = function(ctx) {\n        if (this.flags.collapsed) {\n            return;\n        }\n        if (this.canvas) {\n            ctx.drawImage(\n                this.canvas,\n                0,\n                0,\n                this.canvas.width,\n                this.canvas.height,\n                0,\n                0,\n                this.size[0],\n                this.size[1]\n            );\n        }\n    };\n\n    ImageCrop.prototype.onPropertyChanged = function(name, value) {\n        this.properties[name] = value;\n\n        if (name == "scale") {\n            this.properties[name] = parseFloat(value);\n            if (this.properties[name] == 0) {\n                console.error("Error in scale");\n                this.properties[name] = 1.0;\n            }\n        } else {\n            this.properties[name] = parseInt(value);\n        }\n\n        this.createCanvas();\n\n        return true;\n    };\n\n    LiteGraph.registerNodeType("graphics/cropImage", ImageCrop);\n\n    //CANVAS stuff\n\n    function CanvasNode() {\n        this.addInput("clear", LiteGraph.ACTION);\n        this.addOutput("", "canvas");\n        this.properties = { width: 512, height: 512, autoclear: true };\n\n        this.canvas = document.createElement("canvas");\n        this.ctx = this.canvas.getContext("2d");\n    }\n\n    CanvasNode.title = "Canvas";\n    CanvasNode.desc = "Canvas to render stuff";\n\n    CanvasNode.prototype.onExecute = function() {\n        var canvas = this.canvas;\n        var w = this.properties.width | 0;\n        var h = this.properties.height | 0;\n        if (canvas.width != w) {\n            canvas.width = w;\n        }\n        if (canvas.height != h) {\n            canvas.height = h;\n        }\n\n        if (this.properties.autoclear) {\n            this.ctx.clearRect(0, 0, canvas.width, canvas.height);\n        }\n        this.setOutputData(0, canvas);\n    };\n\n    CanvasNode.prototype.onAction = function(action, param) {\n        if (action == "clear") {\n            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        }\n    };\n\n    LiteGraph.registerNodeType("graphics/canvas", CanvasNode);\n\n    function DrawImageNode() {\n        this.addInput("canvas", "canvas");\n        this.addInput("img", "image,canvas");\n        this.addInput("x", "number");\n        this.addInput("y", "number");\n        this.properties = { x: 0, y: 0, opacity: 1 };\n    }\n\n    DrawImageNode.title = "DrawImage";\n    DrawImageNode.desc = "Draws image into a canvas";\n\n    DrawImageNode.prototype.onExecute = function() {\n        var canvas = this.getInputData(0);\n        if (!canvas) {\n            return;\n        }\n\n        var img = this.getInputOrProperty("img");\n        if (!img) {\n            return;\n        }\n\n        var x = this.getInputOrProperty("x");\n        var y = this.getInputOrProperty("y");\n        var ctx = canvas.getContext("2d");\n        ctx.drawImage(img, x, y);\n    };\n\n    LiteGraph.registerNodeType("graphics/drawImage", DrawImageNode);\n\n    function DrawRectangleNode() {\n        this.addInput("canvas", "canvas");\n        this.addInput("x", "number");\n        this.addInput("y", "number");\n        this.addInput("w", "number");\n        this.addInput("h", "number");\n        this.properties = {\n            x: 0,\n            y: 0,\n            w: 10,\n            h: 10,\n            color: "white",\n            opacity: 1\n        };\n    }\n\n    DrawRectangleNode.title = "DrawRectangle";\n    DrawRectangleNode.desc = "Draws rectangle in canvas";\n\n    DrawRectangleNode.prototype.onExecute = function() {\n        var canvas = this.getInputData(0);\n        if (!canvas) {\n            return;\n        }\n\n        var x = this.getInputOrProperty("x");\n        var y = this.getInputOrProperty("y");\n        var w = this.getInputOrProperty("w");\n        var h = this.getInputOrProperty("h");\n        var ctx = canvas.getContext("2d");\n        ctx.fillRect(x, y, w, h);\n    };\n\n    LiteGraph.registerNodeType("graphics/drawRectangle", DrawRectangleNode);\n\n    function ImageVideo() {\n        this.addInput("t", "number");\n        this.addOutputs([["frame", "image"], ["t", "number"], ["d", "number"]]);\n        this.properties = { url: "", use_proxy: true };\n    }\n\n    ImageVideo.title = "Video";\n    ImageVideo.desc = "Video playback";\n    ImageVideo.widgets = [\n        { name: "play", text: "PLAY", type: "minibutton" },\n        { name: "stop", text: "STOP", type: "minibutton" },\n        { name: "demo", text: "Demo video", type: "button" },\n        { name: "mute", text: "Mute video", type: "button" }\n    ];\n\n    ImageVideo.prototype.onExecute = function() {\n        if (!this.properties.url) {\n            return;\n        }\n\n        if (this.properties.url != this._video_url) {\n            this.loadVideo(this.properties.url);\n        }\n\n        if (!this._video || this._video.width == 0) {\n            return;\n        }\n\n        var t = this.getInputData(0);\n        if (t && t >= 0 && t <= 1.0) {\n            this._video.currentTime = t * this._video.duration;\n            this._video.pause();\n        }\n\n        this._video.dirty = true;\n        this.setOutputData(0, this._video);\n        this.setOutputData(1, this._video.currentTime);\n        this.setOutputData(2, this._video.duration);\n        this.setDirtyCanvas(true);\n    };\n\n    ImageVideo.prototype.onStart = function() {\n        this.play();\n    };\n\n    ImageVideo.prototype.onStop = function() {\n        this.stop();\n    };\n\n    ImageVideo.prototype.loadVideo = function(url) {\n        this._video_url = url;\n\n\t\tvar pos = url.substr(0,10).indexOf(":");\n\t\tvar protocol = "";\n\t\tif(pos != -1)\n\t\t\tprotocol = url.substr(0,pos);\n\n\t\tvar host = "";\n\t\tif(protocol)\n\t\t{\n\t\t\thost = url.substr(0,url.indexOf("/",protocol.length + 3));\n\t\t\thost = host.substr(protocol.length+3);\n\t\t}\n\n        if (\n            this.properties.use_proxy &&\n            protocol &&\n            LiteGraph.proxy &&\n\t\t\thost != location.host\n        ) {\n            url = LiteGraph.proxy + url.substr(url.indexOf(":") + 3);\n        }\n\n        this._video = document.createElement("video");\n        this._video.src = url;\n        this._video.type = "type=video/mp4";\n\n        this._video.muted = true;\n        this._video.autoplay = true;\n\n        var that = this;\n        this._video.addEventListener("loadedmetadata", function(e) {\n            //onload\n            console.log("Duration: " + this.duration + " seconds");\n            console.log("Size: " + this.videoWidth + "," + this.videoHeight);\n            that.setDirtyCanvas(true);\n            this.width = this.videoWidth;\n            this.height = this.videoHeight;\n        });\n        this._video.addEventListener("progress", function(e) {\n            //onload\n            console.log("video loading...");\n        });\n        this._video.addEventListener("error", function(e) {\n            console.error("Error loading video: " + this.src);\n            if (this.error) {\n                switch (this.error.code) {\n                    case this.error.MEDIA_ERR_ABORTED:\n                        console.error("You stopped the video.");\n                        break;\n                    case this.error.MEDIA_ERR_NETWORK:\n                        console.error("Network error - please try again later.");\n                        break;\n                    case this.error.MEDIA_ERR_DECODE:\n                        console.error("Video is broken..");\n                        break;\n                    case this.error.MEDIA_ERR_SRC_NOT_SUPPORTED:\n                        console.error("Sorry, your browser can\'t play this video.");\n                        break;\n                }\n            }\n        });\n\n        this._video.addEventListener("ended", function(e) {\n            console.log("Video Ended.");\n            this.play(); //loop\n        });\n\n        //document.body.appendChild(this.video);\n    };\n\n    ImageVideo.prototype.onPropertyChanged = function(name, value) {\n        this.properties[name] = value;\n        if (name == "url" && value != "") {\n            this.loadVideo(value);\n        }\n\n        return true;\n    };\n\n    ImageVideo.prototype.play = function() {\n        if (this._video && this._video.videoWidth ) { //is loaded\n            this._video.play();\n        }\n    };\n\n    ImageVideo.prototype.playPause = function() {\n        if (!this._video) {\n            return;\n        }\n        if (this._video.paused) {\n            this.play();\n        } else {\n            this.pause();\n        }\n    };\n\n    ImageVideo.prototype.stop = function() {\n        if (!this._video) {\n            return;\n        }\n        this._video.pause();\n        this._video.currentTime = 0;\n    };\n\n    ImageVideo.prototype.pause = function() {\n        if (!this._video) {\n            return;\n        }\n        console.log("Video paused");\n        this._video.pause();\n    };\n\n    ImageVideo.prototype.onWidget = function(e, widget) {\n        /*\n\tif(widget.name == "demo")\n\t{\n\t\tthis.loadVideo();\n\t}\n\telse if(widget.name == "play")\n\t{\n\t\tif(this._video)\n\t\t\tthis.playPause();\n\t}\n\tif(widget.name == "stop")\n\t{\n\t\tthis.stop();\n\t}\n\telse if(widget.name == "mute")\n\t{\n\t\tif(this._video)\n\t\t\tthis._video.muted = !this._video.muted;\n\t}\n\t*/\n    };\n\n    LiteGraph.registerNodeType("graphics/video", ImageVideo);\n\n    // Texture Webcam *****************************************\n    function ImageWebcam() {\n        this.addOutput("Webcam", "image");\n        this.properties = { filterFacingMode: false, facingMode: "user" };\n        this.boxcolor = "black";\n        this.frame = 0;\n    }\n\n    ImageWebcam.title = "Webcam";\n    ImageWebcam.desc = "Webcam image";\n    ImageWebcam.is_webcam_open = false;\n\n    ImageWebcam.prototype.openStream = function() {\n        if (!navigator.mediaDevices.getUserMedia) {\n            console.log(\'getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags\');\n            return;\n        }\n\n        this._waiting_confirmation = true;\n\n        // Not showing vendor prefixes.\n        var constraints = {\n            audio: false,\n            video: !this.properties.filterFacingMode ? true : { facingMode: this.properties.facingMode }\n        };\n        navigator.mediaDevices\n            .getUserMedia(constraints)\n            .then(this.streamReady.bind(this))\n            .catch(onFailSoHard);\n\n        var that = this;\n        function onFailSoHard(e) {\n            console.log("Webcam rejected", e);\n            that._webcam_stream = false;\n            ImageWebcam.is_webcam_open = false;\n            that.boxcolor = "red";\n            that.trigger("stream_error");\n        }\n    };\n\n    ImageWebcam.prototype.closeStream = function() {\n        if (this._webcam_stream) {\n            var tracks = this._webcam_stream.getTracks();\n            if (tracks.length) {\n                for (var i = 0; i < tracks.length; ++i) {\n                    tracks[i].stop();\n                }\n            }\n            ImageWebcam.is_webcam_open = false;\n            this._webcam_stream = null;\n            this._video = null;\n            this.boxcolor = "black";\n            this.trigger("stream_closed");\n        }\n    };\n\n    ImageWebcam.prototype.onPropertyChanged = function(name, value) {\n        if (name == "facingMode") {\n            this.properties.facingMode = value;\n            this.closeStream();\n            this.openStream();\n        }\n    };\n\n    ImageWebcam.prototype.onRemoved = function() {\n        this.closeStream();\n    };\n\n    ImageWebcam.prototype.streamReady = function(localMediaStream) {\n        this._webcam_stream = localMediaStream;\n        //this._waiting_confirmation = false;\n        this.boxcolor = "green";\n\n        var video = this._video;\n        if (!video) {\n            video = document.createElement("video");\n            video.autoplay = true;\n            video.srcObject = localMediaStream;\n            this._video = video;\n            //document.body.appendChild( video ); //debug\n            //when video info is loaded (size and so)\n            video.onloadedmetadata = function(e) {\n                // Ready to go. Do some stuff.\n                console.log(e);\n                ImageWebcam.is_webcam_open = true;\n            };\n        }\n\n        this.trigger("stream_ready", video);\n    };\n\n    ImageWebcam.prototype.onExecute = function() {\n        if (this._webcam_stream == null && !this._waiting_confirmation) {\n            this.openStream();\n        }\n\n        if (!this._video || !this._video.videoWidth) {\n            return;\n        }\n\n        this._video.frame = ++this.frame;\n        this._video.width = this._video.videoWidth;\n        this._video.height = this._video.videoHeight;\n        this.setOutputData(0, this._video);\n        for (var i = 1; i < this.outputs.length; ++i) {\n            if (!this.outputs[i]) {\n                continue;\n            }\n            switch (this.outputs[i].name) {\n                case "width":\n                    this.setOutputData(i, this._video.videoWidth);\n                    break;\n                case "height":\n                    this.setOutputData(i, this._video.videoHeight);\n                    break;\n            }\n        }\n    };\n\n    ImageWebcam.prototype.getExtraMenuOptions = function(graphcanvas) {\n        var that = this;\n        var txt = !that.properties.show ? "Show Frame" : "Hide Frame";\n        return [\n            {\n                content: txt,\n                callback: function() {\n                    that.properties.show = !that.properties.show;\n                }\n            }\n        ];\n    };\n\n    ImageWebcam.prototype.onDrawBackground = function(ctx) {\n        if (\n            this.flags.collapsed ||\n            this.size[1] <= 20 ||\n            !this.properties.show\n        ) {\n            return;\n        }\n\n        if (!this._video) {\n            return;\n        }\n\n        //render to graph canvas\n        ctx.save();\n        ctx.drawImage(this._video, 0, 0, this.size[0], this.size[1]);\n        ctx.restore();\n    };\n\n    ImageWebcam.prototype.onGetOutputs = function() {\n        return [\n            ["width", "number"],\n            ["height", "number"],\n            ["stream_ready", LiteGraph.EVENT],\n            ["stream_closed", LiteGraph.EVENT],\n            ["stream_error", LiteGraph.EVENT]\n        ];\n    };\n\n    LiteGraph.registerNodeType("graphics/webcam", ImageWebcam);\n})(this);\n\n(function(global) {\n    var LiteGraph = global.LiteGraph;\n\tvar LGraphCanvas = global.LGraphCanvas;\n\n    //Works with Litegl.js to create WebGL nodes\n    global.LGraphTexture = null;\n\n    if (typeof GL == "undefined")\n\t\treturn;\n\n\tLGraphCanvas.link_type_colors["Texture"] = "#987";\n\n\tfunction LGraphTexture() {\n\t\tthis.addOutput("tex", "Texture");\n\t\tthis.addOutput("name", "string");\n\t\tthis.properties = { name: "", filter: true };\n\t\tthis.size = [\n\t\t\tLGraphTexture.image_preview_size,\n\t\t\tLGraphTexture.image_preview_size\n\t\t];\n\t}\n\n\tglobal.LGraphTexture = LGraphTexture;\n\n\tLGraphTexture.title = "Texture";\n\tLGraphTexture.desc = "Texture";\n\tLGraphTexture.widgets_info = {\n\t\tname: { widget: "texture" },\n\t\tfilter: { widget: "checkbox" }\n\t};\n\n\t//REPLACE THIS TO INTEGRATE WITH YOUR FRAMEWORK\n\tLGraphTexture.loadTextureCallback = null; //function in charge of loading textures when not present in the container\n\tLGraphTexture.image_preview_size = 256;\n\n\t//flags to choose output texture type\n\tLGraphTexture.UNDEFINED = 0; //not specified\n\tLGraphTexture.PASS_THROUGH = 1; //do not apply FX (like disable but passing the in to the out)\n\tLGraphTexture.COPY = 2; //create new texture with the same properties as the origin texture\n\tLGraphTexture.LOW = 3; //create new texture with low precision (byte)\n\tLGraphTexture.HIGH = 4; //create new texture with high precision (half-float)\n\tLGraphTexture.REUSE = 5; //reuse input texture\n\tLGraphTexture.DEFAULT = 2; //use the default\n\n\tLGraphTexture.MODE_VALUES = {\n\t\t"undefined": LGraphTexture.UNDEFINED,\n\t\t"pass through": LGraphTexture.PASS_THROUGH,\n\t\tcopy: LGraphTexture.COPY,\n\t\tlow: LGraphTexture.LOW,\n\t\thigh: LGraphTexture.HIGH,\n\t\treuse: LGraphTexture.REUSE,\n\t\tdefault: LGraphTexture.DEFAULT\n\t};\n\n\t//returns the container where all the loaded textures are stored (overwrite if you have a Resources Manager)\n\tLGraphTexture.getTexturesContainer = function() {\n\t\treturn gl.textures;\n\t};\n\n\t//process the loading of a texture (overwrite it if you have a Resources Manager)\n\tLGraphTexture.loadTexture = function(name, options) {\n\t\toptions = options || {};\n\t\tvar url = name;\n\t\tif (url.substr(0, 7) == "http://") {\n\t\t\tif (LiteGraph.proxy) {\n\t\t\t\t//proxy external files\n\t\t\t\turl = LiteGraph.proxy + url.substr(7);\n\t\t\t}\n\t\t}\n\n\t\tvar container = LGraphTexture.getTexturesContainer();\n\t\tvar tex = (container[name] = GL.Texture.fromURL(url, options));\n\t\treturn tex;\n\t};\n\n\tLGraphTexture.getTexture = function(name) {\n\t\tvar container = this.getTexturesContainer();\n\n\t\tif (!container) {\n\t\t\tthrow "Cannot load texture, container of textures not found";\n\t\t}\n\n\t\tvar tex = container[name];\n\t\tif (!tex && name && name[0] != ":") {\n\t\t\treturn this.loadTexture(name);\n\t\t}\n\n\t\treturn tex;\n\t};\n\n\t//used to compute the appropiate output texture\n\tLGraphTexture.getTargetTexture = function(origin, target, mode) {\n\t\tif (!origin) {\n\t\t\tthrow "LGraphTexture.getTargetTexture expects a reference texture";\n\t\t}\n\n\t\tvar tex_type = null;\n\n\t\tswitch (mode) {\n\t\t\tcase LGraphTexture.LOW:\n\t\t\t\ttex_type = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\t\t\tcase LGraphTexture.HIGH:\n\t\t\t\ttex_type = gl.HIGH_PRECISION_FORMAT;\n\t\t\t\tbreak;\n\t\t\tcase LGraphTexture.REUSE:\n\t\t\t\treturn origin;\n\t\t\t\tbreak;\n\t\t\tcase LGraphTexture.COPY:\n\t\t\tdefault:\n\t\t\t\ttex_type = origin ? origin.type : gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (\n\t\t\t!target ||\n\t\t\ttarget.width != origin.width ||\n\t\t\ttarget.height != origin.height ||\n\t\t\ttarget.type != tex_type ||\n\t\t\ttarget.format != origin.format \n\t\t) {\n\t\t\ttarget = new GL.Texture(origin.width, origin.height, {\n\t\t\t\ttype: tex_type,\n\t\t\t\tformat: origin.format,\n\t\t\t\tfilter: gl.LINEAR\n\t\t\t});\n\t\t}\n\n\t\treturn target;\n\t};\n\n\tLGraphTexture.getTextureType = function(precision, ref_texture) {\n\t\tvar type = ref_texture ? ref_texture.type : gl.UNSIGNED_BYTE;\n\t\tswitch (precision) {\n\t\t\tcase LGraphTexture.HIGH:\n\t\t\t\ttype = gl.HIGH_PRECISION_FORMAT;\n\t\t\t\tbreak;\n\t\t\tcase LGraphTexture.LOW:\n\t\t\t\ttype = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\t\t\t//no default\n\t\t}\n\t\treturn type;\n\t};\n\n\tLGraphTexture.getWhiteTexture = function() {\n\t\tif (this._white_texture) {\n\t\t\treturn this._white_texture;\n\t\t}\n\t\tvar texture = (this._white_texture = GL.Texture.fromMemory(\n\t\t\t1,\n\t\t\t1,\n\t\t\t[255, 255, 255, 255],\n\t\t\t{ format: gl.RGBA, wrap: gl.REPEAT, filter: gl.NEAREST }\n\t\t));\n\t\treturn texture;\n\t};\n\n\tLGraphTexture.getNoiseTexture = function() {\n\t\tif (this._noise_texture) {\n\t\t\treturn this._noise_texture;\n\t\t}\n\n\t\tvar noise = new Uint8Array(512 * 512 * 4);\n\t\tfor (var i = 0; i < 512 * 512 * 4; ++i) {\n\t\t\tnoise[i] = Math.random() * 255;\n\t\t}\n\n\t\tvar texture = GL.Texture.fromMemory(512, 512, noise, {\n\t\t\tformat: gl.RGBA,\n\t\t\twrap: gl.REPEAT,\n\t\t\tfilter: gl.NEAREST\n\t\t});\n\t\tthis._noise_texture = texture;\n\t\treturn texture;\n\t};\n\n\tLGraphTexture.prototype.onDropFile = function(data, filename, file) {\n\t\tif (!data) {\n\t\t\tthis._drop_texture = null;\n\t\t\tthis.properties.name = "";\n\t\t} else {\n\t\t\tvar texture = null;\n\t\t\tif (typeof data == "string") {\n\t\t\t\ttexture = GL.Texture.fromURL(data);\n\t\t\t} else if (filename.toLowerCase().indexOf(".dds") != -1) {\n\t\t\t\ttexture = GL.Texture.fromDDSInMemory(data);\n\t\t\t} else {\n\t\t\t\tvar blob = new Blob([file]);\n\t\t\t\tvar url = URL.createObjectURL(blob);\n\t\t\t\ttexture = GL.Texture.fromURL(url);\n\t\t\t}\n\n\t\t\tthis._drop_texture = texture;\n\t\t\tthis.properties.name = filename;\n\t\t}\n\t};\n\n\tLGraphTexture.prototype.getExtraMenuOptions = function(graphcanvas) {\n\t\tvar that = this;\n\t\tif (!this._drop_texture) {\n\t\t\treturn;\n\t\t}\n\t\treturn [\n\t\t\t{\n\t\t\t\tcontent: "Clear",\n\t\t\t\tcallback: function() {\n\t\t\t\t\tthat._drop_texture = null;\n\t\t\t\t\tthat.properties.name = "";\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\t};\n\n\tLGraphTexture.prototype.onExecute = function() {\n\t\tvar tex = null;\n\t\tif (this.isOutputConnected(1)) {\n\t\t\ttex = this.getInputData(0);\n\t\t}\n\n\t\tif (!tex && this._drop_texture) {\n\t\t\ttex = this._drop_texture;\n\t\t}\n\n\t\tif (!tex && this.properties.name) {\n\t\t\ttex = LGraphTexture.getTexture(this.properties.name);\n\t\t}\n\n\t\tif (!tex) {\n\t\t\tthis.setOutputData( 0, null );\n\t\t\tthis.setOutputData( 1, "" );\n\t\t\treturn;\n\t\t}\n\n\t\tthis._last_tex = tex;\n\n\t\tif (this.properties.filter === false) {\n\t\t\ttex.setParameter(gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\t\t} else {\n\t\t\ttex.setParameter(gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\t\t}\n\n\t\tthis.setOutputData( 0, tex );\n\t\tthis.setOutputData( 1, tex.fullpath || tex.filename );\n\n\t\tfor (var i = 2; i < this.outputs.length; i++) {\n\t\t\tvar output = this.outputs[i];\n\t\t\tif (!output) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar v = null;\n\t\t\tif (output.name == "width") {\n\t\t\t\tv = tex.width;\n\t\t\t} else if (output.name == "height") {\n\t\t\t\tv = tex.height;\n\t\t\t} else if (output.name == "aspect") {\n\t\t\t\tv = tex.width / tex.height;\n\t\t\t}\n\t\t\tthis.setOutputData(i, v);\n\t\t}\n\t};\n\n\tLGraphTexture.prototype.onResourceRenamed = function(\n\t\told_name,\n\t\tnew_name\n\t) {\n\t\tif (this.properties.name == old_name) {\n\t\t\tthis.properties.name = new_name;\n\t\t}\n\t};\n\n\tLGraphTexture.prototype.onDrawBackground = function(ctx) {\n\t\tif (this.flags.collapsed || this.size[1] <= 20) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._drop_texture && ctx.webgl) {\n\t\t\tctx.drawImage(\n\t\t\t\tthis._drop_texture,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tthis.size[0],\n\t\t\t\tthis.size[1]\n\t\t\t);\n\t\t\t//this._drop_texture.renderQuad(this.pos[0],this.pos[1],this.size[0],this.size[1]);\n\t\t\treturn;\n\t\t}\n\n\t\t//Different texture? then get it from the GPU\n\t\tif (this._last_preview_tex != this._last_tex) {\n\t\t\tif (ctx.webgl) {\n\t\t\t\tthis._canvas = this._last_tex;\n\t\t\t} else {\n\t\t\t\tvar tex_canvas = LGraphTexture.generateLowResTexturePreview(\n\t\t\t\t\tthis._last_tex\n\t\t\t\t);\n\t\t\t\tif (!tex_canvas) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._last_preview_tex = this._last_tex;\n\t\t\t\tthis._canvas = cloneCanvas(tex_canvas);\n\t\t\t}\n\t\t}\n\n\t\tif (!this._canvas) {\n\t\t\treturn;\n\t\t}\n\n\t\t//render to graph canvas\n\t\tctx.save();\n\t\tif (!ctx.webgl) {\n\t\t\t//reverse image\n\t\t\tctx.translate(0, this.size[1]);\n\t\t\tctx.scale(1, -1);\n\t\t}\n\t\tctx.drawImage(this._canvas, 0, 0, this.size[0], this.size[1]);\n\t\tctx.restore();\n\t};\n\n\t//very slow, used at your own risk\n\tLGraphTexture.generateLowResTexturePreview = function(tex) {\n\t\tif (!tex) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar size = LGraphTexture.image_preview_size;\n\t\tvar temp_tex = tex;\n\n\t\tif (tex.format == gl.DEPTH_COMPONENT) {\n\t\t\treturn null;\n\t\t} //cannot generate from depth\n\n\t\t//Generate low-level version in the GPU to speed up\n\t\tif (tex.width > size || tex.height > size) {\n\t\t\ttemp_tex = this._preview_temp_tex;\n\t\t\tif (!this._preview_temp_tex) {\n\t\t\t\ttemp_tex = new GL.Texture(size, size, {\n\t\t\t\t\tminFilter: gl.NEAREST\n\t\t\t\t});\n\t\t\t\tthis._preview_temp_tex = temp_tex;\n\t\t\t}\n\n\t\t\t//copy\n\t\t\ttex.copyTo(temp_tex);\n\t\t\ttex = temp_tex;\n\t\t}\n\n\t\t//create intermediate canvas with lowquality version\n\t\tvar tex_canvas = this._preview_canvas;\n\t\tif (!tex_canvas) {\n\t\t\ttex_canvas = createCanvas(size, size);\n\t\t\tthis._preview_canvas = tex_canvas;\n\t\t}\n\n\t\tif (temp_tex) {\n\t\t\ttemp_tex.toCanvas(tex_canvas);\n\t\t}\n\t\treturn tex_canvas;\n\t};\n\n\tLGraphTexture.prototype.getResources = function(res) {\n\t\tif(this.properties.name)\n\t\t\tres[this.properties.name] = GL.Texture;\n\t\treturn res;\n\t};\n\n\tLGraphTexture.prototype.onGetInputs = function() {\n\t\treturn [["in", "Texture"]];\n\t};\n\n\tLGraphTexture.prototype.onGetOutputs = function() {\n\t\treturn [\n\t\t\t["width", "number"],\n\t\t\t["height", "number"],\n\t\t\t["aspect", "number"]\n\t\t];\n\t};\n\n\t//used to replace shader code\n\tLGraphTexture.replaceCode = function( code, context )\n\t{\n\t\treturn code.replace(/\\{\\{[a-zA-Z0-9_]*\\}\\}/g, function(v){\n\t\t\tv = v.replace( /[\\{\\}]/g, "" );\n\t\t\treturn context[v] || "";\n\t\t});\n\t}\n\n\tLiteGraph.registerNodeType("texture/texture", LGraphTexture);\n\n\t//**************************\n\tfunction LGraphTexturePreview() {\n\t\tthis.addInput("Texture", "Texture");\n\t\tthis.properties = { flipY: false };\n\t\tthis.size = [\n\t\t\tLGraphTexture.image_preview_size,\n\t\t\tLGraphTexture.image_preview_size\n\t\t];\n\t}\n\n\tLGraphTexturePreview.title = "Preview";\n\tLGraphTexturePreview.desc = "Show a texture in the graph canvas";\n\tLGraphTexturePreview.allow_preview = false;\n\n\tLGraphTexturePreview.prototype.onDrawBackground = function(ctx) {\n\t\tif (this.flags.collapsed) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!ctx.webgl && !LGraphTexturePreview.allow_preview) {\n\t\t\treturn;\n\t\t} //not working well\n\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar tex_canvas = null;\n\n\t\tif (!tex.handle && ctx.webgl) {\n\t\t\ttex_canvas = tex;\n\t\t} else {\n\t\t\ttex_canvas = LGraphTexture.generateLowResTexturePreview(tex);\n\t\t}\n\n\t\t//render to graph canvas\n\t\tctx.save();\n\t\tif (this.properties.flipY) {\n\t\t\tctx.translate(0, this.size[1]);\n\t\t\tctx.scale(1, -1);\n\t\t}\n\t\tctx.drawImage(tex_canvas, 0, 0, this.size[0], this.size[1]);\n\t\tctx.restore();\n\t};\n\n\tLiteGraph.registerNodeType("texture/preview", LGraphTexturePreview);\n\n\t//**************************************\n\n\tfunction LGraphTextureSave() {\n\t\tthis.addInput("Texture", "Texture");\n\t\tthis.addOutput("tex", "Texture");\n\t\tthis.addOutput("name", "string");\n\t\tthis.properties = { name: "", generate_mipmaps: false };\n\t}\n\n\tLGraphTextureSave.title = "Save";\n\tLGraphTextureSave.desc = "Save a texture in the repository";\n\n\tLGraphTextureSave.prototype.getPreviewTexture = function()\n\t{\n\t\treturn this._texture;\n\t}\n\n\tLGraphTextureSave.prototype.onExecute = function() {\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.properties.generate_mipmaps) {\n\t\t\ttex.bind(0);\n\t\t\ttex.setParameter( gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR );\n\t\t\tgl.generateMipmap(tex.texture_type);\n\t\t\ttex.unbind(0);\n\t\t}\n\n\t\tif (this.properties.name) {\n\t\t\t//for cases where we want to perform something when storing it\n\t\t\tif (LGraphTexture.storeTexture) {\n\t\t\t\tLGraphTexture.storeTexture(this.properties.name, tex);\n\t\t\t} else {\n\t\t\t\tvar container = LGraphTexture.getTexturesContainer();\n\t\t\t\tcontainer[this.properties.name] = tex;\n\t\t\t}\n\t\t}\n\n\t\tthis._texture = tex;\n\t\tthis.setOutputData(0, tex);\n\t\tthis.setOutputData(1, this.properties.name);\n\t};\n\n\tLiteGraph.registerNodeType("texture/save", LGraphTextureSave);\n\n\t//****************************************************\n\n\tfunction LGraphTextureOperation() {\n\t\tthis.addInput("Texture", "Texture");\n\t\tthis.addInput("TextureB", "Texture");\n\t\tthis.addInput("value", "number");\n\t\tthis.addOutput("Texture", "Texture");\n\t\tthis.help = "<p>pixelcode must be vec3, uvcode must be vec2, is optional</p>\\\n\t\t<p><strong>uv:</strong> tex. coords</p><p><strong>color:</strong> texture <strong>colorB:</strong> textureB</p><p><strong>time:</strong> scene time <strong>value:</strong> input value</p><p>For multiline you must type: result = ...</p>";\n\n\t\tthis.properties = {\n\t\t\tvalue: 1,\n\t\t\tpixelcode: "color + colorB * value",\n\t\t\tuvcode: "",\n\t\t\tprecision: LGraphTexture.DEFAULT\n\t\t};\n\n\t\tthis.has_error = false;\n\t}\n\n\tLGraphTextureOperation.widgets_info = {\n\t\tuvcode: { widget: "code" },\n\t\tpixelcode: { widget: "code" },\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureOperation.title = "Operation";\n\tLGraphTextureOperation.desc = "Texture shader operation";\n\n\tLGraphTextureOperation.presets = {};\n\n\tLGraphTextureOperation.prototype.getExtraMenuOptions = function(\n\t\tgraphcanvas\n\t) {\n\t\tvar that = this;\n\t\tvar txt = !that.properties.show ? "Show Texture" : "Hide Texture";\n\t\treturn [\n\t\t\t{\n\t\t\t\tcontent: txt,\n\t\t\t\tcallback: function() {\n\t\t\t\t\tthat.properties.show = !that.properties.show;\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\t};\n\n\tLGraphTextureOperation.prototype.onPropertyChanged = function()\n\t{\n\t\tthis.has_error = false;\n\t}\n\n\tLGraphTextureOperation.prototype.onDrawBackground = function(ctx) {\n\t\tif (\n\t\t\tthis.flags.collapsed ||\n\t\t\tthis.size[1] <= 20 ||\n\t\t\t!this.properties.show\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._tex) {\n\t\t\treturn;\n\t\t}\n\n\t\t//only works if using a webgl renderer\n\t\tif (this._tex.gl != ctx) {\n\t\t\treturn;\n\t\t}\n\n\t\t//render to graph canvas\n\t\tctx.save();\n\t\tctx.drawImage(this._tex, 0, 0, this.size[0], this.size[1]);\n\t\tctx.restore();\n\t};\n\n\tLGraphTextureOperation.prototype.onExecute = function() {\n\t\tvar tex = this.getInputData(0);\n\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tif (this.properties.precision === LGraphTexture.PASS_THROUGH) {\n\t\t\tthis.setOutputData(0, tex);\n\t\t\treturn;\n\t\t}\n\n\t\tvar texB = this.getInputData(1);\n\n\t\tif (!this.properties.uvcode && !this.properties.pixelcode) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar width = 512;\n\t\tvar height = 512;\n\t\tif (tex) {\n\t\t\twidth = tex.width;\n\t\t\theight = tex.height;\n\t\t} else if (texB) {\n\t\t\twidth = texB.width;\n\t\t\theight = texB.height;\n\t\t}\n\n\t\tif(!texB)\n\t\t\ttexB = GL.Texture.getWhiteTexture();\n\n\t\tvar type = LGraphTexture.getTextureType( this.properties.precision, tex );\n\n\t\tif (!tex && !this._tex) {\n\t\t\tthis._tex = new GL.Texture(width, height, { type: type, format: gl.RGBA, filter: gl.LINEAR });\n\t\t} else {\n\t\t\tthis._tex = LGraphTexture.getTargetTexture( tex || this._tex, this._tex, this.properties.precision );\n\t\t}\n\n\t\tvar uvcode = "";\n\t\tif (this.properties.uvcode) {\n\t\t\tuvcode = "uv = " + this.properties.uvcode;\n\t\t\tif (this.properties.uvcode.indexOf(";") != -1) {\n\t\t\t\t//there are line breaks, means multiline code\n\t\t\t\tuvcode = this.properties.uvcode;\n\t\t\t}\n\t\t}\n\n\t\tvar pixelcode = "";\n\t\tif (this.properties.pixelcode) {\n\t\t\tpixelcode = "result = " + this.properties.pixelcode;\n\t\t\tif (this.properties.pixelcode.indexOf(";") != -1) {\n\t\t\t\t//there are line breaks, means multiline code\n\t\t\t\tpixelcode = this.properties.pixelcode;\n\t\t\t}\n\t\t}\n\n\t\tvar shader = this._shader;\n\n\t\tif ( !this.has_error && (!shader || this._shader_code != uvcode + "|" + pixelcode) ) {\n\n\t\t\tvar final_pixel_code = LGraphTexture.replaceCode( LGraphTextureOperation.pixel_shader, { UV_CODE:uvcode, PIXEL_CODE:pixelcode });\n\n\t\t\ttry {\n\t\t\t\tshader = new GL.Shader( Shader.SCREEN_VERTEX_SHADER, final_pixel_code );\n\t\t\t\tthis.boxcolor = "#00FF00";\n\t\t\t} catch (err) {\n\t\t\t\t//console.log("Error compiling shader: ", err, final_pixel_code );\n\t\t\t\tGL.Shader.dumpErrorToConsole(err,Shader.SCREEN_VERTEX_SHADER, final_pixel_code);\n\t\t\t\tthis.boxcolor = "#FF0000";\n\t\t\t\tthis.has_error = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._shader = shader;\n\t\t\tthis._shader_code = uvcode + "|" + pixelcode;\n\t\t}\n\n\t\tif(!this._shader)\n\t\t\treturn;\n\n\t\tvar value = this.getInputData(2);\n\t\tif (value != null) {\n\t\t\tthis.properties.value = value;\n\t\t} else {\n\t\t\tvalue = parseFloat(this.properties.value);\n\t\t}\n\n\t\tvar time = this.graph.getTime();\n\n\t\tthis._tex.drawTo(function() {\n\t\t\tgl.disable(gl.DEPTH_TEST);\n\t\t\tgl.disable(gl.CULL_FACE);\n\t\t\tgl.disable(gl.BLEND);\n\t\t\tif (tex) {\n\t\t\t\ttex.bind(0);\n\t\t\t}\n\t\t\tif (texB) {\n\t\t\t\ttexB.bind(1);\n\t\t\t}\n\t\t\tvar mesh = Mesh.getScreenQuad();\n\t\t\tshader\n\t\t\t\t.uniforms({\n\t\t\t\t\tu_texture: 0,\n\t\t\t\t\tu_textureB: 1,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\ttexSize: [width, height,1/width,1/height],\n\t\t\t\t\ttime: time\n\t\t\t\t})\n\t\t\t\t.draw(mesh);\n\t\t});\n\n\t\tthis.setOutputData(0, this._tex);\n\t};\n\n\tLGraphTextureOperation.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\t\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform sampler2D u_textureB;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform vec4 texSize;\\n\\\n\t\tuniform float time;\\n\\\n\t\tuniform float value;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tvec2 uv = v_coord;\\n\\\n\t\t\t{{UV_CODE}};\\n\\\n\t\t\tvec4 color4 = texture2D(u_texture, uv);\\n\\\n\t\t\tvec3 color = color4.rgb;\\n\\\n\t\t\tvec4 color4B = texture2D(u_textureB, uv);\\n\\\n\t\t\tvec3 colorB = color4B.rgb;\\n\\\n\t\t\tvec3 result = color;\\n\\\n\t\t\tfloat alpha = 1.0;\\n\\\n\t\t\t{{PIXEL_CODE}};\\n\\\n\t\t\tgl_FragColor = vec4(result, alpha);\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLGraphTextureOperation.registerPreset = function ( name, code )\n\t{\n\t\tLGraphTextureOperation.presets[name] = code;\n\t}\n\n\tLGraphTextureOperation.registerPreset("","");\n\tLGraphTextureOperation.registerPreset("bypass","color");\n\tLGraphTextureOperation.registerPreset("add","color + colorB * value");\n\tLGraphTextureOperation.registerPreset("substract","(color - colorB) * value");\n\tLGraphTextureOperation.registerPreset("mate","mix( color, colorB, color4B.a * value)");\n\tLGraphTextureOperation.registerPreset("invert","vec3(1.0) - color");\n\tLGraphTextureOperation.registerPreset("multiply","color * colorB * value");\n\tLGraphTextureOperation.registerPreset("divide","(color / colorB) / value");\n\tLGraphTextureOperation.registerPreset("difference","abs(color - colorB) * value");\n\tLGraphTextureOperation.registerPreset("max","max(color, colorB) * value");\n\tLGraphTextureOperation.registerPreset("min","min(color, colorB) * value");\n\tLGraphTextureOperation.registerPreset("displace","texture2D(u_texture, uv + (colorB.xy - vec2(0.5)) * value).xyz");\n\tLGraphTextureOperation.registerPreset("grayscale","vec3(color.x + color.y + color.z) * value / 3.0");\n\tLGraphTextureOperation.registerPreset("saturation","mix( vec3(color.x + color.y + color.z) / 3.0, color, value )");\n\tLGraphTextureOperation.registerPreset("normalmap","\\n\\\n\t\tfloat z0 = texture2D(u_texture, uv + vec2(-texSize.z, -texSize.w) ).x;\\n\\\n\t\tfloat z1 = texture2D(u_texture, uv + vec2(0.0, -texSize.w) ).x;\\n\\\n\t\tfloat z2 = texture2D(u_texture, uv + vec2(texSize.z, -texSize.w) ).x;\\n\\\n\t\tfloat z3 = texture2D(u_texture, uv + vec2(-texSize.z, 0.0) ).x;\\n\\\n\t\tfloat z4 = color.x;\\n\\\n\t\tfloat z5 = texture2D(u_texture, uv + vec2(texSize.z, 0.0) ).x;\\n\\\n\t\tfloat z6 = texture2D(u_texture, uv + vec2(-texSize.z, texSize.w) ).x;\\n\\\n\t\tfloat z7 = texture2D(u_texture, uv + vec2(0.0, texSize.w) ).x;\\n\\\n\t\tfloat z8 = texture2D(u_texture, uv + vec2(texSize.z, texSize.w) ).x;\\n\\\n\t\tvec3 normal = vec3( z2 + 2.0*z4 + z7 - z0 - 2.0*z3 - z5, z5 + 2.0*z6 + z7 -z0 - 2.0*z1 - z2, 1.0 );\\n\\\n\t\tnormal.xy *= value;\\n\\\n\t\tresult.xyz = normalize(normal) * 0.5 + vec3(0.5);\\n\\\n\t");\n\tLGraphTextureOperation.registerPreset("threshold","vec3(color.x > colorB.x * value ? 1.0 : 0.0,color.y > colorB.y * value ? 1.0 : 0.0,color.z > colorB.z * value ? 1.0 : 0.0)");\n\n\t//webglstudio stuff...\n\tLGraphTextureOperation.prototype.onInspect = function(widgets)\n\t{\n\t\tvar that = this;\n\t\twidgets.addCombo("Presets","",{ values: Object.keys(LGraphTextureOperation.presets), callback: function(v){\n\t\t\tvar code = LGraphTextureOperation.presets[v];\n\t\t\tif(!code)\n\t\t\t\treturn;\n\t\t\tthat.setProperty("pixelcode",code);\n\t\t\tthat.title = v;\n\t\t\twidgets.refresh();\n\t\t}});\n\t}\n\n\tLiteGraph.registerNodeType("texture/operation", LGraphTextureOperation);\n\n\t//****************************************************\n\n\tfunction LGraphTextureShader() {\n\t\tthis.addOutput("out", "Texture");\n\t\tthis.properties = {\n\t\t\tcode: "",\n\t\t\tu_value: 1,\n\t\t\tu_color: [1,1,1,1],\n\t\t\twidth: 512,\n\t\t\theight: 512,\n\t\t\tprecision: LGraphTexture.DEFAULT\n\t\t};\n\n\t\tthis.properties.code = LGraphTextureShader.pixel_shader;\n\t\tthis._uniforms = { u_value: 1, u_color: vec4.create(), in_texture: 0, texSize: vec4.create(), time: 0 };\n\t}\n\n\tLGraphTextureShader.title = "Shader";\n\tLGraphTextureShader.desc = "Texture shader";\n\tLGraphTextureShader.widgets_info = {\n\t\tcode: { type: "code", lang: "glsl" },\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureShader.prototype.onPropertyChanged = function(\n\t\tname,\n\t\tvalue\n\t) {\n\t\tif (name != "code") {\n\t\t\treturn;\n\t\t}\n\n\t\tvar shader = this.getShader();\n\t\tif (!shader) {\n\t\t\treturn;\n\t\t}\n\n\t\t//update connections\n\t\tvar uniforms = shader.uniformInfo;\n\n\t\t//remove deprecated slots\n\t\tif (this.inputs) {\n\t\t\tvar already = {};\n\t\t\tfor (var i = 0; i < this.inputs.length; ++i) {\n\t\t\t\tvar info = this.getInputInfo(i);\n\t\t\t\tif (!info) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (uniforms[info.name] && !already[info.name]) {\n\t\t\t\t\talready[info.name] = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis.removeInput(i);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\t//update existing ones\n\t\tfor (var i in uniforms) {\n\t\t\tvar info = shader.uniformInfo[i];\n\t\t\tif (info.loc === null) {\n\t\t\t\tcontinue;\n\t\t\t} //is an attribute, not a uniform\n\t\t\tif (i == "time") {\n\t\t\t\t//default one\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar type = "number";\n\t\t\tif (this._shader.samplers[i]) {\n\t\t\t\ttype = "texture";\n\t\t\t} else {\n\t\t\t\tswitch (info.size) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\ttype = "number";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\ttype = "vec2";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\ttype = "vec3";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\ttype = "vec4";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 9:\n\t\t\t\t\t\ttype = "mat3";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttype = "mat4";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar slot = this.findInputSlot(i);\n\t\t\tif (slot == -1) {\n\t\t\t\tthis.addInput(i, type);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar input_info = this.getInputInfo(slot);\n\t\t\tif (!input_info) {\n\t\t\t\tthis.addInput(i, type);\n\t\t\t} else {\n\t\t\t\tif (input_info.type == type) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis.removeInput(slot, type);\n\t\t\t\tthis.addInput(i, type);\n\t\t\t}\n\t\t}\n\t};\n\n\tLGraphTextureShader.prototype.getShader = function() {\n\t\t//replug\n\t\tif (this._shader && this._shader_code == this.properties.code) {\n\t\t\treturn this._shader;\n\t\t}\n\n\t\tthis._shader_code = this.properties.code;\n\t\tthis._shader = new GL.Shader( Shader.SCREEN_VERTEX_SHADER, this.properties.code );\n\t\tif (!this._shader) {\n\t\t\tthis.boxcolor = "red";\n\t\t\treturn null;\n\t\t} else {\n\t\t\tthis.boxcolor = "green";\n\t\t}\n\t\treturn this._shader;\n\t};\n\n\tLGraphTextureShader.prototype.onExecute = function() {\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tvar shader = this.getShader();\n\t\tif (!shader) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar tex_slot = 0;\n\t\tvar in_tex = null;\n\n\t\t//set uniforms\n\t\tif(this.inputs)\n\t\tfor (var i = 0; i < this.inputs.length; ++i) {\n\t\t\tvar info = this.getInputInfo(i);\n\t\t\tvar data = this.getInputData(i);\n\t\t\tif (data == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (data.constructor === GL.Texture) {\n\t\t\t\tdata.bind(tex_slot);\n\t\t\t\tif (!in_tex) {\n\t\t\t\t\tin_tex = data;\n\t\t\t\t}\n\t\t\t\tdata = tex_slot;\n\t\t\t\ttex_slot++;\n\t\t\t}\n\t\t\tshader.setUniform(info.name, data); //data is tex_slot\n\t\t}\n\n\t\tvar uniforms = this._uniforms;\n\t\tvar type = LGraphTexture.getTextureType( this.properties.precision, in_tex );\n\n\t\t//render to texture\n\t\tvar w = this.properties.width | 0;\n\t\tvar h = this.properties.height | 0;\n\t\tif (w == 0) {\n\t\t\tw = in_tex ? in_tex.width : gl.canvas.width;\n\t\t}\n\t\tif (h == 0) {\n\t\t\th = in_tex ? in_tex.height : gl.canvas.height;\n\t\t}\n\t\tuniforms.texSize[0] = w;\n\t\tuniforms.texSize[1] = h;\n\t\tuniforms.texSize[2] = 1/w;\n\t\tuniforms.texSize[3] = 1/h;\n\t\tuniforms.time = this.graph.getTime();\n\t\tuniforms.u_value = this.properties.u_value;\n\t\tuniforms.u_color.set( this.properties.u_color );\n\n\t\tif ( !this._tex || this._tex.type != type ||  this._tex.width != w || this._tex.height != h ) {\n\t\t\tthis._tex = new GL.Texture(w, h, {  type: type, format: gl.RGBA, filter: gl.LINEAR });\n\t\t}\n\t\tvar tex = this._tex;\n\t\ttex.drawTo(function() {\n\t\t\tshader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());\n\t\t});\n\n\t\tthis.setOutputData(0, this._tex);\n\t};\n\n\tLGraphTextureShader.pixel_shader =\n"precision highp float;\\n\\\n\\n\\\nvarying vec2 v_coord;\\n\\\nuniform float time; //time in seconds\\n\\\nuniform vec4 texSize; //tex resolution\\n\\\nuniform float u_value;\\n\\\nuniform vec4 u_color;\\n\\n\\\nvoid main() {\\n\\\n\tvec2 uv = v_coord;\\n\\\n\tvec3 color = vec3(0.0);\\n\\\n\t//your code here\\n\\\n\tcolor.xy=uv;\\n\\n\\\n\tgl_FragColor = vec4(color, 1.0);\\n\\\n}\\n\\\n";\n\n\tLiteGraph.registerNodeType("texture/shader", LGraphTextureShader);\n\n\t// Texture Scale Offset\n\n\tfunction LGraphTextureScaleOffset() {\n\t\tthis.addInput("in", "Texture");\n\t\tthis.addInput("scale", "vec2");\n\t\tthis.addInput("offset", "vec2");\n\t\tthis.addOutput("out", "Texture");\n\t\tthis.properties = {\n\t\t\toffset: vec2.fromValues(0, 0),\n\t\t\tscale: vec2.fromValues(1, 1),\n\t\t\tprecision: LGraphTexture.DEFAULT\n\t\t};\n\t}\n\n\tLGraphTextureScaleOffset.widgets_info = {\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureScaleOffset.title = "Scale/Offset";\n\tLGraphTextureScaleOffset.desc = "Applies an scaling and offseting";\n\n\tLGraphTextureScaleOffset.prototype.onExecute = function() {\n\t\tvar tex = this.getInputData(0);\n\n\t\tif (!this.isOutputConnected(0) || !tex) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tif (this.properties.precision === LGraphTexture.PASS_THROUGH) {\n\t\t\tthis.setOutputData(0, tex);\n\t\t\treturn;\n\t\t}\n\n\t\tvar width = tex.width;\n\t\tvar height = tex.height;\n\t\tvar type =  this.precision === LGraphTexture.LOW ? gl.UNSIGNED_BYTE : gl.HIGH_PRECISION_FORMAT;\n\t\tif (this.precision === LGraphTexture.DEFAULT) {\n\t\t\ttype = tex.type;\n\t\t}\n\n\t\tif (\n\t\t\t!this._tex ||\n\t\t\tthis._tex.width != width ||\n\t\t\tthis._tex.height != height ||\n\t\t\tthis._tex.type != type\n\t\t) {\n\t\t\tthis._tex = new GL.Texture(width, height, {\n\t\t\t\ttype: type,\n\t\t\t\tformat: gl.RGBA,\n\t\t\t\tfilter: gl.LINEAR\n\t\t\t});\n\t\t}\n\n\t\tvar shader = this._shader;\n\n\t\tif (!shader) {\n\t\t\tshader = new GL.Shader(\n\t\t\t\tGL.Shader.SCREEN_VERTEX_SHADER,\n\t\t\t\tLGraphTextureScaleOffset.pixel_shader\n\t\t\t);\n\t\t}\n\n\t\tvar scale = this.getInputData(1);\n\t\tif (scale) {\n\t\t\tthis.properties.scale[0] = scale[0];\n\t\t\tthis.properties.scale[1] = scale[1];\n\t\t} else {\n\t\t\tscale = this.properties.scale;\n\t\t}\n\n\t\tvar offset = this.getInputData(2);\n\t\tif (offset) {\n\t\t\tthis.properties.offset[0] = offset[0];\n\t\t\tthis.properties.offset[1] = offset[1];\n\t\t} else {\n\t\t\toffset = this.properties.offset;\n\t\t}\n\n\t\tthis._tex.drawTo(function() {\n\t\t\tgl.disable(gl.DEPTH_TEST);\n\t\t\tgl.disable(gl.CULL_FACE);\n\t\t\tgl.disable(gl.BLEND);\n\t\t\ttex.bind(0);\n\t\t\tvar mesh = Mesh.getScreenQuad();\n\t\t\tshader\n\t\t\t\t.uniforms({\n\t\t\t\t\tu_texture: 0,\n\t\t\t\t\tu_scale: scale,\n\t\t\t\t\tu_offset: offset\n\t\t\t\t})\n\t\t\t\t.draw(mesh);\n\t\t});\n\n\t\tthis.setOutputData(0, this._tex);\n\t};\n\n\tLGraphTextureScaleOffset.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\t\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform sampler2D u_textureB;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform vec2 u_scale;\\n\\\n\t\tuniform vec2 u_offset;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tvec2 uv = v_coord;\\n\\\n\t\t\tuv = uv / u_scale - u_offset;\\n\\\n\t\t\tgl_FragColor = texture2D(u_texture, uv);\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLiteGraph.registerNodeType(\n\t\t"texture/scaleOffset",\n\t\tLGraphTextureScaleOffset\n\t);\n\n\t// Warp (distort a texture) *************************\n\n\tfunction LGraphTextureWarp() {\n\t\tthis.addInput("in", "Texture");\n\t\tthis.addInput("warp", "Texture");\n\t\tthis.addInput("factor", "number");\n\t\tthis.addOutput("out", "Texture");\n\t\tthis.properties = {\n\t\t\tfactor: 0.01,\n\t\t\tscale: [1,1],\n\t\t\toffset: [0,0],\n\t\t\tprecision: LGraphTexture.DEFAULT\n\t\t};\n\n\t\tthis._uniforms = { \n\t\t\tu_texture: 0, \n\t\t\tu_textureB: 1, \n\t\t\tu_factor: 1, \n\t\t\tu_scale: vec2.create(),\n\t\t\tu_offset: vec2.create()\n\t\t};\n\t}\n\n\tLGraphTextureWarp.widgets_info = {\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureWarp.title = "Warp";\n\tLGraphTextureWarp.desc = "Texture warp operation";\n\n\tLGraphTextureWarp.prototype.onExecute = function() {\n\t\tvar tex = this.getInputData(0);\n\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tif (this.properties.precision === LGraphTexture.PASS_THROUGH) {\n\t\t\tthis.setOutputData(0, tex);\n\t\t\treturn;\n\t\t}\n\n\t\tvar texB = this.getInputData(1);\n\n\t\tvar width = 512;\n\t\tvar height = 512;\n\t\tvar type = gl.UNSIGNED_BYTE;\n\t\tif (tex) {\n\t\t\twidth = tex.width;\n\t\t\theight = tex.height;\n\t\t\ttype = tex.type;\n\t\t} else if (texB) {\n\t\t\twidth = texB.width;\n\t\t\theight = texB.height;\n\t\t\ttype = texB.type;\n\t\t}\n\n\t\tif (!tex && !this._tex) {\n\t\t\tthis._tex = new GL.Texture(width, height, {\n\t\t\t\ttype:\n\t\t\t\t\tthis.precision === LGraphTexture.LOW\n\t\t\t\t\t\t? gl.UNSIGNED_BYTE\n\t\t\t\t\t\t: gl.HIGH_PRECISION_FORMAT,\n\t\t\t\tformat: gl.RGBA,\n\t\t\t\tfilter: gl.LINEAR\n\t\t\t});\n\t\t} else {\n\t\t\tthis._tex = LGraphTexture.getTargetTexture(\n\t\t\t\ttex || this._tex,\n\t\t\t\tthis._tex,\n\t\t\t\tthis.properties.precision\n\t\t\t);\n\t\t}\n\n\t\tvar shader = this._shader;\n\n\t\tif (!shader) {\n\t\t\tshader = new GL.Shader(\n\t\t\t\tGL.Shader.SCREEN_VERTEX_SHADER,\n\t\t\t\tLGraphTextureWarp.pixel_shader\n\t\t\t);\n\t\t}\n\n\t\tvar factor = this.getInputData(2);\n\t\tif (factor != null) {\n\t\t\tthis.properties.factor = factor;\n\t\t} else {\n\t\t\tfactor = parseFloat(this.properties.factor);\n\t\t}\n\t\tvar uniforms = this._uniforms;\n\t\tuniforms.u_factor = factor;\n\t\tuniforms.u_scale.set( this.properties.scale );\n\t\tuniforms.u_offset.set( this.properties.offset );\n\n\t\tthis._tex.drawTo(function() {\n\t\t\tgl.disable(gl.DEPTH_TEST);\n\t\t\tgl.disable(gl.CULL_FACE);\n\t\t\tgl.disable(gl.BLEND);\n\t\t\tif (tex) {\n\t\t\t\ttex.bind(0);\n\t\t\t}\n\t\t\tif (texB) {\n\t\t\t\ttexB.bind(1);\n\t\t\t}\n\t\t\tvar mesh = Mesh.getScreenQuad();\n\t\t\tshader\n\t\t\t\t.uniforms( uniforms )\n\t\t\t\t.draw(mesh);\n\t\t});\n\n\t\tthis.setOutputData(0, this._tex);\n\t};\n\n\tLGraphTextureWarp.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\t\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform sampler2D u_textureB;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform float u_factor;\\n\\\n\t\tuniform vec2 u_scale;\\n\\\n\t\tuniform vec2 u_offset;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tvec2 uv = v_coord;\\n\\\n\t\t\tuv += ( texture2D(u_textureB, uv).rg - vec2(0.5)) * u_factor * u_scale + u_offset;\\n\\\n\t\t\tgl_FragColor = texture2D(u_texture, uv);\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLiteGraph.registerNodeType("texture/warp", LGraphTextureWarp);\n\n\t//****************************************************\n\n\t// Texture to Viewport *****************************************\n\tfunction LGraphTextureToViewport() {\n\t\tthis.addInput("Texture", "Texture");\n\t\tthis.properties = {\n\t\t\tadditive: false,\n\t\t\tantialiasing: false,\n\t\t\tfilter: true,\n\t\t\tdisable_alpha: false,\n\t\t\tgamma: 1.0,\n\t\t\tviewport: [0,0,1,1]\n\t\t};\n\t\tthis.size[0] = 130;\n\t}\n\n\tLGraphTextureToViewport.title = "to Viewport";\n\tLGraphTextureToViewport.desc = "Texture to viewport";\n\n\tLGraphTextureToViewport._prev_viewport = new Float32Array(4);\n\n\tLGraphTextureToViewport.prototype.onDrawBackground = function( ctx )\n\t{\n\t\tif ( this.flags.collapsed || this.size[1] <= 40 )\n\t\t\treturn;\n\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tctx.drawImage( ctx == gl ? tex : gl.canvas, 10,30, this.size[0] -20, this.size[1] -40);\n\t}\n\n\tLGraphTextureToViewport.prototype.onExecute = function() {\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.properties.disable_alpha) {\n\t\t\tgl.disable(gl.BLEND);\n\t\t} else {\n\t\t\tgl.enable(gl.BLEND);\n\t\t\tif (this.properties.additive) {\n\t\t\t\tgl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n\t\t\t} else {\n\t\t\t\tgl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\t\t\t}\n\t\t}\n\n\t\tgl.disable(gl.DEPTH_TEST);\n\t\tvar gamma = this.properties.gamma || 1.0;\n\t\tif (this.isInputConnected(1)) {\n\t\t\tgamma = this.getInputData(1);\n\t\t}\n\n\t\ttex.setParameter(\n\t\t\tgl.TEXTURE_MAG_FILTER,\n\t\t\tthis.properties.filter ? gl.LINEAR : gl.NEAREST\n\t\t);\n\n\t\tvar old_viewport = LGraphTextureToViewport._prev_viewport;\n\t\told_viewport.set( gl.viewport_data );\n\t\tvar new_view = this.properties.viewport;\n\t\tgl.viewport( old_viewport[0] + old_viewport[2] * new_view[0], old_viewport[1] + old_viewport[3] * new_view[1], old_viewport[2] * new_view[2], old_viewport[3] * new_view[3] );\n\t\tvar viewport = gl.getViewport(); //gl.getParameter(gl.VIEWPORT);\n\n\t\tif (this.properties.antialiasing) {\n\t\t\tif (!LGraphTextureToViewport._shader) {\n\t\t\t\tLGraphTextureToViewport._shader = new GL.Shader(\n\t\t\t\t\tGL.Shader.SCREEN_VERTEX_SHADER,\n\t\t\t\t\tLGraphTextureToViewport.aa_pixel_shader\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tvar mesh = Mesh.getScreenQuad();\n\t\t\ttex.bind(0);\n\t\t\tLGraphTextureToViewport._shader\n\t\t\t\t.uniforms({\n\t\t\t\t\tu_texture: 0,\n\t\t\t\t\tuViewportSize: [tex.width, tex.height],\n\t\t\t\t\tu_igamma: 1 / gamma,\n\t\t\t\t\tinverseVP: [1 / tex.width, 1 / tex.height]\n\t\t\t\t})\n\t\t\t\t.draw(mesh);\n\t\t} else {\n\t\t\tif (gamma != 1.0) {\n\t\t\t\tif (!LGraphTextureToViewport._gamma_shader) {\n\t\t\t\t\tLGraphTextureToViewport._gamma_shader = new GL.Shader(\n\t\t\t\t\t\tShader.SCREEN_VERTEX_SHADER,\n\t\t\t\t\t\tLGraphTextureToViewport.gamma_pixel_shader\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\ttex.toViewport(LGraphTextureToViewport._gamma_shader, {\n\t\t\t\t\tu_texture: 0,\n\t\t\t\t\tu_igamma: 1 / gamma\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\ttex.toViewport();\n\t\t\t}\n\t\t}\n\n\t\tgl.viewport( old_viewport[0], old_viewport[1], old_viewport[2], old_viewport[3] );\n\t};\n\n\tLGraphTextureToViewport.prototype.onGetInputs = function() {\n\t\treturn [["gamma", "number"]];\n\t};\n\n\tLGraphTextureToViewport.aa_pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform vec2 uViewportSize;\\n\\\n\t\tuniform vec2 inverseVP;\\n\\\n\t\tuniform float u_igamma;\\n\\\n\t\t#define FXAA_REDUCE_MIN   (1.0/ 128.0)\\n\\\n\t\t#define FXAA_REDUCE_MUL   (1.0 / 8.0)\\n\\\n\t\t#define FXAA_SPAN_MAX     8.0\\n\\\n\t\t\\n\\\n\t\t/* from mitsuhiko/webgl-meincraft based on the code on geeks3d.com */\\n\\\n\t\tvec4 applyFXAA(sampler2D tex, vec2 fragCoord)\\n\\\n\t\t{\\n\\\n\t\t\tvec4 color = vec4(0.0);\\n\\\n\t\t\t/*vec2 inverseVP = vec2(1.0 / uViewportSize.x, 1.0 / uViewportSize.y);*/\\n\\\n\t\t\tvec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * inverseVP).xyz;\\n\\\n\t\t\tvec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * inverseVP).xyz;\\n\\\n\t\t\tvec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * inverseVP).xyz;\\n\\\n\t\t\tvec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * inverseVP).xyz;\\n\\\n\t\t\tvec3 rgbM  = texture2D(tex, fragCoord  * inverseVP).xyz;\\n\\\n\t\t\tvec3 luma = vec3(0.299, 0.587, 0.114);\\n\\\n\t\t\tfloat lumaNW = dot(rgbNW, luma);\\n\\\n\t\t\tfloat lumaNE = dot(rgbNE, luma);\\n\\\n\t\t\tfloat lumaSW = dot(rgbSW, luma);\\n\\\n\t\t\tfloat lumaSE = dot(rgbSE, luma);\\n\\\n\t\t\tfloat lumaM  = dot(rgbM,  luma);\\n\\\n\t\t\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\\n\\\n\t\t\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\\n\\\n\t\t\t\\n\\\n\t\t\tvec2 dir;\\n\\\n\t\t\tdir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\\n\\\n\t\t\tdir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\\n\\\n\t\t\t\\n\\\n\t\t\tfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\\n\\\n\t\t\t\\n\\\n\t\t\tfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\\n\\\n\t\t\tdir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * inverseVP;\\n\\\n\t\t\t\\n\\\n\t\t\tvec3 rgbA = 0.5 * (texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz + \\n\\\n\t\t\t\ttexture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\\n\\\n\t\t\tvec3 rgbB = rgbA * 0.5 + 0.25 * (texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz + \\n\\\n\t\t\t\ttexture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\\n\\\n\t\t\t\\n\\\n\t\t\t//return vec4(rgbA,1.0);\\n\\\n\t\t\tfloat lumaB = dot(rgbB, luma);\\n\\\n\t\t\tif ((lumaB < lumaMin) || (lumaB > lumaMax))\\n\\\n\t\t\t\tcolor = vec4(rgbA, 1.0);\\n\\\n\t\t\telse\\n\\\n\t\t\t\tcolor = vec4(rgbB, 1.0);\\n\\\n\t\t\tif(u_igamma != 1.0)\\n\\\n\t\t\t\tcolor.xyz = pow( color.xyz, vec3(u_igamma) );\\n\\\n\t\t\treturn color;\\n\\\n\t\t}\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t   gl_FragColor = applyFXAA( u_texture, v_coord * uViewportSize) ;\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLGraphTextureToViewport.gamma_pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform float u_igamma;\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tvec4 color = texture2D( u_texture, v_coord);\\n\\\n\t\t\tcolor.xyz = pow(color.xyz, vec3(u_igamma) );\\n\\\n\t\t   gl_FragColor = color;\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLiteGraph.registerNodeType(\n\t\t"texture/toviewport",\n\t\tLGraphTextureToViewport\n\t);\n\n\t// Texture Copy *****************************************\n\tfunction LGraphTextureCopy() {\n\t\tthis.addInput("Texture", "Texture");\n\t\tthis.addOutput("", "Texture");\n\t\tthis.properties = {\n\t\t\tsize: 0,\n\t\t\tgenerate_mipmaps: false,\n\t\t\tprecision: LGraphTexture.DEFAULT\n\t\t};\n\t}\n\n\tLGraphTextureCopy.title = "Copy";\n\tLGraphTextureCopy.desc = "Copy Texture";\n\tLGraphTextureCopy.widgets_info = {\n\t\tsize: {\n\t\t\twidget: "combo",\n\t\t\tvalues: [0, 32, 64, 128, 256, 512, 1024, 2048]\n\t\t},\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureCopy.prototype.onExecute = function() {\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex && !this._temp_texture) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\t//copy the texture\n\t\tif (tex) {\n\t\t\tvar width = tex.width;\n\t\t\tvar height = tex.height;\n\n\t\t\tif (this.properties.size != 0) {\n\t\t\t\twidth = this.properties.size;\n\t\t\t\theight = this.properties.size;\n\t\t\t}\n\n\t\t\tvar temp = this._temp_texture;\n\n\t\t\tvar type = tex.type;\n\t\t\tif (this.properties.precision === LGraphTexture.LOW) {\n\t\t\t\ttype = gl.UNSIGNED_BYTE;\n\t\t\t} else if (this.properties.precision === LGraphTexture.HIGH) {\n\t\t\t\ttype = gl.HIGH_PRECISION_FORMAT;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t!temp ||\n\t\t\t\ttemp.width != width ||\n\t\t\t\ttemp.height != height ||\n\t\t\t\ttemp.type != type\n\t\t\t) {\n\t\t\t\tvar minFilter = gl.LINEAR;\n\t\t\t\tif (\n\t\t\t\t\tthis.properties.generate_mipmaps &&\n\t\t\t\t\tisPowerOfTwo(width) &&\n\t\t\t\t\tisPowerOfTwo(height)\n\t\t\t\t) {\n\t\t\t\t\tminFilter = gl.LINEAR_MIPMAP_LINEAR;\n\t\t\t\t}\n\t\t\t\tthis._temp_texture = new GL.Texture(width, height, {\n\t\t\t\t\ttype: type,\n\t\t\t\t\tformat: gl.RGBA,\n\t\t\t\t\tminFilter: minFilter,\n\t\t\t\t\tmagFilter: gl.LINEAR\n\t\t\t\t});\n\t\t\t}\n\t\t\ttex.copyTo(this._temp_texture);\n\n\t\t\tif (this.properties.generate_mipmaps) {\n\t\t\t\tthis._temp_texture.bind(0);\n\t\t\t\tgl.generateMipmap(this._temp_texture.texture_type);\n\t\t\t\tthis._temp_texture.unbind(0);\n\t\t\t}\n\t\t}\n\n\t\tthis.setOutputData(0, this._temp_texture);\n\t};\n\n\tLiteGraph.registerNodeType("texture/copy", LGraphTextureCopy);\n\n\t// Texture Downsample *****************************************\n\tfunction LGraphTextureDownsample() {\n\t\tthis.addInput("Texture", "Texture");\n\t\tthis.addOutput("", "Texture");\n\t\tthis.properties = {\n\t\t\titerations: 1,\n\t\t\tgenerate_mipmaps: false,\n\t\t\tprecision: LGraphTexture.DEFAULT\n\t\t};\n\t}\n\n\tLGraphTextureDownsample.title = "Downsample";\n\tLGraphTextureDownsample.desc = "Downsample Texture";\n\tLGraphTextureDownsample.widgets_info = {\n\t\titerations: { type: "number", step: 1, precision: 0, min: 0 },\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureDownsample.prototype.onExecute = function() {\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex && !this._temp_texture) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\t//we do not allow any texture different than texture 2D\n\t\tif (!tex || tex.texture_type !== GL.TEXTURE_2D) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.properties.iterations < 1) {\n\t\t\tthis.setOutputData(0, tex);\n\t\t\treturn;\n\t\t}\n\n\t\tvar shader = LGraphTextureDownsample._shader;\n\t\tif (!shader) {\n\t\t\tLGraphTextureDownsample._shader = shader = new GL.Shader(\n\t\t\t\tGL.Shader.SCREEN_VERTEX_SHADER,\n\t\t\t\tLGraphTextureDownsample.pixel_shader\n\t\t\t);\n\t\t}\n\n\t\tvar width = tex.width | 0;\n\t\tvar height = tex.height | 0;\n\t\tvar type = tex.type;\n\t\tif (this.properties.precision === LGraphTexture.LOW) {\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\t\t} else if (this.properties.precision === LGraphTexture.HIGH) {\n\t\t\ttype = gl.HIGH_PRECISION_FORMAT;\n\t\t}\n\t\tvar iterations = this.properties.iterations || 1;\n\n\t\tvar origin = tex;\n\t\tvar target = null;\n\n\t\tvar temp = [];\n\t\tvar options = {\n\t\t\ttype: type,\n\t\t\tformat: tex.format\n\t\t};\n\n\t\tvar offset = vec2.create();\n\t\tvar uniforms = {\n\t\t\tu_offset: offset\n\t\t};\n\n\t\tif (this._texture) {\n\t\t\tGL.Texture.releaseTemporary(this._texture);\n\t\t}\n\n\t\tfor (var i = 0; i < iterations; ++i) {\n\t\t\toffset[0] = 1 / width;\n\t\t\toffset[1] = 1 / height;\n\t\t\twidth = width >> 1 || 0;\n\t\t\theight = height >> 1 || 0;\n\t\t\ttarget = GL.Texture.getTemporary(width, height, options);\n\t\t\ttemp.push(target);\n\t\t\torigin.setParameter(GL.TEXTURE_MAG_FILTER, GL.NEAREST);\n\t\t\torigin.copyTo(target, shader, uniforms);\n\t\t\tif (width == 1 && height == 1) {\n\t\t\t\tbreak;\n\t\t\t} //nothing else to do\n\t\t\torigin = target;\n\t\t}\n\n\t\t//keep the last texture used\n\t\tthis._texture = temp.pop();\n\n\t\t//free the rest\n\t\tfor (var i = 0; i < temp.length; ++i) {\n\t\t\tGL.Texture.releaseTemporary(temp[i]);\n\t\t}\n\n\t\tif (this.properties.generate_mipmaps) {\n\t\t\tthis._texture.bind(0);\n\t\t\tgl.generateMipmap(this._texture.texture_type);\n\t\t\tthis._texture.unbind(0);\n\t\t}\n\n\t\tthis.setOutputData(0, this._texture);\n\t};\n\n\tLGraphTextureDownsample.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform vec2 u_offset;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tvec4 color = texture2D(u_texture, v_coord );\\n\\\n\t\t\tcolor += texture2D(u_texture, v_coord + vec2( u_offset.x, 0.0 ) );\\n\\\n\t\t\tcolor += texture2D(u_texture, v_coord + vec2( 0.0, u_offset.y ) );\\n\\\n\t\t\tcolor += texture2D(u_texture, v_coord + vec2( u_offset.x, u_offset.y ) );\\n\\\n\t\t   gl_FragColor = color * 0.25;\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLiteGraph.registerNodeType(\n\t\t"texture/downsample",\n\t\tLGraphTextureDownsample\n\t);\n\n\n\n\tfunction LGraphTextureResize() {\n\t\tthis.addInput("Texture", "Texture");\n\t\tthis.addOutput("", "Texture");\n\t\tthis.properties = {\n\t\t\tsize: [512,512],\n\t\t\tgenerate_mipmaps: false,\n\t\t\tprecision: LGraphTexture.DEFAULT\n\t\t};\n\t}\n\n\tLGraphTextureResize.title = "Resize";\n\tLGraphTextureResize.desc = "Resize Texture";\n\tLGraphTextureResize.widgets_info = {\n\t\titerations: { type: "number", step: 1, precision: 0, min: 0 },\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureResize.prototype.onExecute = function() {\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex && !this._temp_texture) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\t//we do not allow any texture different than texture 2D\n\t\tif (!tex || tex.texture_type !== GL.TEXTURE_2D) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar width = this.properties.size[0] | 0;\n\t\tvar height = this.properties.size[1] | 0;\n\t\tif(width == 0)\n\t\t\twidth = tex.width;\n\t\tif(height == 0)\n\t\t\theight = tex.height;\n\t\tvar type = tex.type;\n\t\tif (this.properties.precision === LGraphTexture.LOW) {\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\t\t} else if (this.properties.precision === LGraphTexture.HIGH) {\n\t\t\ttype = gl.HIGH_PRECISION_FORMAT;\n\t\t}\n\n\t\tif( !this._texture || this._texture.width != width || this._texture.height != height || this._texture.type != type )\n\t\t\tthis._texture = new GL.Texture( width, height, { type: type } );\n\n\t\ttex.copyTo( this._texture );\n\n\t\tif (this.properties.generate_mipmaps) {\n\t\t\tthis._texture.bind(0);\n\t\t\tgl.generateMipmap(this._texture.texture_type);\n\t\t\tthis._texture.unbind(0);\n\t\t}\n\n\t\tthis.setOutputData(0, this._texture);\n\t};\n\n\tLiteGraph.registerNodeType( "texture/resize", LGraphTextureResize );\n\n\t// Texture Average  *****************************************\n\tfunction LGraphTextureAverage() {\n\t\tthis.addInput("Texture", "Texture");\n\t\tthis.addOutput("tex", "Texture");\n\t\tthis.addOutput("avg", "vec4");\n\t\tthis.addOutput("lum", "number");\n\t\tthis.properties = {\n\t\t\tuse_previous_frame: true, //to avoid stalls \n\t\t\thigh_quality: false //to use as much pixels as possible\n\t\t};\n\n\t\tthis._uniforms = {\n\t\t\tu_texture: 0,\n\t\t\tu_mipmap_offset: 0\n\t\t};\n\t\tthis._luminance = new Float32Array(4);\n\t}\n\n\tLGraphTextureAverage.title = "Average";\n\tLGraphTextureAverage.desc =\n\t\t"Compute a partial average (32 random samples) of a texture and stores it as a 1x1 pixel texture.\\n If high_quality is true, then it generates the mipmaps first and reads from the lower one.";\n\n\tLGraphTextureAverage.prototype.onExecute = function() {\n\t\tif (!this.properties.use_previous_frame) {\n\t\t\tthis.updateAverage();\n\t\t}\n\n\t\tvar v = this._luminance;\n\t\tthis.setOutputData(0, this._temp_texture);\n\t\tthis.setOutputData(1, v);\n\t\tthis.setOutputData(2, (v[0] + v[1] + v[2]) / 3);\n\t};\n\n\t//executed before rendering the frame\n\tLGraphTextureAverage.prototype.onPreRenderExecute = function() {\n\t\tthis.updateAverage();\n\t};\n\n\tLGraphTextureAverage.prototype.updateAverage = function() {\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\t!this.isOutputConnected(0) &&\n\t\t\t!this.isOutputConnected(1) &&\n\t\t\t!this.isOutputConnected(2)\n\t\t) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tif (!LGraphTextureAverage._shader) {\n\t\t\tLGraphTextureAverage._shader = new GL.Shader(\n\t\t\t\tGL.Shader.SCREEN_VERTEX_SHADER,\n\t\t\t\tLGraphTextureAverage.pixel_shader\n\t\t\t);\n\t\t\t//creates 256 random numbers and stores them in two mat4\n\t\t\tvar samples = new Float32Array(16);\n\t\t\tfor (var i = 0; i < samples.length; ++i) {\n\t\t\t\tsamples[i] = Math.random(); //poorly distributed samples\n\t\t\t}\n\t\t\t//upload only once\n\t\t\tLGraphTextureAverage._shader.uniforms({\n\t\t\t\tu_samples_a: samples.subarray(0, 16),\n\t\t\t\tu_samples_b: samples.subarray(16, 32)\n\t\t\t});\n\t\t}\n\n\t\tvar temp = this._temp_texture;\n\t\tvar type = gl.UNSIGNED_BYTE;\n\t\tif (tex.type != type) {\n\t\t\t//force floats, half floats cannot be read with gl.readPixels\n\t\t\ttype = gl.FLOAT;\n\t\t}\n\n\t\tif (!temp || temp.type != type) {\n\t\t\tthis._temp_texture = new GL.Texture(1, 1, {\n\t\t\t\ttype: type,\n\t\t\t\tformat: gl.RGBA,\n\t\t\t\tfilter: gl.NEAREST\n\t\t\t});\n\t\t}\n\n\t\tthis._uniforms.u_mipmap_offset = 0;\n\n\t\tif(this.properties.high_quality)\n\t\t{\n\t\t\tif( !this._temp_pot2_texture || this._temp_pot2_texture.type != type )\n\t\t\t\tthis._temp_pot2_texture = new GL.Texture(512, 512, {\n\t\t\t\t\ttype: type,\n\t\t\t\t\tformat: gl.RGBA,\n\t\t\t\t\tminFilter: gl.LINEAR_MIPMAP_LINEAR,\n\t\t\t\t\tmagFilter: gl.LINEAR\n\t\t\t\t});\n\n\t\t\ttex.copyTo( this._temp_pot2_texture );\n\t\t\ttex = this._temp_pot2_texture;\n\t\t\ttex.bind(0);\n\t\t\tgl.generateMipmap(GL.TEXTURE_2D);\n\t\t\tthis._uniforms.u_mipmap_offset = 9;\n\t\t}\n\n\t\tvar shader = LGraphTextureAverage._shader;\n\t\tvar uniforms = this._uniforms;\n\t\tuniforms.u_mipmap_offset = this.properties.mipmap_offset;\n\t\tgl.disable(gl.DEPTH_TEST);\n\t\tgl.disable(gl.BLEND);\n\t\tthis._temp_texture.drawTo(function() {\n\t\t\ttex.toViewport(shader, uniforms);\n\t\t});\n\n\t\tif (this.isOutputConnected(1) || this.isOutputConnected(2)) {\n\t\t\tvar pixel = this._temp_texture.getPixels();\n\t\t\tif (pixel) {\n\t\t\t\tvar v = this._luminance;\n\t\t\t\tvar type = this._temp_texture.type;\n\t\t\t\tv.set(pixel);\n\t\t\t\tif (type == gl.UNSIGNED_BYTE) {\n\t\t\t\t\tvec4.scale(v, v, 1 / 255);\n\t\t\t\t} else if (\n\t\t\t\t\ttype == GL.HALF_FLOAT ||\n\t\t\t\t\ttype == GL.HALF_FLOAT_OES\n\t\t\t\t) {\n\t\t\t\t\t//no half floats possible, hard to read back unless copyed to a FLOAT texture, so temp_texture is always forced to FLOAT\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tLGraphTextureAverage.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tuniform mat4 u_samples_a;\\n\\\n\t\tuniform mat4 u_samples_b;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform float u_mipmap_offset;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tvec4 color = vec4(0.0);\\n\\\n\t\t\t//random average\\n\\\n\t\t\tfor(int i = 0; i < 4; ++i)\\n\\\n\t\t\t\tfor(int j = 0; j < 4; ++j)\\n\\\n\t\t\t\t{\\n\\\n\t\t\t\t\tcolor += texture2D(u_texture, vec2( u_samples_a[i][j], u_samples_b[i][j] ), u_mipmap_offset );\\n\\\n\t\t\t\t\tcolor += texture2D(u_texture, vec2( 1.0 - u_samples_a[i][j], 1.0 - u_samples_b[i][j] ), u_mipmap_offset );\\n\\\n\t\t\t\t}\\n\\\n\t\t   gl_FragColor = color * 0.03125;\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLiteGraph.registerNodeType("texture/average", LGraphTextureAverage);\n\n\n\n\t// Computes operation between pixels (max, min)  *****************************************\n\tfunction LGraphTextureMinMax() {\n\t\tthis.addInput("Texture", "Texture");\n\t\tthis.addOutput("min_t", "Texture");\n\t\tthis.addOutput("max_t", "Texture");\n\t\tthis.addOutput("min", "vec4");\n\t\tthis.addOutput("max", "vec4");\n\t\tthis.properties = {\n\t\t\tmode: "max",\n\t\t\tuse_previous_frame: true //to avoid stalls \n\t\t};\n\n\t\tthis._uniforms = {\n\t\t\tu_texture: 0\n\t\t};\n\n\t\tthis._max = new Float32Array(4);\n\t\tthis._min = new Float32Array(4);\n\n\t\tthis._textures_chain = [];\n\t}\n\n\tLGraphTextureMinMax.widgets_info = {\n\t\tmode: { widget: "combo", values: ["min","max","avg"] }\n\t};\n\n\tLGraphTextureMinMax.title = "MinMax";\n\tLGraphTextureMinMax.desc = "Compute the scene min max";\n\n\tLGraphTextureMinMax.prototype.onExecute = function() {\n\t\tif (!this.properties.use_previous_frame) {\n\t\t\tthis.update();\n\t\t}\n\n\t\tthis.setOutputData(0, this._temp_texture);\n\t\tthis.setOutputData(1, this._luminance);\n\t};\n\n\t//executed before rendering the frame\n\tLGraphTextureMinMax.prototype.onPreRenderExecute = function() {\n\t\tthis.update();\n\t};\n\n\tLGraphTextureMinMax.prototype.update = function() {\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !this.isOutputConnected(0) && !this.isOutputConnected(1) ) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tif (!LGraphTextureMinMax._shader) {\n\t\t\tLGraphTextureMinMax._shader = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureMinMax.pixel_shader );\n\t\t}\n\n\t\tvar temp = this._temp_texture;\n\t\tvar type = gl.UNSIGNED_BYTE;\n\t\tif (tex.type != type) {\n\t\t\t//force floats, half floats cannot be read with gl.readPixels\n\t\t\ttype = gl.FLOAT;\n\t\t}\n\n\t\tvar size = 512;\n\n\t\tif( !this._textures_chain.length || this._textures_chain[0].type != type )\n\t\t{\n\t\t\tvar index = 0;\n\t\t\twhile(i)\n\t\t\t{\n\t\t\t\tthis._textures_chain[i] = new GL.Texture( size, size, {\n\t\t\t\t\ttype: type,\n\t\t\t\t\tformat: gl.RGBA,\n\t\t\t\t\tfilter: gl.NEAREST\n\t\t\t\t});\n\t\t\t\tsize = size >> 2;\n\t\t\t\ti++;\n\t\t\t\tif(size == 1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttex.copyTo( this._textures_chain[0] );\n\t\tvar prev = this._textures_chain[0];\n\t\tfor(var i = 1; i <= this._textures_chain.length; ++i)\n\t\t{\n\t\t\tvar tex = this._textures_chain[i];\n\n\t\t\tprev = tex;\t\t\t\t\n\t\t}\n\n\t\tvar shader = LGraphTextureMinMax._shader;\n\t\tvar uniforms = this._uniforms;\n\t\tuniforms.u_mipmap_offset = this.properties.mipmap_offset;\n\t\tgl.disable(gl.DEPTH_TEST);\n\t\tgl.disable(gl.BLEND);\n\t\tthis._temp_texture.drawTo(function() {\n\t\t\ttex.toViewport(shader, uniforms);\n\t\t});\n\t};\n\n\tLGraphTextureMinMax.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tuniform mat4 u_samples_a;\\n\\\n\t\tuniform mat4 u_samples_b;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform float u_mipmap_offset;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tvec4 color = vec4(0.0);\\n\\\n\t\t\t//random average\\n\\\n\t\t\tfor(int i = 0; i < 4; ++i)\\n\\\n\t\t\t\tfor(int j = 0; j < 4; ++j)\\n\\\n\t\t\t\t{\\n\\\n\t\t\t\t\tcolor += texture2D(u_texture, vec2( u_samples_a[i][j], u_samples_b[i][j] ), u_mipmap_offset );\\n\\\n\t\t\t\t\tcolor += texture2D(u_texture, vec2( 1.0 - u_samples_a[i][j], 1.0 - u_samples_b[i][j] ), u_mipmap_offset );\\n\\\n\t\t\t\t}\\n\\\n\t\t   gl_FragColor = color * 0.03125;\\n\\\n\t\t}\\n\\\n\t\t";\n\n\t//LiteGraph.registerNodeType("texture/clustered_operation", LGraphTextureClusteredOperation);\n\n\n\tfunction LGraphTextureTemporalSmooth() {\n\t\tthis.addInput("in", "Texture");\n\t\tthis.addInput("factor", "Number");\n\t\tthis.addOutput("out", "Texture");\n\t\tthis.properties = { factor: 0.5 };\n\t\tthis._uniforms = {\n\t\t\tu_texture: 0,\n\t\t\tu_textureB: 1,\n\t\t\tu_factor: this.properties.factor\n\t\t};\n\t}\n\n\tLGraphTextureTemporalSmooth.title = "Smooth";\n\tLGraphTextureTemporalSmooth.desc = "Smooth texture over time";\n\n\tLGraphTextureTemporalSmooth.prototype.onExecute = function() {\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex || !this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!LGraphTextureTemporalSmooth._shader) {\n\t\t\tLGraphTextureTemporalSmooth._shader = new GL.Shader(\n\t\t\t\tGL.Shader.SCREEN_VERTEX_SHADER,\n\t\t\t\tLGraphTextureTemporalSmooth.pixel_shader\n\t\t\t);\n\t\t}\n\n\t\tvar temp = this._temp_texture;\n\t\tif (\n\t\t\t!temp ||\n\t\t\ttemp.type != tex.type ||\n\t\t\ttemp.width != tex.width ||\n\t\t\ttemp.height != tex.height\n\t\t) {\n\t\t\tvar options = {\n\t\t\t\ttype: tex.type,\n\t\t\t\tformat: gl.RGBA,\n\t\t\t\tfilter: gl.NEAREST\n\t\t\t};\n\t\t\tthis._temp_texture = new GL.Texture(tex.width, tex.height, options );\n\t\t\tthis._temp_texture2 = new GL.Texture(tex.width, tex.height, options );\n\t\t\ttex.copyTo(this._temp_texture2);\n\t\t}\n\n\t\tvar tempA = this._temp_texture;\n\t\tvar tempB = this._temp_texture2;\n\n\t\tvar shader = LGraphTextureTemporalSmooth._shader;\n\t\tvar uniforms = this._uniforms;\n\t\tuniforms.u_factor = 1.0 - this.getInputOrProperty("factor");\n\n\t\tgl.disable(gl.BLEND);\n\t\tgl.disable(gl.DEPTH_TEST);\n\t\ttempA.drawTo(function() {\n\t\t\ttempB.bind(1);\n\t\t\ttex.toViewport(shader, uniforms);\n\t\t});\n\n\t\tthis.setOutputData(0, tempA);\n\n\t\t//swap\n\t\tthis._temp_texture = tempB;\n\t\tthis._temp_texture2 = tempA;\n\t};\n\n\tLGraphTextureTemporalSmooth.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform sampler2D u_textureB;\\n\\\n\t\tuniform float u_factor;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tgl_FragColor = mix( texture2D( u_texture, v_coord ), texture2D( u_textureB, v_coord ), u_factor );\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLiteGraph.registerNodeType( "texture/temporal_smooth", LGraphTextureTemporalSmooth );\n\n\n\tfunction LGraphTextureLinearAvgSmooth() {\n\t\tthis.addInput("in", "Texture");\n\t\tthis.addOutput("avg", "Texture");\n\t\tthis.addOutput("array", "Texture");\n\t\tthis.properties = { samples: 64, frames_interval: 1 };\n\t\tthis._uniforms = {\n\t\t\tu_texture: 0,\n\t\t\tu_textureB: 1,\n\t\t\tu_samples: this.properties.samples,\n\t\t\tu_isamples: 1/this.properties.samples\n\t\t};\n\t\tthis.frame = 0;\n\t}\n\n\tLGraphTextureLinearAvgSmooth.title = "Lineal Avg Smooth";\n\tLGraphTextureLinearAvgSmooth.desc = "Smooth texture linearly over time";\n\n\tLGraphTextureLinearAvgSmooth["@samples"] = { type: "number", min: 1, max: 64, step: 1, precision: 1 };\n\n\tLGraphTextureLinearAvgSmooth.prototype.getPreviewTexture = function()\n\t{\n\t\treturn this._temp_texture2;\n\t}\n\n\tLGraphTextureLinearAvgSmooth.prototype.onExecute = function() {\n\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex || !this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!LGraphTextureLinearAvgSmooth._shader) {\n\t\t\tLGraphTextureLinearAvgSmooth._shader_copy = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureLinearAvgSmooth.pixel_shader_copy );\n\t\t\tLGraphTextureLinearAvgSmooth._shader_avg = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureLinearAvgSmooth.pixel_shader_avg );\n\t\t}\n\n\t\tvar samples = clamp(this.properties.samples,0,64);\n\t\tvar frame = this.frame;\n\t\tvar interval = this.properties.frames_interval;\n\n\t\tif( interval == 0 || frame % interval == 0 )\n\t\t{\n\t\t\tvar temp = this._temp_texture;\n\t\t\tif ( !temp || temp.type != tex.type || temp.width != samples ) {\n\t\t\t\tvar options = {\n\t\t\t\t\ttype: tex.type,\n\t\t\t\t\tformat: gl.RGBA,\n\t\t\t\t\tfilter: gl.NEAREST\n\t\t\t\t};\n\t\t\t\tthis._temp_texture = new GL.Texture( samples, 1, options );\n\t\t\t\tthis._temp_texture2 = new GL.Texture( samples, 1, options );\n\t\t\t\tthis._temp_texture_out = new GL.Texture( 1, 1, options );\n\t\t\t}\n\n\t\t\tvar tempA = this._temp_texture;\n\t\t\tvar tempB = this._temp_texture2;\n\n\t\t\tvar shader_copy = LGraphTextureLinearAvgSmooth._shader_copy;\n\t\t\tvar shader_avg = LGraphTextureLinearAvgSmooth._shader_avg;\n\t\t\tvar uniforms = this._uniforms;\n\t\t\tuniforms.u_samples = samples;\n\t\t\tuniforms.u_isamples = 1.0 / samples;\n\n\t\t\tgl.disable(gl.BLEND);\n\t\t\tgl.disable(gl.DEPTH_TEST);\n\t\t\ttempA.drawTo(function() {\n\t\t\t\ttempB.bind(1);\n\t\t\t\ttex.toViewport( shader_copy, uniforms );\n\t\t\t});\n\n\t\t\tthis._temp_texture_out.drawTo(function() {\n\t\t\t\ttempA.toViewport( shader_avg, uniforms );\n\t\t\t});\n\n\t\t\tthis.setOutputData( 0, this._temp_texture_out );\n\n\t\t\t//swap\n\t\t\tthis._temp_texture = tempB;\n\t\t\tthis._temp_texture2 = tempA;\n\t\t}\n\t\telse\n\t\t\tthis.setOutputData(0, this._temp_texture_out);\n\t\tthis.setOutputData(1, this._temp_texture2);\n\t\tthis.frame++;\n\t};\n\n\tLGraphTextureLinearAvgSmooth.pixel_shader_copy =\n\t\t"precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform sampler2D u_textureB;\\n\\\n\t\tuniform float u_isamples;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tif( v_coord.x <= u_isamples )\\n\\\n\t\t\t\tgl_FragColor = texture2D( u_texture, vec2(0.5) );\\n\\\n\t\t\telse\\n\\\n\t\t\t\tgl_FragColor = texture2D( u_textureB, v_coord - vec2(u_isamples,0.0) );\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLGraphTextureLinearAvgSmooth.pixel_shader_avg =\n\t\t"precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform int u_samples;\\n\\\n\t\tuniform float u_isamples;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tvec4 color = vec4(0.0);\\n\\\n\t\t\tfor(int i = 0; i < 64; ++i)\\n\\\n\t\t\t{\\n\\\n\t\t\t\tcolor += texture2D( u_texture, vec2( float(i)*u_isamples,0.0) );\\n\\\n\t\t\t\tif(i == (u_samples - 1))\\n\\\n\t\t\t\t\tbreak;\\n\\\n\t\t\t}\\n\\\n\t\t\tgl_FragColor = color * u_isamples;\\n\\\n\t\t}\\n\\\n\t\t";\n\n\n\tLiteGraph.registerNodeType( "texture/linear_avg_smooth", LGraphTextureLinearAvgSmooth );\n\n\t// Image To Texture *****************************************\n\tfunction LGraphImageToTexture() {\n\t\tthis.addInput("Image", "image");\n\t\tthis.addOutput("", "Texture");\n\t\tthis.properties = {};\n\t}\n\n\tLGraphImageToTexture.title = "Image to Texture";\n\tLGraphImageToTexture.desc = "Uploads an image to the GPU";\n\t//LGraphImageToTexture.widgets_info = { size: { widget:"combo", values:[0,32,64,128,256,512,1024,2048]} };\n\n\tLGraphImageToTexture.prototype.onExecute = function() {\n\t\tvar img = this.getInputData(0);\n\t\tif (!img) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar width = img.videoWidth || img.width;\n\t\tvar height = img.videoHeight || img.height;\n\n\t\t//this is in case we are using a webgl canvas already, no need to reupload it\n\t\tif (img.gltexture) {\n\t\t\tthis.setOutputData(0, img.gltexture);\n\t\t\treturn;\n\t\t}\n\n\t\tvar temp = this._temp_texture;\n\t\tif (!temp || temp.width != width || temp.height != height) {\n\t\t\tthis._temp_texture = new GL.Texture(width, height, {\n\t\t\t\tformat: gl.RGBA,\n\t\t\t\tfilter: gl.LINEAR\n\t\t\t});\n\t\t}\n\n\t\ttry {\n\t\t\tthis._temp_texture.uploadImage(img);\n\t\t} catch (err) {\n\t\t\tconsole.error(\n\t\t\t\t"image comes from an unsafe location, cannot be uploaded to webgl: " +\n\t\t\t\t\terr\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setOutputData(0, this._temp_texture);\n\t};\n\n\tLiteGraph.registerNodeType(\n\t\t"texture/imageToTexture",\n\t\tLGraphImageToTexture\n\t);\n\n\t// Texture LUT *****************************************\n\tfunction LGraphTextureLUT() {\n\t\tthis.addInput("Texture", "Texture");\n\t\tthis.addInput("LUT", "Texture");\n\t\tthis.addInput("Intensity", "number");\n\t\tthis.addOutput("", "Texture");\n\t\tthis.properties = { enabled: true, intensity: 1, precision: LGraphTexture.DEFAULT, texture: null };\n\n\t\tif (!LGraphTextureLUT._shader) {\n\t\t\tLGraphTextureLUT._shader = new GL.Shader( Shader.SCREEN_VERTEX_SHADER, LGraphTextureLUT.pixel_shader );\n\t\t}\n\t}\n\n\tLGraphTextureLUT.widgets_info = {\n\t\ttexture: { widget: "texture" },\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureLUT.title = "LUT";\n\tLGraphTextureLUT.desc = "Apply LUT to Texture";\n\n\tLGraphTextureLUT.prototype.onExecute = function() {\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tvar tex = this.getInputData(0);\n\n\t\tif (this.properties.precision === LGraphTexture.PASS_THROUGH || this.properties.enabled === false) {\n\t\t\tthis.setOutputData(0, tex);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar lut_tex = this.getInputData(1);\n\n\t\tif (!lut_tex) {\n\t\t\tlut_tex = LGraphTexture.getTexture(this.properties.texture);\n\t\t}\n\n\t\tif (!lut_tex) {\n\t\t\tthis.setOutputData(0, tex);\n\t\t\treturn;\n\t\t}\n\n\t\tlut_tex.bind(0);\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t\tgl.texParameteri(\n\t\t\tgl.TEXTURE_2D,\n\t\t\tgl.TEXTURE_WRAP_S,\n\t\t\tgl.CLAMP_TO_EDGE\n\t\t);\n\t\tgl.texParameteri(\n\t\t\tgl.TEXTURE_2D,\n\t\t\tgl.TEXTURE_WRAP_T,\n\t\t\tgl.CLAMP_TO_EDGE\n\t\t);\n\t\tgl.bindTexture(gl.TEXTURE_2D, null);\n\n\t\tvar intensity = this.properties.intensity;\n\t\tif (this.isInputConnected(2)) {\n\t\t\tthis.properties.intensity = intensity = this.getInputData(2);\n\t\t}\n\n\t\tthis._tex = LGraphTexture.getTargetTexture(\n\t\t\ttex,\n\t\t\tthis._tex,\n\t\t\tthis.properties.precision\n\t\t);\n\n\t\t//var mesh = Mesh.getScreenQuad();\n\n\t\tthis._tex.drawTo(function() {\n\t\t\tlut_tex.bind(1);\n\t\t\ttex.toViewport(LGraphTextureLUT._shader, {\n\t\t\t\tu_texture: 0,\n\t\t\t\tu_textureB: 1,\n\t\t\t\tu_amount: intensity\n\t\t\t});\n\t\t});\n\n\t\tthis.setOutputData(0, this._tex);\n\t};\n\n\tLGraphTextureLUT.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform sampler2D u_textureB;\\n\\\n\t\tuniform float u_amount;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\t lowp vec4 textureColor = clamp( texture2D(u_texture, v_coord), vec4(0.0), vec4(1.0) );\\n\\\n\t\t\t mediump float blueColor = textureColor.b * 63.0;\\n\\\n\t\t\t mediump vec2 quad1;\\n\\\n\t\t\t quad1.y = floor(floor(blueColor) / 8.0);\\n\\\n\t\t\t quad1.x = floor(blueColor) - (quad1.y * 8.0);\\n\\\n\t\t\t mediump vec2 quad2;\\n\\\n\t\t\t quad2.y = floor(ceil(blueColor) / 8.0);\\n\\\n\t\t\t quad2.x = ceil(blueColor) - (quad2.y * 8.0);\\n\\\n\t\t\t highp vec2 texPos1;\\n\\\n\t\t\t texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\\n\\\n\t\t\t texPos1.y = 1.0 - ((quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));\\n\\\n\t\t\t highp vec2 texPos2;\\n\\\n\t\t\t texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\\n\\\n\t\t\t texPos2.y = 1.0 - ((quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));\\n\\\n\t\t\t lowp vec4 newColor1 = texture2D(u_textureB, texPos1);\\n\\\n\t\t\t lowp vec4 newColor2 = texture2D(u_textureB, texPos2);\\n\\\n\t\t\t lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\\n\\\n\t\t\t gl_FragColor = vec4( mix( textureColor.rgb, newColor.rgb, u_amount), textureColor.w);\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLiteGraph.registerNodeType("texture/LUT", LGraphTextureLUT);\n\n\n\t// Texture LUT *****************************************\n\tfunction LGraphTextureEncode() {\n\t\tthis.addInput("Texture", "Texture");\n\t\tthis.addInput("Atlas", "Texture");\n\t\tthis.addOutput("", "Texture");\n\t\tthis.properties = { enabled: true, num_row_symbols: 4, symbol_size: 16, brightness: 1, colorize: false, filter: false, invert: false, precision: LGraphTexture.DEFAULT, generate_mipmaps: false, texture: null };\n\n\t\tif (!LGraphTextureEncode._shader) {\n\t\t\tLGraphTextureEncode._shader = new GL.Shader( Shader.SCREEN_VERTEX_SHADER, LGraphTextureEncode.pixel_shader );\n\t\t}\n\n\t\tthis._uniforms = {\n\t\t\t\tu_texture: 0,\n\t\t\t\tu_textureB: 1,\n\t\t\t\tu_row_simbols: 4,\n\t\t\t\tu_simbol_size: 16,\n\t\t\t\tu_res: vec2.create()\n\t\t};\n\t}\n\n\tLGraphTextureEncode.widgets_info = {\n\t\ttexture: { widget: "texture" },\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureEncode.title = "Encode";\n\tLGraphTextureEncode.desc = "Apply a texture atlas to encode a texture";\n\n\tLGraphTextureEncode.prototype.onExecute = function() {\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tvar tex = this.getInputData(0);\n\n\t\tif (this.properties.precision === LGraphTexture.PASS_THROUGH || this.properties.enabled === false) {\n\t\t\tthis.setOutputData(0, tex);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar symbols_tex = this.getInputData(1);\n\n\t\tif (!symbols_tex) {\n\t\t\tsymbols_tex = LGraphTexture.getTexture(this.properties.texture);\n\t\t}\n\n\t\tif (!symbols_tex) {\n\t\t\tthis.setOutputData(0, tex);\n\t\t\treturn;\n\t\t}\n\n\t\tsymbols_tex.bind(0);\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.properties.filter ? gl.LINEAR : gl.NEAREST );\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.properties.filter ? gl.LINEAR : gl.NEAREST );\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\tgl.bindTexture(gl.TEXTURE_2D, null);\n\n\t\tvar uniforms = this._uniforms;\n\t\tuniforms.u_row_simbols = Math.floor(this.properties.num_row_symbols);\n\t\tuniforms.u_symbol_size = this.properties.symbol_size;\n\t\tuniforms.u_brightness = this.properties.brightness;\n\t\tuniforms.u_invert = this.properties.invert ? 1 : 0;\n\t\tuniforms.u_colorize = this.properties.colorize ? 1 : 0;\n\n\t\tthis._tex = LGraphTexture.getTargetTexture( tex, this._tex, this.properties.precision );\n\t\tuniforms.u_res[0] = this._tex.width;\n\t\tuniforms.u_res[1] = this._tex.height;\n\t\tthis._tex.bind(0);\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\tthis._tex.drawTo(function() {\n\t\t\tsymbols_tex.bind(1);\n\t\t\ttex.toViewport(LGraphTextureEncode._shader, uniforms);\n\t\t});\n\n\t\tif (this.properties.generate_mipmaps) {\n\t\t\tthis._tex.bind(0);\n\t\t\tgl.generateMipmap(this._tex.texture_type);\n\t\t\tthis._tex.unbind(0);\n\t\t}\n\n\t\tthis.setOutputData(0, this._tex);\n\t};\n\n\tLGraphTextureEncode.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform sampler2D u_textureB;\\n\\\n\t\tuniform float u_row_simbols;\\n\\\n\t\tuniform float u_symbol_size;\\n\\\n\t\tuniform float u_brightness;\\n\\\n\t\tuniform float u_invert;\\n\\\n\t\tuniform float u_colorize;\\n\\\n\t\tuniform vec2 u_res;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tvec2 total_symbols = u_res / u_symbol_size;\\n\\\n\t\t\tvec2 uv = floor(v_coord * total_symbols) / total_symbols; //pixelate \\n\\\n\t\t\tvec2 local_uv = mod(v_coord * u_res, u_symbol_size) / u_symbol_size;\\n\\\n\t\t\tlowp vec4 textureColor = texture2D(u_texture, uv );\\n\\\n\t\t\tfloat lum = clamp(u_brightness * (textureColor.x + textureColor.y + textureColor.z)/3.0,0.0,1.0);\\n\\\n\t\t\tif( u_invert == 1.0 ) lum = 1.0 - lum;\\n\\\n\t\t\tfloat index = floor( lum * (u_row_simbols * u_row_simbols - 1.0));\\n\\\n\t\t\tfloat col = mod( index, u_row_simbols );\\n\\\n\t\t\tfloat row = u_row_simbols - floor( index / u_row_simbols ) - 1.0;\\n\\\n\t\t\tvec2 simbol_uv = ( vec2( col, row ) + local_uv ) / u_row_simbols;\\n\\\n\t\t\tvec4 color = texture2D( u_textureB, simbol_uv );\\n\\\n\t\t\tif(u_colorize == 1.0)\\n\\\n\t\t\t\tcolor *= textureColor;\\n\\\n\t\t\tgl_FragColor = color;\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLiteGraph.registerNodeType("texture/encode", LGraphTextureEncode);\n\n\t// Texture Channels *****************************************\n\tfunction LGraphTextureChannels() {\n\t\tthis.addInput("Texture", "Texture");\n\n\t\tthis.addOutput("R", "Texture");\n\t\tthis.addOutput("G", "Texture");\n\t\tthis.addOutput("B", "Texture");\n\t\tthis.addOutput("A", "Texture");\n\n\t\t//this.properties = { use_single_channel: true };\n\t\tif (!LGraphTextureChannels._shader) {\n\t\t\tLGraphTextureChannels._shader = new GL.Shader(\n\t\t\t\tShader.SCREEN_VERTEX_SHADER,\n\t\t\t\tLGraphTextureChannels.pixel_shader\n\t\t\t);\n\t\t}\n\t}\n\n\tLGraphTextureChannels.title = "Texture to Channels";\n\tLGraphTextureChannels.desc = "Split texture channels";\n\n\tLGraphTextureChannels.prototype.onExecute = function() {\n\t\tvar texA = this.getInputData(0);\n\t\tif (!texA) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._channels) {\n\t\t\tthis._channels = Array(4);\n\t\t}\n\n\t\t//var format = this.properties.use_single_channel ? gl.LUMINANCE : gl.RGBA; //not supported by WebGL1\n\t\tvar format = gl.RGB;\n\t\tvar connections = 0;\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this.isOutputConnected(i)) {\n\t\t\t\tif (\n\t\t\t\t\t!this._channels[i] ||\n\t\t\t\t\tthis._channels[i].width != texA.width ||\n\t\t\t\t\tthis._channels[i].height != texA.height ||\n\t\t\t\t\tthis._channels[i].type != texA.type ||\n\t\t\t\t\tthis._channels[i].format != format\n\t\t\t\t) {\n\t\t\t\t\tthis._channels[i] = new GL.Texture(\n\t\t\t\t\t\ttexA.width,\n\t\t\t\t\t\ttexA.height,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: texA.type,\n\t\t\t\t\t\t\tformat: format,\n\t\t\t\t\t\t\tfilter: gl.LINEAR\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconnections++;\n\t\t\t} else {\n\t\t\t\tthis._channels[i] = null;\n\t\t\t}\n\t\t}\n\n\t\tif (!connections) {\n\t\t\treturn;\n\t\t}\n\n\t\tgl.disable(gl.BLEND);\n\t\tgl.disable(gl.DEPTH_TEST);\n\n\t\tvar mesh = Mesh.getScreenQuad();\n\t\tvar shader = LGraphTextureChannels._shader;\n\t\tvar masks = [\n\t\t\t[1, 0, 0, 0],\n\t\t\t[0, 1, 0, 0],\n\t\t\t[0, 0, 1, 0],\n\t\t\t[0, 0, 0, 1]\n\t\t];\n\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (!this._channels[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._channels[i].drawTo(function() {\n\t\t\t\ttexA.bind(0);\n\t\t\t\tshader\n\t\t\t\t\t.uniforms({ u_texture: 0, u_mask: masks[i] })\n\t\t\t\t\t.draw(mesh);\n\t\t\t});\n\t\t\tthis.setOutputData(i, this._channels[i]);\n\t\t}\n\t};\n\n\tLGraphTextureChannels.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform vec4 u_mask;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t   gl_FragColor = vec4( vec3( length( texture2D(u_texture, v_coord) * u_mask )), 1.0 );\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLiteGraph.registerNodeType(\n\t\t"texture/textureChannels",\n\t\tLGraphTextureChannels\n\t);\n\n\t// Texture Channels to Texture *****************************************\n\tfunction LGraphChannelsTexture() {\n\t\tthis.addInput("R", "Texture");\n\t\tthis.addInput("G", "Texture");\n\t\tthis.addInput("B", "Texture");\n\t\tthis.addInput("A", "Texture");\n\n\t\tthis.addOutput("Texture", "Texture");\n\n\t\tthis.properties = {\n\t\t\tprecision: LGraphTexture.DEFAULT,\n\t\t\tR: 1,\n\t\t\tG: 1,\n\t\t\tB: 1,\n\t\t\tA: 1\n\t\t};\n\t\tthis._color = vec4.create();\n\t\tthis._uniforms = {\n\t\t\tu_textureR: 0,\n\t\t\tu_textureG: 1,\n\t\t\tu_textureB: 2,\n\t\t\tu_textureA: 3,\n\t\t\tu_color: this._color\n\t\t};\n\t}\n\n\tLGraphChannelsTexture.title = "Channels to Texture";\n\tLGraphChannelsTexture.desc = "Split texture channels";\n\tLGraphChannelsTexture.widgets_info = {\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphChannelsTexture.prototype.onExecute = function() {\n\t\tvar white = LGraphTexture.getWhiteTexture();\n\t\tvar texR = this.getInputData(0) || white;\n\t\tvar texG = this.getInputData(1) || white;\n\t\tvar texB = this.getInputData(2) || white;\n\t\tvar texA = this.getInputData(3) || white;\n\n\t\tgl.disable(gl.BLEND);\n\t\tgl.disable(gl.DEPTH_TEST);\n\n\t\tvar mesh = Mesh.getScreenQuad();\n\t\tif (!LGraphChannelsTexture._shader) {\n\t\t\tLGraphChannelsTexture._shader = new GL.Shader(\n\t\t\t\tShader.SCREEN_VERTEX_SHADER,\n\t\t\t\tLGraphChannelsTexture.pixel_shader\n\t\t\t);\n\t\t}\n\t\tvar shader = LGraphChannelsTexture._shader;\n\n\t\tvar w = Math.max(texR.width, texG.width, texB.width, texA.width);\n\t\tvar h = Math.max(\n\t\t\ttexR.height,\n\t\t\ttexG.height,\n\t\t\ttexB.height,\n\t\t\ttexA.height\n\t\t);\n\t\tvar type =\n\t\t\tthis.properties.precision == LGraphTexture.HIGH\n\t\t\t\t? LGraphTexture.HIGH_PRECISION_FORMAT\n\t\t\t\t: gl.UNSIGNED_BYTE;\n\n\t\tif (\n\t\t\t!this._texture ||\n\t\t\tthis._texture.width != w ||\n\t\t\tthis._texture.height != h ||\n\t\t\tthis._texture.type != type\n\t\t) {\n\t\t\tthis._texture = new GL.Texture(w, h, {\n\t\t\t\ttype: type,\n\t\t\t\tformat: gl.RGBA,\n\t\t\t\tfilter: gl.LINEAR\n\t\t\t});\n\t\t}\n\n\t\tvar color = this._color;\n\t\tcolor[0] = this.properties.R;\n\t\tcolor[1] = this.properties.G;\n\t\tcolor[2] = this.properties.B;\n\t\tcolor[3] = this.properties.A;\n\t\tvar uniforms = this._uniforms;\n\n\t\tthis._texture.drawTo(function() {\n\t\t\ttexR.bind(0);\n\t\t\ttexG.bind(1);\n\t\t\ttexB.bind(2);\n\t\t\ttexA.bind(3);\n\t\t\tshader.uniforms(uniforms).draw(mesh);\n\t\t});\n\t\tthis.setOutputData(0, this._texture);\n\t};\n\n\tLGraphChannelsTexture.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform sampler2D u_textureR;\\n\\\n\t\tuniform sampler2D u_textureG;\\n\\\n\t\tuniform sampler2D u_textureB;\\n\\\n\t\tuniform sampler2D u_textureA;\\n\\\n\t\tuniform vec4 u_color;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t   gl_FragColor = u_color * vec4( \\\n\t\t\t\t\ttexture2D(u_textureR, v_coord).r,\\\n\t\t\t\t\ttexture2D(u_textureG, v_coord).r,\\\n\t\t\t\t\ttexture2D(u_textureB, v_coord).r,\\\n\t\t\t\t\ttexture2D(u_textureA, v_coord).r);\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLiteGraph.registerNodeType(\n\t\t"texture/channelsTexture",\n\t\tLGraphChannelsTexture\n\t);\n\n\t// Texture Color *****************************************\n\tfunction LGraphTextureColor() {\n\t\tthis.addOutput("Texture", "Texture");\n\n\t\tthis._tex_color = vec4.create();\n\t\tthis.properties = {\n\t\t\tcolor: vec4.create(),\n\t\t\tprecision: LGraphTexture.DEFAULT\n\t\t};\n\t}\n\n\tLGraphTextureColor.title = "Color";\n\tLGraphTextureColor.desc =\n\t\t"Generates a 1x1 texture with a constant color";\n\n\tLGraphTextureColor.widgets_info = {\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureColor.prototype.onDrawBackground = function(ctx) {\n\t\tvar c = this.properties.color;\n\t\tctx.fillStyle =\n\t\t\t"rgb(" +\n\t\t\tMath.floor(clamp(c[0], 0, 1) * 255) +\n\t\t\t"," +\n\t\t\tMath.floor(clamp(c[1], 0, 1) * 255) +\n\t\t\t"," +\n\t\t\tMath.floor(clamp(c[2], 0, 1) * 255) +\n\t\t\t")";\n\t\tif (this.flags.collapsed) {\n\t\t\tthis.boxcolor = ctx.fillStyle;\n\t\t} else {\n\t\t\tctx.fillRect(0, 0, this.size[0], this.size[1]);\n\t\t}\n\t};\n\n\tLGraphTextureColor.prototype.onExecute = function() {\n\t\tvar type =\n\t\t\tthis.properties.precision == LGraphTexture.HIGH\n\t\t\t\t? LGraphTexture.HIGH_PRECISION_FORMAT\n\t\t\t\t: gl.UNSIGNED_BYTE;\n\n\t\tif (!this._tex || this._tex.type != type) {\n\t\t\tthis._tex = new GL.Texture(1, 1, {\n\t\t\t\tformat: gl.RGBA,\n\t\t\t\ttype: type,\n\t\t\t\tminFilter: gl.NEAREST\n\t\t\t});\n\t\t}\n\t\tvar color = this.properties.color;\n\n\t\tif (this.inputs) {\n\t\t\tfor (var i = 0; i < this.inputs.length; i++) {\n\t\t\t\tvar input = this.inputs[i];\n\t\t\t\tvar v = this.getInputData(i);\n\t\t\t\tif (v === undefined) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswitch (input.name) {\n\t\t\t\t\tcase "RGB":\n\t\t\t\t\tcase "RGBA":\n\t\t\t\t\t\tcolor.set(v);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase "R":\n\t\t\t\t\t\tcolor[0] = v;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase "G":\n\t\t\t\t\t\tcolor[1] = v;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase "B":\n\t\t\t\t\t\tcolor[2] = v;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase "A":\n\t\t\t\t\t\tcolor[3] = v;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (vec4.sqrDist(this._tex_color, color) > 0.001) {\n\t\t\tthis._tex_color.set(color);\n\t\t\tthis._tex.fill(color);\n\t\t}\n\t\tthis.setOutputData(0, this._tex);\n\t};\n\n\tLGraphTextureColor.prototype.onGetInputs = function() {\n\t\treturn [\n\t\t\t["RGB", "vec3"],\n\t\t\t["RGBA", "vec4"],\n\t\t\t["R", "number"],\n\t\t\t["G", "number"],\n\t\t\t["B", "number"],\n\t\t\t["A", "number"]\n\t\t];\n\t};\n\n\tLiteGraph.registerNodeType("texture/color", LGraphTextureColor);\n\n\t// Texture Channels to Texture *****************************************\n\tfunction LGraphTextureGradient() {\n\t\tthis.addInput("A", "color");\n\t\tthis.addInput("B", "color");\n\t\tthis.addOutput("Texture", "Texture");\n\n\t\tthis.properties = {\n\t\t\tangle: 0,\n\t\t\tscale: 1,\n\t\t\tA: [0, 0, 0],\n\t\t\tB: [1, 1, 1],\n\t\t\ttexture_size: 32\n\t\t};\n\t\tif (!LGraphTextureGradient._shader) {\n\t\t\tLGraphTextureGradient._shader = new GL.Shader(\n\t\t\t\tShader.SCREEN_VERTEX_SHADER,\n\t\t\t\tLGraphTextureGradient.pixel_shader\n\t\t\t);\n\t\t}\n\n\t\tthis._uniforms = {\n\t\t\tu_angle: 0,\n\t\t\tu_colorA: vec3.create(),\n\t\t\tu_colorB: vec3.create()\n\t\t};\n\t}\n\n\tLGraphTextureGradient.title = "Gradient";\n\tLGraphTextureGradient.desc = "Generates a gradient";\n\tLGraphTextureGradient["@A"] = { type: "color" };\n\tLGraphTextureGradient["@B"] = { type: "color" };\n\tLGraphTextureGradient["@texture_size"] = {\n\t\ttype: "enum",\n\t\tvalues: [32, 64, 128, 256, 512]\n\t};\n\n\tLGraphTextureGradient.prototype.onExecute = function() {\n\t\tgl.disable(gl.BLEND);\n\t\tgl.disable(gl.DEPTH_TEST);\n\n\t\tvar mesh = GL.Mesh.getScreenQuad();\n\t\tvar shader = LGraphTextureGradient._shader;\n\n\t\tvar A = this.getInputData(0);\n\t\tif (!A) {\n\t\t\tA = this.properties.A;\n\t\t}\n\t\tvar B = this.getInputData(1);\n\t\tif (!B) {\n\t\t\tB = this.properties.B;\n\t\t}\n\n\t\t//angle and scale\n\t\tfor (var i = 2; i < this.inputs.length; i++) {\n\t\t\tvar input = this.inputs[i];\n\t\t\tvar v = this.getInputData(i);\n\t\t\tif (v === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.properties[input.name] = v;\n\t\t}\n\n\t\tvar uniforms = this._uniforms;\n\t\tthis._uniforms.u_angle = this.properties.angle * DEG2RAD;\n\t\tthis._uniforms.u_scale = this.properties.scale;\n\t\tvec3.copy(uniforms.u_colorA, A);\n\t\tvec3.copy(uniforms.u_colorB, B);\n\n\t\tvar size = parseInt(this.properties.texture_size);\n\t\tif (!this._tex || this._tex.width != size) {\n\t\t\tthis._tex = new GL.Texture(size, size, {\n\t\t\t\tformat: gl.RGB,\n\t\t\t\tfilter: gl.LINEAR\n\t\t\t});\n\t\t}\n\n\t\tthis._tex.drawTo(function() {\n\t\t\tshader.uniforms(uniforms).draw(mesh);\n\t\t});\n\t\tthis.setOutputData(0, this._tex);\n\t};\n\n\tLGraphTextureGradient.prototype.onGetInputs = function() {\n\t\treturn [["angle", "number"], ["scale", "number"]];\n\t};\n\n\tLGraphTextureGradient.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform float u_angle;\\n\\\n\t\tuniform float u_scale;\\n\\\n\t\tuniform vec3 u_colorA;\\n\\\n\t\tuniform vec3 u_colorB;\\n\\\n\t\t\\n\\\n\t\tvec2 rotate(vec2 v, float angle)\\n\\\n\t\t{\\n\\\n\t\t\tvec2 result;\\n\\\n\t\t\tfloat _cos = cos(angle);\\n\\\n\t\t\tfloat _sin = sin(angle);\\n\\\n\t\t\tresult.x = v.x * _cos - v.y * _sin;\\n\\\n\t\t\tresult.y = v.x * _sin + v.y * _cos;\\n\\\n\t\t\treturn result;\\n\\\n\t\t}\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tfloat f = (rotate(u_scale * (v_coord - vec2(0.5)), u_angle) + vec2(0.5)).x;\\n\\\n\t\t\tvec3 color = mix(u_colorA,u_colorB,clamp(f,0.0,1.0));\\n\\\n\t\t   gl_FragColor = vec4(color,1.0);\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLiteGraph.registerNodeType("texture/gradient", LGraphTextureGradient);\n\n\t// Texture Mix *****************************************\n\tfunction LGraphTextureMix() {\n\t\tthis.addInput("A", "Texture");\n\t\tthis.addInput("B", "Texture");\n\t\tthis.addInput("Mixer", "Texture");\n\n\t\tthis.addOutput("Texture", "Texture");\n\t\tthis.properties = { factor: 0.5, size_from_biggest: true, invert: false, precision: LGraphTexture.DEFAULT };\n\t\tthis._uniforms = {\n\t\t\tu_textureA: 0,\n\t\t\tu_textureB: 1,\n\t\t\tu_textureMix: 2,\n\t\t\tu_mix: vec4.create()\n\t\t};\n\t}\n\n\tLGraphTextureMix.title = "Mix";\n\tLGraphTextureMix.desc = "Generates a texture mixing two textures";\n\n\tLGraphTextureMix.widgets_info = {\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureMix.prototype.onExecute = function() {\n\t\tvar texA = this.getInputData(0);\n\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tif (this.properties.precision === LGraphTexture.PASS_THROUGH) {\n\t\t\tthis.setOutputData(0, texA);\n\t\t\treturn;\n\t\t}\n\n\t\tvar texB = this.getInputData(1);\n\t\tif (!texA || !texB) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar texMix = this.getInputData(2);\n\n\t\tvar factor = this.getInputData(3);\n\n\t\tthis._tex = LGraphTexture.getTargetTexture(\n\t\t\tthis.properties.size_from_biggest && texB.width > texA.width ? texB : texA,\n\t\t\tthis._tex,\n\t\t\tthis.properties.precision\n\t\t);\n\n\t\tgl.disable(gl.BLEND);\n\t\tgl.disable(gl.DEPTH_TEST);\n\n\t\tvar mesh = Mesh.getScreenQuad();\n\t\tvar shader = null;\n\t\tvar uniforms = this._uniforms;\n\t\tif (texMix) {\n\t\t\tshader = LGraphTextureMix._shader_tex;\n\t\t\tif (!shader) {\n\t\t\t\tshader = LGraphTextureMix._shader_tex = new GL.Shader(\n\t\t\t\t\tShader.SCREEN_VERTEX_SHADER,\n\t\t\t\t\tLGraphTextureMix.pixel_shader,\n\t\t\t\t\t{ MIX_TEX: "" }\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tshader = LGraphTextureMix._shader_factor;\n\t\t\tif (!shader) {\n\t\t\t\tshader = LGraphTextureMix._shader_factor = new GL.Shader(\n\t\t\t\t\tShader.SCREEN_VERTEX_SHADER,\n\t\t\t\t\tLGraphTextureMix.pixel_shader\n\t\t\t\t);\n\t\t\t}\n\t\t\tvar f = factor == null ? this.properties.factor : factor;\n\t\t\tuniforms.u_mix.set([f, f, f, f]);\n\t\t}\n\n\t\tvar invert = this.properties.invert;\n\n\t\tthis._tex.drawTo(function() {\n\t\t\ttexA.bind( invert ? 1 : 0 );\n\t\t\ttexB.bind( invert ? 0 : 1 );\n\t\t\tif (texMix) {\n\t\t\t\ttexMix.bind(2);\n\t\t\t}\n\t\t\tshader.uniforms(uniforms).draw(mesh);\n\t\t});\n\n\t\tthis.setOutputData(0, this._tex);\n\t};\n\n\tLGraphTextureMix.prototype.onGetInputs = function() {\n\t\treturn [["factor", "number"]];\n\t};\n\n\tLGraphTextureMix.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform sampler2D u_textureA;\\n\\\n\t\tuniform sampler2D u_textureB;\\n\\\n\t\t#ifdef MIX_TEX\\n\\\n\t\t\tuniform sampler2D u_textureMix;\\n\\\n\t\t#else\\n\\\n\t\t\tuniform vec4 u_mix;\\n\\\n\t\t#endif\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\t#ifdef MIX_TEX\\n\\\n\t\t\t   vec4 f = texture2D(u_textureMix, v_coord);\\n\\\n\t\t\t#else\\n\\\n\t\t\t   vec4 f = u_mix;\\n\\\n\t\t\t#endif\\n\\\n\t\t   gl_FragColor = mix( texture2D(u_textureA, v_coord), texture2D(u_textureB, v_coord), f );\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLiteGraph.registerNodeType("texture/mix", LGraphTextureMix);\n\n\t// Texture Edges detection *****************************************\n\tfunction LGraphTextureEdges() {\n\t\tthis.addInput("Tex.", "Texture");\n\n\t\tthis.addOutput("Edges", "Texture");\n\t\tthis.properties = {\n\t\t\tinvert: true,\n\t\t\tthreshold: false,\n\t\t\tfactor: 1,\n\t\t\tprecision: LGraphTexture.DEFAULT\n\t\t};\n\n\t\tif (!LGraphTextureEdges._shader) {\n\t\t\tLGraphTextureEdges._shader = new GL.Shader(\n\t\t\t\tShader.SCREEN_VERTEX_SHADER,\n\t\t\t\tLGraphTextureEdges.pixel_shader\n\t\t\t);\n\t\t}\n\t}\n\n\tLGraphTextureEdges.title = "Edges";\n\tLGraphTextureEdges.desc = "Detects edges";\n\n\tLGraphTextureEdges.widgets_info = {\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureEdges.prototype.onExecute = function() {\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tvar tex = this.getInputData(0);\n\n\t\tif (this.properties.precision === LGraphTexture.PASS_THROUGH) {\n\t\t\tthis.setOutputData(0, tex);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._tex = LGraphTexture.getTargetTexture(\n\t\t\ttex,\n\t\t\tthis._tex,\n\t\t\tthis.properties.precision\n\t\t);\n\n\t\tgl.disable(gl.BLEND);\n\t\tgl.disable(gl.DEPTH_TEST);\n\n\t\tvar mesh = Mesh.getScreenQuad();\n\t\tvar shader = LGraphTextureEdges._shader;\n\t\tvar invert = this.properties.invert;\n\t\tvar factor = this.properties.factor;\n\t\tvar threshold = this.properties.threshold ? 1 : 0;\n\n\t\tthis._tex.drawTo(function() {\n\t\t\ttex.bind(0);\n\t\t\tshader\n\t\t\t\t.uniforms({\n\t\t\t\t\tu_texture: 0,\n\t\t\t\t\tu_isize: [1 / tex.width, 1 / tex.height],\n\t\t\t\t\tu_factor: factor,\n\t\t\t\t\tu_threshold: threshold,\n\t\t\t\t\tu_invert: invert ? 1 : 0\n\t\t\t\t})\n\t\t\t\t.draw(mesh);\n\t\t});\n\n\t\tthis.setOutputData(0, this._tex);\n\t};\n\n\tLGraphTextureEdges.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform vec2 u_isize;\\n\\\n\t\tuniform int u_invert;\\n\\\n\t\tuniform float u_factor;\\n\\\n\t\tuniform float u_threshold;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tvec4 center = texture2D(u_texture, v_coord);\\n\\\n\t\t\tvec4 up = texture2D(u_texture, v_coord + u_isize * vec2(0.0,1.0) );\\n\\\n\t\t\tvec4 down = texture2D(u_texture, v_coord + u_isize * vec2(0.0,-1.0) );\\n\\\n\t\t\tvec4 left = texture2D(u_texture, v_coord + u_isize * vec2(1.0,0.0) );\\n\\\n\t\t\tvec4 right = texture2D(u_texture, v_coord + u_isize * vec2(-1.0,0.0) );\\n\\\n\t\t\tvec4 diff = abs(center - up) + abs(center - down) + abs(center - left) + abs(center - right);\\n\\\n\t\t\tdiff *= u_factor;\\n\\\n\t\t\tif(u_invert == 1)\\n\\\n\t\t\t\tdiff.xyz = vec3(1.0) - diff.xyz;\\n\\\n\t\t\tif( u_threshold == 0.0 )\\n\\\n\t\t\t\tgl_FragColor = vec4( diff.xyz, center.a );\\n\\\n\t\t\telse\\n\\\n\t\t\t\tgl_FragColor = vec4( diff.x > 0.5 ? 1.0 : 0.0, diff.y > 0.5 ? 1.0 : 0.0, diff.z > 0.5 ? 1.0 : 0.0, center.a );\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLiteGraph.registerNodeType("texture/edges", LGraphTextureEdges);\n\n\t// Texture Depth *****************************************\n\tfunction LGraphTextureDepthRange() {\n\t\tthis.addInput("Texture", "Texture");\n\t\tthis.addInput("Distance", "number");\n\t\tthis.addInput("Range", "number");\n\t\tthis.addOutput("Texture", "Texture");\n\t\tthis.properties = {\n\t\t\tdistance: 100,\n\t\t\trange: 50,\n\t\t\tonly_depth: false,\n\t\t\thigh_precision: false\n\t\t};\n\t\tthis._uniforms = {\n\t\t\tu_texture: 0,\n\t\t\tu_distance: 100,\n\t\t\tu_range: 50,\n\t\t\tu_camera_planes: null\n\t\t};\n\t}\n\n\tLGraphTextureDepthRange.title = "Depth Range";\n\tLGraphTextureDepthRange.desc = "Generates a texture with a depth range";\n\n\tLGraphTextureDepthRange.prototype.onExecute = function() {\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar precision = gl.UNSIGNED_BYTE;\n\t\tif (this.properties.high_precision) {\n\t\t\tprecision = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT;\n\t\t}\n\n\t\tif (\n\t\t\t!this._temp_texture ||\n\t\t\tthis._temp_texture.type != precision ||\n\t\t\tthis._temp_texture.width != tex.width ||\n\t\t\tthis._temp_texture.height != tex.height\n\t\t) {\n\t\t\tthis._temp_texture = new GL.Texture(tex.width, tex.height, {\n\t\t\t\ttype: precision,\n\t\t\t\tformat: gl.RGBA,\n\t\t\t\tfilter: gl.LINEAR\n\t\t\t});\n\t\t}\n\n\t\tvar uniforms = this._uniforms;\n\n\t\t//iterations\n\t\tvar distance = this.properties.distance;\n\t\tif (this.isInputConnected(1)) {\n\t\t\tdistance = this.getInputData(1);\n\t\t\tthis.properties.distance = distance;\n\t\t}\n\n\t\tvar range = this.properties.range;\n\t\tif (this.isInputConnected(2)) {\n\t\t\trange = this.getInputData(2);\n\t\t\tthis.properties.range = range;\n\t\t}\n\n\t\tuniforms.u_distance = distance;\n\t\tuniforms.u_range = range;\n\n\t\tgl.disable(gl.BLEND);\n\t\tgl.disable(gl.DEPTH_TEST);\n\t\tvar mesh = Mesh.getScreenQuad();\n\t\tif (!LGraphTextureDepthRange._shader) {\n\t\t\tLGraphTextureDepthRange._shader = new GL.Shader(\n\t\t\t\tShader.SCREEN_VERTEX_SHADER,\n\t\t\t\tLGraphTextureDepthRange.pixel_shader\n\t\t\t);\n\t\t\tLGraphTextureDepthRange._shader_onlydepth = new GL.Shader(\n\t\t\t\tShader.SCREEN_VERTEX_SHADER,\n\t\t\t\tLGraphTextureDepthRange.pixel_shader,\n\t\t\t\t{ ONLY_DEPTH: "" }\n\t\t\t);\n\t\t}\n\t\tvar shader = this.properties.only_depth\n\t\t\t? LGraphTextureDepthRange._shader_onlydepth\n\t\t\t: LGraphTextureDepthRange._shader;\n\n\t\t//NEAR AND FAR PLANES\n\t\tvar planes = null;\n\t\tif (tex.near_far_planes) {\n\t\t\tplanes = tex.near_far_planes;\n\t\t} else if (window.LS && LS.Renderer._main_camera) {\n\t\t\tplanes = LS.Renderer._main_camera._uniforms.u_camera_planes;\n\t\t} else {\n\t\t\tplanes = [0.1, 1000];\n\t\t} //hardcoded\n\t\tuniforms.u_camera_planes = planes;\n\n\t\tthis._temp_texture.drawTo(function() {\n\t\t\ttex.bind(0);\n\t\t\tshader.uniforms(uniforms).draw(mesh);\n\t\t});\n\n\t\tthis._temp_texture.near_far_planes = planes;\n\t\tthis.setOutputData(0, this._temp_texture);\n\t};\n\n\tLGraphTextureDepthRange.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform vec2 u_camera_planes;\\n\\\n\t\tuniform float u_distance;\\n\\\n\t\tuniform float u_range;\\n\\\n\t\t\\n\\\n\t\tfloat LinearDepth()\\n\\\n\t\t{\\n\\\n\t\t\tfloat zNear = u_camera_planes.x;\\n\\\n\t\t\tfloat zFar = u_camera_planes.y;\\n\\\n\t\t\tfloat depth = texture2D(u_texture, v_coord).x;\\n\\\n\t\t\tdepth = depth * 2.0 - 1.0;\\n\\\n\t\t\treturn zNear * (depth + 1.0) / (zFar + zNear - depth * (zFar - zNear));\\n\\\n\t\t}\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tfloat depth = LinearDepth();\\n\\\n\t\t\t#ifdef ONLY_DEPTH\\n\\\n\t\t\t   gl_FragColor = vec4(depth);\\n\\\n\t\t\t#else\\n\\\n\t\t\t\tfloat diff = abs(depth * u_camera_planes.y - u_distance);\\n\\\n\t\t\t\tfloat dof = 1.0;\\n\\\n\t\t\t\tif(diff <= u_range)\\n\\\n\t\t\t\t\tdof = diff / u_range;\\n\\\n\t\t\t   gl_FragColor = vec4(dof);\\n\\\n\t\t\t#endif\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLiteGraph.registerNodeType( "texture/depth_range", LGraphTextureDepthRange );\n\n\n\t// Texture Depth *****************************************\n\tfunction LGraphTextureLinearDepth() {\n\t\tthis.addInput("Texture", "Texture");\n\t\tthis.addOutput("Texture", "Texture");\n\t\tthis.properties = {\n\t\t\tprecision: LGraphTexture.DEFAULT,\n\t\t\tinvert: false\n\t\t};\n\t\tthis._uniforms = {\n\t\t\tu_texture: 0,\n\t\t\tu_camera_planes: null, //filled later\n\t\t\tu_ires: vec2.create()\n\t\t};\n\t}\n\n\tLGraphTextureLinearDepth.widgets_info = {\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureLinearDepth.title = "Linear Depth";\n\tLGraphTextureLinearDepth.desc = "Creates a color texture with linear depth";\n\n\tLGraphTextureLinearDepth.prototype.onExecute = function() {\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex || (tex.format != gl.DEPTH_COMPONENT && tex.format != gl.DEPTH_STENCIL) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar precision = this.properties.precision == LGraphTexture.HIGH ? gl.HIGH_PRECISION_FORMAT : gl.UNSIGNED_BYTE;\n\n\t\tif ( !this._temp_texture || this._temp_texture.type != precision || this._temp_texture.width != tex.width || this._temp_texture.height != tex.height ) {\n\t\t\tthis._temp_texture = new GL.Texture(tex.width, tex.height, {\n\t\t\t\ttype: precision,\n\t\t\t\tformat: gl.RGB,\n\t\t\t\tfilter: gl.LINEAR\n\t\t\t});\n\t\t}\n\n\t\tvar uniforms = this._uniforms;\n\t\tuniforms.u_invert = this.properties.invert ? 1 : 0;\n\n\t\tgl.disable(gl.BLEND);\n\t\tgl.disable(gl.DEPTH_TEST);\n\t\tvar mesh = Mesh.getScreenQuad();\n\t\tif(!LGraphTextureLinearDepth._shader)\n\t\t\tLGraphTextureLinearDepth._shader = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureLinearDepth.pixel_shader);\n\t\tvar shader = LGraphTextureLinearDepth._shader;\n\n\t\t//NEAR AND FAR PLANES\n\t\tvar planes = null;\n\t\tif (tex.near_far_planes) {\n\t\t\tplanes = tex.near_far_planes;\n\t\t} else if (window.LS && LS.Renderer._main_camera) {\n\t\t\tplanes = LS.Renderer._main_camera._uniforms.u_camera_planes;\n\t\t} else {\n\t\t\tplanes = [0.1, 1000];\n\t\t} //hardcoded\n\t\tuniforms.u_camera_planes = planes;\n\t\t//uniforms.u_ires.set([1/tex.width, 1/tex.height]);\n\t\tuniforms.u_ires.set([0,0]);\n\n\t\tthis._temp_texture.drawTo(function() {\n\t\t\ttex.bind(0);\n\t\t\tshader.uniforms(uniforms).draw(mesh);\n\t\t});\n\n\t\tthis._temp_texture.near_far_planes = planes;\n\t\tthis.setOutputData(0, this._temp_texture);\n\t};\n\n\tLGraphTextureLinearDepth.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform vec2 u_camera_planes;\\n\\\n\t\tuniform int u_invert;\\n\\\n\t\tuniform vec2 u_ires;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tfloat zNear = u_camera_planes.x;\\n\\\n\t\t\tfloat zFar = u_camera_planes.y;\\n\\\n\t\t\tfloat depth = texture2D(u_texture, v_coord + u_ires*0.5).x * 2.0 - 1.0;\\n\\\n\t\t\tfloat f = zNear * (depth + 1.0) / (zFar + zNear - depth * (zFar - zNear));\\n\\\n\t\t\tif( u_invert == 1 )\\n\\\n\t\t\t\tf = 1.0 - f;\\n\\\n\t\t\tgl_FragColor = vec4(vec3(f),1.0);\\n\\\n\t\t}\\n\\\n\t\t";\n\n\tLiteGraph.registerNodeType( "texture/linear_depth", LGraphTextureLinearDepth );\n\n\t// Texture Blur *****************************************\n\tfunction LGraphTextureBlur() {\n\t\tthis.addInput("Texture", "Texture");\n\t\tthis.addInput("Iterations", "number");\n\t\tthis.addInput("Intensity", "number");\n\t\tthis.addOutput("Blurred", "Texture");\n\t\tthis.properties = {\n\t\t\tintensity: 1,\n\t\t\titerations: 1,\n\t\t\tpreserve_aspect: false,\n\t\t\tscale: [1, 1],\n\t\t\tprecision: LGraphTexture.DEFAULT\n\t\t};\n\t}\n\n\tLGraphTextureBlur.title = "Blur";\n\tLGraphTextureBlur.desc = "Blur a texture";\n\n\tLGraphTextureBlur.widgets_info = {\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureBlur.max_iterations = 20;\n\n\tLGraphTextureBlur.prototype.onExecute = function() {\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tvar temp = this._final_texture;\n\n\t\tif (\n\t\t\t!temp ||\n\t\t\ttemp.width != tex.width ||\n\t\t\ttemp.height != tex.height ||\n\t\t\ttemp.type != tex.type\n\t\t) {\n\t\t\t//we need two textures to do the blurring\n\t\t\t//this._temp_texture = new GL.Texture( tex.width, tex.height, { type: tex.type, format: gl.RGBA, filter: gl.LINEAR });\n\t\t\ttemp = this._final_texture = new GL.Texture(\n\t\t\t\ttex.width,\n\t\t\t\ttex.height,\n\t\t\t\t{ type: tex.type, format: gl.RGBA, filter: gl.LINEAR }\n\t\t\t);\n\t\t}\n\n\t\t//iterations\n\t\tvar iterations = this.properties.iterations;\n\t\tif (this.isInputConnected(1)) {\n\t\t\titerations = this.getInputData(1);\n\t\t\tthis.properties.iterations = iterations;\n\t\t}\n\t\titerations = Math.min(\n\t\t\tMath.floor(iterations),\n\t\t\tLGraphTextureBlur.max_iterations\n\t\t);\n\t\tif (iterations == 0) {\n\t\t\t//skip blurring\n\t\t\tthis.setOutputData(0, tex);\n\t\t\treturn;\n\t\t}\n\n\t\tvar intensity = this.properties.intensity;\n\t\tif (this.isInputConnected(2)) {\n\t\t\tintensity = this.getInputData(2);\n\t\t\tthis.properties.intensity = intensity;\n\t\t}\n\n\t\t//blur sometimes needs an aspect correction\n\t\tvar aspect = LiteGraph.camera_aspect;\n\t\tif (!aspect && window.gl !== undefined) {\n\t\t\taspect = gl.canvas.height / gl.canvas.width;\n\t\t}\n\t\tif (!aspect) {\n\t\t\taspect = 1;\n\t\t}\n\t\taspect = this.properties.preserve_aspect ? aspect : 1;\n\n\t\tvar scale = this.properties.scale || [1, 1];\n\t\ttex.applyBlur(aspect * scale[0], scale[1], intensity, temp);\n\t\tfor (var i = 1; i < iterations; ++i) {\n\t\t\ttemp.applyBlur(\n\t\t\t\taspect * scale[0] * (i + 1),\n\t\t\t\tscale[1] * (i + 1),\n\t\t\t\tintensity\n\t\t\t);\n\t\t}\n\n\t\tthis.setOutputData(0, temp);\n\t};\n\n\t/*\nLGraphTextureBlur.pixel_shader = "precision highp float;\\n\\\n\t\tprecision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform vec2 u_offset;\\n\\\n\t\tuniform float u_intensity;\\n\\\n\t\tvoid main() {\\n\\\n\t\t   vec4 sum = vec4(0.0);\\n\\\n\t\t   vec4 center = texture2D(u_texture, v_coord);\\n\\\n\t\t   sum += texture2D(u_texture, v_coord + u_offset * -4.0) * 0.05/0.98;\\n\\\n\t\t   sum += texture2D(u_texture, v_coord + u_offset * -3.0) * 0.09/0.98;\\n\\\n\t\t   sum += texture2D(u_texture, v_coord + u_offset * -2.0) * 0.12/0.98;\\n\\\n\t\t   sum += texture2D(u_texture, v_coord + u_offset * -1.0) * 0.15/0.98;\\n\\\n\t\t   sum += center * 0.16/0.98;\\n\\\n\t\t   sum += texture2D(u_texture, v_coord + u_offset * 4.0) * 0.05/0.98;\\n\\\n\t\t   sum += texture2D(u_texture, v_coord + u_offset * 3.0) * 0.09/0.98;\\n\\\n\t\t   sum += texture2D(u_texture, v_coord + u_offset * 2.0) * 0.12/0.98;\\n\\\n\t\t   sum += texture2D(u_texture, v_coord + u_offset * 1.0) * 0.15/0.98;\\n\\\n\t\t   gl_FragColor = u_intensity * sum;\\n\\\n\t\t}\\n\\\n\t\t";\n*/\n\n\tLiteGraph.registerNodeType("texture/blur", LGraphTextureBlur);\n\n\t//Independent glow FX\n\t//based on https://catlikecoding.com/unity/tutorials/advanced-rendering/bloom/\n\tfunction FXGlow()\n\t{\n\t\tthis.intensity = 0.5;\n\t\tthis.persistence = 0.6;\n\t\tthis.iterations = 8;\n\t\tthis.threshold = 0.8;\n\t\tthis.scale = 1;\n\n\t\tthis.dirt_texture = null;\n\t\tthis.dirt_factor = 0.5;\n\n\t\tthis._textures = [];\n\t\tthis._uniforms = {\n\t\t\tu_intensity: 1,\n\t\t\tu_texture: 0,\n\t\t\tu_glow_texture: 1,\n\t\t\tu_threshold: 0,\n\t\t\tu_texel_size: vec2.create()\n\t\t};\n\t}\n\n\tFXGlow.prototype.applyFX = function( tex, output_texture, glow_texture, average_texture ) {\n\n\t\tvar width = tex.width;\n\t\tvar height = tex.height;\n\n\t\tvar texture_info = {\n\t\t\tformat: tex.format,\n\t\t\ttype: tex.type,\n\t\t\tminFilter: GL.LINEAR,\n\t\t\tmagFilter: GL.LINEAR,\n\t\t\twrap: gl.CLAMP_TO_EDGE\n\t\t};\n\n\t\tvar uniforms = this._uniforms;\n\t\tvar textures = this._textures;\n\n\t\t//cut\n\t\tvar shader = FXGlow._cut_shader;\n\t\tif (!shader) {\n\t\t\tshader = FXGlow._cut_shader = new GL.Shader(\n\t\t\t\tGL.Shader.SCREEN_VERTEX_SHADER,\n\t\t\t\tFXGlow.cut_pixel_shader\n\t\t\t);\n\t\t}\n\n\t\tgl.disable(gl.DEPTH_TEST);\n\t\tgl.disable(gl.BLEND);\n\n\t\tuniforms.u_threshold = this.threshold;\n\t\tvar currentDestination = (textures[0] = GL.Texture.getTemporary(\n\t\t\twidth,\n\t\t\theight,\n\t\t\ttexture_info\n\t\t));\n\t\ttex.blit( currentDestination, shader.uniforms(uniforms) );\n\t\tvar currentSource = currentDestination;\n\n\t\tvar iterations = this.iterations;\n\t\titerations = clamp(iterations, 1, 16) | 0;\n\t\tvar texel_size = uniforms.u_texel_size;\n\t\tvar intensity = this.intensity;\n\n\t\tuniforms.u_intensity = 1;\n\t\tuniforms.u_delta = this.scale; //1\n\n\t\t//downscale/upscale shader\n\t\tvar shader = FXGlow._shader;\n\t\tif (!shader) {\n\t\t\tshader = FXGlow._shader = new GL.Shader(\n\t\t\t\tGL.Shader.SCREEN_VERTEX_SHADER,\n\t\t\t\tFXGlow.scale_pixel_shader\n\t\t\t);\n\t\t}\n\n\t\tvar i = 1;\n\t\t//downscale\n\t\tfor (; i < iterations; i++) {\n\t\t\twidth = width >> 1;\n\t\t\tif ((height | 0) > 1) {\n\t\t\t\theight = height >> 1;\n\t\t\t}\n\t\t\tif (width < 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrentDestination = textures[i] = GL.Texture.getTemporary(\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\ttexture_info\n\t\t\t);\n\t\t\ttexel_size[0] = 1 / currentSource.width;\n\t\t\ttexel_size[1] = 1 / currentSource.height;\n\t\t\tcurrentSource.blit(\n\t\t\t\tcurrentDestination,\n\t\t\t\tshader.uniforms(uniforms)\n\t\t\t);\n\t\t\tcurrentSource = currentDestination;\n\t\t}\n\n\t\t//average\n\t\tif (average_texture) {\n\t\t\ttexel_size[0] = 1 / currentSource.width;\n\t\t\ttexel_size[1] = 1 / currentSource.height;\n\t\t\tuniforms.u_intensity = intensity;\n\t\t\tuniforms.u_delta = 1;\n\t\t\tcurrentSource.blit(average_texture, shader.uniforms(uniforms));\n\t\t}\n\n\t\t//upscale and blend\n\t\tgl.enable(gl.BLEND);\n\t\tgl.blendFunc(gl.ONE, gl.ONE);\n\t\tuniforms.u_intensity = this.persistence;\n\t\tuniforms.u_delta = 0.5;\n\n\t\t// i-=2 => -1 to point to last element in array, -1 to go to texture above\n\t\tfor ( i -= 2; i >= 0; i-- ) \n\t\t{\n\t\t\tcurrentDestination = textures[i];\n\t\t\ttextures[i] = null;\n\t\t\ttexel_size[0] = 1 / currentSource.width;\n\t\t\ttexel_size[1] = 1 / currentSource.height;\n\t\t\tcurrentSource.blit(\n\t\t\t\tcurrentDestination,\n\t\t\t\tshader.uniforms(uniforms)\n\t\t\t);\n\t\t\tGL.Texture.releaseTemporary(currentSource);\n\t\t\tcurrentSource = currentDestination;\n\t\t}\n\t\tgl.disable(gl.BLEND);\n\n\t\t//glow\n\t\tif (glow_texture) {\n\t\t\tcurrentSource.blit(glow_texture);\n\t\t}\n\n\t\t//final composition\n\t\tif ( output_texture ) {\n\t\t\tvar final_texture = output_texture;\n\t\t\tvar dirt_texture = this.dirt_texture;\n\t\t\tvar dirt_factor = this.dirt_factor;\n\t\t\tuniforms.u_intensity = intensity;\n\n\t\t\tshader = dirt_texture\n\t\t\t\t? FXGlow._dirt_final_shader\n\t\t\t\t: FXGlow._final_shader;\n\t\t\tif (!shader) {\n\t\t\t\tif (dirt_texture) {\n\t\t\t\t\tshader = FXGlow._dirt_final_shader = new GL.Shader(\n\t\t\t\t\t\tGL.Shader.SCREEN_VERTEX_SHADER,\n\t\t\t\t\t\tFXGlow.final_pixel_shader,\n\t\t\t\t\t\t{ USE_DIRT: "" }\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tshader = FXGlow._final_shader = new GL.Shader(\n\t\t\t\t\t\tGL.Shader.SCREEN_VERTEX_SHADER,\n\t\t\t\t\t\tFXGlow.final_pixel_shader\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal_texture.drawTo(function() {\n\t\t\t\ttex.bind(0);\n\t\t\t\tcurrentSource.bind(1);\n\t\t\t\tif (dirt_texture) {\n\t\t\t\t\tshader.setUniform("u_dirt_factor", dirt_factor);\n\t\t\t\t\tshader.setUniform(\n\t\t\t\t\t\t"u_dirt_texture",\n\t\t\t\t\t\tdirt_texture.bind(2)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tshader.toViewport(uniforms);\n\t\t\t});\n\t\t}\n\n\t\tGL.Texture.releaseTemporary(currentSource);\n\t};\n\n\tFXGlow.cut_pixel_shader =\n\t\t"precision highp float;\\n\\\n\tvarying vec2 v_coord;\\n\\\n\tuniform sampler2D u_texture;\\n\\\n\tuniform float u_threshold;\\n\\\n\tvoid main() {\\n\\\n\t\tgl_FragColor = max( texture2D( u_texture, v_coord ) - vec4( u_threshold ), vec4(0.0) );\\n\\\n\t}";\n\n\tFXGlow.scale_pixel_shader =\n\t\t"precision highp float;\\n\\\n\tvarying vec2 v_coord;\\n\\\n\tuniform sampler2D u_texture;\\n\\\n\tuniform vec2 u_texel_size;\\n\\\n\tuniform float u_delta;\\n\\\n\tuniform float u_intensity;\\n\\\n\t\\n\\\n\tvec4 sampleBox(vec2 uv) {\\n\\\n\t\tvec4 o = u_texel_size.xyxy * vec2(-u_delta, u_delta).xxyy;\\n\\\n\t\tvec4 s = texture2D( u_texture, uv + o.xy ) + texture2D( u_texture, uv + o.zy) + texture2D( u_texture, uv + o.xw) + texture2D( u_texture, uv + o.zw);\\n\\\n\t\treturn s * 0.25;\\n\\\n\t}\\n\\\n\tvoid main() {\\n\\\n\t\tgl_FragColor = u_intensity * sampleBox( v_coord );\\n\\\n\t}";\n\n\tFXGlow.final_pixel_shader =\n\t\t"precision highp float;\\n\\\n\tvarying vec2 v_coord;\\n\\\n\tuniform sampler2D u_texture;\\n\\\n\tuniform sampler2D u_glow_texture;\\n\\\n\t#ifdef USE_DIRT\\n\\\n\t\tuniform sampler2D u_dirt_texture;\\n\\\n\t#endif\\n\\\n\tuniform vec2 u_texel_size;\\n\\\n\tuniform float u_delta;\\n\\\n\tuniform float u_intensity;\\n\\\n\tuniform float u_dirt_factor;\\n\\\n\t\\n\\\n\tvec4 sampleBox(vec2 uv) {\\n\\\n\t\tvec4 o = u_texel_size.xyxy * vec2(-u_delta, u_delta).xxyy;\\n\\\n\t\tvec4 s = texture2D( u_glow_texture, uv + o.xy ) + texture2D( u_glow_texture, uv + o.zy) + texture2D( u_glow_texture, uv + o.xw) + texture2D( u_glow_texture, uv + o.zw);\\n\\\n\t\treturn s * 0.25;\\n\\\n\t}\\n\\\n\tvoid main() {\\n\\\n\t\tvec4 glow = sampleBox( v_coord );\\n\\\n\t\t#ifdef USE_DIRT\\n\\\n\t\t\tglow = mix( glow, glow * texture2D( u_dirt_texture, v_coord ), u_dirt_factor );\\n\\\n\t\t#endif\\n\\\n\t\tgl_FragColor = texture2D( u_texture, v_coord ) + u_intensity * glow;\\n\\\n\t}";\n\n\n\t// Texture Glow *****************************************\n\tfunction LGraphTextureGlow() {\n\t\tthis.addInput("in", "Texture");\n\t\tthis.addInput("dirt", "Texture");\n\t\tthis.addOutput("out", "Texture");\n\t\tthis.addOutput("glow", "Texture");\n\t\tthis.properties = {\n\t\t\tenabled: true,\n\t\t\tintensity: 1,\n\t\t\tpersistence: 0.99,\n\t\t\titerations: 16,\n\t\t\tthreshold: 0,\n\t\t\tscale: 1,\n\t\t\tdirt_factor: 0.5,\n\t\t\tprecision: LGraphTexture.DEFAULT\n\t\t};\n\n\t\tthis.fx = new FXGlow();\n\t}\n\n\tLGraphTextureGlow.title = "Glow";\n\tLGraphTextureGlow.desc = "Filters a texture giving it a glow effect";\n\n\tLGraphTextureGlow.widgets_info = {\n\t\titerations: {\n\t\t\ttype: "number",\n\t\t\tmin: 0,\n\t\t\tmax: 16,\n\t\t\tstep: 1,\n\t\t\tprecision: 0\n\t\t},\n\t\tthreshold: {\n\t\t\ttype: "number",\n\t\t\tmin: 0,\n\t\t\tmax: 10,\n\t\t\tstep: 0.01,\n\t\t\tprecision: 2\n\t\t},\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureGlow.prototype.onGetInputs = function() {\n\t\treturn [\n\t\t\t["enabled", "boolean"],\n\t\t\t["threshold", "number"],\n\t\t\t["intensity", "number"],\n\t\t\t["persistence", "number"],\n\t\t\t["iterations", "number"],\n\t\t\t["dirt_factor", "number"]\n\t\t];\n\t};\n\n\tLGraphTextureGlow.prototype.onGetOutputs = function() {\n\t\treturn [["average", "Texture"]];\n\t};\n\n\tLGraphTextureGlow.prototype.onExecute = function() {\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.isAnyOutputConnected()) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tif (\n\t\t\tthis.properties.precision === LGraphTexture.PASS_THROUGH ||\n\t\t\tthis.getInputOrProperty("enabled") === false\n\t\t) {\n\t\t\tthis.setOutputData(0, tex);\n\t\t\treturn;\n\t\t}\n\n\t\tvar width = tex.width;\n\t\tvar height = tex.height;\n\n\t\tvar fx = this.fx;\n\t\tfx.threshold = this.getInputOrProperty("threshold");\n\t\tfx.iterations = this.getInputOrProperty("iterations");\n\t\tfx.intensity = this.getInputOrProperty("intensity");\n\t\tfx.persistence = this.getInputOrProperty("persistence");\n\t\tfx.dirt_texture = this.getInputData(1);\n\t\tfx.dirt_factor = this.getInputOrProperty("dirt_factor");\n\t\tfx.scale = this.properties.scale;\n\n\t\tvar type = LGraphTexture.getTextureType( this.properties.precision, tex );\n\n\t\tvar average_texture = null;\n\t\tif (this.isOutputConnected(2)) {\n\t\t\taverage_texture = this._average_texture;\n\t\t\tif (\n\t\t\t\t!average_texture ||\n\t\t\t\taverage_texture.type != tex.type ||\n\t\t\t\taverage_texture.format != tex.format\n\t\t\t) {\n\t\t\t\taverage_texture = this._average_texture = new GL.Texture(\n\t\t\t\t\t1,\n\t\t\t\t\t1,\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: tex.type,\n\t\t\t\t\t\tformat: tex.format,\n\t\t\t\t\t\tfilter: gl.LINEAR\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tvar glow_texture = null;\n\t\tif (this.isOutputConnected(1)) {\n\t\t\tglow_texture = this._glow_texture;\n\t\t\tif (\n\t\t\t\t!glow_texture ||\n\t\t\t\tglow_texture.width != tex.width ||\n\t\t\t\tglow_texture.height != tex.height ||\n\t\t\t\tglow_texture.type != type ||\n\t\t\t\tglow_texture.format != tex.format\n\t\t\t) {\n\t\t\t\tglow_texture = this._glow_texture = new GL.Texture(\n\t\t\t\t\ttex.width,\n\t\t\t\t\ttex.height,\n\t\t\t\t\t{ type: type, format: tex.format, filter: gl.LINEAR }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tvar final_texture = null;\n\t\tif (this.isOutputConnected(0)) {\n\t\t\tfinal_texture = this._final_texture;\n\t\t\tif (\n\t\t\t\t!final_texture ||\n\t\t\t\tfinal_texture.width != tex.width ||\n\t\t\t\tfinal_texture.height != tex.height ||\n\t\t\t\tfinal_texture.type != type ||\n\t\t\t\tfinal_texture.format != tex.format\n\t\t\t) {\n\t\t\t\tfinal_texture = this._final_texture = new GL.Texture(\n\t\t\t\t\ttex.width,\n\t\t\t\t\ttex.height,\n\t\t\t\t\t{ type: type, format: tex.format, filter: gl.LINEAR }\n\t\t\t\t);\n\t\t\t}\n\n\t\t}\n\n\t\t//apply FX\n\t\tfx.applyFX(tex, final_texture, glow_texture, average_texture );\n\n\t\tif (this.isOutputConnected(0))\n\t\t\tthis.setOutputData(0, final_texture);\n\n\t\tif (this.isOutputConnected(1))\n\t\t\tthis.setOutputData(1, average_texture);\n\n\t\tif (this.isOutputConnected(2))\n\t\t\tthis.setOutputData(2, glow_texture);\n\t};\n\n\tLiteGraph.registerNodeType("texture/glow", LGraphTextureGlow);\n\n\t// Texture Filter *****************************************\n\tfunction LGraphTextureKuwaharaFilter() {\n\t\tthis.addInput("Texture", "Texture");\n\t\tthis.addOutput("Filtered", "Texture");\n\t\tthis.properties = { intensity: 1, radius: 5 };\n\t}\n\n\tLGraphTextureKuwaharaFilter.title = "Kuwahara Filter";\n\tLGraphTextureKuwaharaFilter.desc =\n\t\t"Filters a texture giving an artistic oil canvas painting";\n\n\tLGraphTextureKuwaharaFilter.max_radius = 10;\n\tLGraphTextureKuwaharaFilter._shaders = [];\n\n\tLGraphTextureKuwaharaFilter.prototype.onExecute = function() {\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tvar temp = this._temp_texture;\n\n\t\tif (\n\t\t\t!temp ||\n\t\t\ttemp.width != tex.width ||\n\t\t\ttemp.height != tex.height ||\n\t\t\ttemp.type != tex.type\n\t\t) {\n\t\t\tthis._temp_texture = new GL.Texture(tex.width, tex.height, {\n\t\t\t\ttype: tex.type,\n\t\t\t\tformat: gl.RGBA,\n\t\t\t\tfilter: gl.LINEAR\n\t\t\t});\n\t\t}\n\n\t\t//iterations\n\t\tvar radius = this.properties.radius;\n\t\tradius = Math.min(\n\t\t\tMath.floor(radius),\n\t\t\tLGraphTextureKuwaharaFilter.max_radius\n\t\t);\n\t\tif (radius == 0) {\n\t\t\t//skip blurring\n\t\t\tthis.setOutputData(0, tex);\n\t\t\treturn;\n\t\t}\n\n\t\tvar intensity = this.properties.intensity;\n\n\t\t//blur sometimes needs an aspect correction\n\t\tvar aspect = LiteGraph.camera_aspect;\n\t\tif (!aspect && window.gl !== undefined) {\n\t\t\taspect = gl.canvas.height / gl.canvas.width;\n\t\t}\n\t\tif (!aspect) {\n\t\t\taspect = 1;\n\t\t}\n\t\taspect = this.properties.preserve_aspect ? aspect : 1;\n\n\t\tif (!LGraphTextureKuwaharaFilter._shaders[radius]) {\n\t\t\tLGraphTextureKuwaharaFilter._shaders[radius] = new GL.Shader(\n\t\t\t\tShader.SCREEN_VERTEX_SHADER,\n\t\t\t\tLGraphTextureKuwaharaFilter.pixel_shader,\n\t\t\t\t{ RADIUS: radius.toFixed(0) }\n\t\t\t);\n\t\t}\n\n\t\tvar shader = LGraphTextureKuwaharaFilter._shaders[radius];\n\t\tvar mesh = GL.Mesh.getScreenQuad();\n\t\ttex.bind(0);\n\n\t\tthis._temp_texture.drawTo(function() {\n\t\t\tshader\n\t\t\t\t.uniforms({\n\t\t\t\t\tu_texture: 0,\n\t\t\t\t\tu_intensity: intensity,\n\t\t\t\t\tu_resolution: [tex.width, tex.height],\n\t\t\t\t\tu_iResolution: [1 / tex.width, 1 / tex.height]\n\t\t\t\t})\n\t\t\t\t.draw(mesh);\n\t\t});\n\n\t\tthis.setOutputData(0, this._temp_texture);\n\t};\n\n\t//from https://www.shadertoy.com/view/MsXSz4\n\tLGraphTextureKuwaharaFilter.pixel_shader =\n\t\t"\\n\\\nprecision highp float;\\n\\\nvarying vec2 v_coord;\\n\\\nuniform sampler2D u_texture;\\n\\\nuniform float u_intensity;\\n\\\nuniform vec2 u_resolution;\\n\\\nuniform vec2 u_iResolution;\\n\\\n#ifndef RADIUS\\n\\\n\t#define RADIUS 7\\n\\\n#endif\\n\\\nvoid main() {\\n\\\n\\n\\\n\tconst int radius = RADIUS;\\n\\\n\tvec2 fragCoord = v_coord;\\n\\\n\tvec2 src_size = u_iResolution;\\n\\\n\tvec2 uv = v_coord;\\n\\\n\tfloat n = float((radius + 1) * (radius + 1));\\n\\\n\tint i;\\n\\\n\tint j;\\n\\\n\tvec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\\n\\\n\tvec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\\n\\\n\tvec3 c;\\n\\\n\t\\n\\\n\tfor (int j = -radius; j <= 0; ++j)  {\\n\\\n\t\tfor (int i = -radius; i <= 0; ++i)  {\\n\\\n\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\\n\\\n\t\t\tm0 += c;\\n\\\n\t\t\ts0 += c * c;\\n\\\n\t\t}\\n\\\n\t}\\n\\\n\t\\n\\\n\tfor (int j = -radius; j <= 0; ++j)  {\\n\\\n\t\tfor (int i = 0; i <= radius; ++i)  {\\n\\\n\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\\n\\\n\t\t\tm1 += c;\\n\\\n\t\t\ts1 += c * c;\\n\\\n\t\t}\\n\\\n\t}\\n\\\n\t\\n\\\n\tfor (int j = 0; j <= radius; ++j)  {\\n\\\n\t\tfor (int i = 0; i <= radius; ++i)  {\\n\\\n\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\\n\\\n\t\t\tm2 += c;\\n\\\n\t\t\ts2 += c * c;\\n\\\n\t\t}\\n\\\n\t}\\n\\\n\t\\n\\\n\tfor (int j = 0; j <= radius; ++j)  {\\n\\\n\t\tfor (int i = -radius; i <= 0; ++i)  {\\n\\\n\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\\n\\\n\t\t\tm3 += c;\\n\\\n\t\t\ts3 += c * c;\\n\\\n\t\t}\\n\\\n\t}\\n\\\n\t\\n\\\n\tfloat min_sigma2 = 1e+2;\\n\\\n\tm0 /= n;\\n\\\n\ts0 = abs(s0 / n - m0 * m0);\\n\\\n\t\\n\\\n\tfloat sigma2 = s0.r + s0.g + s0.b;\\n\\\n\tif (sigma2 < min_sigma2) {\\n\\\n\t\tmin_sigma2 = sigma2;\\n\\\n\t\tgl_FragColor = vec4(m0, 1.0);\\n\\\n\t}\\n\\\n\t\\n\\\n\tm1 /= n;\\n\\\n\ts1 = abs(s1 / n - m1 * m1);\\n\\\n\t\\n\\\n\tsigma2 = s1.r + s1.g + s1.b;\\n\\\n\tif (sigma2 < min_sigma2) {\\n\\\n\t\tmin_sigma2 = sigma2;\\n\\\n\t\tgl_FragColor = vec4(m1, 1.0);\\n\\\n\t}\\n\\\n\t\\n\\\n\tm2 /= n;\\n\\\n\ts2 = abs(s2 / n - m2 * m2);\\n\\\n\t\\n\\\n\tsigma2 = s2.r + s2.g + s2.b;\\n\\\n\tif (sigma2 < min_sigma2) {\\n\\\n\t\tmin_sigma2 = sigma2;\\n\\\n\t\tgl_FragColor = vec4(m2, 1.0);\\n\\\n\t}\\n\\\n\t\\n\\\n\tm3 /= n;\\n\\\n\ts3 = abs(s3 / n - m3 * m3);\\n\\\n\t\\n\\\n\tsigma2 = s3.r + s3.g + s3.b;\\n\\\n\tif (sigma2 < min_sigma2) {\\n\\\n\t\tmin_sigma2 = sigma2;\\n\\\n\t\tgl_FragColor = vec4(m3, 1.0);\\n\\\n\t}\\n\\\n}\\n\\\n";\n\n\tLiteGraph.registerNodeType(\n\t\t"texture/kuwahara",\n\t\tLGraphTextureKuwaharaFilter\n\t);\n\n\t// Texture  *****************************************\n\tfunction LGraphTextureXDoGFilter() {\n\t\tthis.addInput("Texture", "Texture");\n\t\tthis.addOutput("Filtered", "Texture");\n\t\tthis.properties = {\n\t\t\tsigma: 1.4,\n\t\t\tk: 1.6,\n\t\t\tp: 21.7,\n\t\t\tepsilon: 79,\n\t\t\tphi: 0.017\n\t\t};\n\t}\n\n\tLGraphTextureXDoGFilter.title = "XDoG Filter";\n\tLGraphTextureXDoGFilter.desc =\n\t\t"Filters a texture giving an artistic ink style";\n\n\tLGraphTextureXDoGFilter.max_radius = 10;\n\tLGraphTextureXDoGFilter._shaders = [];\n\n\tLGraphTextureXDoGFilter.prototype.onExecute = function() {\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tvar temp = this._temp_texture;\n\t\tif (\n\t\t\t!temp ||\n\t\t\ttemp.width != tex.width ||\n\t\t\ttemp.height != tex.height ||\n\t\t\ttemp.type != tex.type\n\t\t) {\n\t\t\tthis._temp_texture = new GL.Texture(tex.width, tex.height, {\n\t\t\t\ttype: tex.type,\n\t\t\t\tformat: gl.RGBA,\n\t\t\t\tfilter: gl.LINEAR\n\t\t\t});\n\t\t}\n\n\t\tif (!LGraphTextureXDoGFilter._xdog_shader) {\n\t\t\tLGraphTextureXDoGFilter._xdog_shader = new GL.Shader(\n\t\t\t\tShader.SCREEN_VERTEX_SHADER,\n\t\t\t\tLGraphTextureXDoGFilter.xdog_pixel_shader\n\t\t\t);\n\t\t}\n\t\tvar shader = LGraphTextureXDoGFilter._xdog_shader;\n\t\tvar mesh = GL.Mesh.getScreenQuad();\n\n\t\tvar sigma = this.properties.sigma;\n\t\tvar k = this.properties.k;\n\t\tvar p = this.properties.p;\n\t\tvar epsilon = this.properties.epsilon;\n\t\tvar phi = this.properties.phi;\n\t\ttex.bind(0);\n\t\tthis._temp_texture.drawTo(function() {\n\t\t\tshader\n\t\t\t\t.uniforms({\n\t\t\t\t\tsrc: 0,\n\t\t\t\t\tsigma: sigma,\n\t\t\t\t\tk: k,\n\t\t\t\t\tp: p,\n\t\t\t\t\tepsilon: epsilon,\n\t\t\t\t\tphi: phi,\n\t\t\t\t\tcvsWidth: tex.width,\n\t\t\t\t\tcvsHeight: tex.height\n\t\t\t\t})\n\t\t\t\t.draw(mesh);\n\t\t});\n\n\t\tthis.setOutputData(0, this._temp_texture);\n\t};\n\n\t//from https://github.com/RaymondMcGuire/GPU-Based-Image-Processing-Tools/blob/master/lib_webgl/scripts/main.js\n\tLGraphTextureXDoGFilter.xdog_pixel_shader =\n\t\t"\\n\\\nprecision highp float;\\n\\\nuniform sampler2D src;\\n\\n\\\nuniform float cvsHeight;\\n\\\nuniform float cvsWidth;\\n\\n\\\nuniform float sigma;\\n\\\nuniform float k;\\n\\\nuniform float p;\\n\\\nuniform float epsilon;\\n\\\nuniform float phi;\\n\\\nvarying vec2 v_coord;\\n\\n\\\nfloat cosh(float val)\\n\\\n{\\n\\\n\tfloat tmp = exp(val);\\n\\\n\tfloat cosH = (tmp + 1.0 / tmp) / 2.0;\\n\\\n\treturn cosH;\\n\\\n}\\n\\n\\\nfloat tanh(float val)\\n\\\n{\\n\\\n\tfloat tmp = exp(val);\\n\\\n\tfloat tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\\n\\\n\treturn tanH;\\n\\\n}\\n\\n\\\nfloat sinh(float val)\\n\\\n{\\n\\\n\tfloat tmp = exp(val);\\n\\\n\tfloat sinH = (tmp - 1.0 / tmp) / 2.0;\\n\\\n\treturn sinH;\\n\\\n}\\n\\n\\\nvoid main(void){\\n\\\n\tvec3 destColor = vec3(0.0);\\n\\\n\tfloat tFrag = 1.0 / cvsHeight;\\n\\\n\tfloat sFrag = 1.0 / cvsWidth;\\n\\\n\tvec2 Frag = vec2(sFrag,tFrag);\\n\\\n\tvec2 uv = gl_FragCoord.st;\\n\\\n\tfloat twoSigmaESquared = 2.0 * sigma * sigma;\\n\\\n\tfloat twoSigmaRSquared = twoSigmaESquared * k * k;\\n\\\n\tint halfWidth = int(ceil( 1.0 * sigma * k ));\\n\\n\\\n\tconst int MAX_NUM_ITERATION = 99999;\\n\\\n\tvec2 sum = vec2(0.0);\\n\\\n\tvec2 norm = vec2(0.0);\\n\\n\\\n\tfor(int cnt=0;cnt<MAX_NUM_ITERATION;cnt++){\\n\\\n\t\tif(cnt > (2*halfWidth+1)*(2*halfWidth+1)){break;}\\n\\\n\t\tint i = int(cnt / (2*halfWidth+1)) - halfWidth;\\n\\\n\t\tint j = cnt - halfWidth - int(cnt / (2*halfWidth+1)) * (2*halfWidth+1);\\n\\n\\\n\t\tfloat d = length(vec2(i,j));\\n\\\n\t\tvec2 kernel = vec2( exp( -d * d / twoSigmaESquared ), \\n\\\n\t\t\t\t\t\t\texp( -d * d / twoSigmaRSquared ));\\n\\n\\\n\t\tvec2 L = texture2D(src, (uv + vec2(i,j)) * Frag).xx;\\n\\n\\\n\t\tnorm += kernel;\\n\\\n\t\tsum += kernel * L;\\n\\\n\t}\\n\\n\\\n\tsum /= norm;\\n\\n\\\n\tfloat H = 100.0 * ((1.0 + p) * sum.x - p * sum.y);\\n\\\n\tfloat edge = ( H > epsilon )? 1.0 : 1.0 + tanh( phi * (H - epsilon));\\n\\\n\tdestColor = vec3(edge);\\n\\\n\tgl_FragColor = vec4(destColor, 1.0);\\n\\\n}";\n\n\tLiteGraph.registerNodeType("texture/xDoG", LGraphTextureXDoGFilter);\n\n\t// Texture Webcam *****************************************\n\tfunction LGraphTextureWebcam() {\n\t\tthis.addOutput("Webcam", "Texture");\n\t\tthis.properties = { texture_name: "", facingMode: "user" };\n\t\tthis.boxcolor = "black";\n\t\tthis.version = 0;\n\t}\n\n\tLGraphTextureWebcam.title = "Webcam";\n\tLGraphTextureWebcam.desc = "Webcam texture";\n\n\tLGraphTextureWebcam.is_webcam_open = false;\n\n\tLGraphTextureWebcam.prototype.openStream = function() {\n\t\tif (!navigator.getUserMedia) {\n\t\t\t//console.log(\'getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags\');\n\t\t\treturn;\n\t\t}\n\n\t\tthis._waiting_confirmation = true;\n\n\t\t// Not showing vendor prefixes.\n\t\tvar constraints = {\n\t\t\taudio: false,\n\t\t\tvideo: { facingMode: this.properties.facingMode }\n\t\t};\n\t\tnavigator.mediaDevices\n\t\t\t.getUserMedia(constraints)\n\t\t\t.then(this.streamReady.bind(this))\n\t\t\t.catch(onFailSoHard);\n\n\t\tvar that = this;\n\t\tfunction onFailSoHard(e) {\n\t\t\tLGraphTextureWebcam.is_webcam_open = false;\n\t\t\tconsole.log("Webcam rejected", e);\n\t\t\tthat._webcam_stream = false;\n\t\t\tthat.boxcolor = "red";\n\t\t\tthat.trigger("stream_error");\n\t\t}\n\t};\n\n\tLGraphTextureWebcam.prototype.closeStream = function() {\n\t\tif (this._webcam_stream) {\n\t\t\tvar tracks = this._webcam_stream.getTracks();\n\t\t\tif (tracks.length) {\n\t\t\t\tfor (var i = 0; i < tracks.length; ++i) {\n\t\t\t\t\ttracks[i].stop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tLGraphTextureWebcam.is_webcam_open = false;\n\t\t\tthis._webcam_stream = null;\n\t\t\tthis._video = null;\n\t\t\tthis.boxcolor = "black";\n\t\t\tthis.trigger("stream_closed");\n\t\t}\n\t};\n\n\tLGraphTextureWebcam.prototype.streamReady = function(localMediaStream) {\n\t\tthis._webcam_stream = localMediaStream;\n\t\t//this._waiting_confirmation = false;\n\t\tthis.boxcolor = "green";\n\t\tvar video = this._video;\n\t\tif (!video) {\n\t\t\tvideo = document.createElement("video");\n\t\t\tvideo.autoplay = true;\n\t\t\tvideo.srcObject = localMediaStream;\n\t\t\tthis._video = video;\n\t\t\t//document.body.appendChild( video ); //debug\n\t\t\t//when video info is loaded (size and so)\n\t\t\tvideo.onloadedmetadata = function(e) {\n\t\t\t\t// Ready to go. Do some stuff.\n\t\t\t\tLGraphTextureWebcam.is_webcam_open = true;\n\t\t\t\tconsole.log(e);\n\t\t\t};\n\t\t}\n\t\tthis.trigger("stream_ready", video);\n\t};\n\n\tLGraphTextureWebcam.prototype.onPropertyChanged = function(\n\t\tname,\n\t\tvalue\n\t) {\n\t\tif (name == "facingMode") {\n\t\t\tthis.properties.facingMode = value;\n\t\t\tthis.closeStream();\n\t\t\tthis.openStream();\n\t\t}\n\t};\n\n\tLGraphTextureWebcam.prototype.onRemoved = function() {\n\t\tif (!this._webcam_stream) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar tracks = this._webcam_stream.getTracks();\n\t\tif (tracks.length) {\n\t\t\tfor (var i = 0; i < tracks.length; ++i) {\n\t\t\t\ttracks[i].stop();\n\t\t\t}\n\t\t}\n\n\t\tthis._webcam_stream = null;\n\t\tthis._video = null;\n\t};\n\n\tLGraphTextureWebcam.prototype.onDrawBackground = function(ctx) {\n\t\tif (this.flags.collapsed || this.size[1] <= 20) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._video) {\n\t\t\treturn;\n\t\t}\n\n\t\t//render to graph canvas\n\t\tctx.save();\n\t\tif (!ctx.webgl) {\n\t\t\t//reverse image\n\t\t\tctx.drawImage(this._video, 0, 0, this.size[0], this.size[1]);\n\t\t} else {\n\t\t\tif (this._video_texture) {\n\t\t\t\tctx.drawImage(\n\t\t\t\t\tthis._video_texture,\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tthis.size[0],\n\t\t\t\t\tthis.size[1]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tctx.restore();\n\t};\n\n\tLGraphTextureWebcam.prototype.onExecute = function() {\n\t\tif (this._webcam_stream == null && !this._waiting_confirmation) {\n\t\t\tthis.openStream();\n\t\t}\n\n\t\tif (!this._video || !this._video.videoWidth) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar width = this._video.videoWidth;\n\t\tvar height = this._video.videoHeight;\n\n\t\tvar temp = this._video_texture;\n\t\tif (!temp || temp.width != width || temp.height != height) {\n\t\t\tthis._video_texture = new GL.Texture(width, height, {\n\t\t\t\tformat: gl.RGB,\n\t\t\t\tfilter: gl.LINEAR\n\t\t\t});\n\t\t}\n\n\t\tthis._video_texture.uploadImage(this._video);\n\t\tthis._video_texture.version = ++this.version;\n\n\t\tif (this.properties.texture_name) {\n\t\t\tvar container = LGraphTexture.getTexturesContainer();\n\t\t\tcontainer[this.properties.texture_name] = this._video_texture;\n\t\t}\n\n\t\tthis.setOutputData(0, this._video_texture);\n\t\tfor (var i = 1; i < this.outputs.length; ++i) {\n\t\t\tif (!this.outputs[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (this.outputs[i].name) {\n\t\t\t\tcase "width":\n\t\t\t\t\tthis.setOutputData(i, this._video.videoWidth);\n\t\t\t\t\tbreak;\n\t\t\t\tcase "height":\n\t\t\t\t\tthis.setOutputData(i, this._video.videoHeight);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\tLGraphTextureWebcam.prototype.onGetOutputs = function() {\n\t\treturn [\n\t\t\t["width", "number"],\n\t\t\t["height", "number"],\n\t\t\t["stream_ready", LiteGraph.EVENT],\n\t\t\t["stream_closed", LiteGraph.EVENT],\n\t\t\t["stream_error", LiteGraph.EVENT]\n\t\t];\n\t};\n\n\tLiteGraph.registerNodeType("texture/webcam", LGraphTextureWebcam);\n\n\t//from https://github.com/spite/Wagner\n\tfunction LGraphLensFX() {\n\t\tthis.addInput("in", "Texture");\n\t\tthis.addInput("f", "number");\n\t\tthis.addOutput("out", "Texture");\n\t\tthis.properties = {\n\t\t\tenabled: true,\n\t\t\tfactor: 1,\n\t\t\tprecision: LGraphTexture.LOW\n\t\t};\n\n\t\tthis._uniforms = { u_texture: 0, u_factor: 1 };\n\t}\n\n\tLGraphLensFX.title = "Lens FX";\n\tLGraphLensFX.desc = "distortion and chromatic aberration";\n\n\tLGraphLensFX.widgets_info = {\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphLensFX.prototype.onGetInputs = function() {\n\t\treturn [["enabled", "boolean"]];\n\t};\n\n\tLGraphLensFX.prototype.onExecute = function() {\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tif (\n\t\t\tthis.properties.precision === LGraphTexture.PASS_THROUGH ||\n\t\t\tthis.getInputOrProperty("enabled") === false\n\t\t) {\n\t\t\tthis.setOutputData(0, tex);\n\t\t\treturn;\n\t\t}\n\n\t\tvar temp = this._temp_texture;\n\t\tif (\n\t\t\t!temp ||\n\t\t\ttemp.width != tex.width ||\n\t\t\ttemp.height != tex.height ||\n\t\t\ttemp.type != tex.type\n\t\t) {\n\t\t\ttemp = this._temp_texture = new GL.Texture(\n\t\t\t\ttex.width,\n\t\t\t\ttex.height,\n\t\t\t\t{ type: tex.type, format: gl.RGBA, filter: gl.LINEAR }\n\t\t\t);\n\t\t}\n\n\t\tvar shader = LGraphLensFX._shader;\n\t\tif (!shader) {\n\t\t\tshader = LGraphLensFX._shader = new GL.Shader(\n\t\t\t\tGL.Shader.SCREEN_VERTEX_SHADER,\n\t\t\t\tLGraphLensFX.pixel_shader\n\t\t\t);\n\t\t}\n\n\t\tvar factor = this.getInputData(1);\n\t\tif (factor == null) {\n\t\t\tfactor = this.properties.factor;\n\t\t}\n\n\t\tvar uniforms = this._uniforms;\n\t\tuniforms.u_factor = factor;\n\n\t\t//apply shader\n\t\tgl.disable(gl.DEPTH_TEST);\n\t\ttemp.drawTo(function() {\n\t\t\ttex.bind(0);\n\t\t\tshader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());\n\t\t});\n\n\t\tthis.setOutputData(0, temp);\n\t};\n\n\tLGraphLensFX.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform float u_factor;\\n\\\n\t\tvec2 barrelDistortion(vec2 coord, float amt) {\\n\\\n\t\t\tvec2 cc = coord - 0.5;\\n\\\n\t\t\tfloat dist = dot(cc, cc);\\n\\\n\t\t\treturn coord + cc * dist * amt;\\n\\\n\t\t}\\n\\\n\t\t\\n\\\n\t\tfloat sat( float t )\\n\\\n\t\t{\\n\\\n\t\t\treturn clamp( t, 0.0, 1.0 );\\n\\\n\t\t}\\n\\\n\t\t\\n\\\n\t\tfloat linterp( float t ) {\\n\\\n\t\t\treturn sat( 1.0 - abs( 2.0*t - 1.0 ) );\\n\\\n\t\t}\\n\\\n\t\t\\n\\\n\t\tfloat remap( float t, float a, float b ) {\\n\\\n\t\t\treturn sat( (t - a) / (b - a) );\\n\\\n\t\t}\\n\\\n\t\t\\n\\\n\t\tvec4 spectrum_offset( float t ) {\\n\\\n\t\t\tvec4 ret;\\n\\\n\t\t\tfloat lo = step(t,0.5);\\n\\\n\t\t\tfloat hi = 1.0-lo;\\n\\\n\t\t\tfloat w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );\\n\\\n\t\t\tret = vec4(lo,1.0,hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);\\n\\\n\t\t\\n\\\n\t\t\treturn pow( ret, vec4(1.0/2.2) );\\n\\\n\t\t}\\n\\\n\t\t\\n\\\n\t\tconst float max_distort = 2.2;\\n\\\n\t\tconst int num_iter = 12;\\n\\\n\t\tconst float reci_num_iter_f = 1.0 / float(num_iter);\\n\\\n\t\t\\n\\\n\t\tvoid main()\\n\\\n\t\t{\t\\n\\\n\t\t\tvec2 uv=v_coord;\\n\\\n\t\t\tvec4 sumcol = vec4(0.0);\\n\\\n\t\t\tvec4 sumw = vec4(0.0);\t\\n\\\n\t\t\tfor ( int i=0; i<num_iter;++i )\\n\\\n\t\t\t{\\n\\\n\t\t\t\tfloat t = float(i) * reci_num_iter_f;\\n\\\n\t\t\t\tvec4 w = spectrum_offset( t );\\n\\\n\t\t\t\tsumw += w;\\n\\\n\t\t\t\tsumcol += w * texture2D( u_texture, barrelDistortion(uv, .6 * max_distort*t * u_factor ) );\\n\\\n\t\t\t}\\n\\\n\t\t\tgl_FragColor = sumcol / sumw;\\n\\\n\t\t}";\n\n\tLiteGraph.registerNodeType("texture/lensfx", LGraphLensFX);\n\n\n\tfunction LGraphTextureFromData() {\n\t\tthis.addInput("in", "");\n\t\tthis.properties = { precision: LGraphTexture.LOW, width: 0, height: 0, channels: 1 };\n\t\tthis.addOutput("out", "Texture");\n\t}\n\n\tLGraphTextureFromData.title = "Data->Tex";\n\tLGraphTextureFromData.desc = "Generates or applies a curve to a texture";\n\tLGraphTextureFromData.widgets_info = {\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureFromData.prototype.onExecute = function() {\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tvar data = this.getInputData(0);\n\t\tif(!data)\n\t\t\treturn;\n\n\t\tvar channels = this.properties.channels;\n\t\tvar w = this.properties.width;\n\t\tvar h = this.properties.height;\n\t\tif(!w || !h)\n\t\t{\n\t\t\tw = Math.floor(data.length / channels);\n\t\t\th = 1;\n\t\t}\n\t\tvar format = gl.RGBA;\n\t\tif( channels == 3 )\n\t\t\tformat = gl.RGB;\n\t\telse if( channels == 1 )\n\t\t\tformat = gl.LUMINANCE;\n\n\t\tvar temp = this._temp_texture;\n\t\tvar type = LGraphTexture.getTextureType( this.properties.precision );\n\t\tif ( !temp || temp.width != w || temp.height != h || temp.type != type ) {\n\t\t\ttemp = this._temp_texture = new GL.Texture( w, h, { type: type, format: format, filter: gl.LINEAR } );\n\t\t}\n\n\t\ttemp.uploadData( data );\n\t\tthis.setOutputData(0, temp);\n\t}\n\n\tLiteGraph.registerNodeType("texture/fromdata", LGraphTextureFromData);\n\n\t//applies a curve (or generates one)\n\tfunction LGraphTextureCurve() {\n\t\tthis.addInput("in", "Texture");\n\t\tthis.addOutput("out", "Texture");\n\t\tthis.properties = { precision: LGraphTexture.LOW, split_channels: false };\n\t\tthis._values = new Uint8Array(256*4);\n\t\tthis._values.fill(255);\n\t\tthis._curve_texture = null;\n\t\tthis._uniforms = { u_texture: 0, u_curve: 1, u_range: 1.0 };\n\t\tthis._must_update = true;\n\t\tthis._points = {\n\t\t\tRGB: [[0,0],[1,1]],\n\t\t\tR: [[0,0],[1,1]],\n\t\t\tG: [[0,0],[1,1]],\n\t\t\tB: [[0,0],[1,1]]\n\t\t};\n\t\tthis.curve_editor = null;\n\t\tthis.addWidget("toggle","Split Channels",false,"split_channels");\n\t\tthis.addWidget("combo","Channel","RGB",{ values:["RGB","R","G","B"]});\n\t\tthis.curve_offset = 68;\n\t\tthis.size = [ 240, 160 ];\n\t}\n\n\tLGraphTextureCurve.title = "Curve";\n\tLGraphTextureCurve.desc = "Generates or applies a curve to a texture";\n\tLGraphTextureCurve.widgets_info = {\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureCurve.prototype.onExecute = function() {\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tvar tex = this.getInputData(0);\n\n\t\tvar temp = this._temp_texture;\n\t\tif(!tex) //generate one texture, nothing else\n\t\t{\n\t\t\tif(this._must_update || !this._curve_texture )\n\t\t\t\tthis.updateCurve();\n\t\t\tthis.setOutputData(0, this._curve_texture);\n\t\t\treturn;\n\t\t}\n\n\t\tvar type = LGraphTexture.getTextureType( this.properties.precision, tex );\n\t\t\n\t\t//apply curve to input texture\n\t\tif ( !temp || temp.type != type || temp.width != tex.width || temp.height != tex.height || temp.format != tex.format)\n\t\t\ttemp = this._temp_texture = new GL.Texture( tex.width, tex.height, { type: type, format: tex.format, filter: gl.LINEAR } );\n\n\t\tvar shader = LGraphTextureCurve._shader;\n\t\tif (!shader) {\n\t\t\tshader = LGraphTextureCurve._shader = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphTextureCurve.pixel_shader );\n\t\t}\n\n\t\tif(this._must_update || !this._curve_texture )\n\t\t\tthis.updateCurve();\n\n\t\tvar uniforms = this._uniforms;\n\t\tvar curve_texture = this._curve_texture;\n\n\t\t//apply shader\n\t\ttemp.drawTo(function() {\n\t\t\tgl.disable(gl.DEPTH_TEST);\n\t\t\ttex.bind(0);\n\t\t\tcurve_texture.bind(1);\n\t\t\tshader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());\n\t\t});\n\n\t\tthis.setOutputData(0, temp);\n\t}\n\n\tLGraphTextureCurve.prototype.sampleCurve = function(f,points)\n\t{\n\t\tvar points = points || this._points.RGB;\n\t\tif(!points)\n\t\t\treturn;\n\t\tfor(var i = 0; i < points.length - 1; ++i)\n\t\t{\n\t\t\tvar p = points[i];\n\t\t\tvar pn = points[i+1];\n\t\t\tif(pn[0] < f)\n\t\t\t\tcontinue;\n\t\t\tvar r = (pn[0] - p[0]);\n\t\t\tif( Math.abs(r) < 0.00001 )\n\t\t\t\treturn p[1];\n\t\t\tvar local_f = (f - p[0]) / r;\n\t\t\treturn p[1] * (1.0 - local_f) + pn[1] * local_f;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tLGraphTextureCurve.prototype.updateCurve = function()\n\t{\n\t\tvar values = this._values;\n\t\tvar num = values.length / 4;\n\t\tvar split = this.properties.split_channels;\n\t\tfor(var i = 0; i < num; ++i)\n\t\t{\n\t\t\tif(split)\n\t\t\t{\n\t\t\t\tvalues[i*4] = clamp( this.sampleCurve(i/num,this._points.R)*255,0,255);\n\t\t\t\tvalues[i*4+1] = clamp( this.sampleCurve(i/num,this._points.G)*255,0,255);\n\t\t\t\tvalues[i*4+2] = clamp( this.sampleCurve(i/num,this._points.B)*255,0,255);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar v = this.sampleCurve(i/num);//sample curve\n\t\t\t\tvalues[i*4] = values[i*4+1] = values[i*4+2] = clamp(v*255,0,255);\n\t\t\t}\n\t\t\tvalues[i*4+3] = 255; //alpha fixed\n\t\t}\n\t\tif(!this._curve_texture)\n\t\t\tthis._curve_texture = new GL.Texture(256,1,{ format: gl.RGBA, magFilter: gl.LINEAR, wrap: gl.CLAMP_TO_EDGE });\n\t\tthis._curve_texture.uploadData(values,null,true);\n\t}\n\n\tLGraphTextureCurve.prototype.onSerialize = function(o)\n\t{\n\t\tvar curves = {};\n\t\tfor(var i in this._points)\n\t\t\tcurves[i] = this._points[i].concat();\n\t\to.curves = curves;\n\t}\n\n\tLGraphTextureCurve.prototype.onConfigure = function(o)\n\t{\n\t\tthis._points = o.curves;\n\t\tif(this.curve_editor)\n\t\t\tcurve_editor.points = this._points;\n\t\tthis._must_update = true;\n\t}\n\n\tLGraphTextureCurve.prototype.onMouseDown = function(e, localpos, graphcanvas)\n\t{\n\t\tif(this.curve_editor)\n\t\t{\n\t\t\tvar r = this.curve_editor.onMouseDown([localpos[0],localpos[1]-this.curve_offset], graphcanvas);\n\t\t\tif(r)\n\t\t\t\tthis.captureInput(true);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tLGraphTextureCurve.prototype.onMouseMove = function(e, localpos, graphcanvas)\n\t{\n\t\tif(this.curve_editor)\n\t\t\treturn this.curve_editor.onMouseMove([localpos[0],localpos[1]-this.curve_offset], graphcanvas);\n\t}\n\n\tLGraphTextureCurve.prototype.onMouseUp = function(e, localpos, graphcanvas)\n\t{\n\t\tif(this.curve_editor)\n\t\t\treturn this.curve_editor.onMouseUp([localpos[0],localpos[1]-this.curve_offset], graphcanvas);\n\t\tthis.captureInput(false);\n\t}\n\n\tLGraphTextureCurve.channel_line_colors = { "RGB":"#666","R":"#F33","G":"#3F3","B":"#33F" };\n\n\tLGraphTextureCurve.prototype.onDrawBackground = function(ctx, graphcanvas)\n\t{\n\t\tif(this.flags.collapsed)\n\t\t\treturn;\n\n\t\tif(!this.curve_editor)\n\t\t\tthis.curve_editor = new LiteGraph.CurveEditor(this._points.R);\n\t\tctx.save();\n\t\tctx.translate(0,this.curve_offset);\n\t\tvar channel = this.widgets[1].value;\n\n\t\tif(this.properties.split_channels)\n\t\t{\n\t\t\tif(channel == "RGB")\n\t\t\t{\n\t\t\t\tthis.widgets[1].value = channel = "R";\n\t\t\t\tthis.widgets[1].disabled = false;\n\t\t\t}\n\t\t\tthis.curve_editor.points = this._points.R;\n\t\t\tthis.curve_editor.draw( ctx, [this.size[0],this.size[1] - this.curve_offset], graphcanvas, "#111", LGraphTextureCurve.channel_line_colors.R, true );\n\t\t\tctx.globalCompositeOperation = "lighten";\n\t\t\tthis.curve_editor.points = this._points.G;\n\t\t\tthis.curve_editor.draw( ctx, [this.size[0],this.size[1] - this.curve_offset], graphcanvas, null, LGraphTextureCurve.channel_line_colors.G, true );\n\t\t\tthis.curve_editor.points = this._points.B;\n\t\t\tthis.curve_editor.draw( ctx, [this.size[0],this.size[1] - this.curve_offset], graphcanvas, null, LGraphTextureCurve.channel_line_colors.B, true );\n\t\t\tctx.globalCompositeOperation = "source-over";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.widgets[1].value = channel = "RGB";\n\t\t\tthis.widgets[1].disabled = true;\n\t\t}\n\n\t\tthis.curve_editor.points = this._points[channel];\n\t\tthis.curve_editor.draw( ctx, [this.size[0],this.size[1] - this.curve_offset], graphcanvas, this.properties.split_channels ? null : "#111", LGraphTextureCurve.channel_line_colors[channel]  );\n\t\tctx.restore();\n\t}\n\n\tLGraphTextureCurve.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform sampler2D u_curve;\\n\\\n\t\tuniform float u_range;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tvec4 color = texture2D( u_texture, v_coord ) * u_range;\\n\\\n\t\t\tcolor.x = texture2D( u_curve, vec2( color.x, 0.5 ) ).x;\\n\\\n\t\t\tcolor.y = texture2D( u_curve, vec2( color.y, 0.5 ) ).y;\\n\\\n\t\t\tcolor.z = texture2D( u_curve, vec2( color.z, 0.5 ) ).z;\\n\\\n\t\t\t//color.w = texture2D( u_curve, vec2( color.w, 0.5 ) ).w;\\n\\\n\t\t\tgl_FragColor = color;\\n\\\n\t\t}";\n\n\tLiteGraph.registerNodeType("texture/curve", LGraphTextureCurve);\n\n\t//simple exposition, but plan to expand it to support different gamma curves\n\tfunction LGraphExposition() {\n\t\tthis.addInput("in", "Texture");\n\t\tthis.addInput("exp", "number");\n\t\tthis.addOutput("out", "Texture");\n\t\tthis.properties = { exposition: 1, precision: LGraphTexture.LOW };\n\t\tthis._uniforms = { u_texture: 0, u_exposition: 1 };\n\t}\n\n\tLGraphExposition.title = "Exposition";\n\tLGraphExposition.desc = "Controls texture exposition";\n\n\tLGraphExposition.widgets_info = {\n\t\texposition: { widget: "slider", min: 0, max: 3 },\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphExposition.prototype.onExecute = function() {\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tvar temp = this._temp_texture;\n\t\tif (\n\t\t\t!temp ||\n\t\t\ttemp.width != tex.width ||\n\t\t\ttemp.height != tex.height ||\n\t\t\ttemp.type != tex.type\n\t\t) {\n\t\t\ttemp = this._temp_texture = new GL.Texture(\n\t\t\t\ttex.width,\n\t\t\t\ttex.height,\n\t\t\t\t{ type: tex.type, format: gl.RGBA, filter: gl.LINEAR }\n\t\t\t);\n\t\t}\n\n\t\tvar shader = LGraphExposition._shader;\n\t\tif (!shader) {\n\t\t\tshader = LGraphExposition._shader = new GL.Shader(\n\t\t\t\tGL.Shader.SCREEN_VERTEX_SHADER,\n\t\t\t\tLGraphExposition.pixel_shader\n\t\t\t);\n\t\t}\n\n\t\tvar exp = this.properties.exposition;\n\t\tvar exp_input = this.getInputData(1);\n\t\tif (exp_input != null) {\n\t\t\texp = this.properties.exposition = exp_input;\n\t\t}\n\t\tvar uniforms = this._uniforms;\n\n\t\t//apply shader\n\t\ttemp.drawTo(function() {\n\t\t\tgl.disable(gl.DEPTH_TEST);\n\t\t\ttex.bind(0);\n\t\t\tshader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());\n\t\t});\n\n\t\tthis.setOutputData(0, temp);\n\t};\n\n\tLGraphExposition.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform float u_exposition;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tvec4 color = texture2D( u_texture, v_coord );\\n\\\n\t\t\tgl_FragColor = vec4( color.xyz * u_exposition, color.a );\\n\\\n\t\t}";\n\n\tLiteGraph.registerNodeType("texture/exposition", LGraphExposition);\n\n\tfunction LGraphToneMapping() {\n\t\tthis.addInput("in", "Texture");\n\t\tthis.addInput("avg", "number,Texture");\n\t\tthis.addOutput("out", "Texture");\n\t\tthis.properties = {\n\t\t\tenabled: true,\n\t\t\tscale: 1,\n\t\t\tgamma: 1,\n\t\t\taverage_lum: 1,\n\t\t\tlum_white: 1,\n\t\t\tprecision: LGraphTexture.LOW\n\t\t};\n\n\t\tthis._uniforms = {\n\t\t\tu_texture: 0,\n\t\t\tu_lumwhite2: 1,\n\t\t\tu_igamma: 1,\n\t\t\tu_scale: 1,\n\t\t\tu_average_lum: 1\n\t\t};\n\t}\n\n\tLGraphToneMapping.title = "Tone Mapping";\n\tLGraphToneMapping.desc =\n\t\t"Applies Tone Mapping to convert from high to low";\n\n\tLGraphToneMapping.widgets_info = {\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphToneMapping.prototype.onGetInputs = function() {\n\t\treturn [["enabled", "boolean"]];\n\t};\n\n\tLGraphToneMapping.prototype.onExecute = function() {\n\t\tvar tex = this.getInputData(0);\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tif (\n\t\t\tthis.properties.precision === LGraphTexture.PASS_THROUGH ||\n\t\t\tthis.getInputOrProperty("enabled") === false\n\t\t) {\n\t\t\tthis.setOutputData(0, tex);\n\t\t\treturn;\n\t\t}\n\n\t\tvar temp = this._temp_texture;\n\n\t\tif (\n\t\t\t!temp ||\n\t\t\ttemp.width != tex.width ||\n\t\t\ttemp.height != tex.height ||\n\t\t\ttemp.type != tex.type\n\t\t) {\n\t\t\ttemp = this._temp_texture = new GL.Texture(\n\t\t\t\ttex.width,\n\t\t\t\ttex.height,\n\t\t\t\t{ type: tex.type, format: gl.RGBA, filter: gl.LINEAR }\n\t\t\t);\n\t\t}\n\n\t\tvar avg = this.getInputData(1);\n\t\tif (avg == null) {\n\t\t\tavg = this.properties.average_lum;\n\t\t}\n\n\t\tvar uniforms = this._uniforms;\n\t\tvar shader = null;\n\n\t\tif (avg.constructor === Number) {\n\t\t\tthis.properties.average_lum = avg;\n\t\t\tuniforms.u_average_lum = this.properties.average_lum;\n\t\t\tshader = LGraphToneMapping._shader;\n\t\t\tif (!shader) {\n\t\t\t\tshader = LGraphToneMapping._shader = new GL.Shader(\n\t\t\t\t\tGL.Shader.SCREEN_VERTEX_SHADER,\n\t\t\t\t\tLGraphToneMapping.pixel_shader\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (avg.constructor === GL.Texture) {\n\t\t\tuniforms.u_average_texture = avg.bind(1);\n\t\t\tshader = LGraphToneMapping._shader_texture;\n\t\t\tif (!shader) {\n\t\t\t\tshader = LGraphToneMapping._shader_texture = new GL.Shader(\n\t\t\t\t\tGL.Shader.SCREEN_VERTEX_SHADER,\n\t\t\t\t\tLGraphToneMapping.pixel_shader,\n\t\t\t\t\t{ AVG_TEXTURE: "" }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tuniforms.u_lumwhite2 =\n\t\t\tthis.properties.lum_white * this.properties.lum_white;\n\t\tuniforms.u_scale = this.properties.scale;\n\t\tuniforms.u_igamma = 1 / this.properties.gamma;\n\n\t\t//apply shader\n\t\tgl.disable(gl.DEPTH_TEST);\n\t\ttemp.drawTo(function() {\n\t\t\ttex.bind(0);\n\t\t\tshader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());\n\t\t});\n\n\t\tthis.setOutputData(0, this._temp_texture);\n\t};\n\n\tLGraphToneMapping.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform float u_scale;\\n\\\n\t\t#ifdef AVG_TEXTURE\\n\\\n\t\t\tuniform sampler2D u_average_texture;\\n\\\n\t\t#else\\n\\\n\t\t\tuniform float u_average_lum;\\n\\\n\t\t#endif\\n\\\n\t\tuniform float u_lumwhite2;\\n\\\n\t\tuniform float u_igamma;\\n\\\n\t\tvec3 RGB2xyY (vec3 rgb)\\n\\\n\t\t{\\n\\\n\t\t\t const mat3 RGB2XYZ = mat3(0.4124, 0.3576, 0.1805,\\n\\\n\t\t\t\t\t\t\t\t\t   0.2126, 0.7152, 0.0722,\\n\\\n\t\t\t\t\t\t\t\t\t   0.0193, 0.1192, 0.9505);\\n\\\n\t\t\tvec3 XYZ = RGB2XYZ * rgb;\\n\\\n\t\t\t\\n\\\n\t\t\tfloat f = (XYZ.x + XYZ.y + XYZ.z);\\n\\\n\t\t\treturn vec3(XYZ.x / f,\\n\\\n\t\t\t\t\t\tXYZ.y / f,\\n\\\n\t\t\t\t\t\tXYZ.y);\\n\\\n\t\t}\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tvec4 color = texture2D( u_texture, v_coord );\\n\\\n\t\t\tvec3 rgb = color.xyz;\\n\\\n\t\t\tfloat average_lum = 0.0;\\n\\\n\t\t\t#ifdef AVG_TEXTURE\\n\\\n\t\t\t\tvec3 pixel = texture2D(u_average_texture,vec2(0.5)).xyz;\\n\\\n\t\t\t\taverage_lum = (pixel.x + pixel.y + pixel.z) / 3.0;\\n\\\n\t\t\t#else\\n\\\n\t\t\t\taverage_lum = u_average_lum;\\n\\\n\t\t\t#endif\\n\\\n\t\t\t//Ld - this part of the code is the same for both versions\\n\\\n\t\t\tfloat lum = dot(rgb, vec3(0.2126, 0.7152, 0.0722));\\n\\\n\t\t\tfloat L = (u_scale / average_lum) * lum;\\n\\\n\t\t\tfloat Ld = (L * (1.0 + L / u_lumwhite2)) / (1.0 + L);\\n\\\n\t\t\t//first\\n\\\n\t\t\t//vec3 xyY = RGB2xyY(rgb);\\n\\\n\t\t\t//xyY.z *= Ld;\\n\\\n\t\t\t//rgb = xyYtoRGB(xyY);\\n\\\n\t\t\t//second\\n\\\n\t\t\trgb = (rgb / lum) * Ld;\\n\\\n\t\t\trgb = max(rgb,vec3(0.001));\\n\\\n\t\t\trgb = pow( rgb, vec3( u_igamma ) );\\n\\\n\t\t\tgl_FragColor = vec4( rgb, color.a );\\n\\\n\t\t}";\n\n\tLiteGraph.registerNodeType("texture/tonemapping", LGraphToneMapping);\n\n\tfunction LGraphTexturePerlin() {\n\t\tthis.addOutput("out", "Texture");\n\t\tthis.properties = {\n\t\t\twidth: 512,\n\t\t\theight: 512,\n\t\t\tseed: 0,\n\t\t\tpersistence: 0.1,\n\t\t\toctaves: 8,\n\t\t\tscale: 1,\n\t\t\toffset: [0, 0],\n\t\t\tamplitude: 1,\n\t\t\tprecision: LGraphTexture.DEFAULT\n\t\t};\n\t\tthis._key = 0;\n\t\tthis._texture = null;\n\t\tthis._uniforms = {\n\t\t\tu_persistence: 0.1,\n\t\t\tu_seed: 0,\n\t\t\tu_offset: vec2.create(),\n\t\t\tu_scale: 1,\n\t\t\tu_viewport: vec2.create()\n\t\t};\n\t}\n\n\tLGraphTexturePerlin.title = "Perlin";\n\tLGraphTexturePerlin.desc = "Generates a perlin noise texture";\n\n\tLGraphTexturePerlin.widgets_info = {\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES },\n\t\twidth: { type: "number", precision: 0, step: 1 },\n\t\theight: { type: "number", precision: 0, step: 1 },\n\t\toctaves: { type: "number", precision: 0, step: 1, min: 1, max: 50 }\n\t};\n\n\tLGraphTexturePerlin.prototype.onGetInputs = function() {\n\t\treturn [\n\t\t\t["seed", "number"],\n\t\t\t["persistence", "number"],\n\t\t\t["octaves", "number"],\n\t\t\t["scale", "number"],\n\t\t\t["amplitude", "number"],\n\t\t\t["offset", "vec2"]\n\t\t];\n\t};\n\n\tLGraphTexturePerlin.prototype.onExecute = function() {\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tvar w = this.properties.width | 0;\n\t\tvar h = this.properties.height | 0;\n\t\tif (w == 0) {\n\t\t\tw = gl.viewport_data[2];\n\t\t} //0 means default\n\t\tif (h == 0) {\n\t\t\th = gl.viewport_data[3];\n\t\t} //0 means default\n\t\tvar type = LGraphTexture.getTextureType(this.properties.precision);\n\n\t\tvar temp = this._texture;\n\t\tif (\n\t\t\t!temp ||\n\t\t\ttemp.width != w ||\n\t\t\ttemp.height != h ||\n\t\t\ttemp.type != type\n\t\t) {\n\t\t\ttemp = this._texture = new GL.Texture(w, h, {\n\t\t\t\ttype: type,\n\t\t\t\tformat: gl.RGB,\n\t\t\t\tfilter: gl.LINEAR\n\t\t\t});\n\t\t}\n\n\t\tvar persistence = this.getInputOrProperty("persistence");\n\t\tvar octaves = this.getInputOrProperty("octaves");\n\t\tvar offset = this.getInputOrProperty("offset");\n\t\tvar scale = this.getInputOrProperty("scale");\n\t\tvar amplitude = this.getInputOrProperty("amplitude");\n\t\tvar seed = this.getInputOrProperty("seed");\n\n\t\t//reusing old texture\n\t\tvar key =\n\t\t\t"" +\n\t\t\tw +\n\t\t\th +\n\t\t\ttype +\n\t\t\tpersistence +\n\t\t\toctaves +\n\t\t\tscale +\n\t\t\tseed +\n\t\t\toffset[0] +\n\t\t\toffset[1] +\n\t\t\tamplitude;\n\t\tif (key == this._key) {\n\t\t\tthis.setOutputData(0, temp);\n\t\t\treturn;\n\t\t}\n\t\tthis._key = key;\n\n\t\t//gather uniforms\n\t\tvar uniforms = this._uniforms;\n\t\tuniforms.u_persistence = persistence;\n\t\tuniforms.u_octaves = octaves;\n\t\tuniforms.u_offset.set(offset);\n\t\tuniforms.u_scale = scale;\n\t\tuniforms.u_amplitude = amplitude;\n\t\tuniforms.u_seed = seed * 128;\n\t\tuniforms.u_viewport[0] = w;\n\t\tuniforms.u_viewport[1] = h;\n\n\t\t//render\n\t\tvar shader = LGraphTexturePerlin._shader;\n\t\tif (!shader) {\n\t\t\tshader = LGraphTexturePerlin._shader = new GL.Shader(\n\t\t\t\tGL.Shader.SCREEN_VERTEX_SHADER,\n\t\t\t\tLGraphTexturePerlin.pixel_shader\n\t\t\t);\n\t\t}\n\n\t\tgl.disable(gl.BLEND);\n\t\tgl.disable(gl.DEPTH_TEST);\n\n\t\ttemp.drawTo(function() {\n\t\t\tshader.uniforms(uniforms).draw(GL.Mesh.getScreenQuad());\n\t\t});\n\n\t\tthis.setOutputData(0, temp);\n\t};\n\n\tLGraphTexturePerlin.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform vec2 u_offset;\\n\\\n\t\tuniform float u_scale;\\n\\\n\t\tuniform float u_persistence;\\n\\\n\t\tuniform int u_octaves;\\n\\\n\t\tuniform float u_amplitude;\\n\\\n\t\tuniform vec2 u_viewport;\\n\\\n\t\tuniform float u_seed;\\n\\\n\t\t#define M_PI 3.14159265358979323846\\n\\\n\t\t\\n\\\n\t\tfloat rand(vec2 c){\treturn fract(sin(dot(c.xy ,vec2( 12.9898 + u_seed,78.233 + u_seed))) * 43758.5453); }\\n\\\n\t\t\\n\\\n\t\tfloat noise(vec2 p, float freq ){\\n\\\n\t\t\tfloat unit = u_viewport.x/freq;\\n\\\n\t\t\tvec2 ij = floor(p/unit);\\n\\\n\t\t\tvec2 xy = mod(p,unit)/unit;\\n\\\n\t\t\t//xy = 3.*xy*xy-2.*xy*xy*xy;\\n\\\n\t\t\txy = .5*(1.-cos(M_PI*xy));\\n\\\n\t\t\tfloat a = rand((ij+vec2(0.,0.)));\\n\\\n\t\t\tfloat b = rand((ij+vec2(1.,0.)));\\n\\\n\t\t\tfloat c = rand((ij+vec2(0.,1.)));\\n\\\n\t\t\tfloat d = rand((ij+vec2(1.,1.)));\\n\\\n\t\t\tfloat x1 = mix(a, b, xy.x);\\n\\\n\t\t\tfloat x2 = mix(c, d, xy.x);\\n\\\n\t\t\treturn mix(x1, x2, xy.y);\\n\\\n\t\t}\\n\\\n\t\t\\n\\\n\t\tfloat pNoise(vec2 p, int res){\\n\\\n\t\t\tfloat persistance = u_persistence;\\n\\\n\t\t\tfloat n = 0.;\\n\\\n\t\t\tfloat normK = 0.;\\n\\\n\t\t\tfloat f = 4.;\\n\\\n\t\t\tfloat amp = 1.0;\\n\\\n\t\t\tint iCount = 0;\\n\\\n\t\t\tfor (int i = 0; i<50; i++){\\n\\\n\t\t\t\tn+=amp*noise(p, f);\\n\\\n\t\t\t\tf*=2.;\\n\\\n\t\t\t\tnormK+=amp;\\n\\\n\t\t\t\tamp*=persistance;\\n\\\n\t\t\t\tif (iCount >= res)\\n\\\n\t\t\t\t\tbreak;\\n\\\n\t\t\t\tiCount++;\\n\\\n\t\t\t}\\n\\\n\t\t\tfloat nf = n/normK;\\n\\\n\t\t\treturn nf*nf*nf*nf;\\n\\\n\t\t}\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tvec2 uv = v_coord * u_scale * u_viewport + u_offset * u_scale;\\n\\\n\t\t\tvec4 color = vec4( pNoise( uv, u_octaves ) * u_amplitude );\\n\\\n\t\t\tgl_FragColor = color;\\n\\\n\t\t}";\n\n\tLiteGraph.registerNodeType("texture/perlin", LGraphTexturePerlin);\n\n\tfunction LGraphTextureCanvas2D() {\n\t\tthis.addInput("v");\n\t\tthis.addOutput("out", "Texture");\n\t\tthis.properties = {\n\t\t\tcode: LGraphTextureCanvas2D.default_code,\n\t\t\twidth: 512,\n\t\t\theight: 512,\n\t\t\tclear: true,\n\t\t\tprecision: LGraphTexture.DEFAULT,\n\t\t\tuse_html_canvas: false\n\t\t};\n\t\tthis._func = null;\n\t\tthis._temp_texture = null;\n\t\tthis.compileCode();\n\t}\n\n\tLGraphTextureCanvas2D.title = "Canvas2D";\n\tLGraphTextureCanvas2D.desc = "Executes Canvas2D code inside a texture or the viewport.";\n\tLGraphTextureCanvas2D.help = "Set width and height to 0 to match viewport size.";\n\n\tLGraphTextureCanvas2D.default_code = "//vars: canvas,ctx,time\\nctx.fillStyle=\'red\';\\nctx.fillRect(0,0,50,50);\\n";\n\n\tLGraphTextureCanvas2D.widgets_info = {\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES },\n\t\tcode: { type: "code" },\n\t\twidth: { type: "number", precision: 0, step: 1 },\n\t\theight: { type: "number", precision: 0, step: 1 }\n\t};\n\n\tLGraphTextureCanvas2D.prototype.onPropertyChanged = function( name, value ) {\n\t\tif (name == "code" )\n\t\t\tthis.compileCode( value );\n\t}\n\t\n\tLGraphTextureCanvas2D.prototype.compileCode = function( code ) {\n\t\tthis._func = null;\n\t\tif( !LiteGraph.allow_scripts )\n\t\t\treturn;\n\n\t\ttry {\n\t\t\tthis._func = new Function( "canvas", "ctx", "time", "script","v", code );\n\t\t\tthis.boxcolor = "#00FF00";\n\t\t} catch (err) {\n\t\t\tthis.boxcolor = "#FF0000";\n\t\t\tconsole.error("Error parsing script");\n\t\t\tconsole.error(err);\n\t\t}\n\t};\n\n\tLGraphTextureCanvas2D.prototype.onExecute = function() {\n\t\tvar func = this._func;\n\t\tif (!func || !this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t}\n\t\tthis.executeDraw( func );\n\t}\n\n\tLGraphTextureCanvas2D.prototype.executeDraw = function( func_context ) {\n\n\t\tvar width = this.properties.width || gl.canvas.width;\n\t\tvar height = this.properties.height || gl.canvas.height;\n\t\tvar temp = this._temp_texture;\n\t\tvar type = LGraphTexture.getTextureType( this.properties.precision );\n\t\tif (!temp || temp.width != width || temp.height != height || temp.type != type ) {\n\t\t\ttemp = this._temp_texture = new GL.Texture(width, height, {\n\t\t\t\tformat: gl.RGBA,\n\t\t\t\tfilter: gl.LINEAR,\n\t\t\t\ttype: type\n\t\t\t});\n\t\t}\n\n\t\tvar v = this.getInputData(0);\n\n\t\tvar properties = this.properties;\n\t\tvar that = this;\n\t\tvar time = this.graph.getTime();\n\t\tvar ctx = gl;\n\t\tvar canvas = gl.canvas;\n\t\tif( this.properties.use_html_canvas || !global.enableWebGLCanvas )\n\t\t{\n\t\t\tif(!this._canvas)\n\t\t\t{\n\t\t\t\tcanvas = this._canvas = createCanvas(width.height);\n\t\t\t\tctx = this._ctx = canvas.getContext("2d");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcanvas = this._canvas;\n\t\t\t\tctx = this._ctx;\n\t\t\t}\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\t\t}\n\n\t\tif(ctx == gl) //using Canvas2DtoWebGL\n\t\t\ttemp.drawTo(function() {\n\t\t\t\tgl.start2D();\n\t\t\t\tif(properties.clear)\n\t\t\t\t{\n\t\t\t\t\tgl.clearColor(0,0,0,0);\n\t\t\t\t\tgl.clear( gl.COLOR_BUFFER_BIT );\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tif (func_context.draw) {\n\t\t\t\t\t\tfunc_context.draw.call(that, canvas, ctx, time, func_context, v);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfunc_context.call(that, canvas, ctx, time, func_context,v);\n\t\t\t\t\t}\n\t\t\t\t\tthat.boxcolor = "#00FF00";\n\t\t\t\t} catch (err) {\n\t\t\t\t\tthat.boxcolor = "#FF0000";\n\t\t\t\t\tconsole.error("Error executing script");\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t}\n\t\t\t\tgl.finish2D();\n\t\t\t});\n\t\telse //rendering to offscreen canvas and uploading to texture\n\t\t{\n\t\t\tif(properties.clear)\n\t\t\t\tctx.clearRect(0,0,canvas.width,canvas.height);\n\n\t\t\ttry {\n\t\t\t\tif (func_context.draw) {\n\t\t\t\t\tfunc_context.draw.call(this, canvas, ctx, time, func_context, v);\n\t\t\t\t} else {\n\t\t\t\t\tfunc_context.call(this, canvas, ctx, time, func_context,v);\n\t\t\t\t}\n\t\t\t\tthis.boxcolor = "#00FF00";\n\t\t\t} catch (err) {\n\t\t\t\tthis.boxcolor = "#FF0000";\n\t\t\t\tconsole.error("Error executing script");\n\t\t\t\tconsole.error(err);\n\t\t\t}\n\t\t\ttemp.uploadImage( canvas );\n\t\t}\n\n\t\tthis.setOutputData(0, temp);\n\t};\n\n\tLiteGraph.registerNodeType("texture/canvas2D", LGraphTextureCanvas2D);\n\n\t// To do chroma keying *****************\n\n\tfunction LGraphTextureMatte() {\n\t\tthis.addInput("in", "Texture");\n\n\t\tthis.addOutput("out", "Texture");\n\t\tthis.properties = {\n\t\t\tkey_color: vec3.fromValues(0, 1, 0),\n\t\t\tthreshold: 0.8,\n\t\t\tslope: 0.2,\n\t\t\tprecision: LGraphTexture.DEFAULT\n\t\t};\n\t}\n\n\tLGraphTextureMatte.title = "Matte";\n\tLGraphTextureMatte.desc = "Extracts background";\n\n\tLGraphTextureMatte.widgets_info = {\n\t\tkey_color: { widget: "color" },\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\n\t};\n\n\tLGraphTextureMatte.prototype.onExecute = function() {\n\t\tif (!this.isOutputConnected(0)) {\n\t\t\treturn;\n\t\t} //saves work\n\n\t\tvar tex = this.getInputData(0);\n\n\t\tif (this.properties.precision === LGraphTexture.PASS_THROUGH) {\n\t\t\tthis.setOutputData(0, tex);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!tex) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._tex = LGraphTexture.getTargetTexture(\n\t\t\ttex,\n\t\t\tthis._tex,\n\t\t\tthis.properties.precision\n\t\t);\n\n\t\tgl.disable(gl.BLEND);\n\t\tgl.disable(gl.DEPTH_TEST);\n\n\t\tif (!this._uniforms) {\n\t\t\tthis._uniforms = {\n\t\t\t\tu_texture: 0,\n\t\t\t\tu_key_color: this.properties.key_color,\n\t\t\t\tu_threshold: 1,\n\t\t\t\tu_slope: 1\n\t\t\t};\n\t\t}\n\t\tvar uniforms = this._uniforms;\n\n\t\tvar mesh = Mesh.getScreenQuad();\n\t\tvar shader = LGraphTextureMatte._shader;\n\t\tif (!shader) {\n\t\t\tshader = LGraphTextureMatte._shader = new GL.Shader(\n\t\t\t\tGL.Shader.SCREEN_VERTEX_SHADER,\n\t\t\t\tLGraphTextureMatte.pixel_shader\n\t\t\t);\n\t\t}\n\n\t\tuniforms.u_key_color = this.properties.key_color;\n\t\tuniforms.u_threshold = this.properties.threshold;\n\t\tuniforms.u_slope = this.properties.slope;\n\n\t\tthis._tex.drawTo(function() {\n\t\t\ttex.bind(0);\n\t\t\tshader.uniforms(uniforms).draw(mesh);\n\t\t});\n\n\t\tthis.setOutputData(0, this._tex);\n\t};\n\n\tLGraphTextureMatte.pixel_shader =\n\t\t"precision highp float;\\n\\\n\t\tvarying vec2 v_coord;\\n\\\n\t\tuniform sampler2D u_texture;\\n\\\n\t\tuniform vec3 u_key_color;\\n\\\n\t\tuniform float u_threshold;\\n\\\n\t\tuniform float u_slope;\\n\\\n\t\t\\n\\\n\t\tvoid main() {\\n\\\n\t\t\tvec3 color = texture2D( u_texture, v_coord ).xyz;\\n\\\n\t\t\tfloat diff = length( normalize(color) - normalize(u_key_color) );\\n\\\n\t\t\tfloat edge = u_threshold * (1.0 - u_slope);\\n\\\n\t\t\tfloat alpha = smoothstep( edge, u_threshold, diff);\\n\\\n\t\t\tgl_FragColor = vec4( color, alpha );\\n\\\n\t\t}";\n\n\tLiteGraph.registerNodeType("texture/matte", LGraphTextureMatte);\n\n\t//***********************************\n\tfunction LGraphCubemapToTexture2D() {\n\t\tthis.addInput("in", "texture");\n\t\tthis.addInput("yaw", "number");\n\t\tthis.addOutput("out", "texture");\n\t\tthis.properties = { yaw: 0 };\n\t}\n\n\tLGraphCubemapToTexture2D.title = "CubemapToTexture2D";\n\tLGraphCubemapToTexture2D.desc = "Transforms a CUBEMAP texture into a TEXTURE2D in Polar Representation";\n\n\tLGraphCubemapToTexture2D.prototype.onExecute = function() {\n\t\tif (!this.isOutputConnected(0))\n\t\t\treturn;\n\n\t\tvar tex = this.getInputData(0);\n\t\tif ( !tex || tex.texture_type != GL.TEXTURE_CUBE_MAP )\n\t\t\treturn;\n\t\tif( this._last_tex && ( this._last_tex.height != tex.height || this._last_tex.type != tex.type ))\n\t\t\tthis._last_tex = null;\n\t\tvar yaw = this.getInputOrProperty("yaw");\n\t\tthis._last_tex = GL.Texture.cubemapToTexture2D( tex, tex.height, this._last_tex, true, yaw );\n\t\tthis.setOutputData( 0, this._last_tex );\n\t};\n\n\tLiteGraph.registerNodeType( "texture/cubemapToTexture2D", LGraphCubemapToTexture2D );\n})(this);\n\n(function(global) {\r\n\r\n    if (typeof GL == "undefined")\r\n\t\treturn;\r\n\r\n    var LiteGraph = global.LiteGraph;\r\n\tvar LGraphCanvas = global.LGraphCanvas;\r\n\r\n\tvar SHADERNODES_COLOR = "#345";\r\n\r\n\tvar LGShaders = LiteGraph.Shaders = {};\r\n\r\n\tvar GLSL_types = LGShaders.GLSL_types = ["float","vec2","vec3","vec4","mat3","mat4","sampler2D","samplerCube"];\r\n\tvar GLSL_types_const = LGShaders.GLSL_types_const = ["float","vec2","vec3","vec4"];\r\n\r\n\tvar GLSL_functions_desc = {\r\n\t\t"radians": "T radians(T degrees)",\r\n\t\t"degrees": "T degrees(T radians)",\r\n\t\t"sin": "T sin(T angle)",\r\n\t\t"cos": "T cos(T angle)",\r\n\t\t"tan": "T tan(T angle)",\r\n\t\t"asin": "T asin(T x)",\r\n\t\t"acos": "T acos(T x)",\r\n\t\t"atan": "T atan(T x)",\r\n\t\t"atan2": "T atan(T x,T y)",\r\n\t\t"pow": "T pow(T x,T y)",\r\n\t\t"exp": "T exp(T x)",\r\n\t\t"log": "T log(T x)",\r\n\t\t"exp2": "T exp2(T x)",\r\n\t\t"log2": "T log2(T x)",\r\n\t\t"sqrt": "T sqrt(T x)",\r\n\t\t"inversesqrt": "T inversesqrt(T x)",\r\n\t\t"abs": "T abs(T x)",\r\n\t\t"sign": "T sign(T x)",\r\n\t\t"floor": "T floor(T x)",\r\n\t\t"round": "T round(T x)",\r\n\t\t"ceil": "T ceil(T x)",\r\n\t\t"fract": "T fract(T x)",\r\n\t\t"mod": "T mod(T x,T y)", //"T mod(T x,float y)"\r\n\t\t"min": "T min(T x,T y)",\r\n\t\t"max": "T max(T x,T y)",\r\n\t\t"clamp": "T clamp(T x,T minVal = 0.0,T maxVal = 1.0)",\r\n\t\t"mix": "T mix(T x,T y,T a)", //"T mix(T x,T y,float a)"\r\n\t\t"step": "T step(T edge, T edge2, T x)", //"T step(float edge, T x)"\r\n\t\t"smoothstep": "T smoothstep(T edge, T edge2, T x)", //"T smoothstep(float edge, T x)"\r\n\t\t"length":"float length(T x)",\r\n\t\t"distance":"float distance(T p0, T p1)",\r\n\t\t"normalize":"T normalize(T x)",\r\n\t\t"dot": "float dot(T x,T y)",\r\n\t\t"cross": "vec3 cross(vec3 x,vec3 y)",\r\n\t\t"reflect": "vec3 reflect(vec3 V,vec3 N)",\r\n\t\t"refract": "vec3 refract(vec3 V,vec3 N, float IOR)"\r\n\t};\r\n\r\n\t//parse them\r\n\tvar GLSL_functions = {};\r\n\tvar GLSL_functions_name = [];\r\n\tparseGLSLDescriptions();\r\n\r\n\tLGShaders.ALL_TYPES = "float,vec2,vec3,vec4";\r\n\r\n\tfunction parseGLSLDescriptions()\r\n\t{\r\n\t\tGLSL_functions_name.length = 0;\r\n\r\n\t\tfor(var i in GLSL_functions_desc)\r\n\t\t{\r\n\t\t\tvar op = GLSL_functions_desc[i];\r\n\t\t\tvar index = op.indexOf(" ");\r\n\t\t\tvar return_type = op.substr(0,index);\r\n\t\t\tvar index2 = op.indexOf("(",index);\r\n\t\t\tvar func_name = op.substr(index,index2-index).trim();\r\n\t\t\tvar params = op.substr(index2 + 1, op.length - index2 - 2).split(",");\r\n\t\t\tfor(var j in params)\r\n\t\t\t{\r\n\t\t\t\tvar p = params[j].split(" ").filter(function(a){ return a; });\r\n\t\t\t\tparams[j] = { type: p[0].trim(), name: p[1].trim() };\r\n\t\t\t\tif(p[2] == "=")\r\n\t\t\t\t\tparams[j].value = p[3].trim();\r\n\t\t\t}\r\n\t\t\tGLSL_functions[i] = { return_type: return_type, func: func_name, params: params };\r\n\t\t\tGLSL_functions_name.push( func_name );\r\n\t\t\t//console.log( GLSL_functions[i] );\r\n\t\t}\r\n\t}\r\n\r\n\t//common actions to all shader node classes\r\n\tfunction registerShaderNode( type, node_ctor )\r\n\t{\r\n\t\t//static attributes\r\n\t\tnode_ctor.color = SHADERNODES_COLOR;\r\n\t\tnode_ctor.filter = "shader";\r\n\r\n\t\t//common methods\r\n\t\tnode_ctor.prototype.clearDestination = function(){ this.shader_destination = {};  }\r\n\t\tnode_ctor.prototype.propagateDestination = function propagateDestination( dest_name )\r\n\t\t{\r\n\t\t\tthis.shader_destination[ dest_name ] = true;\r\n\t\t\tif(this.inputs)\r\n\t\t\tfor(var i = 0; i < this.inputs.length; ++i)\r\n\t\t\t{\r\n\t\t\t\tvar origin_node = this.getInputNode(i);\r\n\t\t\t\tif(origin_node)\r\n\t\t\t\t\torigin_node.propagateDestination( dest_name );\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(!node_ctor.prototype.onPropertyChanged)\r\n\t\t\tnode_ctor.prototype.onPropertyChanged = function()\r\n\t\t\t{\r\n\t\t\t\tif(this.graph)\r\n\t\t\t\t\t this.graph._version++;\r\n\t\t\t}\r\n\r\n\t\t/*\r\n\t\tif(!node_ctor.prototype.onGetCode)\r\n\t\t\tnode_ctor.prototype.onGetCode = function()\r\n\t\t\t{\r\n\t\t\t\t//check destination to avoid lonely nodes\r\n\t\t\t\tif(!this.shader_destination)\r\n\t\t\t\t\treturn;\r\n\t\t\t\t//grab inputs with types\r\n\t\t\t\tvar inputs = [];\r\n\t\t\t\tif(this.inputs)\r\n\t\t\t\tfor(var i = 0; i < this.inputs.length; ++i)\r\n\t\t\t\t\tinputs.push({ type: this.getInputData(i), name: getInputLinkID(this,i) });\r\n\t\t\t\tvar outputs = [];\r\n\t\t\t\tif(this.outputs)\r\n\t\t\t\tfor(var i = 0; i < this.outputs.length; ++i)\r\n\t\t\t\t\toutputs.push({ name: getOutputLinkID(this,i) });\r\n\t\t\t\t//pass to code func\r\n\t\t\t\tvar results = this.extractCode(inputs);\r\n\t\t\t\t//grab output, pass to next\r\n\t\t\t\tif(results)\r\n\t\t\t\tfor(var i = 0; i < results.length; ++i)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar r = results[i];\r\n\t\t\t\t\tif(!r)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tthis.setOutputData(i,r.value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t*/\r\n\r\n\t\tLiteGraph.registerNodeType( "shader::" + type, node_ctor );\r\n\t}\r\n\r\n\tfunction getShaderNodeVarName( node, name )\r\n\t{\r\n\t\treturn "VAR_" + (name || "TEMP") + "_" + node.id;\r\n\t}\r\n\r\n\tfunction getInputLinkID( node, slot )\r\n\t{\r\n\t\tif(!node.inputs)\r\n\t\t\treturn null;\r\n\t\tvar link = node.getInputLink( slot );\r\n\t\tif( !link )\r\n\t\t\treturn null;\r\n\t\tvar origin_node = node.graph.getNodeById( link.origin_id );\r\n\t\tif( !origin_node )\r\n\t\t\treturn null;\r\n\t\tif(origin_node.getOutputVarName)\r\n\t\t\treturn origin_node.getOutputVarName(link.origin_slot);\r\n\t\t//generate\r\n\t\treturn "link_" + origin_node.id + "_" + link.origin_slot;\r\n\t}\r\n\r\n\tfunction getOutputLinkID( node, slot )\r\n\t{\r\n\t\tif (!node.isOutputConnected(slot))\r\n\t\t\treturn null;\r\n\t\treturn "link_" + node.id + "_" + slot;\r\n\t}\r\n\r\n\tLGShaders.registerShaderNode = registerShaderNode;\r\n\tLGShaders.getInputLinkID = getInputLinkID;\r\n\tLGShaders.getOutputLinkID = getOutputLinkID;\r\n\tLGShaders.getShaderNodeVarName = getShaderNodeVarName;\r\n\tLGShaders.parseGLSLDescriptions = parseGLSLDescriptions;\r\n\r\n\t//given a const number, it transform it to a string that matches a type\r\n\tvar valueToGLSL = LiteGraph.valueToGLSL = function valueToGLSL( v, type, precision )\r\n\t{\r\n\t\tvar n = 5; //num decimals\r\n\t\tif(precision != null)\r\n\t\t\tn = precision;\r\n\t\tif(!type)\r\n\t\t{\r\n\t\t\tif(v.constructor === Number)\r\n\t\t\t\ttype = "float";\r\n\t\t\telse if(v.length)\r\n\t\t\t{\r\n\t\t\t\tswitch(v.length)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase 2: type = "vec2"; break;\r\n\t\t\t\t\tcase 3: type = "vec3"; break;\r\n\t\t\t\t\tcase 4: type = "vec4"; break;\r\n\t\t\t\t\tcase 9: type = "mat3"; break;\r\n\t\t\t\t\tcase 16: type = "mat4"; break;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow("unknown type for glsl value size");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tthrow("unknown type for glsl value: " + v.constructor);\r\n\t\t}\r\n\t\tswitch(type)\r\n\t\t{\r\n\t\t\tcase \'float\': return v.toFixed(n); break;\r\n\t\t\tcase \'vec2\': return "vec2(" + v[0].toFixed(n) + "," + v[1].toFixed(n) + ")"; break;\r\n\t\t\tcase \'color3\':\r\n\t\t\tcase \'vec3\': return "vec3(" + v[0].toFixed(n) + "," + v[1].toFixed(n) + "," + v[2].toFixed(n) + ")"; break;\r\n\t\t\tcase \'color4\':\r\n\t\t\tcase \'vec4\': return "vec4(" + v[0].toFixed(n) + "," + v[1].toFixed(n) + "," + v[2].toFixed(n) + "," + v[3].toFixed(n) + ")"; break;\r\n\t\t\tcase \'mat3\': return "mat3(1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0)"; break; //not fully supported yet\r\n\t\t\tcase \'mat4\': return "mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0)"; break;//not fully supported yet\r\n\t\t\tdefault:\r\n\t\t\t\tthrow("unknown glsl type in valueToGLSL:", type);\r\n\t\t}\r\n\r\n\t\treturn "";\r\n\t}\r\n\r\n\t//makes sure that a var is of a type, and if not, it converts it\r\n\tvar varToTypeGLSL = LiteGraph.varToTypeGLSL = function varToTypeGLSL( v, input_type, output_type )\r\n\t{\r\n\t\tif(input_type == output_type)\r\n\t\t\treturn v;\r\n\t\tif(v == null)\r\n\t\t\tswitch(output_type)\r\n\t\t\t{\r\n\t\t\t\tcase "float": return "0.0";\r\n\t\t\t\tcase "vec2":  return "vec2(0.0)";\r\n\t\t\t\tcase "vec3":  return "vec3(0.0)";\r\n\t\t\t\tcase "vec4":  return "vec4(0.0,0.0,0.0,1.0)";\r\n\t\t\t\tdefault: //null\r\n\t\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\tif(!output_type)\r\n\t\t\tthrow("error: no output type specified");\r\n\t\tif(output_type == "float")\r\n\t\t{\r\n\t\t\tswitch(input_type)\r\n\t\t\t{\r\n\t\t\t\t//case "float":\r\n\t\t\t\tcase "vec2":\r\n\t\t\t\tcase "vec3":\r\n\t\t\t\tcase "vec4":\r\n\t\t\t\t\treturn v + ".x";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault: //null\r\n\t\t\t\t\treturn "0.0";\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(output_type == "vec2")\r\n\t\t{\r\n\t\t\tswitch(input_type)\r\n\t\t\t{\r\n\t\t\t\tcase "float":\r\n\t\t\t\t\treturn "vec2("+v+")";\r\n\t\t\t\t//case "vec2":\r\n\t\t\t\tcase "vec3":\r\n\t\t\t\tcase "vec4":\r\n\t\t\t\t\treturn v + ".xy";\r\n\t\t\t\tdefault: //null\r\n\t\t\t\t\treturn "vec2(0.0)";\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(output_type == "vec3")\r\n\t\t{\r\n\t\t\tswitch(input_type)\r\n\t\t\t{\r\n\t\t\t\tcase "float":\r\n\t\t\t\t\treturn "vec3("+v+")";\r\n\t\t\t\tcase "vec2":\r\n\t\t\t\t\treturn "vec3(" + v + ",0.0)";\r\n\t\t\t\t//case "vec3":\r\n\t\t\t\tcase "vec4":\r\n\t\t\t\t\treturn v + ".xyz";\r\n\t\t\t\tdefault: //null\r\n\t\t\t\t\treturn "vec3(0.0)";\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(output_type == "vec4")\r\n\t\t{\r\n\t\t\tswitch(input_type)\r\n\t\t\t{\r\n\t\t\t\tcase "float":\r\n\t\t\t\t\treturn "vec4("+v+")";\r\n\t\t\t\tcase "vec2":\r\n\t\t\t\t\treturn "vec4(" + v + ",0.0,1.0)";\r\n\t\t\t\tcase "vec3":\r\n\t\t\t\t\treturn "vec4(" + v + ",1.0)";\r\n\t\t\t\tdefault: //null\r\n\t\t\t\t\treturn "vec4(0.0,0.0,0.0,1.0)";\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow("type cannot be converted");\r\n\t}\r\n\r\n\r\n\t//used to plug incompatible stuff\r\n\tvar convertVarToGLSLType = LiteGraph.convertVarToGLSLType = function convertVarToGLSLType( varname, type, target_type )\r\n\t{\r\n\t\tif(type == target_type)\r\n\t\t\treturn varname;\r\n\t\tif(type == "float")\r\n\t\t\treturn target_type + "(" + varname + ")";\r\n\t\tif(target_type == "vec2") //works for vec2,vec3 and vec4\r\n\t\t\treturn "vec2(" + varname + ".xy)";\r\n\t\tif(target_type == "vec3") //works for vec2,vec3 and vec4\r\n\t\t{\r\n\t\t\tif(type == "vec2")\r\n\t\t\t\treturn "vec3(" + varname + ",0.0)";\r\n\t\t\tif(type == "vec4")\r\n\t\t\t\treturn "vec4(" + varname + ".xyz)";\r\n\t\t}\r\n\t\tif(target_type == "vec4")\r\n\t\t{\r\n\t\t\tif(type == "vec2")\r\n\t\t\t\treturn "vec4(" + varname + ",0.0,0.0)";\r\n\t\t\tif(target_type == "vec3")\r\n\t\t\t\treturn "vec4(" + varname + ",1.0)";\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t//used to host a shader body **************************************\r\n\tfunction LGShaderContext()\r\n\t{\r\n\t\t//to store the code template\r\n\t\tthis.vs_template = "";\r\n\t\tthis.fs_template = "";\r\n\r\n\t\t//required so nodes now where to fetch the input data\r\n\t\tthis.buffer_names = {\r\n\t\t\tuvs: "v_coord"\r\n\t\t};\r\n\r\n\t\tthis.extra = {}; //to store custom info from the nodes (like if this shader supports a feature, etc)\r\n\r\n\t\tthis._functions = {};\r\n\t\tthis._uniforms = {};\r\n\t\tthis._codeparts = {};\r\n\t\tthis._uniform_value = null;\r\n\t}\r\n\r\n\tLGShaderContext.prototype.clear = function()\r\n\t{\r\n\t\tthis._uniforms = {};\r\n\t\tthis._functions = {};\r\n\t\tthis._codeparts = {};\r\n\t\tthis._uniform_value = null;\r\n\r\n\t\tthis.extra = {};\r\n\t}\r\n\r\n\tLGShaderContext.prototype.addUniform = function( name, type, value )\r\n\t{\r\n\t\tthis._uniforms[ name ] = type;\r\n\t\tif(value != null)\r\n\t\t{\r\n\t\t\tif(!this._uniform_value)\r\n\t\t\t\tthis._uniform_value = {};\r\n\t\t\tthis._uniform_value[name] = value;\r\n\t\t}\r\n\t}\r\n\r\n\tLGShaderContext.prototype.addFunction = function( name, code )\r\n\t{\r\n\t\tthis._functions[name] = code;\r\n\t}\r\n\r\n\tLGShaderContext.prototype.addCode = function( hook, code, destinations )\r\n\t{\r\n\t\tdestinations = destinations || {"":""};\r\n\t\tfor(var i in destinations)\r\n\t\t{\r\n\t\t\tvar h = i ? i + "_" + hook : hook;\r\n\t\t\tif(!this._codeparts[ h ])\r\n\t\t\t\tthis._codeparts[ h ] = code + "\\n";\r\n\t\t\telse\r\n\t\t\t\tthis._codeparts[ h ] += code + "\\n";\r\n\t\t}\r\n\t}\r\n\r\n\t//the system works by grabbing code fragments from every node and concatenating them in blocks depending on where must they be attached\r\n\tLGShaderContext.prototype.computeCodeBlocks = function( graph, extra_uniforms )\r\n\t{\r\n\t\t//prepare context\r\n\t\tthis.clear();\r\n\r\n\t\t//grab output nodes\r\n\t\tvar vertexout = graph.findNodesByType("shader::output/vertex");\r\n\t\tvertexout = vertexout && vertexout.length ? vertexout[0] : null;\r\n\t\tvar fragmentout = graph.findNodesByType("shader::output/fragcolor");\r\n\t\tfragmentout = fragmentout && fragmentout.length ? fragmentout[0] : null;\r\n\t\tif(!fragmentout) //??\r\n\t\t\treturn null; \r\n\r\n\t\t//propagate back destinations\r\n\t\tgraph.sendEventToAllNodes( "clearDestination" );\r\n\t\tif(vertexout)\r\n\t\t\tvertexout.propagateDestination("vs");\r\n\t\tif(fragmentout)\r\n\t\t\tfragmentout.propagateDestination("fs");\r\n\r\n\t\t//gets code from graph\r\n\t\tgraph.sendEventToAllNodes("onGetCode", this );\r\n\r\n\t\tvar uniforms = "";\r\n\t\tfor(var i in this._uniforms)\r\n\t\t\tuniforms += "uniform " + this._uniforms[i] + " " + i + ";\\n";\r\n\t\tif(extra_uniforms)\r\n\t\t\tfor(var i in extra_uniforms)\r\n\t\t\t\tuniforms += "uniform " + extra_uniforms[i] + " " + i + ";\\n";\r\n\r\n\t\tvar functions = "";\r\n\t\tfor(var i in this._functions)\r\n\t\t\tfunctions += "//" + i + "\\n" + this._functions[i] + "\\n";\r\n\r\n\t\tvar blocks = this._codeparts;\r\n\t\tblocks.uniforms = uniforms;\r\n\t\tblocks.functions = functions;\r\n\t\treturn blocks;\r\n\t}\r\n\r\n\t//replaces blocks using the vs and fs template and returns the final codes\r\n\tLGShaderContext.prototype.computeShaderCode = function( graph )\r\n\t{\r\n\t\tvar blocks = this.computeCodeBlocks( graph );\r\n\t\tvar vs_code = GL.Shader.replaceCodeUsingContext( this.vs_template, blocks );\r\n\t\tvar fs_code = GL.Shader.replaceCodeUsingContext( this.fs_template, blocks );\r\n\t\treturn {\r\n\t\t\tvs_code: vs_code,\r\n\t\t\tfs_code: fs_code\r\n\t\t};\r\n\t}\r\n\r\n\t//generates the shader code from the template and the \r\n\tLGShaderContext.prototype.computeShader = function( graph, shader )\r\n\t{\r\n\t\tvar finalcode = this.computeShaderCode( graph );\r\n\t\tconsole.log( finalcode.vs_code, finalcode.fs_code );\r\n\r\n\t\tif(!LiteGraph.catch_exceptions)\r\n\t\t{\r\n\t\t\tthis._shader_error = true;\r\n\t\t\tif(shader)\r\n\t\t\t\tshader.updateShader( finalcode.vs_code, finalcode.fs_code );\r\n\t\t\telse\r\n\t\t\t\tshader = new GL.Shader( finalcode.vs_code, finalcode.fs_code );\r\n\t\t\tthis._shader_error = false;\r\n\t\t\treturn shader;\r\n\t\t}\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tif(shader)\r\n\t\t\t\tshader.updateShader( finalcode.vs_code, finalcode.fs_code );\r\n\t\t\telse\r\n\t\t\t\tshader = new GL.Shader( finalcode.vs_code, finalcode.fs_code );\r\n\t\t\tthis._shader_error = false;\r\n\t\t\treturn shader;\r\n\t\t}\r\n\t\tcatch (err)\r\n\t\t{\r\n\t\t\tif(!this._shader_error)\r\n\t\t\t{\r\n\t\t\t\tconsole.error(err);\r\n\t\t\t\tif(err.indexOf("Fragment shader") != -1)\r\n\t\t\t\t\tconsole.log( finalcode.fs_code.split("\\n").map(function(v,i){ return i + ".- " + v; }).join("\\n") );\r\n\t\t\t\telse\r\n\t\t\t\t\tconsole.log( finalcode.vs_code );\r\n\t\t\t}\r\n\t\t\tthis._shader_error = true;\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn null;//never here\r\n\t}\r\n\r\n\tLGShaderContext.prototype.getShader = function( graph )\r\n\t{\r\n\t\t//if graph not changed?\r\n\t\tif(this._shader && this._shader._version == graph._version)\r\n\t\t\treturn this._shader;\r\n\r\n\t\t//compile shader\r\n\t\tvar shader = this.computeShader( graph, this._shader );\r\n\t\tif(!shader)\r\n\t\t\treturn null;\r\n\t\t\r\n\t\tthis._shader = shader;\r\n\t\tshader._version = graph._version;\r\n\t\treturn shader;\r\n\t}\r\n\r\n\t//some shader nodes could require to fill the box with some uniforms\r\n\tLGShaderContext.prototype.fillUniforms = function( uniforms, param )\r\n\t{\r\n\t\tif(!this._uniform_value)\r\n\t\t\treturn;\r\n\r\n\t\tfor(var i in this._uniform_value)\r\n\t\t{\r\n\t\t\tvar v = this._uniform_value[i];\r\n\t\t\tif(v == null)\r\n\t\t\t\tcontinue;\r\n\t\t\tif(v.constructor === Function)\r\n\t\t\t\tuniforms[i] = v.call( this, param );\r\n\t\t\telse if(v.constructor === GL.Texture)\r\n\t\t\t{\r\n\t\t\t\t//todo...\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tuniforms[i] = v;\r\n\t\t}\r\n\t}\r\n\r\n\tLiteGraph.ShaderContext = LiteGraph.Shaders.Context = LGShaderContext;\r\n\r\n\t// LGraphShaderGraph *****************************\r\n\t// applies a shader graph to texture, it can be uses as an example\r\n\r\n\tfunction LGraphShaderGraph() {\r\n\r\n\t\t//before inputs\r\n        this.subgraph = new LiteGraph.LGraph();\r\n        this.subgraph._subgraph_node = this;\r\n        this.subgraph._is_subgraph = true;\r\n\t\tthis.subgraph.filter = "shader";\r\n\r\n\t\tthis.addInput("in", "texture");\r\n\t\tthis.addOutput("out", "texture");\r\n\t\tthis.properties = { width: 0, height: 0, alpha: false, precision: typeof(LGraphTexture) != "undefined" ? LGraphTexture.DEFAULT : 2 };\r\n\r\n\t\tvar inputNode = this.subgraph.findNodesByType("shader::input/uniform")[0];\r\n\t\tinputNode.pos = [200,300];\r\n\r\n\t\tvar sampler = LiteGraph.createNode("shader::texture/sampler2D");\r\n\t\tsampler.pos = [400,300];\r\n\t\tthis.subgraph.add( sampler );\r\n\r\n\t\tvar outnode = LiteGraph.createNode("shader::output/fragcolor");\r\n\t\toutnode.pos = [600,300];\r\n\t\tthis.subgraph.add( outnode );\r\n\r\n\t\tinputNode.connect( 0, sampler );\r\n\t\tsampler.connect( 0, outnode );\r\n\r\n\t\tthis.size = [180,60];\r\n\t\tthis.redraw_on_mouse = true; //force redraw\r\n\r\n\t\tthis._uniforms = {};\r\n\t\tthis._shader = null;\r\n\t\tthis._context = new LGShaderContext();\r\n\t\tthis._context.vs_template = "#define VERTEX\\n" + GL.Shader.SCREEN_VERTEX_SHADER;\r\n\t\tthis._context.fs_template = LGraphShaderGraph.template;\r\n\t}\r\n\r\n\tLGraphShaderGraph.template = "\\n\\\r\n#define FRAGMENT\\n\\\r\nprecision highp float;\\n\\\r\nvarying vec2 v_coord;\\n\\\r\n{{varying}}\\n\\\r\n{{uniforms}}\\n\\\r\n{{functions}}\\n\\\r\n{{fs_functions}}\\n\\\r\nvoid main() {\\n\\n\\\r\nvec2 uv = v_coord;\\n\\\r\nvec4 fragcolor = vec4(0.0);\\n\\\r\nvec4 fragcolor1 = vec4(0.0);\\n\\\r\n{{fs_code}}\\n\\\r\ngl_FragColor = fragcolor;\\n\\\r\n}\\n\\\r\n\t";\r\n\r\n\tLGraphShaderGraph.widgets_info = {\r\n\t\tprecision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\r\n\t};\r\n\r\n\tLGraphShaderGraph.title = "ShaderGraph";\r\n\tLGraphShaderGraph.desc = "Builds a shader using a graph";\r\n\tLGraphShaderGraph.input_node_type = "input/uniform";\r\n\tLGraphShaderGraph.output_node_type = "output/fragcolor";\r\n\tLGraphShaderGraph.title_color = SHADERNODES_COLOR;\r\n\r\n\tLGraphShaderGraph.prototype.onSerialize = function(o)\r\n\t{\r\n\t\to.subgraph = this.subgraph.serialize();\r\n\t}\r\n\r\n\tLGraphShaderGraph.prototype.onConfigure = function(o)\r\n\t{\r\n\t\tthis.subgraph.configure(o.subgraph);\r\n\t}\r\n\r\n\tLGraphShaderGraph.prototype.onExecute = function() {\r\n\t\tif (!this.isOutputConnected(0))\r\n\t\t\treturn;\r\n\r\n\t\t//read input texture\r\n\t\tvar intex = this.getInputData(0);\r\n\t\tif(intex && intex.constructor != GL.Texture)\r\n\t\t\tintex = null;\r\n\r\n\t\tvar w = this.properties.width | 0;\r\n\t\tvar h = this.properties.height | 0;\r\n\t\tif (w == 0) {\r\n\t\t\tw = intex ? intex.width : gl.viewport_data[2];\r\n\t\t} //0 means default\r\n\t\tif (h == 0) {\r\n\t\t\th = intex ? intex.height : gl.viewport_data[3];\r\n\t\t} //0 means default\r\n\r\n\t\tvar type = LGraphTexture.getTextureType( this.properties.precision, intex );\r\n\r\n\t\tvar texture = this._texture;\r\n\t\tif ( !texture || texture.width != w || texture.height != h || texture.type != type ) {\r\n\t\t\ttexture = this._texture = new GL.Texture(w, h, {\r\n\t\t\t\ttype: type,\r\n\t\t\t\tformat: this.alpha ? gl.RGBA : gl.RGB,\r\n\t\t\t\tfilter: gl.LINEAR\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\tvar shader = this.getShader( this.subgraph );\r\n\t\tif(!shader)\r\n\t\t\treturn;\r\n\r\n\t\tvar uniforms = this._uniforms;\r\n\t\tthis._context.fillUniforms( uniforms );\r\n\r\n\t\tvar tex_slot = 0;\r\n\t\tif(this.inputs)\r\n\t\tfor(var i = 0; i < this.inputs.length; ++i)\r\n\t\t{\r\n\t\t\tvar input = this.inputs[i];\r\n\t\t\tvar data = this.getInputData(i);\r\n\t\t\tif(input.type == "texture")\r\n\t\t\t{\r\n\t\t\t\tif(!data)\r\n\t\t\t\t\tdata = GL.Texture.getWhiteTexture();\r\n\t\t\t\tdata = data.bind(tex_slot++);\r\n\t\t\t}\r\n\r\n\t\t\tif(data != null)\r\n\t\t\t\tuniforms[ "u_" + input.name ] = data;\r\n\t\t}\r\n\r\n\t\tvar mesh = GL.Mesh.getScreenQuad();\r\n\r\n\t\tgl.disable( gl.DEPTH_TEST );\r\n\t\tgl.disable( gl.BLEND );\r\n\r\n\t\ttexture.drawTo(function(){\r\n\t\t\tshader.uniforms( uniforms );\r\n\t\t\tshader.draw( mesh );\r\n\t\t});\r\n\r\n\t\t//use subgraph output \r\n\t\tthis.setOutputData(0, texture );\r\n\t};\r\n\r\n\t//add input node inside subgraph\r\n\tLGraphShaderGraph.prototype.onInputAdded = function( slot_info )\r\n\t{\r\n\t\tvar subnode = LiteGraph.createNode("shader::input/uniform");\r\n\t\tsubnode.setProperty("name",slot_info.name);\r\n\t\tsubnode.setProperty("type",slot_info.type);\r\n\t\tthis.subgraph.add( subnode );\r\n\t}\r\n\r\n\t//remove all\r\n\tLGraphShaderGraph.prototype.onInputRemoved = function( slot, slot_info )\r\n\t{\r\n\t\tvar nodes = this.subgraph.findNodesByType("shader::input/uniform");\r\n\t\tfor(var i = 0; i < nodes.length; ++i)\r\n\t\t{\r\n\t\t\tvar node = nodes[i];\r\n\t\t\tif(node.properties.name == slot_info.name )\r\n\t\t\t\tthis.subgraph.remove( node );\r\n\t\t}\r\n\t}\r\n\r\n\tLGraphShaderGraph.prototype.computeSize = function()\r\n\t{\r\n\t\tvar num_inputs = this.inputs ? this.inputs.length : 0;\r\n\t\tvar num_outputs = this.outputs ? this.outputs.length : 0;\r\n\t\treturn [ 200, Math.max(num_inputs,num_outputs) * LiteGraph.NODE_SLOT_HEIGHT + LiteGraph.NODE_TITLE_HEIGHT + 10];\r\n\t}\r\n\r\n\tLGraphShaderGraph.prototype.getShader = function()\r\n\t{\r\n\t\tvar shader = this._context.getShader( this.subgraph );\r\n\t\tif(!shader)\r\n\t\t\tthis.boxcolor = "red";\r\n\t\telse\r\n\t\t\tthis.boxcolor = null;\r\n\t\treturn shader;\r\n\t}\r\n\r\n\tLGraphShaderGraph.prototype.onDrawBackground = function(ctx, graphcanvas, canvas, pos)\r\n\t{\r\n\t\tif(this.flags.collapsed)\r\n\t\t\treturn;\r\n\r\n\t\t//allows to preview the node if the canvas is a webgl canvas\r\n\t\tvar tex = this.getOutputData(0);\r\n\t\tvar inputs_y = this.inputs ? this.inputs.length * LiteGraph.NODE_SLOT_HEIGHT : 0;\r\n\t\tif (tex && ctx == tex.gl && this.size[1] > inputs_y + LiteGraph.NODE_TITLE_HEIGHT ) {\r\n\t\t\tctx.drawImage( tex, 10,y, this.size[0] - 20, this.size[1] - inputs_y - LiteGraph.NODE_TITLE_HEIGHT );\r\n\t\t}\r\n\r\n\t\tvar y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;\r\n\r\n\t\t//button\r\n\t\tvar over = LiteGraph.isInsideRectangle(pos[0],pos[1],this.pos[0],this.pos[1] + y,this.size[0],LiteGraph.NODE_TITLE_HEIGHT);\r\n\t\tctx.fillStyle = over ? "#555" : "#222";\r\n\t\tctx.beginPath();\r\n\t\tif (this._shape == LiteGraph.BOX_SHAPE)\r\n\t\t\tctx.rect(0, y, this.size[0]+1, LiteGraph.NODE_TITLE_HEIGHT);\r\n\t\telse\r\n\t\t\tctx.roundRect( 0, y, this.size[0]+1, LiteGraph.NODE_TITLE_HEIGHT, 0, 8);\r\n\t\tctx.fill();\r\n\r\n\t\t//button\r\n\t\tctx.textAlign = "center";\r\n\t\tctx.font = "24px Arial";\r\n\t\tctx.fillStyle = over ? "#DDD" : "#999";\r\n\t\tctx.fillText( "+", this.size[0] * 0.5, y + 24 );\r\n\t}\r\n\r\n\tLGraphShaderGraph.prototype.onMouseDown = function(e, localpos, graphcanvas)\r\n\t{\r\n\t\tvar y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;\r\n\t\tif(localpos[1] > y)\r\n\t\t{\r\n\t\t\tgraphcanvas.showSubgraphPropertiesDialog(this);\r\n\t\t}\r\n\t}\r\n\r\n\tLGraphShaderGraph.prototype.onDrawSubgraphBackground = function(graphcanvas)\r\n\t{\r\n\t\t//TODO\r\n\t}\r\n\r\n\tLGraphShaderGraph.prototype.getExtraMenuOptions = function(graphcanvas)\r\n\t{\r\n\t\tvar that = this;\r\n\t\tvar options = [{ content: "Print Code", callback: function(){\r\n\t\t\tvar code = that._context.computeShaderCode();\r\n\t\t\tconsole.log( code.vs_code, code.fs_code );\r\n\t\t}}];\r\n\r\n\t\treturn options;\r\n\t}\r\n\r\n\tLiteGraph.registerNodeType( "texture/shaderGraph", LGraphShaderGraph );\r\n\r\n\tfunction shaderNodeFromFunction( classname, params, return_type, code )\r\n\t{\r\n\t\t//TODO\r\n\t}\r\n\r\n\t//Shader Nodes ***********************************************************\r\n\r\n\t//applies a shader graph to a code\r\n\tfunction LGraphShaderUniform() {\r\n\t\tthis.addOutput("out", "");\r\n\t\tthis.properties = { name: "", type: "" };\r\n\t}\r\n\r\n\tLGraphShaderUniform.title = "Uniform";\r\n\tLGraphShaderUniform.desc = "Input data for the shader";\r\n\r\n\tLGraphShaderUniform.prototype.getTitle = function()\r\n\t{\r\n\t\tif( this.properties.name && this.flags.collapsed)\r\n\t\t\treturn this.properties.type + " " + this.properties.name;\r\n\t\treturn "Uniform";\r\n\t}\r\n\r\n\tLGraphShaderUniform.prototype.onPropertyChanged = function(name,value)\r\n\t{\r\n\t\tthis.outputs[0].name = this.properties.type + " " + this.properties.name;\r\n\t}\r\n\r\n\tLGraphShaderUniform.prototype.onGetCode = function( context )\r\n\t{\r\n\t\tif(!this.shader_destination)\r\n\t\t\treturn;\r\n\r\n\t\tvar type = this.properties.type;\r\n\t\tif( !type )\r\n\t\t{\r\n\t\t\tif( !context.onGetPropertyInfo )\r\n\t\t\t\treturn;\r\n\t\t\tvar info = context.onGetPropertyInfo( this.property.name );\r\n\t\t\tif(!info)\r\n\t\t\t\treturn;\r\n\t\t\ttype = info.type;\r\n\t\t}\r\n\t\tif(type == "number")\r\n\t\t\ttype = "float";\r\n\t\telse if(type == "texture")\r\n\t\t\ttype = "sampler2D";\r\n\t\tif ( LGShaders.GLSL_types.indexOf(type) == -1 )\r\n\t\t\treturn;\r\n\r\n\t\tcontext.addUniform( "u_" + this.properties.name, type );\r\n\t\tthis.setOutputData( 0, type );\r\n\t}\r\n\r\n\tLGraphShaderUniform.prototype.getOutputVarName = function(slot)\r\n\t{\r\n\t\treturn "u_" + this.properties.name;\r\n\t}\r\n\r\n\tregisterShaderNode( "input/uniform", LGraphShaderUniform );\r\n\r\n\r\n\tfunction LGraphShaderAttribute() {\r\n\t\tthis.addOutput("out", "vec2");\r\n\t\tthis.properties = { name: "coord", type: "vec2" };\r\n\t}\r\n\r\n\tLGraphShaderAttribute.title = "Attribute";\r\n\tLGraphShaderAttribute.desc = "Input data from mesh attribute";\r\n\r\n\tLGraphShaderAttribute.prototype.getTitle = function()\r\n\t{\r\n\t\treturn "att. " + this.properties.name;\r\n\t}\r\n\r\n\tLGraphShaderAttribute.prototype.onGetCode = function( context )\r\n\t{\r\n\t\tif(!this.shader_destination)\r\n\t\t\treturn;\r\n\r\n\t\tvar type = this.properties.type;\r\n\t\tif( !type || LGShaders.GLSL_types.indexOf(type) == -1 )\r\n\t\t\treturn;\r\n\t\tif(type == "number")\r\n\t\t\ttype = "float";\r\n\t\tif( this.properties.name != "coord")\r\n\t\t{\r\n\t\t\tcontext.addCode( "varying", " varying " + type +" v_" + this.properties.name + ";" );\r\n\t\t\t//if( !context.varyings[ this.properties.name ] )\r\n\t\t\t//context.addCode( "vs_code", "v_" + this.properties.name + " = " + input_name + ";" );\r\n\t\t}\r\n\t\tthis.setOutputData( 0, type );\r\n\t}\r\n\r\n\tLGraphShaderAttribute.prototype.getOutputVarName = function(slot)\r\n\t{\r\n\t\treturn "v_" + this.properties.name;\r\n\t}\r\n\r\n\tregisterShaderNode( "input/attribute", LGraphShaderAttribute );\r\n\r\n\tfunction LGraphShaderSampler2D() {\r\n\t\tthis.addInput("tex", "sampler2D");\r\n\t\tthis.addInput("uv", "vec2");\r\n\t\tthis.addOutput("rgba", "vec4");\r\n\t\tthis.addOutput("rgb", "vec3");\r\n\t}\r\n\r\n\tLGraphShaderSampler2D.title = "Sampler2D";\r\n\tLGraphShaderSampler2D.desc = "Reads a pixel from a texture";\r\n\r\n\tLGraphShaderSampler2D.prototype.onGetCode = function( context )\r\n\t{\r\n\t\tif(!this.shader_destination)\r\n\t\t\treturn;\r\n\r\n\t\tvar texname = getInputLinkID( this, 0 );\r\n\t\tvar varname = getShaderNodeVarName(this);\r\n\t\tvar code = "vec4 " + varname + " = vec4(0.0);\\n";\r\n\t\tif(texname)\r\n\t\t{\r\n\t\t\tvar uvname = getInputLinkID( this, 1 ) || context.buffer_names.uvs;\r\n\t\t\tcode += varname + " = texture2D("+texname+","+uvname+");\\n";\r\n\t\t}\r\n\r\n\t\tvar link0 = getOutputLinkID( this, 0 );\r\n\t\tif(link0)\r\n\t\t\tcode += "vec4 " + getOutputLinkID( this, 0 ) + " = "+varname+";\\n";\r\n\r\n\t\tvar link1 = getOutputLinkID( this, 1 );\r\n\t\tif(link1)\r\n\t\t\tcode += "vec3 " + getOutputLinkID( this, 1 ) + " = "+varname+".xyz;\\n";\r\n\r\n\t\tcontext.addCode( "code", code, this.shader_destination );\r\n\t\tthis.setOutputData( 0, "vec4" );\r\n\t\tthis.setOutputData( 1, "vec3" );\r\n\t}\r\n\r\n\tregisterShaderNode( "texture/sampler2D", LGraphShaderSampler2D );\r\n\r\n\t//*********************************\r\n\r\n\tfunction LGraphShaderConstant()\r\n\t{\r\n\t\tthis.addOutput("","float");\r\n\r\n\t\tthis.properties = {\r\n\t\t\ttype: "float",\r\n\t\t\tvalue: 0\r\n\t\t};\r\n\r\n\t\tthis.addWidget("combo","type","float",null, { values: GLSL_types_const, property: "type" } );\r\n\t\tthis.updateWidgets();\r\n\t}\r\n\r\n\tLGraphShaderConstant.title = "const";\r\n\r\n\tLGraphShaderConstant.prototype.getTitle = function()\r\n\t{\r\n\t\tif(this.flags.collapsed)\r\n\t\t\treturn valueToGLSL( this.properties.value, this.properties.type, 2 );\r\n\t\treturn "Const";\r\n\t}\r\n\r\n\tLGraphShaderConstant.prototype.onPropertyChanged = function(name,value)\r\n\t{\r\n\t\tvar that = this;\r\n\t\tif(name == "type")\r\n\t\t{\r\n\t\t\tif(this.outputs[0].type != value)\r\n\t\t\t{\r\n\t\t\t\tthis.disconnectOutput(0);\r\n\t\t\t\tthis.outputs[0].type = value;\r\n\t\t\t}\r\n\t\t\tthis.widgets.length = 1; //remove extra widgets\r\n\t\t\tthis.updateWidgets();\r\n\t\t}\r\n\t\tif(name == "value")\r\n\t\t{\r\n\t\t\tif(!value.length)\r\n\t\t\t\tthis.widgets[1].value = value;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis.widgets[1].value = value[1];\r\n\t\t\t\tif(value.length > 2)\r\n\t\t\t\t\tthis.widgets[2].value = value[2];\r\n\t\t\t\tif(value.length > 3)\r\n\t\t\t\t\tthis.widgets[3].value = value[3];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tLGraphShaderConstant.prototype.updateWidgets = function( old_value )\r\n\t{\r\n\t\tvar that = this;\r\n\t\tvar old_value = this.properties.value;\r\n\t\tvar options = { step: 0.01 };\r\n\t\tswitch(this.properties.type)\r\n\t\t{\r\n\t\t\tcase \'float\': \r\n\t\t\t\tthis.properties.value = 0;\r\n\t\t\t\tthis.addWidget("number","v",0,{ step:0.01, property: "value" });\r\n\t\t\t\tbreak;\r\n\t\t\tcase \'vec2\': \r\n\t\t\t\tthis.properties.value = old_value && old_value.length == 2 ? [old_value[0],old_value[1]] : [0,0,0];\r\n\t\t\t\tthis.addWidget("number","x",this.properties.value[0], function(v){ that.properties.value[0] = v; },options); \r\n\t\t\t\tthis.addWidget("number","y",this.properties.value[1], function(v){ that.properties.value[1] = v; },options); \r\n\t\t\t\tbreak;\r\n\t\t\tcase \'vec3\': \r\n\t\t\t\tthis.properties.value = old_value && old_value.length == 3 ? [old_value[0],old_value[1],old_value[2]] : [0,0,0];\r\n\t\t\t\tthis.addWidget("number","x",this.properties.value[0], function(v){ that.properties.value[0] = v; },options); \r\n\t\t\t\tthis.addWidget("number","y",this.properties.value[1], function(v){ that.properties.value[1] = v; },options); \r\n\t\t\t\tthis.addWidget("number","z",this.properties.value[2], function(v){ that.properties.value[2] = v; },options); \r\n\t\t\t\tbreak;\r\n\t\t\tcase \'vec4\': \r\n\t\t\t\tthis.properties.value = old_value && old_value.length == 4 ? [old_value[0],old_value[1],old_value[2],old_value[3]] : [0,0,0,0];\r\n\t\t\t\tthis.addWidget("number","x",this.properties.value[0], function(v){ that.properties.value[0] = v; },options); \r\n\t\t\t\tthis.addWidget("number","y",this.properties.value[1], function(v){ that.properties.value[1] = v; },options); \r\n\t\t\t\tthis.addWidget("number","z",this.properties.value[2], function(v){ that.properties.value[2] = v; },options); \r\n\t\t\t\tthis.addWidget("number","w",this.properties.value[3], function(v){ that.properties.value[3] = v; },options); \r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tconsole.error("unknown type for constant");\r\n\t\t}\r\n\t}\r\n\r\n\tLGraphShaderConstant.prototype.onGetCode = function( context )\r\n\t{\r\n\t\tif(!this.shader_destination)\r\n\t\t\treturn;\r\n\r\n\t\tvar value = valueToGLSL( this.properties.value, this.properties.type );\r\n\t\tvar link_name = getOutputLinkID(this,0);\r\n\t\tif(!link_name) //not connected\r\n\t\t\treturn;\r\n\r\n\t\tvar code = "\t" + this.properties.type + " " + link_name + " = " + value + ";";\r\n\t\tcontext.addCode( "code", code, this.shader_destination );\r\n\r\n\t\tthis.setOutputData( 0, this.properties.type );\r\n\t}\r\n\r\n\tregisterShaderNode( "const/const", LGraphShaderConstant );\r\n\r\n\tfunction LGraphShaderVec2()\r\n\t{\r\n\t\tthis.addInput("xy","vec2");\r\n\t\tthis.addInput("x","float");\r\n\t\tthis.addInput("y","float");\r\n\t\tthis.addOutput("xy","vec2");\r\n\t\tthis.addOutput("x","float");\r\n\t\tthis.addOutput("y","float");\r\n\r\n\t\tthis.properties = { x: 0, y: 0 };\r\n\t}\r\n\r\n\tLGraphShaderVec2.title = "vec2";\r\n\tLGraphShaderVec2.varmodes = ["xy","x","y"];\r\n\r\n\tLGraphShaderVec2.prototype.onPropertyChanged = function()\r\n\t{\r\n\t\tif(this.graph)\r\n\t\t\t this.graph._version++;\r\n\t}\r\n\r\n\tLGraphShaderVec2.prototype.onGetCode = function( context )\r\n\t{\r\n\t\tif(!this.shader_destination)\r\n\t\t\treturn;\r\n\r\n\t\tvar props = this.properties;\r\n\r\n\t\tvar varname = getShaderNodeVarName(this);\r\n\t\tvar code = "\tvec2 " + varname + " = " + valueToGLSL([props.x,props.y]) + ";\\n";\r\n\r\n\t\tfor(var i = 0;i < LGraphShaderVec2.varmodes.length; ++i)\r\n\t\t{\r\n\t\t\tvar varmode = LGraphShaderVec2.varmodes[i];\r\n\t\t\tvar inlink = getInputLinkID(this,i);\r\n\t\t\tif(!inlink)\r\n\t\t\t\tcontinue;\r\n\t\t\tcode += "\t" + varname + "."+varmode+" = " + inlink + ";\\n";\r\n\t\t}\r\n\r\n\t\tfor(var i = 0;i < LGraphShaderVec2.varmodes.length; ++i)\r\n\t\t{\r\n\t\t\tvar varmode = LGraphShaderVec2.varmodes[i];\r\n\t\t\tvar outlink = getOutputLinkID(this,i);\r\n\t\t\tif(!outlink)\r\n\t\t\t\tcontinue;\r\n\t\t\tvar type = GLSL_types_const[varmode.length - 1];\r\n\t\t\tcode += "\t"+type+" " + outlink + " = " + varname + "." + varmode + ";\\n";\r\n\t\t\tthis.setOutputData( i, type );\r\n\t\t}\r\n\r\n\t\tcontext.addCode( "code", code, this.shader_destination );\r\n\t}\r\n\r\n\tregisterShaderNode( "const/vec2", LGraphShaderVec2 );\t\r\n\r\n\tfunction LGraphShaderVec3()\r\n\t{\r\n\t\tthis.addInput("xyz","vec3");\r\n\t\tthis.addInput("x","float");\r\n\t\tthis.addInput("y","float");\r\n\t\tthis.addInput("z","float");\r\n\t\tthis.addInput("xy","vec2");\r\n\t\tthis.addInput("xz","vec2");\r\n\t\tthis.addInput("yz","vec2");\r\n\t\tthis.addOutput("xyz","vec3");\r\n\t\tthis.addOutput("x","float");\r\n\t\tthis.addOutput("y","float");\r\n\t\tthis.addOutput("z","float");\r\n\t\tthis.addOutput("xy","vec2");\r\n\t\tthis.addOutput("xz","vec2");\r\n\t\tthis.addOutput("yz","vec2");\r\n\r\n\t\tthis.properties = { x:0, y: 0, z: 0 };\r\n\t}\r\n\r\n\tLGraphShaderVec3.title = "vec3";\r\n\tLGraphShaderVec3.varmodes = ["xyz","x","y","z","xy","xz","yz"];\r\n\r\n\tLGraphShaderVec3.prototype.onPropertyChanged = function()\r\n\t{\r\n\t\tif(this.graph)\r\n\t\t\tthis.graph._version++;\r\n\t}\r\n\r\n\tLGraphShaderVec3.prototype.onGetCode = function( context )\r\n\t{\r\n\t\tif(!this.shader_destination)\r\n\t\t\treturn;\r\n\r\n\t\tvar props = this.properties;\r\n\r\n\t\tvar varname = getShaderNodeVarName(this);\r\n\t\tvar code = "vec3 " + varname + " = " + valueToGLSL([props.x,props.y,props.z]) + ";\\n";\r\n\r\n\t\tfor(var i = 0;i < LGraphShaderVec3.varmodes.length; ++i)\r\n\t\t{\r\n\t\t\tvar varmode = LGraphShaderVec3.varmodes[i];\r\n\t\t\tvar inlink = getInputLinkID(this,i);\r\n\t\t\tif(!inlink)\r\n\t\t\t\tcontinue;\r\n\t\t\tcode += "\t" + varname + "."+varmode+" = " + inlink + ";\\n";\r\n\t\t}\r\n\r\n\t\tfor(var i = 0; i < LGraphShaderVec3.varmodes.length; ++i)\r\n\t\t{\r\n\t\t\tvar varmode = LGraphShaderVec3.varmodes[i];\r\n\t\t\tvar outlink = getOutputLinkID(this,i);\r\n\t\t\tif(!outlink)\r\n\t\t\t\tcontinue;\r\n\t\t\tvar type = GLSL_types_const[varmode.length - 1];\r\n\t\t\tcode += "\t"+type+" " + outlink + " = " + varname + "." + varmode + ";\\n";\r\n\t\t\tthis.setOutputData( i, type );\r\n\t\t}\r\n\r\n\t\tcontext.addCode( "code", code, this.shader_destination );\r\n\t}\r\n\r\n\tregisterShaderNode( "const/vec3", LGraphShaderVec3 );\t\r\n\r\n\r\n\tfunction LGraphShaderVec4()\r\n\t{\r\n\t\tthis.addInput("xyzw","vec4");\r\n\t\tthis.addInput("xyz","vec3");\r\n\t\tthis.addInput("x","float");\r\n\t\tthis.addInput("y","float");\r\n\t\tthis.addInput("z","float");\r\n\t\tthis.addInput("w","float");\r\n\t\tthis.addInput("xy","vec2");\r\n\t\tthis.addInput("yz","vec2");\r\n\t\tthis.addInput("zw","vec2");\r\n\t\tthis.addOutput("xyzw","vec4");\r\n\t\tthis.addOutput("xyz","vec3");\r\n\t\tthis.addOutput("x","float");\r\n\t\tthis.addOutput("y","float");\r\n\t\tthis.addOutput("z","float");\r\n\t\tthis.addOutput("xy","vec2");\r\n\t\tthis.addOutput("yz","vec2");\r\n\t\tthis.addOutput("zw","vec2");\r\n\r\n\t\tthis.properties = { x:0, y: 0, z: 0, w: 0 };\r\n\t}\r\n\r\n\tLGraphShaderVec4.title = "vec4";\r\n\tLGraphShaderVec4.varmodes = ["xyzw","xyz","x","y","z","w","xy","yz","zw"];\r\n\r\n\tLGraphShaderVec4.prototype.onPropertyChanged = function()\r\n\t{\r\n\t\tif(this.graph)\r\n\t\t\tthis.graph._version++;\r\n\t}\r\n\r\n\tLGraphShaderVec4.prototype.onGetCode = function( context )\r\n\t{\r\n\t\tif(!this.shader_destination)\r\n\t\t\treturn;\r\n\r\n\t\tvar props = this.properties;\r\n\r\n\t\tvar varname = getShaderNodeVarName(this);\r\n\t\tvar code = "vec4 " + varname + " = " + valueToGLSL([props.x,props.y,props.z,props.w]) + ";\\n";\r\n\r\n\t\tfor(var i = 0;i < LGraphShaderVec4.varmodes.length; ++i)\r\n\t\t{\r\n\t\t\tvar varmode = LGraphShaderVec4.varmodes[i];\r\n\t\t\tvar inlink = getInputLinkID(this,i);\r\n\t\t\tif(!inlink)\r\n\t\t\t\tcontinue;\r\n\t\t\tcode += "\t" + varname + "."+varmode+" = " + inlink + ";\\n";\r\n\t\t}\r\n\r\n\t\tfor(var i = 0;i < LGraphShaderVec4.varmodes.length; ++i)\r\n\t\t{\r\n\t\t\tvar varmode = LGraphShaderVec4.varmodes[i];\r\n\t\t\tvar outlink = getOutputLinkID(this,i);\r\n\t\t\tif(!outlink)\r\n\t\t\t\tcontinue;\r\n\t\t\tvar type = GLSL_types_const[varmode.length - 1];\r\n\t\t\tcode += "\t"+type+" " + outlink + " = " + varname + "." + varmode + ";\\n";\r\n\t\t\tthis.setOutputData( i, type );\r\n\t\t}\r\n\r\n\t\tcontext.addCode( "code", code, this.shader_destination );\r\n\r\n\t}\r\n\r\n\tregisterShaderNode( "const/vec4", LGraphShaderVec4 );\t\r\n\t\r\n\t//*********************************\r\n\r\n\tfunction LGraphShaderFragColor() {\r\n\t\tthis.addInput("color", LGShaders.ALL_TYPES );\r\n\t\tthis.block_delete = true;\r\n\t}\r\n\r\n\tLGraphShaderFragColor.title = "FragColor";\r\n\tLGraphShaderFragColor.desc = "Pixel final color";\r\n\r\n\tLGraphShaderFragColor.prototype.onGetCode = function( context )\r\n\t{\r\n\t\tvar link_name = getInputLinkID( this, 0 );\r\n\t\tif(!link_name)\r\n\t\t\treturn;\r\n\t\tvar type = this.getInputData(0);\r\n\t\tvar code = varToTypeGLSL( link_name, type, "vec4" );\r\n\t\tcontext.addCode("fs_code", "fragcolor = " + code + ";");\r\n\t}\r\n\r\n\tregisterShaderNode( "output/fragcolor", LGraphShaderFragColor );\r\n\r\n\r\n\t/*\r\n\tfunction LGraphShaderDiscard()\r\n\t{\r\n\t\tthis.addInput("v","T");\r\n\t\tthis.addInput("min","T");\r\n\t\tthis.properties = { min_value: 0.0 };\r\n\t\tthis.addWidget("number","min",0,{ step: 0.01, property: "min_value" });\r\n\t}\r\n\r\n\tLGraphShaderDiscard.title = "Discard";\r\n\r\n\tLGraphShaderDiscard.prototype.onGetCode = function( context )\r\n\t{\r\n\t\tif(!this.isOutputConnected(0))\r\n\t\t\treturn;\r\n\r\n\t\tvar inlink = getInputLinkID(this,0);\r\n\t\tvar inlink1 = getInputLinkID(this,1);\r\n\r\n\t\tif(!inlink && !inlink1) //not connected\r\n\t\t\treturn;\r\n\t\tcontext.addCode("code", return_type + " " + outlink + " = ( (" + inlink + " - "+minv+") / ("+ maxv+" - "+minv+") ) * ("+ maxv2+" - "+minv2+") + " + minv2 + ";", this.shader_destination );\r\n\t\tthis.setOutputData( 0, return_type );\r\n\t}\r\n\r\n\tregisterShaderNode( "output/discard", LGraphShaderDiscard );\r\n\t*/\r\n\r\n\r\n\t// *************************************************\r\n\r\n\tfunction LGraphShaderOperation()\r\n\t{\r\n\t\tthis.addInput("A", LGShaders.ALL_TYPES );\r\n\t\tthis.addInput("B", LGShaders.ALL_TYPES );\r\n\t\tthis.addOutput("out","");\r\n\t\tthis.properties = {\r\n\t\t\toperation: "*"\r\n\t\t};\r\n\t\tthis.addWidget("combo","op.",this.properties.operation,{ property: "operation", values: LGraphShaderOperation.operations });\r\n\t}\r\n\r\n\tLGraphShaderOperation.title = "Operation";\r\n\tLGraphShaderOperation.operations = ["+","-","*","/"];\r\n\r\n\tLGraphShaderOperation.prototype.getTitle = function()\r\n\t{\r\n\t\tif(this.flags.collapsed)\r\n\t\t\treturn "A" + this.properties.operation + "B";\r\n\t\telse\r\n\t\t\treturn "Operation";\r\n\t}\r\n\r\n\tLGraphShaderOperation.prototype.onGetCode = function( context )\r\n\t{\r\n\t\tif(!this.shader_destination)\r\n\t\t\treturn;\r\n\r\n\t\tif(!this.isOutputConnected(0))\r\n\t\t\treturn;\r\n\r\n\t\tvar inlinks = [];\r\n\t\tfor(var i = 0; i < 3; ++i)\r\n\t\t\tinlinks.push( { name: getInputLinkID(this,i), type: this.getInputData(i) || "float" } );\r\n\r\n\t\tvar outlink = getOutputLinkID(this,0);\r\n\t\tif(!outlink) //not connected\r\n\t\t\treturn;\r\n\r\n\t\t//func_desc\r\n\t\tvar base_type = inlinks[0].type;\r\n\t\tvar return_type = base_type;\r\n\t\tvar op = this.properties.operation;\r\n\r\n\t\tvar params = [];\r\n\t\tfor(var i = 0; i < 2; ++i)\r\n\t\t{\r\n\t\t\tvar param_code = inlinks[i].name;\r\n\t\t\tif(param_code == null) //not plugged\r\n\t\t\t{\r\n\t\t\t\tparam_code = p.value != null ? p.value : "(1.0)";\r\n\t\t\t\tinlinks[i].type = "float";\r\n\t\t\t}\r\n\r\n\t\t\t//convert\r\n\t\t\tif( inlinks[i].type != base_type ) \r\n\t\t\t{\r\n\t\t\t\tif( inlinks[i].type == "float" && (op == "*" || op == "/") )\r\n\t\t\t\t{\r\n\t\t\t\t\t//I find hard to create the opposite condition now, so I prefeer an else\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tparam_code = convertVarToGLSLType( param_code, inlinks[i].type, base_type );\r\n\t\t\t}\r\n\t\t\tparams.push( param_code );\r\n\t\t}\r\n\t\t\r\n\t\tcontext.addCode("code", return_type + " " + outlink + " = "+ params[0] + op + params[1] + ";", this.shader_destination );\r\n\t\tthis.setOutputData( 0, return_type );\r\n\t}\r\n\r\n\tregisterShaderNode( "math/operation", LGraphShaderOperation );\r\n\r\n\r\n\tfunction LGraphShaderFunc()\r\n\t{\r\n\t\tthis.addInput("A", LGShaders.ALL_TYPES );\r\n\t\tthis.addInput("B", LGShaders.ALL_TYPES );\r\n\t\tthis.addOutput("out","");\r\n\t\tthis.properties = {\r\n\t\t\tfunc: "floor"\r\n\t\t};\r\n\t\tthis._current = "floor";\r\n\t\tthis.addWidget("combo","func",this.properties.func,{ property: "func", values: GLSL_functions_name });\r\n\t}\r\n\r\n\tLGraphShaderFunc.title = "Func";\r\n\r\n\tLGraphShaderFunc.prototype.onPropertyChanged = function(name,value)\r\n\t{\r\n\t\tif(this.graph)\r\n\t\t\tthis.graph._version++;\r\n\r\n\t\tif(name == "func")\r\n\t\t{\r\n\t\t\tvar func_desc = GLSL_functions[ value ];\r\n\t\t\tif(!func_desc)\r\n\t\t\t\treturn;\r\n\r\n\t\t\t//remove extra inputs\r\n\t\t\tfor(var i = func_desc.params.length; i < this.inputs.length; ++i)\r\n\t\t\t\tthis.removeInput(i);\r\n\r\n\t\t\t//add and update inputs\r\n\t\t\tfor(var i = 0; i < func_desc.params.length; ++i)\r\n\t\t\t{\r\n\t\t\t\tvar p = func_desc.params[i];\r\n\t\t\t\tif( this.inputs[i] )\r\n\t\t\t\t\tthis.inputs[i].name = p.name + (p.value ? " (" + p.value + ")" : "");\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.addInput( p.name, LGShaders.ALL_TYPES );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tLGraphShaderFunc.prototype.getTitle = function()\r\n\t{\r\n\t\tif(this.flags.collapsed)\r\n\t\t\treturn this.properties.func;\r\n\t\telse\r\n\t\t\treturn "Func";\r\n\t}\r\n\r\n\tLGraphShaderFunc.prototype.onGetCode = function( context )\r\n\t{\r\n\t\tif(!this.shader_destination)\r\n\t\t\treturn;\r\n\r\n\t\tif(!this.isOutputConnected(0))\r\n\t\t\treturn;\r\n\r\n\t\tvar inlinks = [];\r\n\t\tfor(var i = 0; i < 3; ++i)\r\n\t\t\tinlinks.push( { name: getInputLinkID(this,i), type: this.getInputData(i) || "float" } );\r\n\r\n\t\tvar outlink = getOutputLinkID(this,0);\r\n\t\tif(!outlink) //not connected\r\n\t\t\treturn;\r\n\r\n\t\tvar func_desc = GLSL_functions[ this.properties.func ];\r\n\t\tif(!func_desc)\r\n\t\t\treturn;\r\n\r\n\t\t//func_desc\r\n\t\tvar base_type = inlinks[0].type;\r\n\t\tvar return_type = func_desc.return_type;\r\n\t\tif( return_type == "T" )\r\n\t\t\treturn_type = base_type;\r\n\r\n\t\tvar params = [];\r\n\t\tfor(var i = 0; i < func_desc.params.length; ++i)\r\n\t\t{\r\n\t\t\tvar p = func_desc.params[i];\r\n\t\t\tvar param_code = inlinks[i].name;\r\n\t\t\tif(param_code == null) //not plugged\r\n\t\t\t{\r\n\t\t\t\tparam_code = p.value != null ? p.value : "(1.0)";\r\n\t\t\t\tinlinks[i].type = "float";\r\n\t\t\t}\r\n\t\t\tif( (p.type == "T" && inlinks[i].type != base_type) ||\r\n\t\t\t\t(p.type != "T" && inlinks[i].type != base_type) )\r\n\t\t\t\tparam_code = convertVarToGLSLType( param_code, inlinks[i].type, base_type );\r\n\t\t\tparams.push( param_code );\r\n\t\t}\r\n\t\t\r\n\t\tcontext.addFunction("round","float round(float v){ return floor(v+0.5); }\\nvec2 round(vec2 v){ return floor(v+vec2(0.5));}\\nvec3 round(vec3 v){ return floor(v+vec3(0.5));}\\nvec4 round(vec4 v){ return floor(v+vec4(0.5)); }\\n");\r\n\t\tcontext.addCode("code", return_type + " " + outlink + " = "+func_desc.func+"("+params.join(",")+");", this.shader_destination );\r\n\r\n\t\tthis.setOutputData( 0, return_type );\r\n\t}\r\n\r\n\tregisterShaderNode( "math/func", LGraphShaderFunc );\r\n\r\n\r\n\r\n\tfunction LGraphShaderSnippet()\r\n\t{\r\n\t\tthis.addInput("A", LGShaders.ALL_TYPES );\r\n\t\tthis.addInput("B", LGShaders.ALL_TYPES );\r\n\t\tthis.addOutput("C","vec4");\r\n\t\tthis.properties = {\r\n\t\t\tcode:"C = A+B",\r\n\t\t\ttype: "vec4"\r\n\t\t}\r\n\t\tthis.addWidget("text","code",this.properties.code,{ property: "code" });\r\n\t\tthis.addWidget("combo","type",this.properties.type,{ values:["float","vec2","vec3","vec4"], property: "type" });\r\n\t}\r\n\r\n\tLGraphShaderSnippet.title = "Snippet";\r\n\r\n\tLGraphShaderSnippet.prototype.onPropertyChanged = function(name,value)\r\n\t{\r\n\t\tif(this.graph)\r\n\t\t\tthis.graph._version++;\r\n\r\n\t\tif(name == "type"&& this.outputs[0].type != value)\r\n\t\t{\r\n\t\t\tthis.disconnectOutput(0);\r\n\t\t\tthis.outputs[0].type = value;\r\n\t\t}\r\n\t}\r\n\r\n\tLGraphShaderSnippet.prototype.getTitle = function()\r\n\t{\r\n\t\tif(this.flags.collapsed)\r\n\t\t\treturn this.properties.code;\r\n\t\telse\r\n\t\t\treturn "Snippet";\r\n\t}\r\n\r\n\tLGraphShaderSnippet.prototype.onGetCode = function( context )\r\n\t{\r\n\t\tif(!this.shader_destination || !this.isOutputConnected(0))\r\n\t\t\treturn;\r\n\r\n\t\tvar inlinkA = getInputLinkID(this,0);\r\n\t\tif(!inlinkA)\r\n\t\t\tinlinkA = "1.0";\r\n\t\tvar inlinkB = getInputLinkID(this,1);\r\n\t\tif(!inlinkB)\r\n\t\t\tinlinkB = "1.0";\r\n\t\tvar outlink = getOutputLinkID(this,0);\r\n\t\tif(!outlink) //not connected\r\n\t\t\treturn;\r\n\r\n\t\tvar inA_type = this.getInputData(0) || "float";\r\n\t\tvar inB_type = this.getInputData(1) || "float";\r\n\t\tvar return_type = this.properties.type;\r\n\r\n\t\t//cannot resolve input\r\n\t\tif(inA_type == "T" || inB_type == "T")\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tvar funcname = "funcSnippet" + this.id;\r\n\r\n\t\tvar func_code = "\\n" + return_type + " " + funcname + "( " + inA_type + " A, " + inB_type + " B) {\\n";\r\n\t\tfunc_code += "\t" + return_type + " C = " + return_type + "(0.0);\\n";\r\n\t\tfunc_code += "\t" + this.properties.code + ";\\n";\r\n\t\tfunc_code += "\treturn C;\\n}\\n";\r\n\r\n\t\tcontext.addCode("functions", func_code, this.shader_destination );\r\n\t\tcontext.addCode("code", return_type + " " + outlink + " = "+funcname+"("+inlinkA+","+inlinkB+");", this.shader_destination );\r\n\r\n\t\tthis.setOutputData( 0, return_type );\r\n\t}\r\n\r\n\tregisterShaderNode( "utils/snippet", LGraphShaderSnippet );\r\n\r\n\t//************************************\r\n\r\n\tfunction LGraphShaderRand()\r\n\t{\r\n\t\tthis.addOutput("out","float");\r\n\t}\r\n\r\n\tLGraphShaderRand.title = "Rand";\r\n\r\n\tLGraphShaderRand.prototype.onGetCode = function( context )\r\n\t{\r\n\t\tif(!this.shader_destination || !this.isOutputConnected(0))\r\n\t\t\treturn;\r\n\r\n\t\tvar outlink = getOutputLinkID(this,0);\r\n\r\n\t\tcontext.addUniform( "u_rand" + this.id, "float", function(){ return Math.random(); });\r\n\t\tcontext.addCode("code", "float " + outlink + " = u_rand" + this.id +";", this.shader_destination );\r\n\t\tthis.setOutputData( 0, "float" );\r\n\t}\r\n\r\n\tregisterShaderNode( "input/rand", LGraphShaderRand );\r\n\r\n\t//noise\r\n\t//https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\r\n\tfunction LGraphShaderNoise()\r\n\t{\r\n\t\tthis.addInput("out", LGShaders.ALL_TYPES );\r\n\t\tthis.addInput("scale", "float" );\r\n\t\tthis.addOutput("out","float");\r\n\t\tthis.properties = {\r\n\t\t\ttype: "noise",\r\n\t\t\tscale: 1\r\n\t\t};\r\n\t\tthis.addWidget("combo","type", this.properties.type, { property: "type", values: LGraphShaderNoise.NOISE_TYPES });\r\n\t\tthis.addWidget("number","scale", this.properties.scale, { property: "scale" });\r\n\t}\r\n\r\n\tLGraphShaderNoise.NOISE_TYPES = ["noise","rand"];\r\n\r\n\tLGraphShaderNoise.title = "noise";\r\n\r\n\tLGraphShaderNoise.prototype.onGetCode = function( context )\r\n\t{\r\n\t\tif(!this.shader_destination || !this.isOutputConnected(0))\r\n\t\t\treturn;\r\n\r\n\t\tvar inlink = getInputLinkID(this,0);\r\n\t\tvar outlink = getOutputLinkID(this,0);\r\n\r\n\t\tvar intype = this.getInputData(0);\r\n\t\tif(!inlink)\r\n\t\t{\r\n\t\t\tintype = "vec2";\r\n\t\t\tinlink = context.buffer_names.uvs;\r\n\t\t}\r\n\r\n\t\tcontext.addFunction("noise",LGraphShaderNoise.shader_functions);\r\n\t\tcontext.addUniform( "u_noise_scale" + this.id, "float", this.properties.scale );\r\n\t\tif( intype == "float" )\r\n\t\t\tcontext.addCode("code", "float " + outlink + " = snoise( vec2(" + inlink +") * u_noise_scale" + this.id +");", this.shader_destination );\r\n\t\telse if( intype == "vec2" || intype == "vec3" )\r\n\t\t\tcontext.addCode("code", "float " + outlink + " = snoise(" + inlink +" * u_noise_scale" + this.id +");", this.shader_destination );\r\n\t\telse if( intype == "vec4" )\r\n\t\t\tcontext.addCode("code", "float " + outlink + " = snoise(" + inlink +".xyz * u_noise_scale" + this.id +");", this.shader_destination );\r\n\t\tthis.setOutputData( 0, "float" );\r\n\t}\r\n\r\n\tregisterShaderNode( "math/noise", LGraphShaderNoise );\r\n\r\nLGraphShaderNoise.shader_functions = "\\n\\\r\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\\n\\\r\n\\n\\\r\nfloat snoise(vec2 v){\\n\\\r\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,-0.577350269189626, 0.024390243902439);\\n\\\r\n  vec2 i  = floor(v + dot(v, C.yy) );\\n\\\r\n  vec2 x0 = v -   i + dot(i, C.xx);\\n\\\r\n  vec2 i1;\\n\\\r\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n\\\r\n  vec4 x12 = x0.xyxy + C.xxzz;\\n\\\r\n  x12.xy -= i1;\\n\\\r\n  i = mod(i, 289.0);\\n\\\r\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\\n\\\r\n  + i.x + vec3(0.0, i1.x, 1.0 ));\\n\\\r\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)), 0.0);\\n\\\r\n  m = m*m ;\\n\\\r\n  m = m*m ;\\n\\\r\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\\n\\\r\n  vec3 h = abs(x) - 0.5;\\n\\\r\n  vec3 ox = floor(x + 0.5);\\n\\\r\n  vec3 a0 = x - ox;\\n\\\r\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\\n\\\r\n  vec3 g;\\n\\\r\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\\n\\\r\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\\n\\\r\n  return 130.0 * dot(m, g);\\n\\\r\n}\\n\\\r\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\\n\\\r\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\\n\\\r\n\\n\\\r\nfloat snoise(vec3 v){ \\n\\\r\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n\\\r\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\\r\n\\n\\\r\n// First corner\\n\\\r\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n\\\r\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\\r\n\\n\\\r\n// Other corners\\n\\\r\n  vec3 g = step(x0.yzx, x0.xyz);\\n\\\r\n  vec3 l = 1.0 - g;\\n\\\r\n  vec3 i1 = min( g.xyz, l.zxy );\\n\\\r\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\\r\n\\n\\\r\n  //  x0 = x0 - 0. + 0.0 * C \\n\\\r\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\\n\\\r\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\\n\\\r\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\\n\\\r\n\\n\\\r\n// Permutations\\n\\\r\n  i = mod(i, 289.0 ); \\n\\\r\n  vec4 p = permute( permute( permute( \\n\\\r\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n\\\r\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \\n\\\r\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\\r\n\\n\\\r\n// Gradients\\n\\\r\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\\n\\\r\n  float n_ = 1.0/7.0; // N=7\\n\\\r\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\\r\n\\n\\\r\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\\n\\\r\n\\n\\\r\n  vec4 x_ = floor(j * ns.z);\\n\\\r\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\\r\n\\n\\\r\n  vec4 x = x_ *ns.x + ns.yyyy;\\n\\\r\n  vec4 y = y_ *ns.x + ns.yyyy;\\n\\\r\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\\r\n\\n\\\r\n  vec4 b0 = vec4( x.xy, y.xy );\\n\\\r\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\\r\n\\n\\\r\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n\\\r\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n\\\r\n  vec4 sh = -step(h, vec4(0.0));\\n\\\r\n\\n\\\r\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n\\\r\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\\r\n\\n\\\r\n  vec3 p0 = vec3(a0.xy,h.x);\\n\\\r\n  vec3 p1 = vec3(a0.zw,h.y);\\n\\\r\n  vec3 p2 = vec3(a1.xy,h.z);\\n\\\r\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\\r\n\\n\\\r\n//Normalise gradients\\n\\\r\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n\\\r\n  p0 *= norm.x;\\n\\\r\n  p1 *= norm.y;\\n\\\r\n  p2 *= norm.z;\\n\\\r\n  p3 *= norm.w;\\n\\\r\n\\n\\\r\n// Mix final noise value\\n\\\r\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n\\\r\n  m = m * m;\\n\\\r\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\\n\\\r\n}\\n\\\r\n\\n\\\r\nvec3 hash3( vec2 p ){\\n\\\r\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \\n\\\r\n\t\t\t\t   dot(p,vec2(269.5,183.3)), \\n\\\r\n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\\n\\\r\n\treturn fract(sin(q)*43758.5453);\\n\\\r\n}\\n\\\r\nvec4 hash4( vec3 p ){\\n\\\r\n    vec4 q = vec4( dot(p,vec3(127.1,311.7,257.3)), \\n\\\r\n\t\t\t\t   dot(p,vec3(269.5,183.3,335.1)), \\n\\\r\n\t\t\t\t   dot(p,vec3(314.5,235.1,467.3)), \\n\\\r\n\t\t\t\t   dot(p,vec3(419.2,371.9,114.9)) );\\n\\\r\n\treturn fract(sin(q)*43758.5453);\\n\\\r\n}\\n\\\r\n\\n\\\r\nfloat iqnoise( in vec2 x, float u, float v ){\\n\\\r\n    vec2 p = floor(x);\\n\\\r\n    vec2 f = fract(x);\\n\\\r\n\t\\n\\\r\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\\n\\\r\n\t\\n\\\r\n\tfloat va = 0.0;\\n\\\r\n\tfloat wt = 0.0;\\n\\\r\n    for( int j=-2; j<=2; j++ )\\n\\\r\n    for( int i=-2; i<=2; i++ )\\n\\\r\n    {\\n\\\r\n        vec2 g = vec2( float(i),float(j) );\\n\\\r\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\\n\\\r\n\t\tvec2 r = g - f + o.xy;\\n\\\r\n\t\tfloat d = dot(r,r);\\n\\\r\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\\n\\\r\n\t\tva += o.z*ww;\\n\\\r\n\t\twt += ww;\\n\\\r\n    }\\n\\\r\n\t\\n\\\r\n    return va/wt;\\n\\\r\n}\\n\\\r\n"\r\n\r\n\tfunction LGraphShaderTime()\r\n\t{\r\n\t\tthis.addOutput("out","float");\r\n\t}\r\n\r\n\tLGraphShaderTime.title = "Time";\r\n\r\n\tLGraphShaderTime.prototype.onGetCode = function( context )\r\n\t{\r\n\t\tif(!this.shader_destination || !this.isOutputConnected(0))\r\n\t\t\treturn;\r\n\r\n\t\tvar outlink = getOutputLinkID(this,0);\r\n\r\n\t\tcontext.addUniform( "u_time" + this.id, "float", function(){ return getTime() * 0.001; });\r\n\t\tcontext.addCode("code", "float " + outlink + " = u_time" + this.id +";", this.shader_destination );\r\n\t\tthis.setOutputData( 0, "float" );\r\n\t}\r\n\r\n\tregisterShaderNode( "input/time", LGraphShaderTime );\r\n\r\n\r\n\tfunction LGraphShaderDither()\r\n\t{\r\n\t\tthis.addInput("in","T");\r\n\t\tthis.addOutput("out","float");\r\n\t}\r\n\r\n\tLGraphShaderDither.title = "Dither";\r\n\r\n\tLGraphShaderDither.prototype.onGetCode = function( context )\r\n\t{\r\n\t\tif(!this.shader_destination || !this.isOutputConnected(0))\r\n\t\t\treturn;\r\n\r\n\t\tvar inlink = getInputLinkID(this,0);\r\n\t\tvar return_type = "float";\r\n\t\tvar outlink = getOutputLinkID(this,0);\r\n\t\tvar intype = this.getInputData(0);\r\n\t\tinlink = varToTypeGLSL( inlink, intype, "float" );\r\n\t\tcontext.addFunction("dither8x8", LGraphShaderDither.dither_func);\r\n\t\tcontext.addCode("code", return_type + " " + outlink + " = dither8x8("+ inlink +");", this.shader_destination );\r\n\t\tthis.setOutputData( 0, return_type );\r\n\t}\r\n\r\n\tLGraphShaderDither.dither_values = [0.515625,0.140625,0.640625,0.046875,0.546875,0.171875,0.671875,0.765625,0.265625,0.890625,0.390625,0.796875,0.296875,0.921875,0.421875,0.203125,0.703125,0.078125,0.578125,0.234375,0.734375,0.109375,0.609375,0.953125,0.453125,0.828125,0.328125,0.984375,0.484375,0.859375,0.359375,0.0625,0.5625,0.1875,0.6875,0.03125,0.53125,0.15625,0.65625,0.8125,0.3125,0.9375,0.4375,0.78125,0.28125,0.90625,0.40625,0.25,0.75,0.125,0.625,0.21875,0.71875,0.09375,0.59375,1.0001,0.5,0.875,0.375,0.96875,0.46875,0.84375,0.34375];\r\n\t\r\n\tLGraphShaderDither.dither_func = "\\n\\\r\n\t\tfloat dither8x8(float brightness) {\\n\\\r\n\t\t  vec2 position = vec2(0.0);\\n\\\r\n\t\t  #ifdef FRAGMENT\\n\\\r\n\t\t\tposition = gl_FragCoord.xy;\\n\\\r\n\t\t  #endif\\n\\\r\n\t\t  int x = int(mod(position.x, 8.0));\\n\\\r\n\t\t  int y = int(mod(position.y, 8.0));\\n\\\r\n\t\t  int index = x + y * 8;\\n\\\r\n\t\t  float limit = 0.0;\\n\\\r\n\t\t  if (x < 8) {\\n\\\r\n\t\t\tif(index==0) limit = 0.015625;\\n\\\r\n\t\t\t"+(LGraphShaderDither.dither_values.map( function(v,i){ return "else if(index== "+(i+1)+") limit = " + v + ";"}).join("\\n"))+"\\n\\\r\n\t\t  }\\n\\\r\n\t\t  return brightness < limit ? 0.0 : 1.0;\\n\\\r\n\t\t}\\n",\r\n\r\n\tregisterShaderNode( "math/dither", LGraphShaderDither );\r\n\r\n\tfunction LGraphShaderRemap()\r\n\t{\r\n\t\tthis.addInput("", LGShaders.ALL_TYPES );\r\n\t\tthis.addOutput("","");\r\n\t\tthis.properties = {\r\n\t\t\tmin_value: 0,\r\n\t\t\tmax_value: 1,\r\n\t\t\tmin_value2: 0,\r\n\t\t\tmax_value2: 1\r\n\t\t};\r\n\t\tthis.addWidget("number","min",0,{ step: 0.1, property: "min_value" });\r\n\t\tthis.addWidget("number","max",1,{ step: 0.1, property: "max_value" });\r\n\t\tthis.addWidget("number","min2",0,{ step: 0.1, property: "min_value2"});\r\n\t\tthis.addWidget("number","max2",1,{ step: 0.1, property: "max_value2"});\r\n\t}\r\n\r\n\tLGraphShaderRemap.title = "Remap";\r\n\r\n\tLGraphShaderRemap.prototype.onPropertyChanged = function()\r\n\t{\r\n\t\tif(this.graph)\r\n\t\t\tthis.graph._version++;\r\n\t}\r\n\r\n\tLGraphShaderRemap.prototype.onConnectionsChange = function()\r\n\t{\r\n\t\tvar return_type = this.getInputDataType(0);\r\n\t\tthis.outputs[0].type = return_type || "T";\r\n\t}\r\n\r\n\tLGraphShaderRemap.prototype.onGetCode = function( context )\r\n\t{\r\n\t\tif(!this.shader_destination || !this.isOutputConnected(0))\r\n\t\t\treturn;\r\n\r\n\t\tvar inlink = getInputLinkID(this,0);\r\n\t\tvar outlink = getOutputLinkID(this,0);\r\n\t\tif(!inlink && !outlink) //not connected\r\n\t\t\treturn;\r\n\r\n\t\tvar return_type = this.getInputDataType(0);\r\n\t\tthis.outputs[0].type = return_type;\r\n\t\tif(return_type == "T")\r\n\t\t{\r\n\t\t\tconsole.warn("node type is T and cannot be resolved");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif(!inlink)\r\n\t\t{\r\n\t\t\tcontext.addCode("code","\t" + return_type + " " + outlink + " = " + return_type + "(0.0);\\n");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar minv = valueToGLSL( this.properties.min_value );\r\n\t\tvar maxv = valueToGLSL( this.properties.max_value );\r\n\t\tvar minv2 = valueToGLSL( this.properties.min_value2 );\r\n\t\tvar maxv2 = valueToGLSL( this.properties.max_value2 );\r\n\r\n\t\tcontext.addCode("code", return_type + " " + outlink + " = ( (" + inlink + " - "+minv+") / ("+ maxv+" - "+minv+") ) * ("+ maxv2+" - "+minv2+") + " + minv2 + ";", this.shader_destination );\r\n\t\tthis.setOutputData( 0, return_type );\r\n\t}\r\n\r\n\tregisterShaderNode( "math/remap", LGraphShaderRemap );\r\n\r\n})(this);\r\n\r\n\r\n\n(function(global) {\r\n    var LiteGraph = global.LiteGraph;\r\n\r\n\tvar view_matrix = new Float32Array(16);\r\n\tvar projection_matrix = new Float32Array(16);\r\n\tvar viewprojection_matrix = new Float32Array(16);\r\n\tvar model_matrix = new Float32Array(16);\r\n\tvar global_uniforms = {\r\n\t\tu_view: view_matrix,\r\n\t\tu_projection: projection_matrix,\r\n\t\tu_viewprojection: viewprojection_matrix,\r\n\t\tu_model: model_matrix \r\n\t};\r\n\r\n\tLiteGraph.LGraphRender = {\r\n\t\tonRequestCameraMatrices: null //overwrite with your 3D engine specifics, it will receive (view_matrix, projection_matrix,viewprojection_matrix) and must be filled\r\n\t};\r\n\r\n\tfunction generateGeometryId() {\r\n\t\treturn (Math.random() * 100000)|0;\r\n\t}\r\n\r\n\tfunction LGraphPoints3D() {\r\n\r\n\t\tthis.addInput("obj", "");\r\n\t\tthis.addInput("radius", "number");\r\n\r\n\t\tthis.addOutput("out", "geometry");\r\n\t\tthis.addOutput("points", "[vec3]");\r\n\t\tthis.properties = {\r\n\t\t\tradius: 1,\r\n\t\t\tnum_points: 4096,\r\n\t\t\tgenerate_normals: true,\r\n\t\t\tregular: false,\r\n\t\t\tmode: LGraphPoints3D.SPHERE,\r\n\t\t\tforce_update: false\r\n\t\t};\r\n\r\n\t\tthis.points = new Float32Array( this.properties.num_points * 3 );\r\n\t\tthis.normals = new Float32Array( this.properties.num_points * 3 );\r\n\t\tthis.must_update = true;\r\n\t\tthis.version = 0;\r\n\r\n\t\tvar that = this;\r\n\t\tthis.addWidget("button","update",null, function(){ that.must_update = true; });\r\n\r\n\t\tthis.geometry = {\r\n\t\t\tvertices: null,\r\n\t\t\t_id: generateGeometryId()\r\n\t\t}\r\n\r\n\t\tthis._old_obj = null;\r\n\t\tthis._last_radius = null;\r\n\t}\r\n\r\n\tglobal.LGraphPoints3D = LGraphPoints3D;\r\n\r\n\tLGraphPoints3D.RECTANGLE = 1;\r\n\tLGraphPoints3D.CIRCLE = 2;\r\n\r\n\tLGraphPoints3D.CUBE = 10;\r\n\tLGraphPoints3D.SPHERE = 11;\r\n\tLGraphPoints3D.HEMISPHERE = 12;\r\n\tLGraphPoints3D.INSIDE_SPHERE = 13;\r\n\r\n\tLGraphPoints3D.OBJECT = 20;\r\n\tLGraphPoints3D.OBJECT_UNIFORMLY = 21;\r\n\tLGraphPoints3D.OBJECT_INSIDE = 22;\r\n\r\n\tLGraphPoints3D.MODE_VALUES = { "rectangle":LGraphPoints3D.RECTANGLE, "circle":LGraphPoints3D.CIRCLE, "cube":LGraphPoints3D.CUBE, "sphere":LGraphPoints3D.SPHERE, "hemisphere":LGraphPoints3D.HEMISPHERE, "inside_sphere":LGraphPoints3D.INSIDE_SPHERE, "object":LGraphPoints3D.OBJECT, "object_uniformly":LGraphPoints3D.OBJECT_UNIFORMLY, "object_inside":LGraphPoints3D.OBJECT_INSIDE };\r\n\r\n\tLGraphPoints3D.widgets_info = {\r\n\t\tmode: { widget: "combo", values: LGraphPoints3D.MODE_VALUES }\r\n\t};\r\n\r\n\tLGraphPoints3D.title = "list of points";\r\n\tLGraphPoints3D.desc = "returns an array of points";\r\n\r\n\tLGraphPoints3D.prototype.onPropertyChanged = function(name,value)\r\n\t{\r\n\t\tthis.must_update = true;\r\n\t}\r\n\r\n\tLGraphPoints3D.prototype.onExecute = function() {\r\n\r\n\t\tvar obj = this.getInputData(0);\r\n\t\tif( obj != this._old_obj || (obj && obj._version != this._old_obj_version) )\r\n\t\t{\r\n\t\t\tthis._old_obj = obj;\r\n\t\t\tthis.must_update = true;\r\n\t\t}\r\n\r\n\t\tvar radius = this.getInputData(1);\r\n\t\tif(radius == null)\r\n\t\t\tradius = this.properties.radius;\r\n\t\tif( this._last_radius != radius )\r\n\t\t{\r\n\t\t\tthis._last_radius = radius;\r\n\t\t\tthis.must_update = true;\r\n\t\t}\r\n\r\n\t\tif(this.must_update || this.properties.force_update )\r\n\t\t{\r\n\t\t\tthis.must_update = false;\r\n\t\t\tthis.updatePoints();\r\n\t\t}\r\n\r\n\t\tthis.geometry.vertices = this.points;\r\n\t\tthis.geometry.normals = this.normals;\r\n\t\tthis.geometry._version = this.version;\r\n\r\n\t\tthis.setOutputData( 0, this.geometry );\r\n\t}\r\n\r\n\tLGraphPoints3D.prototype.updatePoints = function() {\r\n\t\tvar num_points = this.properties.num_points|0;\r\n\t\tif(num_points < 1)\r\n\t\t\tnum_points = 1;\r\n\r\n\t\tif(!this.points || this.points.length != num_points * 3)\r\n\t\t\tthis.points = new Float32Array( num_points * 3 );\r\n\r\n\t\tif(this.properties.generate_normals)\r\n\t\t{\r\n\t\t\tif (!this.normals || this.normals.length != this.points.length)\r\n\t\t\t\tthis.normals = new Float32Array( this.points.length );\r\n\t\t}\r\n\t\telse\r\n\t\t\tthis.normals = null;\r\n\r\n\t\tvar radius = this._last_radius || this.properties.radius;\r\n\t\tvar mode = this.properties.mode;\r\n\r\n\t\tvar obj = this.getInputData(0);\r\n\t\tthis._old_obj_version = obj ? obj._version : null;\r\n\r\n\t\tthis.points = LGraphPoints3D.generatePoints( radius, num_points, mode, this.points, this.normals, this.properties.regular, obj );\r\n\r\n\t\tthis.version++;\r\n\t}\r\n\r\n\t//global\r\n\tLGraphPoints3D.generatePoints = function( radius, num_points, mode, points, normals, regular, obj )\r\n\t{\r\n\t\tvar size = num_points * 3;\r\n\t\tif(!points || points.length != size)\r\n\t\t\tpoints = new Float32Array( size );\r\n\t\tvar temp = new Float32Array(3);\r\n\t\tvar UP = new Float32Array([0,1,0]);\r\n\r\n\t\tif(regular)\r\n\t\t{\r\n\t\t\tif( mode == LGraphPoints3D.RECTANGLE)\r\n\t\t\t{\r\n\t\t\t\tvar side = Math.floor(Math.sqrt(num_points));\r\n\t\t\t\tfor(var i = 0; i < side; ++i)\r\n\t\t\t\tfor(var j = 0; j < side; ++j)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar pos = i*3 + j*3*side;\r\n\t\t\t\t\tpoints[pos] = ((i/side) - 0.5) * radius * 2;\r\n\t\t\t\t\tpoints[pos+1] = 0;\r\n\t\t\t\t\tpoints[pos+2] = ((j/side) - 0.5) * radius * 2;\r\n\t\t\t\t}\r\n\t\t\t\tpoints = new Float32Array( points.subarray(0,side*side*3) );\r\n\t\t\t\tif(normals)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor(var i = 0; i < normals.length; i+=3)\r\n\t\t\t\t\t\tnormals.set(UP, i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if( mode == LGraphPoints3D.SPHERE)\r\n\t\t\t{\r\n\t\t\t\tvar side = Math.floor(Math.sqrt(num_points));\r\n\t\t\t\tfor(var i = 0; i < side; ++i)\r\n\t\t\t\tfor(var j = 0; j < side; ++j)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar pos = i*3 + j*3*side;\r\n\t\t\t\t\tpolarToCartesian( temp, (i/side) * 2 * Math.PI, ((j/side) - 0.5) * 2 * Math.PI, radius );\r\n\t\t\t\t\tpoints[pos] = temp[0];\r\n\t\t\t\t\tpoints[pos+1] = temp[1];\r\n\t\t\t\t\tpoints[pos+2] = temp[2];\r\n\t\t\t\t}\r\n\t\t\t\tpoints = new Float32Array( points.subarray(0,side*side*3) );\r\n\t\t\t\tif(normals)\r\n\t\t\t\t\tLGraphPoints3D.generateSphericalNormals( points, normals );\r\n\t\t\t}\r\n\t\t\telse if( mode == LGraphPoints3D.CIRCLE)\r\n\t\t\t{\r\n\t\t\t\tfor(var i = 0; i < size; i+=3)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar angle = 2 * Math.PI * (i/size);\r\n\t\t\t\t\tpoints[i] = Math.cos( angle ) * radius;\r\n\t\t\t\t\tpoints[i+1] = 0;\r\n\t\t\t\t\tpoints[i+2] = Math.sin( angle ) * radius;\r\n\t\t\t\t}\r\n\t\t\t\tif(normals)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor(var i = 0; i < normals.length; i+=3)\r\n\t\t\t\t\t\tnormals.set(UP, i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse //non regular\r\n\t\t{\r\n\t\t\tif( mode == LGraphPoints3D.RECTANGLE)\r\n\t\t\t{\r\n\t\t\t\tfor(var i = 0; i < size; i+=3)\r\n\t\t\t\t{\r\n\t\t\t\t\tpoints[i] = (Math.random() - 0.5) * radius * 2;\r\n\t\t\t\t\tpoints[i+1] = 0;\r\n\t\t\t\t\tpoints[i+2] = (Math.random() - 0.5) * radius * 2;\r\n\t\t\t\t}\r\n\t\t\t\tif(normals)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor(var i = 0; i < normals.length; i+=3)\r\n\t\t\t\t\t\tnormals.set(UP, i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if( mode == LGraphPoints3D.CUBE)\r\n\t\t\t{\r\n\t\t\t\tfor(var i = 0; i < size; i+=3)\r\n\t\t\t\t{\r\n\t\t\t\t\tpoints[i] = (Math.random() - 0.5) * radius * 2;\r\n\t\t\t\t\tpoints[i+1] = (Math.random() - 0.5) * radius * 2;\r\n\t\t\t\t\tpoints[i+2] = (Math.random() - 0.5) * radius * 2;\r\n\t\t\t\t}\r\n\t\t\t\tif(normals)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor(var i = 0; i < normals.length; i+=3)\r\n\t\t\t\t\t\tnormals.set(UP, i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if( mode == LGraphPoints3D.SPHERE)\r\n\t\t\t{\r\n\t\t\t\tLGraphPoints3D.generateSphere( points, size, radius );\r\n\t\t\t\tif(normals)\r\n\t\t\t\t\tLGraphPoints3D.generateSphericalNormals( points, normals );\r\n\t\t\t}\r\n\t\t\telse if( mode == LGraphPoints3D.HEMISPHERE)\r\n\t\t\t{\r\n\t\t\t\tLGraphPoints3D.generateHemisphere( points, size, radius );\r\n\t\t\t\tif(normals)\r\n\t\t\t\t\tLGraphPoints3D.generateSphericalNormals( points, normals );\r\n\t\t\t}\r\n\t\t\telse if( mode == LGraphPoints3D.CIRCLE)\r\n\t\t\t{\r\n\t\t\t\tLGraphPoints3D.generateInsideCircle( points, size, radius );\r\n\t\t\t\tif(normals)\r\n\t\t\t\t\tLGraphPoints3D.generateSphericalNormals( points, normals );\r\n\t\t\t}\r\n\t\t\telse if( mode == LGraphPoints3D.INSIDE_SPHERE)\r\n\t\t\t{\r\n\t\t\t\tLGraphPoints3D.generateInsideSphere( points, size, radius );\r\n\t\t\t\tif(normals)\r\n\t\t\t\t\tLGraphPoints3D.generateSphericalNormals( points, normals );\r\n\t\t\t}\r\n\t\t\telse if( mode == LGraphPoints3D.OBJECT)\r\n\t\t\t{\r\n\t\t\t\tLGraphPoints3D.generateFromObject( points, normals, size, obj, false );\r\n\t\t\t}\r\n\t\t\telse if( mode == LGraphPoints3D.OBJECT_UNIFORMLY)\r\n\t\t\t{\r\n\t\t\t\tLGraphPoints3D.generateFromObject( points, normals, size, obj, true );\r\n\t\t\t}\r\n\t\t\telse if( mode == LGraphPoints3D.OBJECT_INSIDE)\r\n\t\t\t{\r\n\t\t\t\tLGraphPoints3D.generateFromInsideObject( points, size, obj );\r\n\t\t\t\t//if(normals)\r\n\t\t\t\t//\tLGraphPoints3D.generateSphericalNormals( points, normals );\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tconsole.warn("wrong mode in LGraphPoints3D");\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\t}\r\n\r\n\tLGraphPoints3D.generateSphericalNormals = function(points, normals)\r\n\t{\r\n\t\tvar temp = new Float32Array(3);\r\n\t\tfor(var i = 0; i < normals.length; i+=3)\r\n\t\t{\r\n\t\t\ttemp[0] = points[i];\r\n\t\t\ttemp[1] = points[i+1];\r\n\t\t\ttemp[2] = points[i+2];\r\n\t\t\tvec3.normalize(temp,temp);\r\n\t\t\tnormals.set(temp,i);\r\n\t\t}\r\n\t}\r\n\r\n\tLGraphPoints3D.generateSphere = function (points, size, radius)\r\n\t{\r\n\t\tfor(var i = 0; i < size; i+=3)\r\n\t\t{\r\n\t\t\tvar r1 = Math.random();\r\n\t\t\tvar r2 = Math.random();\r\n\t\t\tvar x = 2 * Math.cos( 2 * Math.PI * r1 ) * Math.sqrt( r2 * (1-r2) );\r\n\t\t\tvar y = 1 - 2 * r2;\r\n\t\t\tvar z = 2 * Math.sin( 2 * Math.PI * r1 ) * Math.sqrt( r2 * (1-r2) );\r\n\t\t\tpoints[i] = x * radius;\r\n\t\t\tpoints[i+1] = y * radius;\r\n\t\t\tpoints[i+2] = z * radius;\r\n\t\t}\t\t\t\r\n\t}\r\n\r\n\tLGraphPoints3D.generateHemisphere = function (points, size, radius)\r\n\t{\r\n\t\tfor(var i = 0; i < size; i+=3)\r\n\t\t{\r\n\t\t\tvar r1 = Math.random();\r\n\t\t\tvar r2 = Math.random();\r\n\t\t\tvar x = Math.cos( 2 * Math.PI * r1 ) * Math.sqrt(1 - r2*r2 );\r\n\t\t\tvar y = r2;\r\n\t\t\tvar z = Math.sin( 2 * Math.PI * r1 ) * Math.sqrt(1 - r2*r2 );\r\n\t\t\tpoints[i] = x * radius;\r\n\t\t\tpoints[i+1] = y * radius;\r\n\t\t\tpoints[i+2] = z * radius;\r\n\t\t}\r\n\t}\r\n\r\n\tLGraphPoints3D.generateInsideCircle = function (points, size, radius)\r\n\t{\r\n\t\tfor(var i = 0; i < size; i+=3)\r\n\t\t{\r\n\t\t\tvar r1 = Math.random();\r\n\t\t\tvar r2 = Math.random();\r\n\t\t\tvar x = Math.cos( 2 * Math.PI * r1 ) * Math.sqrt(1 - r2*r2 );\r\n\t\t\tvar y = r2;\r\n\t\t\tvar z = Math.sin( 2 * Math.PI * r1 ) * Math.sqrt(1 - r2*r2 );\r\n\t\t\tpoints[i] = x * radius;\r\n\t\t\tpoints[i+1] = 0;\r\n\t\t\tpoints[i+2] = z * radius;\r\n\t\t}\r\n\t}\r\n\r\n\tLGraphPoints3D.generateInsideSphere = function (points, size, radius)\r\n\t{\r\n\t\tfor(var i = 0; i < size; i+=3)\r\n\t\t{\r\n\t\t\tvar u = Math.random();\r\n\t\t\tvar v = Math.random();\r\n\t\t\tvar theta = u * 2.0 * Math.PI;\r\n\t\t\tvar phi = Math.acos(2.0 * v - 1.0);\r\n\t\t\tvar r = Math.cbrt(Math.random()) * radius;\r\n\t\t\tvar sinTheta = Math.sin(theta);\r\n\t\t\tvar cosTheta = Math.cos(theta);\r\n\t\t\tvar sinPhi = Math.sin(phi);\r\n\t\t\tvar cosPhi = Math.cos(phi);\r\n\t\t\tpoints[i] = r * sinPhi * cosTheta;\r\n\t\t\tpoints[i+1] = r * sinPhi * sinTheta;\r\n\t\t\tpoints[i+2] = r * cosPhi;\r\n\t\t}\t\r\n\t}\r\n\r\n\tfunction findRandomTriangle( areas, f )\r\n\t{\r\n\t\tvar l = areas.length;\r\n\t\tvar imin = 0;\r\n\t\tvar imid = 0;\r\n\t\tvar imax = l;\r\n\r\n\t\tif(l == 0)\r\n\t\t\treturn -1;\r\n\t\tif(l == 1)\r\n\t\t\treturn 0;\r\n\t\t//dichotomic search\r\n\t\twhile (imax >= imin)\r\n\t\t{\r\n\t\t\timid = ((imax + imin)*0.5)|0;\r\n\t\t\tvar t = areas[ imid ];\r\n\t\t\tif( t == f )\r\n\t\t\t\treturn imid; \r\n\t\t\tif( imin == (imax - 1) )\r\n\t\t\t\treturn imin;\r\n\t\t\tif (t < f)\r\n\t\t\t\timin = imid;\r\n\t\t\telse         \r\n\t\t\t\timax = imid;\r\n\t\t}\r\n\t\treturn imid;\t\t\r\n\t}\r\n\r\n\tLGraphPoints3D.generateFromObject = function( points, normals, size, obj, evenly )\r\n\t{\r\n\t\tif(!obj)\r\n\t\t\treturn;\r\n\r\n\t\tvar vertices = null;\r\n\t\tvar mesh_normals = null;\r\n\t\tvar indices = null;\r\n\t\tvar areas = null;\r\n\t\tif( obj.constructor === GL.Mesh )\r\n\t\t{\r\n\t\t\tvertices = obj.vertexBuffers.vertices.data;\r\n\t\t\tmesh_normals = obj.vertexBuffers.normals ? obj.vertexBuffers.normals.data : null;\r\n\t\t\tindices = obj.indexBuffers.indices ? obj.indexBuffers.indices.data : null;\r\n\t\t\tif(!indices)\r\n\t\t\t\tindices = obj.indexBuffers.triangles ? obj.indexBuffers.triangles.data : null;\r\n\t\t}\r\n\t\tif(!vertices)\r\n\t\t\treturn null;\r\n\t\tvar num_triangles = indices ? indices.length / 3 : vertices.length / (3*3);\r\n\t\tvar total_area = 0; //sum of areas of all triangles\r\n\r\n\t\tif(evenly)\r\n\t\t{\r\n\t\t\tareas = new Float32Array(num_triangles); //accum\r\n\t\t\tfor(var i = 0; i < num_triangles; ++i)\r\n\t\t\t{\r\n\t\t\t\tif(indices)\r\n\t\t\t\t{\r\n\t\t\t\t\ta = indices[i*3]*3;\r\n\t\t\t\t\tb = indices[i*3+1]*3;\r\n\t\t\t\t\tc = indices[i*3+2]*3;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\ta = i*9;\r\n\t\t\t\t\tb = i*9+3;\r\n\t\t\t\t\tc = i*9+6;\r\n\t\t\t\t}\r\n\t\t\t\tvar P1 = vertices.subarray(a,a+3);\r\n\t\t\t\tvar P2 = vertices.subarray(b,b+3);\r\n\t\t\t\tvar P3 = vertices.subarray(c,c+3);\r\n\t\t\t\tvar aL = vec3.distance( P1, P2 );\r\n\t\t\t\tvar bL = vec3.distance( P2, P3 );\r\n\t\t\t\tvar cL = vec3.distance( P3, P1 );\r\n\t\t\t\tvar s = (aL + bL+ cL) / 2;\r\n\t\t\t\ttotal_area += Math.sqrt(s * (s - aL) * (s - bL) * (s - cL));\r\n\t\t\t\tareas[i] = total_area;\r\n\t\t\t}\t\t\t\r\n\t\t\tfor(var i = 0; i < num_triangles; ++i) //normalize\r\n\t\t\t\tareas[i] /= total_area;\r\n\t\t}\r\n\r\n\t\tfor(var i = 0; i < size; i+=3)\r\n\t\t{\r\n\t\t\tvar r = Math.random();\r\n\t\t\tvar index = evenly ? findRandomTriangle( areas, r ) : Math.floor(r * num_triangles );\r\n\t\t\t//get random triangle\r\n\t\t\tvar a = 0;\r\n\t\t\tvar b = 0;\r\n\t\t\tvar c = 0;\r\n\t\t\tif(indices)\r\n\t\t\t{\r\n\t\t\t\ta = indices[index*3]*3;\r\n\t\t\t\tb = indices[index*3+1]*3;\r\n\t\t\t\tc = indices[index*3+2]*3;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\ta = index*9;\r\n\t\t\t\tb = index*9+3;\r\n\t\t\t\tc = index*9+6;\r\n\t\t\t}\r\n\t\t\tvar s = Math.random();\r\n\t\t\tvar t = Math.random();\r\n\t\t\tvar sqrt_s = Math.sqrt(s);\r\n\t\t\tvar af = 1 - sqrt_s;\r\n\t\t\tvar bf = sqrt_s * ( 1 - t);\r\n\t\t\tvar cf = t * sqrt_s;\r\n\t\t\tpoints[i] = af * vertices[a] + bf*vertices[b] + cf*vertices[c];\r\n\t\t\tpoints[i+1] = af * vertices[a+1] + bf*vertices[b+1] + cf*vertices[c+1];\r\n\t\t\tpoints[i+2] = af * vertices[a+2] + bf*vertices[b+2] + cf*vertices[c+2];\r\n\t\t\tif(normals && mesh_normals)\r\n\t\t\t{\r\n\t\t\t\tnormals[i] = af * mesh_normals[a] + bf*mesh_normals[b] + cf*mesh_normals[c];\r\n\t\t\t\tnormals[i+1] = af * mesh_normals[a+1] + bf*mesh_normals[b+1] + cf*mesh_normals[c+1];\r\n\t\t\t\tnormals[i+2] = af * mesh_normals[a+2] + bf*mesh_normals[b+2] + cf*mesh_normals[c+2];\r\n\t\t\t\tvar N = normals.subarray(i,i+3);\r\n\t\t\t\tvec3.normalize(N,N);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tLGraphPoints3D.generateFromInsideObject = function( points, size, mesh )\r\n\t{\r\n\t\tif(!mesh || mesh.constructor !== GL.Mesh)\r\n\t\t\treturn;\r\n\r\n\t\tvar aabb = mesh.getBoundingBox();\r\n\t\tif(!mesh.octree)\r\n\t\t\tmesh.octree = new GL.Octree( mesh );\r\n\t\tvar octree = mesh.octree;\r\n\t\tvar origin = vec3.create();\r\n\t\tvar direction = vec3.fromValues(1,0,0);\r\n\t\tvar temp = vec3.create();\r\n\t\tvar i = 0;\r\n\t\tvar tries = 0;\r\n\t\twhile(i < size && tries < points.length * 10) //limit to avoid problems\r\n\t\t{\r\n\t\t\ttries += 1\r\n\t\t\tvar r = vec3.random(temp); //random point inside the aabb\r\n\t\t\tr[0] = (r[0] * 2 - 1) * aabb[3] + aabb[0];\r\n\t\t\tr[1] = (r[1] * 2 - 1) * aabb[4] + aabb[1];\r\n\t\t\tr[2] = (r[2] * 2 - 1) * aabb[5] + aabb[2];\r\n\t\t\torigin.set(r);\r\n\t\t\tvar hit = octree.testRay( origin, direction, 0, 10000, true, GL.Octree.ALL );\r\n\t\t\tif(!hit || hit.length % 2 == 0) //not inside\r\n\t\t\t\tcontinue;\r\n\t\t\tpoints.set( r, i );\r\n\t\t\ti+=3;\r\n\t\t}\r\n\t}\r\n\r\n\tLiteGraph.registerNodeType( "geometry/points3D", LGraphPoints3D );\r\n\r\n\r\n\r\n\tfunction LGraphPointsToInstances() {\r\n\t\tthis.addInput("points", "geometry");\r\n\t\tthis.addOutput("instances", "[mat4]");\r\n\t\tthis.properties = {\r\n\t\t\tmode: 1,\r\n\t\t\tautoupdate: true\r\n\t\t};\r\n\r\n\t\tthis.must_update = true;\r\n\t\tthis.matrices = [];\r\n\t\tthis.first_time = true;\r\n\t}\r\n\r\n\tLGraphPointsToInstances.NORMAL = 0;\r\n\tLGraphPointsToInstances.VERTICAL = 1;\r\n\tLGraphPointsToInstances.SPHERICAL = 2;\r\n\tLGraphPointsToInstances.RANDOM = 3;\r\n\tLGraphPointsToInstances.RANDOM_VERTICAL = 4;\r\n\r\n\tLGraphPointsToInstances.modes = {"normal":0,"vertical":1,"spherical":2,"random":3,"random_vertical":4};\r\n\tLGraphPointsToInstances.widgets_info = {\r\n\t\tmode: { widget: "combo", values: LGraphPointsToInstances.modes }\r\n\t};\r\n\r\n\tLGraphPointsToInstances.title = "points to inst";\r\n\r\n\tLGraphPointsToInstances.prototype.onExecute = function()\r\n\t{\r\n\t\tvar geo = this.getInputData(0);\r\n\t\tif( !geo )\r\n\t\t{\r\n\t\t\tthis.setOutputData(0,null);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif( !this.isOutputConnected(0) )\r\n\t\t\treturn;\r\n\r\n\t\tvar has_changed = (geo._version != this._version || geo._id != this._geometry_id);\r\n\r\n\t\tif( has_changed && this.properties.autoupdate || this.first_time )\r\n\t\t{\r\n\t\t\tthis.first_time = false;\r\n\t\t\tthis.updateInstances( geo );\r\n\t\t}\r\n\r\n\t\tthis.setOutputData( 0, this.matrices );\r\n\t}\r\n\r\n\tLGraphPointsToInstances.prototype.updateInstances = function( geometry )\r\n\t{\r\n\t\tvar vertices = geometry.vertices;\r\n\t\tif(!vertices)\r\n\t\t\treturn null;\r\n\t\tvar normals = geometry.normals;\r\n\r\n\t\tvar matrices = this.matrices;\r\n\t\tvar num_points = vertices.length / 3;\r\n\t\tif( matrices.length != num_points)\r\n\t\t\tmatrices.length = num_points;\r\n\t\tvar identity = mat4.create();\r\n\t\tvar temp = vec3.create();\r\n\t\tvar zero = vec3.create();\r\n\t\tvar UP = vec3.fromValues(0,1,0);\r\n\t\tvar FRONT = vec3.fromValues(0,0,-1);\r\n\t\tvar RIGHT = vec3.fromValues(1,0,0);\r\n\t\tvar R = quat.create();\r\n\r\n\t\tvar front = vec3.create();\r\n\t\tvar right = vec3.create();\r\n\t\tvar top = vec3.create();\r\n\r\n\t\tfor(var i = 0; i < vertices.length; i += 3)\r\n\t\t{\r\n\t\t\tvar index = i/3;\r\n\t\t\tvar m = matrices[index];\r\n\t\t\tif(!m)\r\n\t\t\t\tm = matrices[index] = mat4.create();\r\n\t\t\tm.set( identity );\r\n\t\t\tvar point = vertices.subarray(i,i+3);\r\n\r\n\t\t\tswitch(this.properties.mode)\r\n\t\t\t{\r\n\t\t\t\tcase LGraphPointsToInstances.NORMAL: \r\n\t\t\t\t\tmat4.setTranslation( m, point );\r\n\t\t\t\t\tif(normals)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar normal = normals.subarray(i,i+3);\r\n\t\t\t\t\t\ttop.set( normal );\r\n\t\t\t\t\t\tvec3.normalize( top, top );\r\n\t\t\t\t\t\tvec3.cross( right, FRONT, top );\r\n\t\t\t\t\t\tvec3.normalize( right, right );\r\n\t\t\t\t\t\tvec3.cross( front, right, top );\r\n\t\t\t\t\t\tvec3.normalize( front, front );\r\n\t\t\t\t\t\tm.set(right,0);\r\n\t\t\t\t\t\tm.set(top,4);\r\n\t\t\t\t\t\tm.set(front,8);\r\n\t\t\t\t\t\tmat4.setTranslation( m, point );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase LGraphPointsToInstances.VERTICAL: \r\n\t\t\t\t\tmat4.setTranslation( m, point );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase LGraphPointsToInstances.SPHERICAL: \r\n\t\t\t\t\tfront.set( point );\r\n\t\t\t\t\tvec3.normalize( front, front );\r\n\t\t\t\t\tvec3.cross( right, UP, front );\r\n\t\t\t\t\tvec3.normalize( right, right );\r\n\t\t\t\t\tvec3.cross( top, front, right );\r\n\t\t\t\t\tvec3.normalize( top, top );\r\n\t\t\t\t\tm.set(right,0);\r\n\t\t\t\t\tm.set(top,4);\r\n\t\t\t\t\tm.set(front,8);\r\n\t\t\t\t\tmat4.setTranslation( m, point );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase LGraphPointsToInstances.RANDOM:\r\n\t\t\t\t\ttemp[0] = Math.random()*2 - 1;\r\n\t\t\t\t\ttemp[1] = Math.random()*2 - 1;\r\n\t\t\t\t\ttemp[2] = Math.random()*2 - 1;\r\n\t\t\t\t\tvec3.normalize( temp, temp );\r\n\t\t\t\t\tquat.setAxisAngle( R, temp, Math.random() * 2 * Math.PI );\r\n\t\t\t\t\tmat4.fromQuat(m, R);\r\n\t\t\t\t\tmat4.setTranslation( m, point );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase LGraphPointsToInstances.RANDOM_VERTICAL:\r\n\t\t\t\t\tquat.setAxisAngle( R, UP, Math.random() * 2 * Math.PI );\r\n\t\t\t\t\tmat4.fromQuat(m, R);\r\n\t\t\t\t\tmat4.setTranslation( m, point );\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._version = geometry._version;\r\n\t\tthis._geometry_id = geometry._id;\r\n\t}\r\n\r\n\tLiteGraph.registerNodeType( "geometry/points_to_instances", LGraphPointsToInstances );\r\n\r\n\r\n\tfunction LGraphGeometryTransform() {\r\n\t\tthis.addInput("in", "geometry,[mat4]");\r\n\t\tthis.addInput("mat4", "mat4");\r\n\t\tthis.addOutput("out", "geometry");\r\n\t\tthis.properties = {};\r\n\r\n\t\tthis.geometry = {\r\n\t\t\ttype: "triangles",\r\n\t\t\tvertices: null,\r\n\t\t\t_id: generateGeometryId(),\r\n\t\t\t_version: 0\r\n\t\t};\r\n\r\n\t\tthis._last_geometry_id = -1;\r\n\t\tthis._last_version = -1;\r\n\t\tthis._last_key = "";\r\n\r\n\t\tthis.must_update = true;\r\n\t}\r\n\r\n\tLGraphGeometryTransform.title = "Transform";\r\n\r\n\tLGraphGeometryTransform.prototype.onExecute = function() {\r\n\r\n\t\tvar input = this.getInputData(0);\r\n\t\tvar model = this.getInputData(1);\r\n\r\n\t\tif(!input)\r\n\t\t\treturn;\r\n\r\n\t\t//array of matrices\r\n\t\tif(input.constructor === Array)\r\n\t\t{\r\n\t\t\tif(input.length == 0)\r\n\t\t\t\treturn;\r\n\t\t\tthis.outputs[0].type = "[mat4]";\r\n\t\t\tif( !this.isOutputConnected(0) )\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif(!model)\r\n\t\t\t{\r\n\t\t\t\tthis.setOutputData(0,input);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif(!this._output)\r\n\t\t\t\tthis._output = new Array();\r\n\t\t\tif(this._output.length != input.length)\r\n\t\t\t\tthis._output.length = input.length;\r\n\t\t\tfor(var i = 0; i < input.length; ++i)\r\n\t\t\t{\r\n\t\t\t\tvar m = this._output[i];\r\n\t\t\t\tif(!m)\r\n\t\t\t\t\tm = this._output[i] = mat4.create();\r\n\t\t\t\tmat4.multiply(m,input[i],model);\r\n\t\t\t}\r\n\t\t\tthis.setOutputData(0,this._output);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t//geometry\r\n\t\tif(!input.vertices || !input.vertices.length)\r\n\t\t\treturn;\r\n\t\tvar geo = input;\r\n\t\tthis.outputs[0].type = "geometry";\r\n\t\tif( !this.isOutputConnected(0) )\r\n\t\t\treturn;\r\n\t\tif(!model)\r\n\t\t{\r\n\t\t\tthis.setOutputData(0,geo);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar key = typedArrayToArray(model).join(",");\r\n\r\n\t\tif( this.must_update || geo._id != this._last_geometry_id || geo._version != this._last_version || key != this._last_key )\r\n\t\t{\r\n\t\t\tthis.updateGeometry(geo, model);\r\n\t\t\tthis._last_key = key;\r\n\t\t\tthis._last_version = geo._version;\r\n\t\t\tthis._last_geometry_id = geo._id;\r\n\t\t\tthis.must_update = false;\r\n\t\t}\r\n\r\n\t\tthis.setOutputData(0,this.geometry);\r\n\t}\r\n\r\n\tLGraphGeometryTransform.prototype.updateGeometry = function(geometry, model) {\r\n\t\tvar old_vertices = geometry.vertices;\r\n\t\tvar vertices = this.geometry.vertices;\r\n\t\tif( !vertices || vertices.length != old_vertices.length )\r\n\t\t\tvertices = this.geometry.vertices = new Float32Array( old_vertices.length );\r\n\t\tvar temp = vec3.create();\r\n\r\n\t\tfor(var i = 0, l = vertices.length; i < l; i+=3)\r\n\t\t{\r\n\t\t\ttemp[0] = old_vertices[i]; temp[1] = old_vertices[i+1]; temp[2] = old_vertices[i+2]; \r\n\t\t\tmat4.multiplyVec3( temp, model, temp );\r\n\t\t\tvertices[i] = temp[0]; vertices[i+1] = temp[1]; vertices[i+2] = temp[2];\r\n\t\t}\r\n\r\n\t\tif(geometry.normals)\r\n\t\t{\r\n\t\t\tif( !this.geometry.normals || this.geometry.normals.length != geometry.normals.length )\r\n\t\t\t\tthis.geometry.normals = new Float32Array( geometry.normals.length );\r\n\t\t\tvar normals = this.geometry.normals;\r\n\t\t\tvar normal_model = mat4.invert(mat4.create(), model);\r\n\t\t\tif(normal_model)\r\n\t\t\t\tmat4.transpose(normal_model, normal_model);\r\n\t\t\tvar old_normals = geometry.normals;\r\n\t\t\tfor(var i = 0, l = normals.length; i < l; i+=3)\r\n\t\t\t{\r\n\t\t\t\ttemp[0] = old_normals[i]; temp[1] = old_normals[i+1]; temp[2] = old_normals[i+2]; \r\n\t\t\t\tmat4.multiplyVec3( temp, normal_model, temp );\r\n\t\t\t\tnormals[i] = temp[0]; normals[i+1] = temp[1]; normals[i+2] = temp[2];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.geometry.type = geometry.type;\r\n\t\tthis.geometry._version++;\r\n\t}\r\n\r\n\tLiteGraph.registerNodeType( "geometry/transform", LGraphGeometryTransform );\r\n\r\n\r\n\tfunction LGraphGeometryPolygon() {\r\n\t\tthis.addInput("sides", "number");\r\n\t\tthis.addInput("radius", "number");\r\n\t\tthis.addOutput("out", "geometry");\r\n\t\tthis.properties = { sides: 6, radius: 1, uvs: false }\r\n\r\n\t\tthis.geometry = {\r\n\t\t\ttype: "line_loop",\r\n\t\t\tvertices: null,\r\n\t\t\t_id: generateGeometryId()\r\n\t\t};\r\n\t\tthis.geometry_id = -1;\r\n\t\tthis.version = -1;\r\n\t\tthis.must_update = true;\r\n\r\n\t\tthis.last_info = { sides: -1, radius: -1 };\r\n\t}\r\n\r\n\tLGraphGeometryPolygon.title = "Polygon";\r\n\r\n\tLGraphGeometryPolygon.prototype.onExecute = function() {\r\n\r\n\t\tif( !this.isOutputConnected(0) )\r\n\t\t\treturn;\r\n\r\n\t\tvar sides = this.getInputOrProperty("sides");\r\n\t\tvar radius = this.getInputOrProperty("radius");\r\n\t\tsides = Math.max(3,sides)|0;\r\n\r\n\t\t//update\r\n\t\tif( this.last_info.sides != sides || this.last_info.radius != radius )\r\n\t\t\tthis.updateGeometry(sides, radius);\r\n\r\n\t\tthis.setOutputData(0,this.geometry);\r\n\t}\r\n\r\n\tLGraphGeometryPolygon.prototype.updateGeometry = function(sides, radius) {\r\n\t\tvar num = 3*sides;\r\n\t\tvar vertices = this.geometry.vertices;\r\n\t\tif( !vertices || vertices.length != num )\r\n\t\t\tvertices = this.geometry.vertices = new Float32Array( 3*sides );\r\n\t\tvar delta = (Math.PI * 2) / sides;\r\n\t\tvar gen_uvs = this.properties.uvs;\r\n\t\tif(gen_uvs)\r\n\t\t{\r\n\t\t\tuvs = this.geometry.coords = new Float32Array( 3*sides );\r\n\t\t}\r\n\r\n\r\n\t\tfor(var i = 0; i < sides; ++i)\r\n\t\t{\r\n\t\t\tvar angle = delta * -i;\r\n\t\t\tvar x = Math.cos( angle ) * radius;\r\n\t\t\tvar y = 0;\r\n\t\t\tvar z = Math.sin( angle ) * radius;\r\n\t\t\tvertices[i*3] = x;\r\n\t\t\tvertices[i*3+1] = y;\r\n\t\t\tvertices[i*3+2] = z;\r\n\r\n\t\t\tif(gen_uvs)\r\n\t\t\t{\r\n\t\t\t\t\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.geometry._id = ++this.geometry_id;\r\n\t\tthis.geometry._version = ++this.version;\r\n\t\tthis.last_info.sides = sides;\r\n\t\tthis.last_info.radius = radius;\r\n\t}\r\n\r\n\tLiteGraph.registerNodeType( "geometry/polygon", LGraphGeometryPolygon );\r\n\r\n\r\n\tfunction LGraphGeometryExtrude() {\r\n\r\n\t\tthis.addInput("", "geometry");\r\n\t\tthis.addOutput("", "geometry");\r\n\t\tthis.properties = { top_cap: true, bottom_cap: true, offset: [0,100,0] };\r\n\t\tthis.version = -1;\r\n\r\n\t\tthis._last_geo_version = -1;\r\n\t\tthis._must_update = true;\r\n\t}\r\n\r\n\tLGraphGeometryExtrude.title = "extrude";\r\n\r\n\tLGraphGeometryExtrude.prototype.onPropertyChanged = function(name, value)\r\n\t{\r\n\t\tthis._must_update = true;\r\n\t}\r\n\r\n\tLGraphGeometryExtrude.prototype.onExecute = function()\r\n\t{\r\n\t\tvar geo = this.getInputData(0);\r\n\t\tif( !geo || !this.isOutputConnected(0) )\r\n\t\t\treturn;\r\n\r\n\t\tif(geo.version != this._last_geo_version || this._must_update)\r\n\t\t{\r\n\t\t\tthis._geo = this.extrudeGeometry( geo, this._geo );\r\n\t\t\tif(this._geo)\r\n\t\t\t\tthis._geo.version = this.version++;\r\n\t\t\tthis._must_update = false;\r\n\t\t}\r\n\r\n\t\tthis.setOutputData(0, this._geo);\r\n\t}\r\n\r\n\tLGraphGeometryExtrude.prototype.extrudeGeometry = function( geo )\r\n\t{\r\n\t\t//for every pair of vertices\r\n\t\tvar vertices = geo.vertices;\r\n\t\tvar num_points = vertices.length / 3;\r\n\r\n\t\tvar tempA = vec3.create();\r\n\t\tvar tempB = vec3.create();\r\n\t\tvar tempC = vec3.create();\r\n\t\tvar tempD = vec3.create();\r\n\t\tvar offset = new Float32Array( this.properties.offset );\r\n\r\n\t\tif(geo.type == "line_loop")\r\n\t\t{\r\n\t\t\tvar new_vertices = new Float32Array( num_points * 6 * 3 ); //every points become 6 ( caps not included )\r\n\t\t\tvar npos = 0;\r\n\t\t\tfor(var i = 0, l = vertices.length; i < l; i += 3)\r\n\t\t\t{\r\n\t\t\t\ttempA[0] = vertices[i]; tempA[1] = vertices[i+1]; tempA[2] = vertices[i+2];\r\n\r\n\t\t\t\tif( i+3 < l ) //loop\r\n\t\t\t\t{\r\n\t\t\t\t\ttempB[0] = vertices[i+3]; tempB[1] = vertices[i+4]; tempB[2] = vertices[i+5];\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\ttempB[0] = vertices[0]; tempB[1] = vertices[1]; tempB[2] = vertices[2];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvec3.add( tempC, tempA, offset );\r\n\t\t\t\tvec3.add( tempD, tempB, offset );\r\n\r\n\t\t\t\tnew_vertices.set( tempA, npos ); npos += 3;\r\n\t\t\t\tnew_vertices.set( tempB, npos ); npos += 3;\r\n\t\t\t\tnew_vertices.set( tempC, npos ); npos += 3;\r\n\r\n\t\t\t\tnew_vertices.set( tempB, npos ); npos += 3;\r\n\t\t\t\tnew_vertices.set( tempD, npos ); npos += 3;\r\n\t\t\t\tnew_vertices.set( tempC, npos ); npos += 3;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar out_geo = {\r\n\t\t\t_id: generateGeometryId(),\r\n\t\t\ttype: "triangles",\r\n\t\t\tvertices: new_vertices\r\n\t\t};\r\n\r\n\t\treturn out_geo;\r\n\t}\r\n\r\n\tLiteGraph.registerNodeType( "geometry/extrude", LGraphGeometryExtrude );\r\n\r\n\r\n\tfunction LGraphGeometryEval() {\r\n\t\tthis.addInput("in", "geometry");\r\n\t\tthis.addOutput("out", "geometry");\r\n\r\n\t\tthis.properties = {\r\n\t\t\tcode: "V[1] += 0.01 * Math.sin(I + T*0.001);",\r\n\t\t\texecute_every_frame: false\r\n\t\t};\r\n\r\n\t\tthis.geometry = null;\r\n\t\tthis.geometry_id = -1;\r\n\t\tthis.version = -1;\r\n\t\tthis.must_update = true;\r\n\r\n\t\tthis.vertices = null;\r\n\t\tthis.func = null;\r\n\t}\r\n\r\n\tLGraphGeometryEval.title = "geoeval";\r\n\tLGraphGeometryEval.desc = "eval code";\r\n\r\n\tLGraphGeometryEval.widgets_info = {\r\n\t\tcode: { widget: "code" }\r\n\t};\r\n\r\n\tLGraphGeometryEval.prototype.onConfigure = function(o)\r\n\t{\r\n\t\tthis.compileCode();\r\n\t}\r\n\r\n\tLGraphGeometryEval.prototype.compileCode = function()\r\n\t{\r\n\t\tif(!this.properties.code)\r\n\t\t\treturn;\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tthis.func = new Function("V","I","T", this.properties.code); \r\n\t\t\tthis.boxcolor = "#AFA";\r\n\t\t\tthis.must_update = true;\r\n\t\t}\r\n\t\tcatch (err)\r\n\t\t{\r\n\t\t\tthis.boxcolor = "red";\r\n\t\t}\r\n\t}\r\n\r\n\tLGraphGeometryEval.prototype.onPropertyChanged = function(name, value)\r\n\t{\r\n\t\tif(name == "code")\r\n\t\t{\r\n\t\t\tthis.properties.code = value;\r\n\t\t\tthis.compileCode();\r\n\t\t}\r\n\t}\r\n\r\n\tLGraphGeometryEval.prototype.onExecute = function() {\r\n\t\tvar geometry = this.getInputData(0);\r\n\t\tif(!geometry)\r\n\t\t\treturn;\r\n\r\n\t\tif(!this.func)\r\n\t\t{\r\n\t\t\tthis.setOutputData(0,geometry);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif( this.geometry_id != geometry._id || this.version != geometry._version || this.must_update || this.properties.execute_every_frame )\r\n\t\t{\r\n\t\t\tthis.must_update = false;\r\n\t\t\tthis.geometry_id = geometry._id;\r\n\t\t\tif(this.properties.execute_every_frame)\r\n\t\t\t\tthis.version++;\r\n\t\t\telse\r\n\t\t\t\tthis.version = geometry._version;\r\n\t\t\tvar func = this.func;\r\n\t\t\tvar T = getTime();\r\n\r\n\t\t\t//clone\r\n\t\t\tif(!this.geometry)\r\n\t\t\t\tthis.geometry = {};\r\n\t\t\tfor(var i in geometry)\r\n\t\t\t{\r\n\t\t\t\tif(geometry[i] == null)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tif( geometry[i].constructor == Float32Array )\r\n\t\t\t\t\tthis.geometry[i] = new Float32Array( geometry[i] );\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.geometry[i] = geometry[i];\r\n\t\t\t}\r\n\t\t\tthis.geometry._id = geometry._id;\r\n\t\t\tif(this.properties.execute_every_frame)\r\n\t\t\t\tthis.geometry._version = this.version;\r\n\t\t\telse\r\n\t\t\t\tthis.geometry._version = geometry._version + 1;\r\n\r\n\t\t\tvar V = vec3.create();\r\n\t\t\tvar vertices = this.vertices;\r\n\t\t\tif(!vertices || this.vertices.length != geometry.vertices.length)\r\n\t\t\t\tvertices = this.vertices = new Float32Array( geometry.vertices );\r\n\t\t\telse\r\n\t\t\t\tvertices.set( geometry.vertices );\r\n\t\t\tfor(var i = 0; i < vertices.length; i+=3)\r\n\t\t\t{\r\n\t\t\t\tV[0] = vertices[i];\r\n\t\t\t\tV[1] = vertices[i+1];\r\n\t\t\t\tV[2] = vertices[i+2];\r\n\t\t\t\tfunc(V,i/3,T);\r\n\t\t\t\tvertices[i] = V[0];\r\n\t\t\t\tvertices[i+1] = V[1];\r\n\t\t\t\tvertices[i+2] = V[2];\r\n\t\t\t}\r\n\t\t\tthis.geometry.vertices = vertices;\r\n\t\t}\r\n\r\n\t\tthis.setOutputData(0,this.geometry);\r\n\t}\r\n\r\n\tLiteGraph.registerNodeType( "geometry/eval", LGraphGeometryEval );\r\n\r\n/*\r\nfunction LGraphGeometryDisplace() {\r\n\t\tthis.addInput("in", "geometry");\r\n\t\tthis.addInput("img", "image");\r\n\t\tthis.addOutput("out", "geometry");\r\n\r\n\t\tthis.properties = {\r\n\t\t\tgrid_size: 1\r\n\t\t};\r\n\r\n\t\tthis.geometry = null;\r\n\t\tthis.geometry_id = -1;\r\n\t\tthis.version = -1;\r\n\t\tthis.must_update = true;\r\n\r\n\t\tthis.vertices = null;\r\n\t}\r\n\r\n\tLGraphGeometryDisplace.title = "displace";\r\n\tLGraphGeometryDisplace.desc = "displace points";\r\n\r\n\tLGraphGeometryDisplace.prototype.onExecute = function() {\r\n\t\tvar geometry = this.getInputData(0);\r\n\t\tvar image = this.getInputData(1);\r\n\t\tif(!geometry)\r\n\t\t\treturn;\r\n\r\n\t\tif(!image)\r\n\t\t{\r\n\t\t\tthis.setOutputData(0,geometry);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif( this.geometry_id != geometry._id || this.version != geometry._version || this.must_update )\r\n\t\t{\r\n\t\t\tthis.must_update = false;\r\n\t\t\tthis.geometry_id = geometry._id;\r\n\t\t\tthis.version = geometry._version;\r\n\r\n\t\t\t//copy\r\n\t\t\tthis.geometry = {};\r\n\t\t\tfor(var i in geometry)\r\n\t\t\t\tthis.geometry[i] = geometry[i];\r\n\t\t\tthis.geometry._id = geometry._id;\r\n\t\t\tthis.geometry._version = geometry._version + 1;\r\n\r\n\t\t\tvar grid_size = this.properties.grid_size;\r\n\t\t\tif(grid_size != 0)\r\n\t\t\t{\r\n\t\t\t\tvar vertices = this.vertices;\r\n\t\t\t\tif(!vertices || this.vertices.length != this.geometry.vertices.length)\r\n\t\t\t\t\tvertices = this.vertices = new Float32Array( this.geometry.vertices );\r\n\t\t\t\tfor(var i = 0; i < vertices.length; i+=3)\r\n\t\t\t\t{\r\n\t\t\t\t\tvertices[i] = Math.round(vertices[i]/grid_size) * grid_size;\r\n\t\t\t\t\tvertices[i+1] = Math.round(vertices[i+1]/grid_size) * grid_size;\r\n\t\t\t\t\tvertices[i+2] = Math.round(vertices[i+2]/grid_size) * grid_size;\r\n\t\t\t\t}\r\n\t\t\t\tthis.geometry.vertices = vertices;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.setOutputData(0,this.geometry);\r\n\t}\r\n\r\n\tLiteGraph.registerNodeType( "geometry/displace", LGraphGeometryDisplace );\r\n*/\r\n\r\n\tfunction LGraphConnectPoints() {\r\n\t\tthis.addInput("in", "geometry");\r\n\t\tthis.addOutput("out", "geometry");\r\n\r\n\t\tthis.properties = {\r\n\t\t\tmin_dist: 0.4,\r\n\t\t\tmax_dist: 0.5,\r\n\t\t\tmax_connections: 0,\r\n\t\t\tprobability: 1\r\n\t\t};\r\n\r\n\t\tthis.geometry_id = -1;\r\n\t\tthis.version = -1;\r\n\t\tthis.my_version = 1;\r\n\t\tthis.must_update = true;\r\n\t}\r\n\r\n\tLGraphConnectPoints.title = "connect points";\r\n\tLGraphConnectPoints.desc = "adds indices between near points";\r\n\r\n\tLGraphConnectPoints.prototype.onPropertyChanged = function(name,value)\r\n\t{\r\n\t\tthis.must_update = true;\r\n\t}\r\n\r\n\tLGraphConnectPoints.prototype.onExecute = function() {\r\n\t\tvar geometry = this.getInputData(0);\r\n\t\tif(!geometry)\r\n\t\t\treturn;\r\n\r\n\t\tif( this.geometry_id != geometry._id || this.version != geometry._version || this.must_update )\r\n\t\t{\r\n\t\t\tthis.must_update = false;\r\n\t\t\tthis.geometry_id = geometry._id;\r\n\t\t\tthis.version = geometry._version;\r\n\r\n\t\t\t//copy\r\n\t\t\tthis.geometry = {};\r\n\t\t\tfor(var i in geometry)\r\n\t\t\t\tthis.geometry[i] = geometry[i];\r\n\t\t\tthis.geometry._id = generateGeometryId();\r\n\t\t\tthis.geometry._version = this.my_version++;\r\n\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\t\tvar l = vertices.length;\r\n\t\t\tvar min_dist = this.properties.min_dist;\r\n\t\t\tvar max_dist = this.properties.max_dist;\r\n\t\t\tvar probability = this.properties.probability;\r\n\t\t\tvar max_connections = this.properties.max_connections;\r\n\t\t\tvar indices = [];\r\n\t\t\t\r\n\t\t\tfor(var i = 0; i < l; i+=3)\r\n\t\t\t{\r\n\t\t\t\tvar x = vertices[i];\r\n\t\t\t\tvar y = vertices[i+1];\r\n\t\t\t\tvar z = vertices[i+2];\r\n\t\t\t\tvar connections = 0;\r\n\t\t\t\tfor(var j = i+3; j < l; j+=3)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar x2 = vertices[j];\r\n\t\t\t\t\tvar y2 = vertices[j+1];\r\n\t\t\t\t\tvar z2 = vertices[j+2];\r\n\t\t\t\t\tvar dist = Math.sqrt( (x-x2)*(x-x2) + (y-y2)*(y-y2) + (z-z2)*(z-z2));\r\n\t\t\t\t\tif(dist > max_dist || dist < min_dist || (probability < 1 && probability < Math.random()) )\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tindices.push(i/3,j/3);\r\n\t\t\t\t\tconnections += 1;\r\n\t\t\t\t\tif(max_connections && connections > max_connections)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.geometry.indices = this.indices = new Uint32Array(indices);\r\n\t\t}\r\n\r\n\t\tif(this.indices && this.indices.length)\r\n\t\t{\r\n\t\t\tthis.geometry.indices = this.indices;\r\n\t\t\tthis.setOutputData( 0, this.geometry );\r\n\t\t}\r\n\t\telse\r\n\t\t\tthis.setOutputData( 0, null );\r\n\t}\r\n\r\n\tLiteGraph.registerNodeType( "geometry/connectPoints", LGraphConnectPoints );\r\n\r\n    //Works with Litegl.js to create WebGL nodes\r\n    if (typeof GL == "undefined") //LiteGL RELATED **********************************************\r\n\t\treturn;\r\n\r\n\tfunction LGraphToGeometry() {\r\n\t\tthis.addInput("mesh", "mesh");\r\n\t\tthis.addOutput("out", "geometry");\r\n\r\n\t\tthis.geometry = {};\r\n\t\tthis.last_mesh = null;\r\n\t}\r\n\r\n\tLGraphToGeometry.title = "to geometry";\r\n\tLGraphToGeometry.desc = "converts a mesh to geometry";\r\n\r\n\tLGraphToGeometry.prototype.onExecute = function() {\r\n\t\tvar mesh = this.getInputData(0);\r\n\t\tif(!mesh)\r\n\t\t\treturn;\r\n\r\n\t\tif(mesh != this.last_mesh)\r\n\t\t{\r\n\t\t\tthis.last_mesh = mesh;\r\n\t\t\tfor(i in mesh.vertexBuffers)\r\n\t\t\t{\r\n\t\t\t\tvar buffer = mesh.vertexBuffers[i];\r\n\t\t\t\tthis.geometry[i] = buffer.data\r\n\t\t\t}\r\n\t\t\tif(mesh.indexBuffers["triangles"])\r\n\t\t\t\tthis.geometry.indices = mesh.indexBuffers["triangles"].data;\r\n\r\n\t\t\tthis.geometry._id = generateGeometryId();\r\n\t\t\tthis.geometry._version = 0;\r\n\t\t}\r\n\r\n\t\tthis.setOutputData(0,this.geometry);\r\n\t\tif(this.geometry)\r\n\t\t\tthis.setOutputData(1,this.geometry.vertices);\r\n\t}\r\n\r\n\tLiteGraph.registerNodeType( "geometry/toGeometry", LGraphToGeometry );\r\n\r\n\tfunction LGraphGeometryToMesh() {\r\n\t\tthis.addInput("in", "geometry");\r\n\t\tthis.addOutput("mesh", "mesh");\r\n\t\tthis.properties = {};\r\n\t\tthis.version = -1;\r\n\t\tthis.mesh = null;\r\n\t}\r\n\r\n\tLGraphGeometryToMesh.title = "Geo to Mesh";\r\n\r\n\tLGraphGeometryToMesh.prototype.updateMesh = function(geometry)\r\n\t{\r\n\t\tif(!this.mesh)\r\n\t\t\tthis.mesh = new GL.Mesh();\r\n\r\n\t\tfor(var i in geometry)\r\n\t\t{\r\n\t\t\tif(i[0] == "_")\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tvar buffer_data = geometry[i];\r\n\r\n\t\t\tvar info = GL.Mesh.common_buffers[i];\r\n\t\t\tif(!info && i != "indices") //unknown buffer\r\n\t\t\t\tcontinue;\r\n\t\t\tvar spacing = info ? info.spacing : 3;\r\n\t\t\tvar mesh_buffer = this.mesh.vertexBuffers[i];\r\n\r\n\t\t\tif(!mesh_buffer || mesh_buffer.data.length != buffer_data.length)\r\n\t\t\t{\r\n\t\t\t\tmesh_buffer = new GL.Buffer( i == "indices" ? GL.ELEMENT_ARRAY_BUFFER : GL.ARRAY_BUFFER, buffer_data, spacing, GL.DYNAMIC_DRAW );\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tmesh_buffer.data.set( buffer_data );\r\n\t\t\t\tmesh_buffer.upload(GL.DYNAMIC_DRAW);\r\n\t\t\t}\r\n\r\n\t\t\tthis.mesh.addBuffer( i, mesh_buffer );\r\n\t\t}\r\n\r\n\t\tif(this.mesh.vertexBuffers.normals &&this.mesh.vertexBuffers.normals.data.length != this.mesh.vertexBuffers.vertices.data.length )\r\n\t\t{\r\n\t\t\tvar n = new Float32Array([0,1,0]);\r\n\t\t\tvar normals = new Float32Array( this.mesh.vertexBuffers.vertices.data.length );\r\n\t\t\tfor(var i = 0; i < normals.length; i+= 3)\r\n\t\t\t\tnormals.set( n, i );\r\n\t\t\tmesh_buffer = new GL.Buffer( GL.ARRAY_BUFFER, normals, 3 );\r\n\t\t\tthis.mesh.addBuffer( "normals", mesh_buffer );\r\n\t\t}\r\n\r\n\t\tthis.mesh.updateBoundingBox();\r\n\t\tthis.geometry_id = this.mesh.id = geometry._id;\r\n\t\tthis.version = this.mesh.version = geometry._version;\r\n\t\treturn this.mesh;\r\n\t}\r\n\r\n\tLGraphGeometryToMesh.prototype.onExecute = function() {\r\n\r\n\t\tvar geometry = this.getInputData(0);\r\n\t\tif(!geometry)\r\n\t\t\treturn;\r\n\t\tif( this.version != geometry._version || this.geometry_id != geometry._id )\r\n\t\t\tthis.updateMesh( geometry );\r\n\t\tthis.setOutputData(0, this.mesh);\r\n\t}\r\n\r\n\tLiteGraph.registerNodeType( "geometry/toMesh", LGraphGeometryToMesh );\r\n\r\n\tfunction LGraphRenderMesh() {\r\n\t\tthis.addInput("mesh", "mesh");\r\n\t\tthis.addInput("mat4", "mat4");\r\n\t\tthis.addInput("tex", "texture");\r\n\r\n\t\tthis.properties = {\r\n\t\t\tenabled: true,\r\n\t\t\tprimitive: GL.TRIANGLES,\r\n\t\t\tadditive: false,\r\n\t\t\tcolor: [1,1,1],\r\n\t\t\topacity: 1\r\n\t\t};\r\n\r\n\t\tthis.color = vec4.create([1,1,1,1]);\r\n\t\tthis.model_matrix = mat4.create();\r\n\t\tthis.uniforms = {\r\n\t\t\tu_color: this.color,\r\n\t\t\tu_model: this.model_matrix\r\n\t\t};\r\n\t}\r\n\r\n\tLGraphRenderMesh.title = "Render Mesh";\r\n\tLGraphRenderMesh.desc = "renders a mesh flat";\r\n\r\n\tLGraphRenderMesh.PRIMITIVE_VALUES = { "points":GL.POINTS, "lines":GL.LINES, "line_loop":GL.LINE_LOOP,"line_strip":GL.LINE_STRIP, "triangles":GL.TRIANGLES, "triangle_fan":GL.TRIANGLE_FAN, "triangle_strip":GL.TRIANGLE_STRIP };\r\n\r\n\tLGraphRenderMesh.widgets_info = {\r\n\t\tprimitive: { widget: "combo", values: LGraphRenderMesh.PRIMITIVE_VALUES },\r\n\t\tcolor: { widget: "color" }\r\n\t};\r\n\r\n\tLGraphRenderMesh.prototype.onExecute = function() {\r\n\r\n\t\tif(!this.properties.enabled)\r\n\t\t\treturn;\r\n\r\n\t\tvar mesh = this.getInputData(0);\r\n\t\tif(!mesh)\r\n\t\t\treturn;\r\n\r\n\t\tif(!LiteGraph.LGraphRender.onRequestCameraMatrices)\r\n\t\t{\r\n\t\t\tconsole.warn("cannot render geometry, LiteGraph.onRequestCameraMatrices is null, remember to fill this with a callback(view_matrix, projection_matrix,viewprojection_matrix) to use 3D rendering from the graph");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tLiteGraph.LGraphRender.onRequestCameraMatrices( view_matrix, projection_matrix,viewprojection_matrix );\r\n\t\tvar shader = null;\r\n\t\tvar texture = this.getInputData(2);\r\n\t\tif(texture)\r\n\t\t{\r\n\t\t\tshader = gl.shaders["textured"];\r\n\t\t\tif(!shader)\r\n\t\t\t\tshader = gl.shaders["textured"] = new GL.Shader( LGraphRenderPoints.vertex_shader_code, LGraphRenderPoints.fragment_shader_code, { USE_TEXTURE:"" });\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tshader = gl.shaders["flat"];\r\n\t\t\tif(!shader)\r\n\t\t\t\tshader = gl.shaders["flat"] = new GL.Shader( LGraphRenderPoints.vertex_shader_code, LGraphRenderPoints.fragment_shader_code );\r\n\t\t}\r\n\r\n\t\tthis.color.set( this.properties.color );\r\n\t\tthis.color[3] = this.properties.opacity;\r\n\r\n\t\tvar model_matrix = this.model_matrix;\r\n\t\tvar m = this.getInputData(1);\r\n\t\tif(m)\r\n\t\t\tmodel_matrix.set(m);\r\n\t\telse\r\n\t\t\tmat4.identity( model_matrix );\r\n\r\n\t\tthis.uniforms.u_point_size = 1;\r\n\t\tvar primitive = this.properties.primitive;\r\n\r\n\t\tshader.uniforms( global_uniforms );\r\n\t\tshader.uniforms( this.uniforms );\r\n\r\n\t\tif(this.properties.opacity >= 1)\r\n\t\t\tgl.disable( gl.BLEND );\r\n\t\telse\r\n\t\t\tgl.enable( gl.BLEND );\r\n\t\tgl.enable( gl.DEPTH_TEST );\r\n\t\tif( this.properties.additive )\r\n\t\t{\r\n\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\r\n\t\t\tgl.depthMask( false );\r\n\t\t}\r\n\t\telse\r\n\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\tvar indices = "indices";\r\n\t\tif( mesh.indexBuffers.triangles )\r\n\t\t\tindices = "triangles";\r\n\t\tshader.draw( mesh, primitive, indices );\r\n\t\tgl.disable( gl.BLEND );\r\n\t\tgl.depthMask( true );\r\n\t}\r\n\r\n\tLiteGraph.registerNodeType( "geometry/render_mesh", LGraphRenderMesh );\r\n\r\n\t//**************************\r\n\r\n\r\n\tfunction LGraphGeometryPrimitive() {\r\n\t\tthis.addInput("size", "number");\r\n\t\tthis.addOutput("out", "mesh");\r\n\t\tthis.properties = { type: 1, size: 1, subdivisions: 32 };\r\n\r\n\t\tthis.version = (Math.random() * 100000)|0;\r\n\t\tthis.last_info = { type: -1, size: -1, subdivisions: -1 };\r\n\t}\r\n\r\n\tLGraphGeometryPrimitive.title = "Primitive";\r\n\r\n\tLGraphGeometryPrimitive.VALID = { "CUBE":1, "PLANE":2, "CYLINDER":3, "SPHERE":4, "CIRCLE":5, "HEMISPHERE":6, "ICOSAHEDRON":7, "CONE":8, "QUAD":9 };\r\n\tLGraphGeometryPrimitive.widgets_info = {\r\n\t\ttype: { widget: "combo", values: LGraphGeometryPrimitive.VALID }\r\n\t};\r\n\r\n\tLGraphGeometryPrimitive.prototype.onExecute = function() {\r\n\r\n\t\tif( !this.isOutputConnected(0) )\r\n\t\t\treturn;\r\n\r\n\t\tvar size = this.getInputOrProperty("size");\r\n\r\n\t\t//update\r\n\t\tif( this.last_info.type != this.properties.type || this.last_info.size != size || this.last_info.subdivisions != this.properties.subdivisions )\r\n\t\t\tthis.updateMesh( this.properties.type, size, this.properties.subdivisions );\r\n\r\n\t\tthis.setOutputData(0,this._mesh);\r\n\t}\r\n\r\n\tLGraphGeometryPrimitive.prototype.updateMesh = function(type, size, subdivisions)\r\n\t{\r\n\t\tsubdivisions = Math.max(0,subdivisions)|0;\r\n\r\n\t\tswitch (type)\r\n\t\t{\r\n\t\t\tcase 1: //CUBE: \r\n\t\t\t\tthis._mesh = GL.Mesh.cube({size: size, normals:true,coords:true});\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2: //PLANE:\r\n\t\t\t\tthis._mesh = GL.Mesh.plane({size: size, xz: true, detail: subdivisions, normals:true,coords:true});\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3: //CYLINDER:\r\n\t\t\t\tthis._mesh = GL.Mesh.cylinder({size: size, subdivisions: subdivisions, normals:true,coords:true});\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4: //SPHERE:\r\n\t\t\t\tthis._mesh = GL.Mesh.sphere({size: size, "long": subdivisions, lat: subdivisions, normals:true,coords:true});\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5: //CIRCLE:\r\n\t\t\t\tthis._mesh = GL.Mesh.circle({size: size, slices: subdivisions, normals:true, coords:true});\r\n\t\t\t\tbreak;\r\n\t\t\tcase 6: //HEMISPHERE:\r\n\t\t\t\tthis._mesh = GL.Mesh.sphere({size: size, "long": subdivisions, lat: subdivisions, normals:true, coords:true, hemi: true});\r\n\t\t\t\tbreak;\r\n\t\t\tcase 7: //ICOSAHEDRON:\r\n\t\t\t\tthis._mesh = GL.Mesh.icosahedron({size: size, subdivisions:subdivisions });\r\n\t\t\t\tbreak;\r\n\t\t\tcase 8: //CONE:\r\n\t\t\t\tthis._mesh = GL.Mesh.cone({radius: size, height: size, subdivisions:subdivisions });\r\n\t\t\t\tbreak;\r\n\t\t\tcase 9: //QUAD:\r\n\t\t\t\tthis._mesh = GL.Mesh.plane({size: size, xz: false, detail: subdivisions, normals:true, coords:true });\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tthis.last_info.type = type;\r\n\t\tthis.last_info.size = size;\r\n\t\tthis.last_info.subdivisions = subdivisions;\r\n\t\tthis._mesh.version = this.version++;\r\n\t}\r\n\r\n\tLiteGraph.registerNodeType( "geometry/mesh_primitive", LGraphGeometryPrimitive );\r\n\r\n\r\n\tfunction LGraphRenderPoints() {\r\n\t\tthis.addInput("in", "geometry");\r\n\t\tthis.addInput("mat4", "mat4");\r\n\t\tthis.addInput("tex", "texture");\r\n\t\tthis.properties = {\r\n\t\t\tenabled: true,\r\n\t\t\tpoint_size: 0.1,\r\n\t\t\tfixed_size: false,\r\n\t\t\tadditive: true,\r\n\t\t\tcolor: [1,1,1],\r\n\t\t\topacity: 1\r\n\t\t};\r\n\r\n\t\tthis.color = vec4.create([1,1,1,1]);\r\n\r\n\t\tthis.uniforms = {\r\n\t\t\tu_point_size: 1,\r\n\t\t\tu_perspective: 1,\r\n\t\t\tu_point_perspective: 1,\r\n\t\t\tu_color: this.color\r\n\t\t};\r\n\r\n\t\tthis.geometry_id = -1;\r\n\t\tthis.version = -1;\r\n\t\tthis.mesh = null;\r\n\t}\r\n\r\n\tLGraphRenderPoints.title = "renderPoints";\r\n\tLGraphRenderPoints.desc = "render points with a texture";\r\n\r\n\tLGraphRenderPoints.widgets_info = {\r\n\t\tcolor: { widget: "color" }\r\n\t};\r\n\r\n\tLGraphRenderPoints.prototype.updateMesh = function(geometry)\r\n\t{\r\n\t\tvar buffer = this.buffer;\r\n\t\tif(!this.buffer || !this.buffer.data || this.buffer.data.length != geometry.vertices.length)\r\n\t\t\tthis.buffer = new GL.Buffer( GL.ARRAY_BUFFER, geometry.vertices,3,GL.DYNAMIC_DRAW);\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.buffer.data.set( geometry.vertices );\r\n\t\t\tthis.buffer.upload(GL.DYNAMIC_DRAW);\r\n\t\t}\r\n\r\n\t\tif(!this.mesh)\r\n\t\t\tthis.mesh = new GL.Mesh();\r\n\r\n\t\tthis.mesh.addBuffer("vertices",this.buffer);\r\n\t\tthis.geometry_id = this.mesh.id = geometry._id;\r\n\t\tthis.version = this.mesh.version = geometry._version;\r\n\t}\r\n\r\n\tLGraphRenderPoints.prototype.onExecute = function() {\r\n\r\n\t\tif(!this.properties.enabled)\r\n\t\t\treturn;\r\n\r\n\t\tvar geometry = this.getInputData(0);\r\n\t\tif(!geometry)\r\n\t\t\treturn;\r\n\t\tif(this.version != geometry._version || this.geometry_id != geometry._id )\r\n\t\t\tthis.updateMesh( geometry );\r\n\r\n\t\tif(!LiteGraph.LGraphRender.onRequestCameraMatrices)\r\n\t\t{\r\n\t\t\tconsole.warn("cannot render geometry, LiteGraph.onRequestCameraMatrices is null, remember to fill this with a callback(view_matrix, projection_matrix,viewprojection_matrix) to use 3D rendering from the graph");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tLiteGraph.LGraphRender.onRequestCameraMatrices( view_matrix, projection_matrix,viewprojection_matrix );\r\n\t\tvar shader = null;\r\n\r\n\t\tvar texture = this.getInputData(2);\r\n\t\t\r\n\t\tif(texture)\r\n\t\t{\r\n\t\t\tshader = gl.shaders["textured_points"];\r\n\t\t\tif(!shader)\r\n\t\t\t\tshader = gl.shaders["textured_points"] = new GL.Shader( LGraphRenderPoints.vertex_shader_code, LGraphRenderPoints.fragment_shader_code, { USE_TEXTURED_POINTS:"" });\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tshader = gl.shaders["points"];\r\n\t\t\tif(!shader)\r\n\t\t\t\tshader = gl.shaders["points"] = new GL.Shader( LGraphRenderPoints.vertex_shader_code, LGraphRenderPoints.fragment_shader_code, { USE_POINTS: "" });\r\n\t\t}\r\n\r\n\t\tthis.color.set( this.properties.color );\r\n\t\tthis.color[3] = this.properties.opacity;\r\n\r\n\t\tvar m = this.getInputData(1);\r\n\t\tif(m)\r\n\t\t\tmodel_matrix.set(m);\r\n\t\telse\r\n\t\t\tmat4.identity( model_matrix );\r\n\r\n\t\tthis.uniforms.u_point_size = this.properties.point_size;\r\n\t\tthis.uniforms.u_point_perspective = this.properties.fixed_size ? 0 : 1;\r\n\t\tthis.uniforms.u_perspective = gl.viewport_data[3] * projection_matrix[5];\r\n\r\n\t\tshader.uniforms( global_uniforms );\r\n\t\tshader.uniforms( this.uniforms );\r\n\r\n\t\tif(this.properties.opacity >= 1)\r\n\t\t\tgl.disable( gl.BLEND );\r\n\t\telse\r\n\t\t\tgl.enable( gl.BLEND );\r\n\r\n\t\tgl.enable( gl.DEPTH_TEST );\r\n\t\tif( this.properties.additive )\r\n\t\t{\r\n\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\r\n\t\t\tgl.depthMask( false );\r\n\t\t}\r\n\t\telse\r\n\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\tshader.draw( this.mesh, GL.POINTS );\r\n\r\n\t\tgl.disable( gl.BLEND );\r\n\t\tgl.depthMask( true );\r\n\t}\r\n\r\n\tLiteGraph.registerNodeType( "geometry/render_points", LGraphRenderPoints );\r\n\r\n\tLGraphRenderPoints.vertex_shader_code = \'\\\r\n\t\tprecision mediump float;\\n\\\r\n\t\tattribute vec3 a_vertex;\\n\\\r\n\t\tvarying vec3 v_vertex;\\n\\\r\n\t\tattribute vec3 a_normal;\\n\\\r\n\t\tvarying vec3 v_normal;\\n\\\r\n\t\t#ifdef USE_COLOR\\n\\\r\n\t\t\tattribute vec4 a_color;\\n\\\r\n\t\t\tvarying vec4 v_color;\\n\\\r\n\t\t#endif\\n\\\r\n\t\tattribute vec2 a_coord;\\n\\\r\n\t\tvarying vec2 v_coord;\\n\\\r\n\t\t#ifdef USE_SIZE\\n\\\r\n\t\t\tattribute float a_extra;\\n\\\r\n\t\t#endif\\n\\\r\n\t\t#ifdef USE_INSTANCING\\n\\\r\n\t\t\tattribute mat4 u_model;\\n\\\r\n\t\t#else\\n\\\r\n\t\t\tuniform mat4 u_model;\\n\\\r\n\t\t#endif\\n\\\r\n\t\tuniform mat4 u_viewprojection;\\n\\\r\n\t\tuniform float u_point_size;\\n\\\r\n\t\tuniform float u_perspective;\\n\\\r\n\t\tuniform float u_point_perspective;\\n\\\r\n\t\tfloat computePointSize(float radius, float w)\\n\\\r\n\t\t{\\n\\\r\n\t\t\tif(radius < 0.0)\\n\\\r\n\t\t\t\treturn -radius;\\n\\\r\n\t\t\treturn u_perspective * radius / w;\\n\\\r\n\t\t}\\n\\\r\n\t\tvoid main() {\\n\\\r\n\t\t\tv_coord = a_coord;\\n\\\r\n\t\t\t#ifdef USE_COLOR\\n\\\r\n\t\t\t\tv_color = a_color;\\n\\\r\n\t\t\t#endif\\n\\\r\n\t\t\tv_vertex = ( u_model * vec4( a_vertex, 1.0 )).xyz;\\n\\\r\n\t\t\tv_normal = ( u_model * vec4( a_normal, 0.0 )).xyz;\\n\\\r\n\t\t\tgl_Position = u_viewprojection * vec4(v_vertex,1.0);\\n\\\r\n\t\t\tgl_PointSize = u_point_size;\\n\\\r\n\t\t\t#ifdef USE_SIZE\\n\\\r\n\t\t\t\tgl_PointSize = a_extra;\\n\\\r\n\t\t\t#endif\\n\\\r\n\t\t\tif(u_point_perspective != 0.0)\\n\\\r\n\t\t\t\tgl_PointSize = computePointSize( gl_PointSize, gl_Position.w );\\n\\\r\n\t\t}\\\r\n\t\';\r\n\r\n\tLGraphRenderPoints.fragment_shader_code = \'\\\r\n\t\tprecision mediump float;\\n\\\r\n\t\tuniform vec4 u_color;\\n\\\r\n\t\t#ifdef USE_COLOR\\n\\\r\n\t\t\tvarying vec4 v_color;\\n\\\r\n\t\t#endif\\n\\\r\n\t\tvarying vec2 v_coord;\\n\\\r\n\t\tuniform sampler2D u_texture;\\n\\\r\n\t\tvoid main() {\\n\\\r\n\t\t\tvec4 color = u_color;\\n\\\r\n\t\t\t#ifdef USE_TEXTURED_POINTS\\n\\\r\n\t\t\t\tcolor *= texture2D(u_texture, gl_PointCoord.xy);\\n\\\r\n\t\t\t#else\\n\\\r\n\t\t\t\t#ifdef USE_TEXTURE\\n\\\r\n\t\t\t\t  color *= texture2D(u_texture, v_coord);\\n\\\r\n\t\t\t\t  if(color.a < 0.1)\\n\\\r\n\t\t\t\t\tdiscard;\\n\\\r\n\t\t\t\t#endif\\n\\\r\n\t\t\t\t#ifdef USE_POINTS\\n\\\r\n\t\t\t\t\tfloat dist = length( gl_PointCoord.xy - vec2(0.5) );\\n\\\r\n\t\t\t\t\tif( dist > 0.45 )\\n\\\r\n\t\t\t\t\t\tdiscard;\\n\\\r\n\t\t\t\t#endif\\n\\\r\n\t\t\t#endif\\n\\\r\n\t\t\t#ifdef USE_COLOR\\n\\\r\n\t\t\t\tcolor *= v_color;\\n\\\r\n\t\t\t#endif\\n\\\r\n\t\t\tgl_FragColor = color;\\n\\\r\n\t\t}\\\r\n\t\';\r\n\r\n\t//based on https://inconvergent.net/2019/depth-of-field/\r\n\t/*\r\n\tfunction LGraphRenderGeometryDOF() {\r\n\t\tthis.addInput("in", "geometry");\r\n\t\tthis.addInput("mat4", "mat4");\r\n\t\tthis.addInput("tex", "texture");\r\n\t\tthis.properties = {\r\n\t\t\tenabled: true,\r\n\t\t\tlines: true,\r\n\t\t\tpoint_size: 0.1,\r\n\t\t\tfixed_size: false,\r\n\t\t\tadditive: true,\r\n\t\t\tcolor: [1,1,1],\r\n\t\t\topacity: 1\r\n\t\t};\r\n\r\n\t\tthis.color = vec4.create([1,1,1,1]);\r\n\r\n\t\tthis.uniforms = {\r\n\t\t\tu_point_size: 1,\r\n\t\t\tu_perspective: 1,\r\n\t\t\tu_point_perspective: 1,\r\n\t\t\tu_color: this.color\r\n\t\t};\r\n\r\n\t\tthis.geometry_id = -1;\r\n\t\tthis.version = -1;\r\n\t\tthis.mesh = null;\r\n\t}\r\n\r\n\tLGraphRenderGeometryDOF.widgets_info = {\r\n\t\tcolor: { widget: "color" }\r\n\t};\r\n\r\n\tLGraphRenderGeometryDOF.prototype.updateMesh = function(geometry)\r\n\t{\r\n\t\tvar buffer = this.buffer;\r\n\t\tif(!this.buffer || this.buffer.data.length != geometry.vertices.length)\r\n\t\t\tthis.buffer = new GL.Buffer( GL.ARRAY_BUFFER, geometry.vertices,3,GL.DYNAMIC_DRAW);\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.buffer.data.set( geometry.vertices );\r\n\t\t\tthis.buffer.upload(GL.DYNAMIC_DRAW);\r\n\t\t}\r\n\r\n\t\tif(!this.mesh)\r\n\t\t\tthis.mesh = new GL.Mesh();\r\n\r\n\t\tthis.mesh.addBuffer("vertices",this.buffer);\r\n\t\tthis.geometry_id = this.mesh.id = geometry._id;\r\n\t\tthis.version = this.mesh.version = geometry._version;\r\n\t}\r\n\r\n\tLGraphRenderGeometryDOF.prototype.onExecute = function() {\r\n\r\n\t\tif(!this.properties.enabled)\r\n\t\t\treturn;\r\n\r\n\t\tvar geometry = this.getInputData(0);\r\n\t\tif(!geometry)\r\n\t\t\treturn;\r\n\t\tif(this.version != geometry._version || this.geometry_id != geometry._id )\r\n\t\t\tthis.updateMesh( geometry );\r\n\r\n\t\tif(!LiteGraph.LGraphRender.onRequestCameraMatrices)\r\n\t\t{\r\n\t\t\tconsole.warn("cannot render geometry, LiteGraph.onRequestCameraMatrices is null, remember to fill this with a callback(view_matrix, projection_matrix,viewprojection_matrix) to use 3D rendering from the graph");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tLiteGraph.LGraphRender.onRequestCameraMatrices( view_matrix, projection_matrix,viewprojection_matrix );\r\n\t\tvar shader = null;\r\n\r\n\t\tvar texture = this.getInputData(2);\r\n\t\t\r\n\t\tif(texture)\r\n\t\t{\r\n\t\t\tshader = gl.shaders["textured_points"];\r\n\t\t\tif(!shader)\r\n\t\t\t\tshader = gl.shaders["textured_points"] = new GL.Shader( LGraphRenderGeometryDOF.vertex_shader_code, LGraphRenderGeometryDOF.fragment_shader_code, { USE_TEXTURED_POINTS:"" });\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tshader = gl.shaders["points"];\r\n\t\t\tif(!shader)\r\n\t\t\t\tshader = gl.shaders["points"] = new GL.Shader( LGraphRenderGeometryDOF.vertex_shader_code, LGraphRenderGeometryDOF.fragment_shader_code, { USE_POINTS: "" });\r\n\t\t}\r\n\r\n\t\tthis.color.set( this.properties.color );\r\n\t\tthis.color[3] = this.properties.opacity;\r\n\r\n\t\tvar m = this.getInputData(1);\r\n\t\tif(m)\r\n\t\t\tmodel_matrix.set(m);\r\n\t\telse\r\n\t\t\tmat4.identity( model_matrix );\r\n\r\n\t\tthis.uniforms.u_point_size = this.properties.point_size;\r\n\t\tthis.uniforms.u_point_perspective = this.properties.fixed_size ? 0 : 1;\r\n\t\tthis.uniforms.u_perspective = gl.viewport_data[3] * projection_matrix[5];\r\n\r\n\t\tshader.uniforms( global_uniforms );\r\n\t\tshader.uniforms( this.uniforms );\r\n\r\n\t\tif(this.properties.opacity >= 1)\r\n\t\t\tgl.disable( gl.BLEND );\r\n\t\telse\r\n\t\t\tgl.enable( gl.BLEND );\r\n\r\n\t\tgl.enable( gl.DEPTH_TEST );\r\n\t\tif( this.properties.additive )\r\n\t\t{\r\n\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\r\n\t\t\tgl.depthMask( false );\r\n\t\t}\r\n\t\telse\r\n\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\tshader.draw( this.mesh, GL.POINTS );\r\n\r\n\t\tgl.disable( gl.BLEND );\r\n\t\tgl.depthMask( true );\r\n\t}\r\n\r\n\tLiteGraph.registerNodeType( "geometry/render_dof", LGraphRenderGeometryDOF );\r\n\r\n\tLGraphRenderGeometryDOF.vertex_shader_code = \'\\\r\n\t\tprecision mediump float;\\n\\\r\n\t\tattribute vec3 a_vertex;\\n\\\r\n\t\tvarying vec3 v_vertex;\\n\\\r\n\t\tattribute vec3 a_normal;\\n\\\r\n\t\tvarying vec3 v_normal;\\n\\\r\n\t\t#ifdef USE_COLOR\\n\\\r\n\t\t\tattribute vec4 a_color;\\n\\\r\n\t\t\tvarying vec4 v_color;\\n\\\r\n\t\t#endif\\n\\\r\n\t\tattribute vec2 a_coord;\\n\\\r\n\t\tvarying vec2 v_coord;\\n\\\r\n\t\t#ifdef USE_SIZE\\n\\\r\n\t\t\tattribute float a_extra;\\n\\\r\n\t\t#endif\\n\\\r\n\t\t#ifdef USE_INSTANCING\\n\\\r\n\t\t\tattribute mat4 u_model;\\n\\\r\n\t\t#else\\n\\\r\n\t\t\tuniform mat4 u_model;\\n\\\r\n\t\t#endif\\n\\\r\n\t\tuniform mat4 u_viewprojection;\\n\\\r\n\t\tuniform float u_point_size;\\n\\\r\n\t\tuniform float u_perspective;\\n\\\r\n\t\tuniform float u_point_perspective;\\n\\\r\n\t\tfloat computePointSize(float radius, float w)\\n\\\r\n\t\t{\\n\\\r\n\t\t\tif(radius < 0.0)\\n\\\r\n\t\t\t\treturn -radius;\\n\\\r\n\t\t\treturn u_perspective * radius / w;\\n\\\r\n\t\t}\\n\\\r\n\t\tvoid main() {\\n\\\r\n\t\t\tv_coord = a_coord;\\n\\\r\n\t\t\t#ifdef USE_COLOR\\n\\\r\n\t\t\t\tv_color = a_color;\\n\\\r\n\t\t\t#endif\\n\\\r\n\t\t\tv_vertex = ( u_model * vec4( a_vertex, 1.0 )).xyz;\\n\\\r\n\t\t\tv_normal = ( u_model * vec4( a_normal, 0.0 )).xyz;\\n\\\r\n\t\t\tgl_Position = u_viewprojection * vec4(v_vertex,1.0);\\n\\\r\n\t\t\tgl_PointSize = u_point_size;\\n\\\r\n\t\t\t#ifdef USE_SIZE\\n\\\r\n\t\t\t\tgl_PointSize = a_extra;\\n\\\r\n\t\t\t#endif\\n\\\r\n\t\t\tif(u_point_perspective != 0.0)\\n\\\r\n\t\t\t\tgl_PointSize = computePointSize( gl_PointSize, gl_Position.w );\\n\\\r\n\t\t}\\\r\n\t\';\r\n\r\n\tLGraphRenderGeometryDOF.fragment_shader_code = \'\\\r\n\t\tprecision mediump float;\\n\\\r\n\t\tuniform vec4 u_color;\\n\\\r\n\t\t#ifdef USE_COLOR\\n\\\r\n\t\t\tvarying vec4 v_color;\\n\\\r\n\t\t#endif\\n\\\r\n\t\tvarying vec2 v_coord;\\n\\\r\n\t\tuniform sampler2D u_texture;\\n\\\r\n\t\tvoid main() {\\n\\\r\n\t\t\tvec4 color = u_color;\\n\\\r\n\t\t\t#ifdef USE_TEXTURED_POINTS\\n\\\r\n\t\t\t\tcolor *= texture2D(u_texture, gl_PointCoord.xy);\\n\\\r\n\t\t\t#else\\n\\\r\n\t\t\t\t#ifdef USE_TEXTURE\\n\\\r\n\t\t\t\t  color *= texture2D(u_texture, v_coord);\\n\\\r\n\t\t\t\t  if(color.a < 0.1)\\n\\\r\n\t\t\t\t\tdiscard;\\n\\\r\n\t\t\t\t#endif\\n\\\r\n\t\t\t\t#ifdef USE_POINTS\\n\\\r\n\t\t\t\t\tfloat dist = length( gl_PointCoord.xy - vec2(0.5) );\\n\\\r\n\t\t\t\t\tif( dist > 0.45 )\\n\\\r\n\t\t\t\t\t\tdiscard;\\n\\\r\n\t\t\t\t#endif\\n\\\r\n\t\t\t#endif\\n\\\r\n\t\t\t#ifdef USE_COLOR\\n\\\r\n\t\t\t\tcolor *= v_color;\\n\\\r\n\t\t\t#endif\\n\\\r\n\t\t\tgl_FragColor = color;\\n\\\r\n\t\t}\\\r\n\t\';\r\n\t*/\r\n\r\n\r\n\r\n})(this);\n(function(global) {\r\n    var LiteGraph = global.LiteGraph;\r\n    var LGraphTexture = global.LGraphTexture;\r\n\r\n    //Works with Litegl.js to create WebGL nodes\r\n    if (typeof GL != "undefined") {\r\n        // Texture Lens *****************************************\r\n        function LGraphFXLens() {\r\n            this.addInput("Texture", "Texture");\r\n            this.addInput("Aberration", "number");\r\n            this.addInput("Distortion", "number");\r\n            this.addInput("Blur", "number");\r\n            this.addOutput("Texture", "Texture");\r\n            this.properties = {\r\n                aberration: 1.0,\r\n                distortion: 1.0,\r\n                blur: 1.0,\r\n                precision: LGraphTexture.DEFAULT\r\n            };\r\n\r\n            if (!LGraphFXLens._shader) {\r\n                LGraphFXLens._shader = new GL.Shader(\r\n                    GL.Shader.SCREEN_VERTEX_SHADER,\r\n                    LGraphFXLens.pixel_shader\r\n                );\r\n                LGraphFXLens._texture = new GL.Texture(3, 1, {\r\n                    format: gl.RGB,\r\n                    wrap: gl.CLAMP_TO_EDGE,\r\n                    magFilter: gl.LINEAR,\r\n                    minFilter: gl.LINEAR,\r\n                    pixel_data: [255, 0, 0, 0, 255, 0, 0, 0, 255]\r\n                });\r\n            }\r\n        }\r\n\r\n        LGraphFXLens.title = "Lens";\r\n        LGraphFXLens.desc = "Camera Lens distortion";\r\n        LGraphFXLens.widgets_info = {\r\n            precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\r\n        };\r\n\r\n        LGraphFXLens.prototype.onExecute = function() {\r\n            var tex = this.getInputData(0);\r\n            if (this.properties.precision === LGraphTexture.PASS_THROUGH) {\r\n                this.setOutputData(0, tex);\r\n                return;\r\n            }\r\n\r\n            if (!tex) {\r\n                return;\r\n            }\r\n\r\n            this._tex = LGraphTexture.getTargetTexture(\r\n                tex,\r\n                this._tex,\r\n                this.properties.precision\r\n            );\r\n\r\n            var aberration = this.properties.aberration;\r\n            if (this.isInputConnected(1)) {\r\n                aberration = this.getInputData(1);\r\n                this.properties.aberration = aberration;\r\n            }\r\n\r\n            var distortion = this.properties.distortion;\r\n            if (this.isInputConnected(2)) {\r\n                distortion = this.getInputData(2);\r\n                this.properties.distortion = distortion;\r\n            }\r\n\r\n            var blur = this.properties.blur;\r\n            if (this.isInputConnected(3)) {\r\n                blur = this.getInputData(3);\r\n                this.properties.blur = blur;\r\n            }\r\n\r\n            gl.disable(gl.BLEND);\r\n            gl.disable(gl.DEPTH_TEST);\r\n            var mesh = Mesh.getScreenQuad();\r\n            var shader = LGraphFXLens._shader;\r\n            //var camera = LS.Renderer._current_camera;\r\n\r\n            this._tex.drawTo(function() {\r\n                tex.bind(0);\r\n                shader\r\n                    .uniforms({\r\n                        u_texture: 0,\r\n                        u_aberration: aberration,\r\n                        u_distortion: distortion,\r\n                        u_blur: blur\r\n                    })\r\n                    .draw(mesh);\r\n            });\r\n\r\n            this.setOutputData(0, this._tex);\r\n        };\r\n\r\n        LGraphFXLens.pixel_shader =\r\n            "precision highp float;\\n\\\r\n\t\t\tprecision highp float;\\n\\\r\n\t\t\tvarying vec2 v_coord;\\n\\\r\n\t\t\tuniform sampler2D u_texture;\\n\\\r\n\t\t\tuniform vec2 u_camera_planes;\\n\\\r\n\t\t\tuniform float u_aberration;\\n\\\r\n\t\t\tuniform float u_distortion;\\n\\\r\n\t\t\tuniform float u_blur;\\n\\\r\n\t\t\t\\n\\\r\n\t\t\tvoid main() {\\n\\\r\n\t\t\t\tvec2 coord = v_coord;\\n\\\r\n\t\t\t\tfloat dist = distance(vec2(0.5), coord);\\n\\\r\n\t\t\t\tvec2 dist_coord = coord - vec2(0.5);\\n\\\r\n\t\t\t\tfloat percent = 1.0 + ((0.5 - dist) / 0.5) * u_distortion;\\n\\\r\n\t\t\t\tdist_coord *= percent;\\n\\\r\n\t\t\t\tcoord = dist_coord + vec2(0.5);\\n\\\r\n\t\t\t\tvec4 color = texture2D(u_texture,coord, u_blur * dist);\\n\\\r\n\t\t\t\tcolor.r = texture2D(u_texture,vec2(0.5) + dist_coord * (1.0+0.01*u_aberration), u_blur * dist ).r;\\n\\\r\n\t\t\t\tcolor.b = texture2D(u_texture,vec2(0.5) + dist_coord * (1.0-0.01*u_aberration), u_blur * dist ).b;\\n\\\r\n\t\t\t\tgl_FragColor = color;\\n\\\r\n\t\t\t}\\n\\\r\n\t\t\t";\r\n        /*\r\n\t\t\tfloat normalized_tunable_sigmoid(float xs, float k)\\n\\\r\n\t\t\t{\\n\\\r\n\t\t\t\txs = xs * 2.0 - 1.0;\\n\\\r\n\t\t\t\tfloat signx = sign(xs);\\n\\\r\n\t\t\t\tfloat absx = abs(xs);\\n\\\r\n\t\t\t\treturn signx * ((-k - 1.0)*absx)/(2.0*(-2.0*k*absx+k-1.0)) + 0.5;\\n\\\r\n\t\t\t}\\n\\\r\n\t\t*/\r\n\r\n        LiteGraph.registerNodeType("fx/lens", LGraphFXLens);\r\n        global.LGraphFXLens = LGraphFXLens;\r\n\r\n        /* not working yet\r\n\tfunction LGraphDepthOfField()\r\n\t{\r\n\t\tthis.addInput("Color","Texture");\r\n\t\tthis.addInput("Linear Depth","Texture");\r\n\t\tthis.addInput("Camera","camera");\r\n\t\tthis.addOutput("Texture","Texture");\r\n\t\tthis.properties = { high_precision: false };\r\n\t}\r\n\r\n\tLGraphDepthOfField.title = "Depth Of Field";\r\n\tLGraphDepthOfField.desc = "Applies a depth of field effect";\r\n\r\n\tLGraphDepthOfField.prototype.onExecute = function()\r\n\t{\r\n\t\tvar tex = this.getInputData(0);\r\n\t\tvar depth = this.getInputData(1);\r\n\t\tvar camera = this.getInputData(2);\r\n\r\n\t\tif(!tex || !depth || !camera) \r\n\t\t{\r\n\t\t\tthis.setOutputData(0, tex);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar precision = gl.UNSIGNED_BYTE;\r\n\t\tif(this.properties.high_precision)\r\n\t\t\tprecision = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT;\t\t\t\r\n\t\tif(!this._temp_texture || this._temp_texture.type != precision ||\r\n\t\t\tthis._temp_texture.width != tex.width || this._temp_texture.height != tex.height)\r\n\t\t\tthis._temp_texture = new GL.Texture( tex.width, tex.height, { type: precision, format: gl.RGBA, filter: gl.LINEAR });\r\n\r\n\t\tvar shader = LGraphDepthOfField._shader = new GL.Shader( GL.Shader.SCREEN_VERTEX_SHADER, LGraphDepthOfField._pixel_shader );\r\n\r\n\t\tvar screen_mesh = Mesh.getScreenQuad();\r\n\r\n\t\tgl.disable( gl.DEPTH_TEST );\r\n\t\tgl.disable( gl.BLEND );\r\n\r\n\t\tvar camera_position = camera.getEye();\r\n\t\tvar focus_point = camera.getCenter();\r\n\t\tvar distance = vec3.distance( camera_position, focus_point );\r\n\t\tvar far = camera.far;\r\n\t\tvar focus_range = distance * 0.5;\r\n\r\n\t\tthis._temp_texture.drawTo( function() {\r\n\t\t\ttex.bind(0);\r\n\t\t\tdepth.bind(1);\r\n\t\t\tshader.uniforms({u_texture:0, u_depth_texture:1, u_resolution: [1/tex.width, 1/tex.height], u_far: far, u_focus_point: distance, u_focus_scale: focus_range }).draw(screen_mesh);\r\n\t\t});\r\n\r\n\t\tthis.setOutputData(0, this._temp_texture);\r\n\t}\r\n\r\n\t//from http://tuxedolabs.blogspot.com.es/2018/05/bokeh-depth-of-field-in-single-pass.html\r\n\tLGraphDepthOfField._pixel_shader = "\\n\\\r\n\t\tprecision highp float;\\n\\\r\n\t\tvarying vec2 v_coord;\\n\\\r\n\t\tuniform sampler2D u_texture; //Image to be processed\\n\\\r\n\t\tuniform sampler2D u_depth_texture; //Linear depth, where 1.0 == far plane\\n\\\r\n\t\tuniform vec2 u_iresolution; //The size of a pixel: vec2(1.0/width, 1.0/height)\\n\\\r\n\t\tuniform float u_far; // Far plane\\n\\\r\n\t\tuniform float u_focus_point;\\n\\\r\n\t\tuniform float u_focus_scale;\\n\\\r\n\t\t\\n\\\r\n\t\tconst float GOLDEN_ANGLE = 2.39996323;\\n\\\r\n\t\tconst float MAX_BLUR_SIZE = 20.0;\\n\\\r\n\t\tconst float RAD_SCALE = 0.5; // Smaller = nicer blur, larger = faster\\n\\\r\n\t\t\\n\\\r\n\t\tfloat getBlurSize(float depth, float focusPoint, float focusScale)\\n\\\r\n\t\t{\\n\\\r\n\t\t float coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\\n\\\r\n\t\t return abs(coc) * MAX_BLUR_SIZE;\\n\\\r\n\t\t}\\n\\\r\n\t\t\\n\\\r\n\t\tvec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale)\\n\\\r\n\t\t{\\n\\\r\n\t\t float centerDepth = texture2D(u_depth_texture, texCoord).r * u_far;\\n\\\r\n\t\t float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\\n\\\r\n\t\t vec3 color = texture2D(u_texture, v_coord).rgb;\\n\\\r\n\t\t float tot = 1.0;\\n\\\r\n\t\t\\n\\\r\n\t\t float radius = RAD_SCALE;\\n\\\r\n\t\t for (float ang = 0.0; ang < 100.0; ang += GOLDEN_ANGLE)\\n\\\r\n\t\t {\\n\\\r\n\t\t  vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * u_iresolution * radius;\\n\\\r\n\t\t\t\\n\\\r\n\t\t  vec3 sampleColor = texture2D(u_texture, tc).rgb;\\n\\\r\n\t\t  float sampleDepth = texture2D(u_depth_texture, tc).r * u_far;\\n\\\r\n\t\t  float sampleSize = getBlurSize( sampleDepth, focusPoint, focusScale );\\n\\\r\n\t\t  if (sampleDepth > centerDepth)\\n\\\r\n\t\t   sampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\\n\\\r\n\t\t\t\\n\\\r\n\t\t  float m = smoothstep(radius-0.5, radius+0.5, sampleSize);\\n\\\r\n\t\t  color += mix(color/tot, sampleColor, m);\\n\\\r\n\t\t  tot += 1.0;\\n\\\r\n\t\t  radius += RAD_SCALE/radius;\\n\\\r\n\t\t  if(radius>=MAX_BLUR_SIZE)\\n\\\r\n\t\t\t return color / tot;\\n\\\r\n\t\t }\\n\\\r\n\t\t return color / tot;\\n\\\r\n\t\t}\\n\\\r\n\t\tvoid main()\\n\\\r\n\t\t{\\n\\\r\n\t\t\tgl_FragColor = vec4( depthOfField( v_coord, u_focus_point, u_focus_scale ), 1.0 );\\n\\\r\n\t\t\t//gl_FragColor = vec4( texture2D(u_depth_texture, v_coord).r );\\n\\\r\n\t\t}\\n\\\r\n\t\t";\r\n\r\n\tLiteGraph.registerNodeType("fx/DOF", LGraphDepthOfField );\r\n\tglobal.LGraphDepthOfField = LGraphDepthOfField;\r\n\t*/\r\n\r\n        //*******************************************************\r\n\r\n        function LGraphFXBokeh() {\r\n            this.addInput("Texture", "Texture");\r\n            this.addInput("Blurred", "Texture");\r\n            this.addInput("Mask", "Texture");\r\n            this.addInput("Threshold", "number");\r\n            this.addOutput("Texture", "Texture");\r\n            this.properties = {\r\n                shape: "",\r\n                size: 10,\r\n                alpha: 1.0,\r\n                threshold: 1.0,\r\n                high_precision: false\r\n            };\r\n        }\r\n\r\n        LGraphFXBokeh.title = "Bokeh";\r\n        LGraphFXBokeh.desc = "applies an Bokeh effect";\r\n\r\n        LGraphFXBokeh.widgets_info = { shape: { widget: "texture" } };\r\n\r\n        LGraphFXBokeh.prototype.onExecute = function() {\r\n            var tex = this.getInputData(0);\r\n            var blurred_tex = this.getInputData(1);\r\n            var mask_tex = this.getInputData(2);\r\n            if (!tex || !mask_tex || !this.properties.shape) {\r\n                this.setOutputData(0, tex);\r\n                return;\r\n            }\r\n\r\n            if (!blurred_tex) {\r\n                blurred_tex = tex;\r\n            }\r\n\r\n            var shape_tex = LGraphTexture.getTexture(this.properties.shape);\r\n            if (!shape_tex) {\r\n                return;\r\n            }\r\n\r\n            var threshold = this.properties.threshold;\r\n            if (this.isInputConnected(3)) {\r\n                threshold = this.getInputData(3);\r\n                this.properties.threshold = threshold;\r\n            }\r\n\r\n            var precision = gl.UNSIGNED_BYTE;\r\n            if (this.properties.high_precision) {\r\n                precision = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT;\r\n            }\r\n            if (\r\n                !this._temp_texture ||\r\n                this._temp_texture.type != precision ||\r\n                this._temp_texture.width != tex.width ||\r\n                this._temp_texture.height != tex.height\r\n            ) {\r\n                this._temp_texture = new GL.Texture(tex.width, tex.height, {\r\n                    type: precision,\r\n                    format: gl.RGBA,\r\n                    filter: gl.LINEAR\r\n                });\r\n            }\r\n\r\n            //iterations\r\n            var size = this.properties.size;\r\n\r\n            var first_shader = LGraphFXBokeh._first_shader;\r\n            if (!first_shader) {\r\n                first_shader = LGraphFXBokeh._first_shader = new GL.Shader(\r\n                    Shader.SCREEN_VERTEX_SHADER,\r\n                    LGraphFXBokeh._first_pixel_shader\r\n                );\r\n            }\r\n\r\n            var second_shader = LGraphFXBokeh._second_shader;\r\n            if (!second_shader) {\r\n                second_shader = LGraphFXBokeh._second_shader = new GL.Shader(\r\n                    LGraphFXBokeh._second_vertex_shader,\r\n                    LGraphFXBokeh._second_pixel_shader\r\n                );\r\n            }\r\n\r\n            var points_mesh = this._points_mesh;\r\n            if (\r\n                !points_mesh ||\r\n                points_mesh._width != tex.width ||\r\n                points_mesh._height != tex.height ||\r\n                points_mesh._spacing != 2\r\n            ) {\r\n                points_mesh = this.createPointsMesh(tex.width, tex.height, 2);\r\n            }\r\n\r\n            var screen_mesh = Mesh.getScreenQuad();\r\n\r\n            var point_size = this.properties.size;\r\n            var min_light = this.properties.min_light;\r\n            var alpha = this.properties.alpha;\r\n\r\n            gl.disable(gl.DEPTH_TEST);\r\n            gl.disable(gl.BLEND);\r\n\r\n            this._temp_texture.drawTo(function() {\r\n                tex.bind(0);\r\n                blurred_tex.bind(1);\r\n                mask_tex.bind(2);\r\n                first_shader\r\n                    .uniforms({\r\n                        u_texture: 0,\r\n                        u_texture_blur: 1,\r\n                        u_mask: 2,\r\n                        u_texsize: [tex.width, tex.height]\r\n                    })\r\n                    .draw(screen_mesh);\r\n            });\r\n\r\n            this._temp_texture.drawTo(function() {\r\n                //clear because we use blending\r\n                //gl.clearColor(0.0,0.0,0.0,1.0);\r\n                //gl.clear( gl.COLOR_BUFFER_BIT );\r\n                gl.enable(gl.BLEND);\r\n                gl.blendFunc(gl.ONE, gl.ONE);\r\n\r\n                tex.bind(0);\r\n                shape_tex.bind(3);\r\n                second_shader\r\n                    .uniforms({\r\n                        u_texture: 0,\r\n                        u_mask: 2,\r\n                        u_shape: 3,\r\n                        u_alpha: alpha,\r\n                        u_threshold: threshold,\r\n                        u_pointSize: point_size,\r\n                        u_itexsize: [1.0 / tex.width, 1.0 / tex.height]\r\n                    })\r\n                    .draw(points_mesh, gl.POINTS);\r\n            });\r\n\r\n            this.setOutputData(0, this._temp_texture);\r\n        };\r\n\r\n        LGraphFXBokeh.prototype.createPointsMesh = function(\r\n            width,\r\n            height,\r\n            spacing\r\n        ) {\r\n            var nwidth = Math.round(width / spacing);\r\n            var nheight = Math.round(height / spacing);\r\n\r\n            var vertices = new Float32Array(nwidth * nheight * 2);\r\n\r\n            var ny = -1;\r\n            var dx = (2 / width) * spacing;\r\n            var dy = (2 / height) * spacing;\r\n            for (var y = 0; y < nheight; ++y) {\r\n                var nx = -1;\r\n                for (var x = 0; x < nwidth; ++x) {\r\n                    var pos = y * nwidth * 2 + x * 2;\r\n                    vertices[pos] = nx;\r\n                    vertices[pos + 1] = ny;\r\n                    nx += dx;\r\n                }\r\n                ny += dy;\r\n            }\r\n\r\n            this._points_mesh = GL.Mesh.load({ vertices2D: vertices });\r\n            this._points_mesh._width = width;\r\n            this._points_mesh._height = height;\r\n            this._points_mesh._spacing = spacing;\r\n\r\n            return this._points_mesh;\r\n        };\r\n\r\n        /*\r\n\tLGraphTextureBokeh._pixel_shader = "precision highp float;\\n\\\r\n\t\t\tvarying vec2 a_coord;\\n\\\r\n\t\t\tuniform sampler2D u_texture;\\n\\\r\n\t\t\tuniform sampler2D u_shape;\\n\\\r\n\t\t\t\\n\\\r\n\t\t\tvoid main() {\\n\\\r\n\t\t\t\tvec4 color = texture2D( u_texture, gl_PointCoord );\\n\\\r\n\t\t\t\tcolor *= v_color * u_alpha;\\n\\\r\n\t\t\t\tgl_FragColor = color;\\n\\\r\n\t\t\t}\\n";\r\n\t*/\r\n\r\n        LGraphFXBokeh._first_pixel_shader =\r\n            "precision highp float;\\n\\\r\n\t\t\tprecision highp float;\\n\\\r\n\t\t\tvarying vec2 v_coord;\\n\\\r\n\t\t\tuniform sampler2D u_texture;\\n\\\r\n\t\t\tuniform sampler2D u_texture_blur;\\n\\\r\n\t\t\tuniform sampler2D u_mask;\\n\\\r\n\t\t\t\\n\\\r\n\t\t\tvoid main() {\\n\\\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\\n\\\r\n\t\t\t\tvec4 blurred_color = texture2D(u_texture_blur, v_coord);\\n\\\r\n\t\t\t\tfloat mask = texture2D(u_mask, v_coord).x;\\n\\\r\n\t\t\t   gl_FragColor = mix(color, blurred_color, mask);\\n\\\r\n\t\t\t}\\n\\\r\n\t\t\t";\r\n\r\n        LGraphFXBokeh._second_vertex_shader =\r\n            "precision highp float;\\n\\\r\n\t\t\tattribute vec2 a_vertex2D;\\n\\\r\n\t\t\tvarying vec4 v_color;\\n\\\r\n\t\t\tuniform sampler2D u_texture;\\n\\\r\n\t\t\tuniform sampler2D u_mask;\\n\\\r\n\t\t\tuniform vec2 u_itexsize;\\n\\\r\n\t\t\tuniform float u_pointSize;\\n\\\r\n\t\t\tuniform float u_threshold;\\n\\\r\n\t\t\tvoid main() {\\n\\\r\n\t\t\t\tvec2 coord = a_vertex2D * 0.5 + 0.5;\\n\\\r\n\t\t\t\tv_color = texture2D( u_texture, coord );\\n\\\r\n\t\t\t\tv_color += texture2D( u_texture, coord + vec2(u_itexsize.x, 0.0) );\\n\\\r\n\t\t\t\tv_color += texture2D( u_texture, coord + vec2(0.0, u_itexsize.y));\\n\\\r\n\t\t\t\tv_color += texture2D( u_texture, coord + u_itexsize);\\n\\\r\n\t\t\t\tv_color *= 0.25;\\n\\\r\n\t\t\t\tfloat mask = texture2D(u_mask, coord).x;\\n\\\r\n\t\t\t\tfloat luminance = length(v_color) * mask;\\n\\\r\n\t\t\t\t/*luminance /= (u_pointSize*u_pointSize)*0.01 */;\\n\\\r\n\t\t\t\tluminance -= u_threshold;\\n\\\r\n\t\t\t\tif(luminance < 0.0)\\n\\\r\n\t\t\t\t{\\n\\\r\n\t\t\t\t\tgl_Position.x = -100.0;\\n\\\r\n\t\t\t\t\treturn;\\n\\\r\n\t\t\t\t}\\n\\\r\n\t\t\t\tgl_PointSize = u_pointSize;\\n\\\r\n\t\t\t\tgl_Position = vec4(a_vertex2D,0.0,1.0);\\n\\\r\n\t\t\t}\\n\\\r\n\t\t\t";\r\n\r\n        LGraphFXBokeh._second_pixel_shader =\r\n            "precision highp float;\\n\\\r\n\t\t\tvarying vec4 v_color;\\n\\\r\n\t\t\tuniform sampler2D u_shape;\\n\\\r\n\t\t\tuniform float u_alpha;\\n\\\r\n\t\t\t\\n\\\r\n\t\t\tvoid main() {\\n\\\r\n\t\t\t\tvec4 color = texture2D( u_shape, gl_PointCoord );\\n\\\r\n\t\t\t\tcolor *= v_color * u_alpha;\\n\\\r\n\t\t\t\tgl_FragColor = color;\\n\\\r\n\t\t\t}\\n";\r\n\r\n        LiteGraph.registerNodeType("fx/bokeh", LGraphFXBokeh);\r\n        global.LGraphFXBokeh = LGraphFXBokeh;\r\n\r\n        //************************************************\r\n\r\n        function LGraphFXGeneric() {\r\n            this.addInput("Texture", "Texture");\r\n            this.addInput("value1", "number");\r\n            this.addInput("value2", "number");\r\n            this.addOutput("Texture", "Texture");\r\n            this.properties = {\r\n                fx: "halftone",\r\n                value1: 1,\r\n                value2: 1,\r\n                precision: LGraphTexture.DEFAULT\r\n            };\r\n        }\r\n\r\n        LGraphFXGeneric.title = "FX";\r\n        LGraphFXGeneric.desc = "applies an FX from a list";\r\n\r\n        LGraphFXGeneric.widgets_info = {\r\n            fx: {\r\n                widget: "combo",\r\n                values: ["halftone", "pixelate", "lowpalette", "noise", "gamma"]\r\n            },\r\n            precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\r\n        };\r\n        LGraphFXGeneric.shaders = {};\r\n\r\n        LGraphFXGeneric.prototype.onExecute = function() {\r\n            if (!this.isOutputConnected(0)) {\r\n                return;\r\n            } //saves work\r\n\r\n            var tex = this.getInputData(0);\r\n            if (this.properties.precision === LGraphTexture.PASS_THROUGH) {\r\n                this.setOutputData(0, tex);\r\n                return;\r\n            }\r\n\r\n            if (!tex) {\r\n                return;\r\n            }\r\n\r\n            this._tex = LGraphTexture.getTargetTexture(\r\n                tex,\r\n                this._tex,\r\n                this.properties.precision\r\n            );\r\n\r\n            //iterations\r\n            var value1 = this.properties.value1;\r\n            if (this.isInputConnected(1)) {\r\n                value1 = this.getInputData(1);\r\n                this.properties.value1 = value1;\r\n            }\r\n\r\n            var value2 = this.properties.value2;\r\n            if (this.isInputConnected(2)) {\r\n                value2 = this.getInputData(2);\r\n                this.properties.value2 = value2;\r\n            }\r\n\r\n            var fx = this.properties.fx;\r\n            var shader = LGraphFXGeneric.shaders[fx];\r\n            if (!shader) {\r\n                var pixel_shader_code = LGraphFXGeneric["pixel_shader_" + fx];\r\n                if (!pixel_shader_code) {\r\n                    return;\r\n                }\r\n\r\n                shader = LGraphFXGeneric.shaders[fx] = new GL.Shader(\r\n                    Shader.SCREEN_VERTEX_SHADER,\r\n                    pixel_shader_code\r\n                );\r\n            }\r\n\r\n            gl.disable(gl.BLEND);\r\n            gl.disable(gl.DEPTH_TEST);\r\n            var mesh = Mesh.getScreenQuad();\r\n            var camera = global.LS ? LS.Renderer._current_camera : null;\r\n            var camera_planes;\r\n            if (camera) {\r\n                camera_planes = [\r\n                    LS.Renderer._current_camera.near,\r\n                    LS.Renderer._current_camera.far\r\n                ];\r\n            } else {\r\n                camera_planes = [1, 100];\r\n            }\r\n\r\n            var noise = null;\r\n            if (fx == "noise") {\r\n                noise = LGraphTexture.getNoiseTexture();\r\n            }\r\n\r\n            this._tex.drawTo(function() {\r\n                tex.bind(0);\r\n                if (fx == "noise") {\r\n                    noise.bind(1);\r\n                }\r\n\r\n                shader\r\n                    .uniforms({\r\n                        u_texture: 0,\r\n                        u_noise: 1,\r\n                        u_size: [tex.width, tex.height],\r\n                        u_rand: [Math.random(), Math.random()],\r\n                        u_value1: value1,\r\n                        u_value2: value2,\r\n                        u_camera_planes: camera_planes\r\n                    })\r\n                    .draw(mesh);\r\n            });\r\n\r\n            this.setOutputData(0, this._tex);\r\n        };\r\n\r\n        LGraphFXGeneric.pixel_shader_halftone =\r\n            "precision highp float;\\n\\\r\n\t\t\tvarying vec2 v_coord;\\n\\\r\n\t\t\tuniform sampler2D u_texture;\\n\\\r\n\t\t\tuniform vec2 u_camera_planes;\\n\\\r\n\t\t\tuniform vec2 u_size;\\n\\\r\n\t\t\tuniform float u_value1;\\n\\\r\n\t\t\tuniform float u_value2;\\n\\\r\n\t\t\t\\n\\\r\n\t\t\tfloat pattern() {\\n\\\r\n\t\t\t\tfloat s = sin(u_value1 * 3.1415), c = cos(u_value1 * 3.1415);\\n\\\r\n\t\t\t\tvec2 tex = v_coord * u_size.xy;\\n\\\r\n\t\t\t\tvec2 point = vec2(\\n\\\r\n\t\t\t\t   c * tex.x - s * tex.y ,\\n\\\r\n\t\t\t\t   s * tex.x + c * tex.y \\n\\\r\n\t\t\t\t) * u_value2;\\n\\\r\n\t\t\t\treturn (sin(point.x) * sin(point.y)) * 4.0;\\n\\\r\n\t\t\t}\\n\\\r\n\t\t\tvoid main() {\\n\\\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\\n\\\r\n\t\t\t\tfloat average = (color.r + color.g + color.b) / 3.0;\\n\\\r\n\t\t\t\tgl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\\n\\\r\n\t\t\t}\\n";\r\n\r\n        LGraphFXGeneric.pixel_shader_pixelate =\r\n            "precision highp float;\\n\\\r\n\t\t\tvarying vec2 v_coord;\\n\\\r\n\t\t\tuniform sampler2D u_texture;\\n\\\r\n\t\t\tuniform vec2 u_camera_planes;\\n\\\r\n\t\t\tuniform vec2 u_size;\\n\\\r\n\t\t\tuniform float u_value1;\\n\\\r\n\t\t\tuniform float u_value2;\\n\\\r\n\t\t\t\\n\\\r\n\t\t\tvoid main() {\\n\\\r\n\t\t\t\tvec2 coord = vec2( floor(v_coord.x * u_value1) / u_value1, floor(v_coord.y * u_value2) / u_value2 );\\n\\\r\n\t\t\t\tvec4 color = texture2D(u_texture, coord);\\n\\\r\n\t\t\t\tgl_FragColor = color;\\n\\\r\n\t\t\t}\\n";\r\n\r\n        LGraphFXGeneric.pixel_shader_lowpalette =\r\n            "precision highp float;\\n\\\r\n\t\t\tvarying vec2 v_coord;\\n\\\r\n\t\t\tuniform sampler2D u_texture;\\n\\\r\n\t\t\tuniform vec2 u_camera_planes;\\n\\\r\n\t\t\tuniform vec2 u_size;\\n\\\r\n\t\t\tuniform float u_value1;\\n\\\r\n\t\t\tuniform float u_value2;\\n\\\r\n\t\t\t\\n\\\r\n\t\t\tvoid main() {\\n\\\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\\n\\\r\n\t\t\t\tgl_FragColor = floor(color * u_value1) / u_value1;\\n\\\r\n\t\t\t}\\n";\r\n\r\n        LGraphFXGeneric.pixel_shader_noise =\r\n            "precision highp float;\\n\\\r\n\t\t\tvarying vec2 v_coord;\\n\\\r\n\t\t\tuniform sampler2D u_texture;\\n\\\r\n\t\t\tuniform sampler2D u_noise;\\n\\\r\n\t\t\tuniform vec2 u_size;\\n\\\r\n\t\t\tuniform float u_value1;\\n\\\r\n\t\t\tuniform float u_value2;\\n\\\r\n\t\t\tuniform vec2 u_rand;\\n\\\r\n\t\t\t\\n\\\r\n\t\t\tvoid main() {\\n\\\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\\n\\\r\n\t\t\t\tvec3 noise = texture2D(u_noise, v_coord * vec2(u_size.x / 512.0, u_size.y / 512.0) + u_rand).xyz - vec3(0.5);\\n\\\r\n\t\t\t\tgl_FragColor = vec4( color.xyz + noise * u_value1, color.a );\\n\\\r\n\t\t\t}\\n";\r\n\r\n        LGraphFXGeneric.pixel_shader_gamma =\r\n            "precision highp float;\\n\\\r\n\t\t\tvarying vec2 v_coord;\\n\\\r\n\t\t\tuniform sampler2D u_texture;\\n\\\r\n\t\t\tuniform float u_value1;\\n\\\r\n\t\t\t\\n\\\r\n\t\t\tvoid main() {\\n\\\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\\n\\\r\n\t\t\t\tfloat gamma = 1.0 / u_value1;\\n\\\r\n\t\t\t\tgl_FragColor = vec4( pow( color.xyz, vec3(gamma) ), color.a );\\n\\\r\n\t\t\t}\\n";\r\n\r\n        LiteGraph.registerNodeType("fx/generic", LGraphFXGeneric);\r\n        global.LGraphFXGeneric = LGraphFXGeneric;\r\n\r\n        // Vigneting ************************************\r\n\r\n        function LGraphFXVigneting() {\r\n            this.addInput("Tex.", "Texture");\r\n            this.addInput("intensity", "number");\r\n\r\n            this.addOutput("Texture", "Texture");\r\n            this.properties = {\r\n                intensity: 1,\r\n                invert: false,\r\n                precision: LGraphTexture.DEFAULT\r\n            };\r\n\r\n            if (!LGraphFXVigneting._shader) {\r\n                LGraphFXVigneting._shader = new GL.Shader(\r\n                    Shader.SCREEN_VERTEX_SHADER,\r\n                    LGraphFXVigneting.pixel_shader\r\n                );\r\n            }\r\n        }\r\n\r\n        LGraphFXVigneting.title = "Vigneting";\r\n        LGraphFXVigneting.desc = "Vigneting";\r\n\r\n        LGraphFXVigneting.widgets_info = {\r\n            precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }\r\n        };\r\n\r\n        LGraphFXVigneting.prototype.onExecute = function() {\r\n            var tex = this.getInputData(0);\r\n\r\n            if (this.properties.precision === LGraphTexture.PASS_THROUGH) {\r\n                this.setOutputData(0, tex);\r\n                return;\r\n            }\r\n\r\n            if (!tex) {\r\n                return;\r\n            }\r\n\r\n            this._tex = LGraphTexture.getTargetTexture(\r\n                tex,\r\n                this._tex,\r\n                this.properties.precision\r\n            );\r\n\r\n            var intensity = this.properties.intensity;\r\n            if (this.isInputConnected(1)) {\r\n                intensity = this.getInputData(1);\r\n                this.properties.intensity = intensity;\r\n            }\r\n\r\n            gl.disable(gl.BLEND);\r\n            gl.disable(gl.DEPTH_TEST);\r\n\r\n            var mesh = Mesh.getScreenQuad();\r\n            var shader = LGraphFXVigneting._shader;\r\n            var invert = this.properties.invert;\r\n\r\n            this._tex.drawTo(function() {\r\n                tex.bind(0);\r\n                shader\r\n                    .uniforms({\r\n                        u_texture: 0,\r\n                        u_intensity: intensity,\r\n                        u_isize: [1 / tex.width, 1 / tex.height],\r\n                        u_invert: invert ? 1 : 0\r\n                    })\r\n                    .draw(mesh);\r\n            });\r\n\r\n            this.setOutputData(0, this._tex);\r\n        };\r\n\r\n        LGraphFXVigneting.pixel_shader =\r\n            "precision highp float;\\n\\\r\n\t\t\tprecision highp float;\\n\\\r\n\t\t\tvarying vec2 v_coord;\\n\\\r\n\t\t\tuniform sampler2D u_texture;\\n\\\r\n\t\t\tuniform float u_intensity;\\n\\\r\n\t\t\tuniform int u_invert;\\n\\\r\n\t\t\t\\n\\\r\n\t\t\tvoid main() {\\n\\\r\n\t\t\t\tfloat luminance = 1.0 - length( v_coord - vec2(0.5) ) * 1.414;\\n\\\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\\n\\\r\n\t\t\t\tif(u_invert == 1)\\n\\\r\n\t\t\t\t\tluminance = 1.0 - luminance;\\n\\\r\n\t\t\t\tluminance = mix(1.0, luminance, u_intensity);\\n\\\r\n\t\t\t   gl_FragColor = vec4( luminance * color.xyz, color.a);\\n\\\r\n\t\t\t}\\n\\\r\n\t\t\t";\r\n\r\n        LiteGraph.registerNodeType("fx/vigneting", LGraphFXVigneting);\r\n        global.LGraphFXVigneting = LGraphFXVigneting;\r\n    }\r\n})(this);\r\n\n(function(global) {\r\n    var LiteGraph = global.LiteGraph;\r\n    var MIDI_COLOR = "#243";\r\n\r\n    function MIDIEvent(data) {\r\n        this.channel = 0;\r\n        this.cmd = 0;\r\n        this.data = new Uint32Array(3);\r\n\r\n        if (data) {\r\n            this.setup(data);\r\n        }\r\n    }\r\n\r\n    LiteGraph.MIDIEvent = MIDIEvent;\r\n\r\n    MIDIEvent.prototype.fromJSON = function(o) {\r\n        this.setup(o.data);\r\n    };\r\n\r\n    MIDIEvent.prototype.setup = function(data) {\r\n        var raw_data = data;\r\n        if (data.constructor === Object) {\r\n            raw_data = data.data;\r\n        }\r\n\r\n        this.data.set(raw_data);\r\n\r\n        var midiStatus = raw_data[0];\r\n        this.status = midiStatus;\r\n\r\n        var midiCommand = midiStatus & 0xf0;\r\n\r\n        if (midiStatus >= 0xf0) {\r\n            this.cmd = midiStatus;\r\n        } else {\r\n            this.cmd = midiCommand;\r\n        }\r\n\r\n        if (this.cmd == MIDIEvent.NOTEON && this.velocity == 0) {\r\n            this.cmd = MIDIEvent.NOTEOFF;\r\n        }\r\n\r\n        this.cmd_str = MIDIEvent.commands[this.cmd] || "";\r\n\r\n        if (\r\n            midiCommand >= MIDIEvent.NOTEON ||\r\n            midiCommand <= MIDIEvent.NOTEOFF\r\n        ) {\r\n            this.channel = midiStatus & 0x0f;\r\n        }\r\n    };\r\n\r\n    Object.defineProperty(MIDIEvent.prototype, "velocity", {\r\n        get: function() {\r\n            if (this.cmd == MIDIEvent.NOTEON) {\r\n                return this.data[2];\r\n            }\r\n            return -1;\r\n        },\r\n        set: function(v) {\r\n            this.data[2] = v; //  v / 127;\r\n        },\r\n        enumerable: true\r\n    });\r\n\r\n    MIDIEvent.notes = [\r\n        "A",\r\n        "A#",\r\n        "B",\r\n        "C",\r\n        "C#",\r\n        "D",\r\n        "D#",\r\n        "E",\r\n        "F",\r\n        "F#",\r\n        "G",\r\n        "G#"\r\n    ];\r\n    MIDIEvent.note_to_index = {\r\n        A: 0,\r\n        "A#": 1,\r\n        B: 2,\r\n        C: 3,\r\n        "C#": 4,\r\n        D: 5,\r\n        "D#": 6,\r\n        E: 7,\r\n        F: 8,\r\n        "F#": 9,\r\n        G: 10,\r\n        "G#": 11\r\n    };\r\n\r\n    Object.defineProperty(MIDIEvent.prototype, "note", {\r\n        get: function() {\r\n            if (this.cmd != MIDIEvent.NOTEON) {\r\n                return -1;\r\n            }\r\n            return MIDIEvent.toNoteString(this.data[1], true);\r\n        },\r\n        set: function(v) {\r\n            throw "notes cannot be assigned this way, must modify the data[1]";\r\n        },\r\n        enumerable: true\r\n    });\r\n\r\n    Object.defineProperty(MIDIEvent.prototype, "octave", {\r\n        get: function() {\r\n            if (this.cmd != MIDIEvent.NOTEON) {\r\n                return -1;\r\n            }\r\n            var octave = this.data[1] - 24;\r\n            return Math.floor(octave / 12 + 1);\r\n        },\r\n        set: function(v) {\r\n            throw "octave cannot be assigned this way, must modify the data[1]";\r\n        },\r\n        enumerable: true\r\n    });\r\n\r\n    //returns HZs\r\n    MIDIEvent.prototype.getPitch = function() {\r\n        return Math.pow(2, (this.data[1] - 69) / 12) * 440;\r\n    };\r\n\r\n    MIDIEvent.computePitch = function(note) {\r\n        return Math.pow(2, (note - 69) / 12) * 440;\r\n    };\r\n\r\n    MIDIEvent.prototype.getCC = function() {\r\n        return this.data[1];\r\n    };\r\n\r\n    MIDIEvent.prototype.getCCValue = function() {\r\n        return this.data[2];\r\n    };\r\n\r\n    //not tested, there is a formula missing here\r\n    MIDIEvent.prototype.getPitchBend = function() {\r\n        return this.data[1] + (this.data[2] << 7) - 8192;\r\n    };\r\n\r\n    MIDIEvent.computePitchBend = function(v1, v2) {\r\n        return v1 + (v2 << 7) - 8192;\r\n    };\r\n\r\n    MIDIEvent.prototype.setCommandFromString = function(str) {\r\n        this.cmd = MIDIEvent.computeCommandFromString(str);\r\n    };\r\n\r\n    MIDIEvent.computeCommandFromString = function(str) {\r\n        if (!str) {\r\n            return 0;\r\n        }\r\n\r\n        if (str && str.constructor === Number) {\r\n            return str;\r\n        }\r\n\r\n        str = str.toUpperCase();\r\n        switch (str) {\r\n            case "NOTE ON":\r\n            case "NOTEON":\r\n                return MIDIEvent.NOTEON;\r\n                break;\r\n            case "NOTE OFF":\r\n            case "NOTEOFF":\r\n                return MIDIEvent.NOTEON;\r\n                break;\r\n            case "KEY PRESSURE":\r\n            case "KEYPRESSURE":\r\n                return MIDIEvent.KEYPRESSURE;\r\n                break;\r\n            case "CONTROLLER CHANGE":\r\n            case "CONTROLLERCHANGE":\r\n            case "CC":\r\n                return MIDIEvent.CONTROLLERCHANGE;\r\n                break;\r\n            case "PROGRAM CHANGE":\r\n            case "PROGRAMCHANGE":\r\n            case "PC":\r\n                return MIDIEvent.PROGRAMCHANGE;\r\n                break;\r\n            case "CHANNEL PRESSURE":\r\n            case "CHANNELPRESSURE":\r\n                return MIDIEvent.CHANNELPRESSURE;\r\n                break;\r\n            case "PITCH BEND":\r\n            case "PITCHBEND":\r\n                return MIDIEvent.PITCHBEND;\r\n                break;\r\n            case "TIME TICK":\r\n            case "TIMETICK":\r\n                return MIDIEvent.TIMETICK;\r\n                break;\r\n            default:\r\n                return Number(str); //assume its a hex code\r\n        }\r\n    };\r\n\r\n    //transform from a pitch number to string like "C4"\r\n    MIDIEvent.toNoteString = function(d, skip_octave) {\r\n        d = Math.round(d); //in case it has decimals\r\n        var note = d - 21;\r\n        var octave = Math.floor((d - 24) / 12 + 1);\r\n        note = note % 12;\r\n        if (note < 0) {\r\n            note = 12 + note;\r\n        }\r\n        return MIDIEvent.notes[note] + (skip_octave ? "" : octave);\r\n    };\r\n\r\n    MIDIEvent.NoteStringToPitch = function(str) {\r\n        str = str.toUpperCase();\r\n        var note = str[0];\r\n        var octave = 4;\r\n\r\n        if (str[1] == "#") {\r\n            note += "#";\r\n            if (str.length > 2) {\r\n                octave = Number(str[2]);\r\n            }\r\n        } else {\r\n            if (str.length > 1) {\r\n                octave = Number(str[1]);\r\n            }\r\n        }\r\n        var pitch = MIDIEvent.note_to_index[note];\r\n        if (pitch == null) {\r\n            return null;\r\n        }\r\n        return (octave - 1) * 12 + pitch + 21;\r\n    };\r\n\r\n    MIDIEvent.prototype.toString = function() {\r\n        var str = "" + this.channel + ". ";\r\n        switch (this.cmd) {\r\n            case MIDIEvent.NOTEON:\r\n                str += "NOTEON " + MIDIEvent.toNoteString(this.data[1]);\r\n                break;\r\n            case MIDIEvent.NOTEOFF:\r\n                str += "NOTEOFF " + MIDIEvent.toNoteString(this.data[1]);\r\n                break;\r\n            case MIDIEvent.CONTROLLERCHANGE:\r\n                str += "CC " + this.data[1] + " " + this.data[2];\r\n                break;\r\n            case MIDIEvent.PROGRAMCHANGE:\r\n                str += "PC " + this.data[1];\r\n                break;\r\n            case MIDIEvent.PITCHBEND:\r\n                str += "PITCHBEND " + this.getPitchBend();\r\n                break;\r\n            case MIDIEvent.KEYPRESSURE:\r\n                str += "KEYPRESS " + this.data[1];\r\n                break;\r\n        }\r\n\r\n        return str;\r\n    };\r\n\r\n    MIDIEvent.prototype.toHexString = function() {\r\n        var str = "";\r\n        for (var i = 0; i < this.data.length; i++) {\r\n            str += this.data[i].toString(16) + " ";\r\n        }\r\n    };\r\n\r\n    MIDIEvent.prototype.toJSON = function() {\r\n        return {\r\n            data: [this.data[0], this.data[1], this.data[2]],\r\n            object_class: "MIDIEvent"\r\n        };\r\n    };\r\n\r\n    MIDIEvent.NOTEOFF = 0x80;\r\n    MIDIEvent.NOTEON = 0x90;\r\n    MIDIEvent.KEYPRESSURE = 0xa0;\r\n    MIDIEvent.CONTROLLERCHANGE = 0xb0;\r\n    MIDIEvent.PROGRAMCHANGE = 0xc0;\r\n    MIDIEvent.CHANNELPRESSURE = 0xd0;\r\n    MIDIEvent.PITCHBEND = 0xe0;\r\n    MIDIEvent.TIMETICK = 0xf8;\r\n\r\n    MIDIEvent.commands = {\r\n        0x80: "note off",\r\n        0x90: "note on",\r\n        0xa0: "key pressure",\r\n        0xb0: "controller change",\r\n        0xc0: "program change",\r\n        0xd0: "channel pressure",\r\n        0xe0: "pitch bend",\r\n        0xf0: "system",\r\n        0xf2: "Song pos",\r\n        0xf3: "Song select",\r\n        0xf6: "Tune request",\r\n        0xf8: "time tick",\r\n        0xfa: "Start Song",\r\n        0xfb: "Continue Song",\r\n        0xfc: "Stop Song",\r\n        0xfe: "Sensing",\r\n        0xff: "Reset"\r\n    };\r\n\r\n    MIDIEvent.commands_short = {\r\n        0x80: "NOTEOFF",\r\n        0x90: "NOTEOFF",\r\n        0xa0: "KEYP",\r\n        0xb0: "CC",\r\n        0xc0: "PC",\r\n        0xd0: "CP",\r\n        0xe0: "PB",\r\n        0xf0: "SYS",\r\n        0xf2: "POS",\r\n        0xf3: "SELECT",\r\n        0xf6: "TUNEREQ",\r\n        0xf8: "TT",\r\n        0xfa: "START",\r\n        0xfb: "CONTINUE",\r\n        0xfc: "STOP",\r\n        0xfe: "SENS",\r\n        0xff: "RESET"\r\n    };\r\n\r\n    MIDIEvent.commands_reversed = {};\r\n    for (var i in MIDIEvent.commands) {\r\n        MIDIEvent.commands_reversed[MIDIEvent.commands[i]] = i;\r\n    }\r\n\r\n    //MIDI wrapper, instantiate by MIDIIn and MIDIOut\r\n    function MIDIInterface(on_ready, on_error) {\r\n        if (!navigator.requestMIDIAccess) {\r\n            this.error = "not suppoorted";\r\n            if (on_error) {\r\n                on_error("Not supported");\r\n            } else {\r\n                console.error("MIDI NOT SUPPORTED, enable by chrome://flags");\r\n            }\r\n            return;\r\n        }\r\n\r\n        this.on_ready = on_ready;\r\n\r\n        this.state = {\r\n            note: [],\r\n            cc: []\r\n        };\r\n\r\n\t\tthis.input_ports = null;\r\n\t\tthis.input_ports_info = [];\r\n\t\tthis.output_ports = null;\r\n\t\tthis.output_ports_info = [];\r\n\r\n        navigator.requestMIDIAccess().then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this));\r\n    }\r\n\r\n    MIDIInterface.input = null;\r\n\r\n    MIDIInterface.MIDIEvent = MIDIEvent;\r\n\r\n    MIDIInterface.prototype.onMIDISuccess = function(midiAccess) {\r\n        console.log("MIDI ready!");\r\n        console.log(midiAccess);\r\n        this.midi = midiAccess; // store in the global (in real usage, would probably keep in an object instance)\r\n        this.updatePorts();\r\n\r\n        if (this.on_ready) {\r\n            this.on_ready(this);\r\n        }\r\n    };\r\n\r\n    MIDIInterface.prototype.updatePorts = function() {\r\n        var midi = this.midi;\r\n        this.input_ports = midi.inputs;\r\n\t\tthis.input_ports_info = [];\r\n        this.output_ports = midi.outputs;\r\n\t\tthis.output_ports_info = [];\r\n\r\n        var num = 0;\r\n\r\n        var it = this.input_ports.values();\r\n        var it_value = it.next();\r\n        while (it_value && it_value.done === false) {\r\n            var port_info = it_value.value;\r\n\t\t\tthis.input_ports_info.push(port_info);\r\n            console.log( "Input port [type:\'" + port_info.type + "\'] id:\'" + port_info.id + "\' manufacturer:\'" + port_info.manufacturer + "\' name:\'" + port_info.name + "\' version:\'" + port_info.version + "\'" );\r\n            num++;\r\n            it_value = it.next();\r\n        }\r\n        this.num_input_ports = num;\r\n\r\n        num = 0;\r\n        var it = this.output_ports.values();\r\n        var it_value = it.next();\r\n        while (it_value && it_value.done === false) {\r\n            var port_info = it_value.value;\r\n\t\t\tthis.output_ports_info.push(port_info);\r\n            console.log( "Output port [type:\'" + port_info.type + "\'] id:\'" + port_info.id + "\' manufacturer:\'" + port_info.manufacturer + "\' name:\'" + port_info.name + "\' version:\'" + port_info.version + "\'" );\r\n            num++;\r\n            it_value = it.next();\r\n        }\r\n        this.num_output_ports = num;\r\n    };\r\n\r\n    MIDIInterface.prototype.onMIDIFailure = function(msg) {\r\n        console.error("Failed to get MIDI access - " + msg);\r\n    };\r\n\r\n    MIDIInterface.prototype.openInputPort = function(port, callback) {\r\n        var input_port = this.input_ports.get("input-" + port);\r\n        if (!input_port) {\r\n            return false;\r\n        }\r\n        MIDIInterface.input = this;\r\n        var that = this;\r\n\r\n        input_port.onmidimessage = function(a) {\r\n            var midi_event = new MIDIEvent(a.data);\r\n            that.updateState(midi_event);\r\n            if (callback) {\r\n                callback(a.data, midi_event);\r\n            }\r\n            if (MIDIInterface.on_message) {\r\n                MIDIInterface.on_message(a.data, midi_event);\r\n            }\r\n        };\r\n        console.log("port open: ", input_port);\r\n        return true;\r\n    };\r\n\r\n    MIDIInterface.parseMsg = function(data) {};\r\n\r\n    MIDIInterface.prototype.updateState = function(midi_event) {\r\n        switch (midi_event.cmd) {\r\n            case MIDIEvent.NOTEON:\r\n                this.state.note[midi_event.value1 | 0] = midi_event.value2;\r\n                break;\r\n            case MIDIEvent.NOTEOFF:\r\n                this.state.note[midi_event.value1 | 0] = 0;\r\n                break;\r\n            case MIDIEvent.CONTROLLERCHANGE:\r\n                this.state.cc[midi_event.getCC()] = midi_event.getCCValue();\r\n                break;\r\n        }\r\n    };\r\n\r\n    MIDIInterface.prototype.sendMIDI = function(port, midi_data) {\r\n        if (!midi_data) {\r\n            return;\r\n        }\r\n\r\n        var output_port = this.output_ports_info[port];//this.output_ports.get("output-" + port);\r\n        if (!output_port) {\r\n            return;\r\n        }\r\n\r\n        MIDIInterface.output = this;\r\n\r\n        if (midi_data.constructor === MIDIEvent) {\r\n            output_port.send(midi_data.data);\r\n        } else {\r\n            output_port.send(midi_data);\r\n        }\r\n    };\r\n\r\n    function LGMIDIIn() {\r\n        this.addOutput("on_midi", LiteGraph.EVENT);\r\n        this.addOutput("out", "midi");\r\n        this.properties = { port: 0 };\r\n        this._last_midi_event = null;\r\n        this._current_midi_event = null;\r\n        this.boxcolor = "#AAA";\r\n        this._last_time = 0;\r\n\r\n        var that = this;\r\n        new MIDIInterface(function(midi) {\r\n            //open\r\n            that._midi = midi;\r\n            if (that._waiting) {\r\n                that.onStart();\r\n            }\r\n            that._waiting = false;\r\n        });\r\n    }\r\n\r\n    LGMIDIIn.MIDIInterface = MIDIInterface;\r\n\r\n    LGMIDIIn.title = "MIDI Input";\r\n    LGMIDIIn.desc = "Reads MIDI from a input port";\r\n    LGMIDIIn.color = MIDI_COLOR;\r\n\r\n    LGMIDIIn.prototype.getPropertyInfo = function(name) {\r\n        if (!this._midi) {\r\n            return;\r\n        }\r\n\r\n        if (name == "port") {\r\n            var values = {};\r\n            for (var i = 0; i < this._midi.input_ports_info.length; ++i) {\r\n                var input = this._midi.input_ports_info[i];\r\n                values[i] = i + ".- " + input.name + " version:" + input.version;\r\n            }\r\n            return { type: "enum", values: values };\r\n        }\r\n    };\r\n\r\n    LGMIDIIn.prototype.onStart = function() {\r\n        if (this._midi) {\r\n            this._midi.openInputPort(\r\n                this.properties.port,\r\n                this.onMIDIEvent.bind(this)\r\n            );\r\n        } else {\r\n            this._waiting = true;\r\n        }\r\n    };\r\n\r\n    LGMIDIIn.prototype.onMIDIEvent = function(data, midi_event) {\r\n        this._last_midi_event = midi_event;\r\n        this.boxcolor = "#AFA";\r\n        this._last_time = LiteGraph.getTime();\r\n        this.trigger("on_midi", midi_event);\r\n        if (midi_event.cmd == MIDIEvent.NOTEON) {\r\n            this.trigger("on_noteon", midi_event);\r\n        } else if (midi_event.cmd == MIDIEvent.NOTEOFF) {\r\n            this.trigger("on_noteoff", midi_event);\r\n        } else if (midi_event.cmd == MIDIEvent.CONTROLLERCHANGE) {\r\n            this.trigger("on_cc", midi_event);\r\n        } else if (midi_event.cmd == MIDIEvent.PROGRAMCHANGE) {\r\n            this.trigger("on_pc", midi_event);\r\n        } else if (midi_event.cmd == MIDIEvent.PITCHBEND) {\r\n            this.trigger("on_pitchbend", midi_event);\r\n        }\r\n    };\r\n\r\n    LGMIDIIn.prototype.onDrawBackground = function(ctx) {\r\n        this.boxcolor = "#AAA";\r\n        if (!this.flags.collapsed && this._last_midi_event) {\r\n            ctx.fillStyle = "white";\r\n            var now = LiteGraph.getTime();\r\n            var f = 1.0 - Math.max(0, (now - this._last_time) * 0.001);\r\n            if (f > 0) {\r\n                var t = ctx.globalAlpha;\r\n                ctx.globalAlpha *= f;\r\n                ctx.font = "12px Tahoma";\r\n                ctx.fillText(\r\n                    this._last_midi_event.toString(),\r\n                    2,\r\n                    this.size[1] * 0.5 + 3\r\n                );\r\n                //ctx.fillRect(0,0,this.size[0],this.size[1]);\r\n                ctx.globalAlpha = t;\r\n            }\r\n        }\r\n    };\r\n\r\n    LGMIDIIn.prototype.onExecute = function() {\r\n        if (this.outputs) {\r\n            var last = this._last_midi_event;\r\n            for (var i = 0; i < this.outputs.length; ++i) {\r\n                var output = this.outputs[i];\r\n                var v = null;\r\n                switch (output.name) {\r\n                    case "midi":\r\n                        v = this._midi;\r\n                        break;\r\n                    case "last_midi":\r\n                        v = last;\r\n                        break;\r\n                    default:\r\n                        continue;\r\n                }\r\n                this.setOutputData(i, v);\r\n            }\r\n        }\r\n    };\r\n\r\n    LGMIDIIn.prototype.onGetOutputs = function() {\r\n        return [\r\n            ["last_midi", "midi"],\r\n            ["on_midi", LiteGraph.EVENT],\r\n            ["on_noteon", LiteGraph.EVENT],\r\n            ["on_noteoff", LiteGraph.EVENT],\r\n            ["on_cc", LiteGraph.EVENT],\r\n            ["on_pc", LiteGraph.EVENT],\r\n            ["on_pitchbend", LiteGraph.EVENT]\r\n        ];\r\n    };\r\n\r\n    LiteGraph.registerNodeType("midi/input", LGMIDIIn);\r\n\r\n    function LGMIDIOut() {\r\n        this.addInput("send", LiteGraph.EVENT);\r\n        this.properties = { port: 0 };\r\n\r\n        var that = this;\r\n        new MIDIInterface(function(midi) {\r\n            that._midi = midi;\r\n\t\t\tthat.widget.options.values = that.getMIDIOutputs();\r\n        });\r\n\t\tthis.widget = this.addWidget("combo","Device",this.properties.port,{ property: "port", values: this.getMIDIOutputs.bind(this) });\r\n\t\tthis.size = [340,60];\r\n    }\r\n\r\n    LGMIDIOut.MIDIInterface = MIDIInterface;\r\n\r\n    LGMIDIOut.title = "MIDI Output";\r\n    LGMIDIOut.desc = "Sends MIDI to output channel";\r\n    LGMIDIOut.color = MIDI_COLOR;\r\n\r\n    LGMIDIOut.prototype.onGetPropertyInfo = function(name) {\r\n        if (!this._midi) {\r\n            return;\r\n        }\r\n\r\n        if (name == "port") {\r\n\t\t\tvar values = this.getMIDIOutputs();\r\n            return { type: "enum", values: values };\r\n        }\r\n    };\r\n\tLGMIDIOut.default_ports = {0:"unknown"};\r\n\r\n\tLGMIDIOut.prototype.getMIDIOutputs = function()\r\n\t{\r\n\t\tvar values = {};\r\n\t\tif(!this._midi)\r\n\t\t\treturn LGMIDIOut.default_ports;\r\n\t\tif(this._midi.output_ports_info)\r\n\t\tfor (var i = 0; i < this._midi.output_ports_info.length; ++i) {\r\n\t\t\tvar output = this._midi.output_ports_info[i];\r\n\t\t\tif(!output)\r\n\t\t\t\tcontinue;\r\n\t\t\tvar name = i + ".- " + output.name + " version:" + output.version;\r\n\t\t\tvalues[i] = name;\r\n\t\t}\r\n\t\treturn values;\r\n\t}\r\n\r\n    LGMIDIOut.prototype.onAction = function(event, midi_event) {\r\n        //console.log(midi_event);\r\n        if (!this._midi) {\r\n            return;\r\n        }\r\n        if (event == "send") {\r\n            this._midi.sendMIDI(this.properties.port, midi_event);\r\n        }\r\n        this.trigger("midi", midi_event);\r\n    };\r\n\r\n    LGMIDIOut.prototype.onGetInputs = function() {\r\n        return [["send", LiteGraph.ACTION]];\r\n    };\r\n\r\n    LGMIDIOut.prototype.onGetOutputs = function() {\r\n        return [["on_midi", LiteGraph.EVENT]];\r\n    };\r\n\r\n    LiteGraph.registerNodeType("midi/output", LGMIDIOut);\r\n\r\n\r\n    function LGMIDIShow() {\r\n        this.addInput("on_midi", LiteGraph.EVENT);\r\n        this._str = "";\r\n        this.size = [200, 40];\r\n    }\r\n\r\n    LGMIDIShow.title = "MIDI Show";\r\n    LGMIDIShow.desc = "Shows MIDI in the graph";\r\n    LGMIDIShow.color = MIDI_COLOR;\r\n\r\n    LGMIDIShow.prototype.getTitle = function() {\r\n        if (this.flags.collapsed) {\r\n            return this._str;\r\n        }\r\n        return this.title;\r\n    };\r\n\r\n    LGMIDIShow.prototype.onAction = function(event, midi_event) {\r\n        if (!midi_event) {\r\n            return;\r\n        }\r\n        if (midi_event.constructor === MIDIEvent) {\r\n            this._str = midi_event.toString();\r\n        } else {\r\n            this._str = "???";\r\n        }\r\n    };\r\n\r\n    LGMIDIShow.prototype.onDrawForeground = function(ctx) {\r\n        if (!this._str || this.flags.collapsed) {\r\n            return;\r\n        }\r\n\r\n        ctx.font = "30px Arial";\r\n        ctx.fillText(this._str, 10, this.size[1] * 0.8);\r\n    };\r\n\r\n    LGMIDIShow.prototype.onGetInputs = function() {\r\n        return [["in", LiteGraph.ACTION]];\r\n    };\r\n\r\n    LGMIDIShow.prototype.onGetOutputs = function() {\r\n        return [["on_midi", LiteGraph.EVENT]];\r\n    };\r\n\r\n    LiteGraph.registerNodeType("midi/show", LGMIDIShow);\r\n\r\n    function LGMIDIFilter() {\r\n        this.properties = {\r\n            channel: -1,\r\n            cmd: -1,\r\n            min_value: -1,\r\n            max_value: -1\r\n        };\r\n\r\n        var that = this;\r\n        this._learning = false;\r\n        this.addWidget("button", "Learn", "", function() {\r\n            that._learning = true;\r\n            that.boxcolor = "#FA3";\r\n        });\r\n\r\n        this.addInput("in", LiteGraph.EVENT);\r\n        this.addOutput("on_midi", LiteGraph.EVENT);\r\n        this.boxcolor = "#AAA";\r\n    }\r\n\r\n    LGMIDIFilter.title = "MIDI Filter";\r\n    LGMIDIFilter.desc = "Filters MIDI messages";\r\n    LGMIDIFilter.color = MIDI_COLOR;\r\n\r\n    LGMIDIFilter["@cmd"] = {\r\n        type: "enum",\r\n        title: "Command",\r\n        values: MIDIEvent.commands_reversed\r\n    };\r\n\r\n    LGMIDIFilter.prototype.getTitle = function() {\r\n        var str = null;\r\n        if (this.properties.cmd == -1) {\r\n            str = "Nothing";\r\n        } else {\r\n            str = MIDIEvent.commands_short[this.properties.cmd] || "Unknown";\r\n        }\r\n\r\n        if (\r\n            this.properties.min_value != -1 &&\r\n            this.properties.max_value != -1\r\n        ) {\r\n            str +=\r\n                " " +\r\n                (this.properties.min_value == this.properties.max_value\r\n                    ? this.properties.max_value\r\n                    : this.properties.min_value +\r\n                      ".." +\r\n                      this.properties.max_value);\r\n        }\r\n\r\n        return "Filter: " + str;\r\n    };\r\n\r\n    LGMIDIFilter.prototype.onPropertyChanged = function(name, value) {\r\n        if (name == "cmd") {\r\n            var num = Number(value);\r\n            if (isNaN(num)) {\r\n                num = MIDIEvent.commands[value] || 0;\r\n            }\r\n            this.properties.cmd = num;\r\n        }\r\n    };\r\n\r\n    LGMIDIFilter.prototype.onAction = function(event, midi_event) {\r\n        if (!midi_event || midi_event.constructor !== MIDIEvent) {\r\n            return;\r\n        }\r\n\r\n        if (this._learning) {\r\n            this._learning = false;\r\n            this.boxcolor = "#AAA";\r\n            this.properties.channel = midi_event.channel;\r\n            this.properties.cmd = midi_event.cmd;\r\n            this.properties.min_value = this.properties.max_value =\r\n                midi_event.data[1];\r\n        } else {\r\n            if (\r\n                this.properties.channel != -1 &&\r\n                midi_event.channel != this.properties.channel\r\n            ) {\r\n                return;\r\n            }\r\n            if (\r\n                this.properties.cmd != -1 &&\r\n                midi_event.cmd != this.properties.cmd\r\n            ) {\r\n                return;\r\n            }\r\n            if (\r\n                this.properties.min_value != -1 &&\r\n                midi_event.data[1] < this.properties.min_value\r\n            ) {\r\n                return;\r\n            }\r\n            if (\r\n                this.properties.max_value != -1 &&\r\n                midi_event.data[1] > this.properties.max_value\r\n            ) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.trigger("on_midi", midi_event);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("midi/filter", LGMIDIFilter);\r\n\r\n    function LGMIDIEvent() {\r\n        this.properties = {\r\n            channel: 0,\r\n            cmd: 144, //0x90\r\n            value1: 1,\r\n            value2: 1\r\n        };\r\n\r\n        this.addInput("send", LiteGraph.EVENT);\r\n        this.addInput("assign", LiteGraph.EVENT);\r\n        this.addOutput("on_midi", LiteGraph.EVENT);\r\n\r\n        this.midi_event = new MIDIEvent();\r\n        this.gate = false;\r\n    }\r\n\r\n    LGMIDIEvent.title = "MIDIEvent";\r\n    LGMIDIEvent.desc = "Create a MIDI Event";\r\n    LGMIDIEvent.color = MIDI_COLOR;\r\n\r\n    LGMIDIEvent.prototype.onAction = function(event, midi_event) {\r\n        if (event == "assign") {\r\n            this.properties.channel = midi_event.channel;\r\n            this.properties.cmd = midi_event.cmd;\r\n            this.properties.value1 = midi_event.data[1];\r\n            this.properties.value2 = midi_event.data[2];\r\n            if (midi_event.cmd == MIDIEvent.NOTEON) {\r\n                this.gate = true;\r\n            } else if (midi_event.cmd == MIDIEvent.NOTEOFF) {\r\n                this.gate = false;\r\n            }\r\n            return;\r\n        }\r\n\r\n        //send\r\n        var midi_event = this.midi_event;\r\n        midi_event.channel = this.properties.channel;\r\n        if (this.properties.cmd && this.properties.cmd.constructor === String) {\r\n            midi_event.setCommandFromString(this.properties.cmd);\r\n        } else {\r\n            midi_event.cmd = this.properties.cmd;\r\n        }\r\n        midi_event.data[0] = midi_event.cmd | midi_event.channel;\r\n        midi_event.data[1] = Number(this.properties.value1);\r\n        midi_event.data[2] = Number(this.properties.value2);\r\n\r\n        this.trigger("on_midi", midi_event);\r\n    };\r\n\r\n    LGMIDIEvent.prototype.onExecute = function() {\r\n        var props = this.properties;\r\n\r\n        if (this.inputs) {\r\n            for (var i = 0; i < this.inputs.length; ++i) {\r\n                var input = this.inputs[i];\r\n                if (input.link == -1) {\r\n                    continue;\r\n                }\r\n                switch (input.name) {\r\n                    case "note":\r\n                        var v = this.getInputData(i);\r\n                        if (v != null) {\r\n                            if (v.constructor === String) {\r\n                                v = MIDIEvent.NoteStringToPitch(v);\r\n                            }\r\n                            this.properties.value1 = (v | 0) % 255;\r\n                        }\r\n                        break;\r\n                    case "cmd":\r\n                        var v = this.getInputData(i);\r\n                        if (v != null) {\r\n                            this.properties.cmd = v;\r\n                        }\r\n                        break;\r\n                    case "value1":\r\n                        var v = this.getInputData(i);\r\n                        if (v != null) {\r\n                            this.properties.value1 = clamp(v|0,0,127);\r\n                        }\r\n                        break;\r\n                    case "value2":\r\n                        var v = this.getInputData(i);\r\n                        if (v != null) {\r\n                            this.properties.value2 = clamp(v|0,0,127);\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.outputs) {\r\n            for (var i = 0; i < this.outputs.length; ++i) {\r\n                var output = this.outputs[i];\r\n                var v = null;\r\n                switch (output.name) {\r\n                    case "midi":\r\n                        v = new MIDIEvent();\r\n                        v.setup([props.cmd, props.value1, props.value2]);\r\n                        v.channel = props.channel;\r\n                        break;\r\n                    case "command":\r\n                        v = props.cmd;\r\n                        break;\r\n                    case "cc":\r\n                        v = props.value1;\r\n                        break;\r\n                    case "cc_value":\r\n                        v = props.value2;\r\n                        break;\r\n                    case "note":\r\n                        v =\r\n                            props.cmd == MIDIEvent.NOTEON ||\r\n                            props.cmd == MIDIEvent.NOTEOFF\r\n                                ? props.value1\r\n                                : null;\r\n                        break;\r\n                    case "velocity":\r\n                        v = props.cmd == MIDIEvent.NOTEON ? props.value2 : null;\r\n                        break;\r\n                    case "pitch":\r\n                        v =\r\n                            props.cmd == MIDIEvent.NOTEON\r\n                                ? MIDIEvent.computePitch(props.value1)\r\n                                : null;\r\n                        break;\r\n                    case "pitchbend":\r\n                        v =\r\n                            props.cmd == MIDIEvent.PITCHBEND\r\n                                ? MIDIEvent.computePitchBend(\r\n                                      props.value1,\r\n                                      props.value2\r\n                                  )\r\n                                : null;\r\n                        break;\r\n                    case "gate":\r\n                        v = this.gate;\r\n                        break;\r\n                    default:\r\n                        continue;\r\n                }\r\n                if (v !== null) {\r\n                    this.setOutputData(i, v);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    LGMIDIEvent.prototype.onPropertyChanged = function(name, value) {\r\n        if (name == "cmd") {\r\n            this.properties.cmd = MIDIEvent.computeCommandFromString(value);\r\n        }\r\n    };\r\n\r\n    LGMIDIEvent.prototype.onGetInputs = function() {\r\n        return [["cmd", "number"],["note", "number"],["value1", "number"],["value2", "number"]];\r\n    };\r\n\r\n    LGMIDIEvent.prototype.onGetOutputs = function() {\r\n        return [\r\n            ["midi", "midi"],\r\n            ["on_midi", LiteGraph.EVENT],\r\n            ["command", "number"],\r\n            ["note", "number"],\r\n            ["velocity", "number"],\r\n            ["cc", "number"],\r\n            ["cc_value", "number"],\r\n            ["pitch", "number"],\r\n            ["gate", "bool"],\r\n            ["pitchbend", "number"]\r\n        ];\r\n    };\r\n\r\n    LiteGraph.registerNodeType("midi/event", LGMIDIEvent);\r\n\r\n    function LGMIDICC() {\r\n        this.properties = {\r\n            //\t\tchannel: 0,\r\n            cc: 1,\r\n            value: 0\r\n        };\r\n\r\n        this.addOutput("value", "number");\r\n    }\r\n\r\n    LGMIDICC.title = "MIDICC";\r\n    LGMIDICC.desc = "gets a Controller Change";\r\n    LGMIDICC.color = MIDI_COLOR;\r\n\r\n    LGMIDICC.prototype.onExecute = function() {\r\n        var props = this.properties;\r\n        if (MIDIInterface.input) {\r\n            this.properties.value =\r\n                MIDIInterface.input.state.cc[this.properties.cc];\r\n        }\r\n        this.setOutputData(0, this.properties.value);\r\n    };\r\n\r\n    LiteGraph.registerNodeType("midi/cc", LGMIDICC);\r\n\r\n    function LGMIDIGenerator() {\r\n        this.addInput("generate", LiteGraph.ACTION);\r\n        this.addInput("scale", "string");\r\n        this.addInput("octave", "number");\r\n        this.addOutput("note", LiteGraph.EVENT);\r\n        this.properties = {\r\n            notes: "A,A#,B,C,C#,D,D#,E,F,F#,G,G#",\r\n            octave: 2,\r\n            duration: 0.5,\r\n            mode: "sequence"\r\n        };\r\n\r\n        this.notes_pitches = LGMIDIGenerator.processScale(\r\n            this.properties.notes\r\n        );\r\n        this.sequence_index = 0;\r\n    }\r\n\r\n    LGMIDIGenerator.title = "MIDI Generator";\r\n    LGMIDIGenerator.desc = "Generates a random MIDI note";\r\n    LGMIDIGenerator.color = MIDI_COLOR;\r\n\r\n    LGMIDIGenerator.processScale = function(scale) {\r\n        var notes = scale.split(",");\r\n        for (var i = 0; i < notes.length; ++i) {\r\n            var n = notes[i];\r\n            if ((n.length == 2 && n[1] != "#") || n.length > 2) {\r\n                notes[i] = -LiteGraph.MIDIEvent.NoteStringToPitch(n);\r\n            } else {\r\n                notes[i] = MIDIEvent.note_to_index[n] || 0;\r\n            }\r\n        }\r\n        return notes;\r\n    };\r\n\r\n    LGMIDIGenerator.prototype.onPropertyChanged = function(name, value) {\r\n        if (name == "notes") {\r\n            this.notes_pitches = LGMIDIGenerator.processScale(value);\r\n        }\r\n    };\r\n\r\n    LGMIDIGenerator.prototype.onExecute = function() {\r\n        var octave = this.getInputData(2);\r\n        if (octave != null) {\r\n            this.properties.octave = octave;\r\n        }\r\n\r\n        var scale = this.getInputData(1);\r\n        if (scale) {\r\n            this.notes_pitches = LGMIDIGenerator.processScale(scale);\r\n        }\r\n    };\r\n\r\n    LGMIDIGenerator.prototype.onAction = function(event, midi_event) {\r\n        //var range = this.properties.max - this.properties.min;\r\n        //var pitch = this.properties.min + ((Math.random() * range)|0);\r\n        var pitch = 0;\r\n        var range = this.notes_pitches.length;\r\n        var index = 0;\r\n\r\n        if (this.properties.mode == "sequence") {\r\n            index = this.sequence_index = (this.sequence_index + 1) % range;\r\n        } else if (this.properties.mode == "random") {\r\n            index = Math.floor(Math.random() * range);\r\n        }\r\n\r\n        var note = this.notes_pitches[index];\r\n        if (note >= 0) {\r\n            pitch = note + (this.properties.octave - 1) * 12 + 33;\r\n        } else {\r\n            pitch = -note;\r\n        }\r\n\r\n        var midi_event = new MIDIEvent();\r\n        midi_event.setup([MIDIEvent.NOTEON, pitch, 10]);\r\n        var duration = this.properties.duration || 1;\r\n        this.trigger("note", midi_event);\r\n\r\n        //noteoff\r\n        setTimeout(\r\n            function() {\r\n                var midi_event = new MIDIEvent();\r\n                midi_event.setup([MIDIEvent.NOTEOFF, pitch, 0]);\r\n                this.trigger("note", midi_event);\r\n            }.bind(this),\r\n            duration * 1000\r\n        );\r\n    };\r\n\r\n    LiteGraph.registerNodeType("midi/generator", LGMIDIGenerator);\r\n\r\n    function LGMIDITranspose() {\r\n        this.properties = {\r\n            amount: 0\r\n        };\r\n        this.addInput("in", LiteGraph.ACTION);\r\n        this.addInput("amount", "number");\r\n        this.addOutput("out", LiteGraph.EVENT);\r\n\r\n        this.midi_event = new MIDIEvent();\r\n    }\r\n\r\n    LGMIDITranspose.title = "MIDI Transpose";\r\n    LGMIDITranspose.desc = "Transpose a MIDI note";\r\n    LGMIDITranspose.color = MIDI_COLOR;\r\n\r\n    LGMIDITranspose.prototype.onAction = function(event, midi_event) {\r\n        if (!midi_event || midi_event.constructor !== MIDIEvent) {\r\n            return;\r\n        }\r\n\r\n        if (\r\n            midi_event.data[0] == MIDIEvent.NOTEON ||\r\n            midi_event.data[0] == MIDIEvent.NOTEOFF\r\n        ) {\r\n            this.midi_event = new MIDIEvent();\r\n            this.midi_event.setup(midi_event.data);\r\n            this.midi_event.data[1] = Math.round(\r\n                this.midi_event.data[1] + this.properties.amount\r\n            );\r\n            this.trigger("out", this.midi_event);\r\n        } else {\r\n            this.trigger("out", midi_event);\r\n        }\r\n    };\r\n\r\n    LGMIDITranspose.prototype.onExecute = function() {\r\n        var amount = this.getInputData(1);\r\n        if (amount != null) {\r\n            this.properties.amount = amount;\r\n        }\r\n    };\r\n\r\n    LiteGraph.registerNodeType("midi/transpose", LGMIDITranspose);\r\n\r\n    function LGMIDIQuantize() {\r\n        this.properties = {\r\n            scale: "A,A#,B,C,C#,D,D#,E,F,F#,G,G#"\r\n        };\r\n        this.addInput("note", LiteGraph.ACTION);\r\n        this.addInput("scale", "string");\r\n        this.addOutput("out", LiteGraph.EVENT);\r\n\r\n        this.valid_notes = new Array(12);\r\n        this.offset_notes = new Array(12);\r\n        this.processScale(this.properties.scale);\r\n    }\r\n\r\n    LGMIDIQuantize.title = "MIDI Quantize Pitch";\r\n    LGMIDIQuantize.desc = "Transpose a MIDI note tp fit an scale";\r\n    LGMIDIQuantize.color = MIDI_COLOR;\r\n\r\n    LGMIDIQuantize.prototype.onPropertyChanged = function(name, value) {\r\n        if (name == "scale") {\r\n            this.processScale(value);\r\n        }\r\n    };\r\n\r\n    LGMIDIQuantize.prototype.processScale = function(scale) {\r\n        this._current_scale = scale;\r\n        this.notes_pitches = LGMIDIGenerator.processScale(scale);\r\n        for (var i = 0; i < 12; ++i) {\r\n            this.valid_notes[i] = this.notes_pitches.indexOf(i) != -1;\r\n        }\r\n        for (var i = 0; i < 12; ++i) {\r\n            if (this.valid_notes[i]) {\r\n                this.offset_notes[i] = 0;\r\n                continue;\r\n            }\r\n            for (var j = 1; j < 12; ++j) {\r\n                if (this.valid_notes[(i - j) % 12]) {\r\n                    this.offset_notes[i] = -j;\r\n                    break;\r\n                }\r\n                if (this.valid_notes[(i + j) % 12]) {\r\n                    this.offset_notes[i] = j;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    LGMIDIQuantize.prototype.onAction = function(event, midi_event) {\r\n        if (!midi_event || midi_event.constructor !== MIDIEvent) {\r\n            return;\r\n        }\r\n\r\n        if (\r\n            midi_event.data[0] == MIDIEvent.NOTEON ||\r\n            midi_event.data[0] == MIDIEvent.NOTEOFF\r\n        ) {\r\n            this.midi_event = new MIDIEvent();\r\n            this.midi_event.setup(midi_event.data);\r\n            var note = midi_event.note;\r\n            var index = MIDIEvent.note_to_index[note];\r\n            var offset = this.offset_notes[index];\r\n            this.midi_event.data[1] += offset;\r\n            this.trigger("out", this.midi_event);\r\n        } else {\r\n            this.trigger("out", midi_event);\r\n        }\r\n    };\r\n\r\n    LGMIDIQuantize.prototype.onExecute = function() {\r\n        var scale = this.getInputData(1);\r\n        if (scale != null && scale != this._current_scale) {\r\n            this.processScale(scale);\r\n        }\r\n    };\r\n\r\n    LiteGraph.registerNodeType("midi/quantize", LGMIDIQuantize);\r\n\r\n\tfunction LGMIDIFromFile() {\r\n        this.properties = {\r\n            url: "",\r\n\t\t\tautoplay: true\r\n        };\r\n\r\n        this.addInput("play", LiteGraph.ACTION);\r\n        this.addInput("pause", LiteGraph.ACTION);\r\n        this.addOutput("note", LiteGraph.EVENT);\r\n\t\tthis._midi = null;\r\n\t\tthis._current_time = 0;\r\n\t\tthis._playing = false;\r\n\r\n        if (typeof MidiParser == "undefined") {\r\n            console.error(\r\n                "midi-parser.js not included, LGMidiPlay requires that library: https://raw.githubusercontent.com/colxi/midi-parser-js/master/src/main.js"\r\n            );\r\n            this.boxcolor = "red";\r\n\t\t}\r\n\r\n\t}\r\n\r\n    LGMIDIFromFile.title = "MIDI fromFile";\r\n    LGMIDIFromFile.desc = "Plays a MIDI file";\r\n    LGMIDIFromFile.color = MIDI_COLOR;\r\n\r\n\tLGMIDIFromFile.prototype.onAction = function( name )\r\n\t{\r\n\t\tif(name == "play")\r\n\t\t\tthis.play();\r\n\t\telse if(name == "pause")\r\n\t\t\tthis._playing = !this._playing;\r\n\t}\r\n\r\n\tLGMIDIFromFile.prototype.onPropertyChanged = function(name,value)\r\n\t{\r\n\t\tif(name == "url")\r\n\t\t\tthis.loadMIDIFile(value);\r\n\t}\r\n\r\n    LGMIDIFromFile.prototype.onExecute = function() {\r\n\t\tif(!this._midi)\r\n\t\t\treturn;\r\n\r\n\t\tif(!this._playing)\r\n\t\t\treturn;\r\n\r\n\t\tthis._current_time += this.graph.elapsed_time;\r\n\t\tvar current_time = this._current_time * 100;\r\n\r\n\t\tfor(var i = 0; i < this._midi.tracks; ++i)\r\n\t\t{\r\n\t\t\tvar track = this._midi.track[i];\r\n\t\t\tif(!track._last_pos)\r\n\t\t\t{\r\n\t\t\t\ttrack._last_pos = 0;\r\n\t\t\t\ttrack._time = 0;\r\n\t\t\t}\r\n\r\n\t\t\tvar elem = track.event[ track._last_pos ];\r\n\t\t\tif(elem && (track._time + elem.deltaTime) <= current_time )\r\n\t\t\t{\r\n\t\t\t\ttrack._last_pos++;\r\n\t\t\t\ttrack._time += elem.deltaTime;\r\n\r\n\t\t\t\tif(elem.data)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar midi_cmd = elem.type << 4 + elem.channel;\r\n\t\t\t\t\tvar midi_event = new MIDIEvent();\r\n\t\t\t\t\tmidi_event.setup([midi_cmd, elem.data[0], elem.data[1]]);\r\n\t\t\t\t\tthis.trigger("note", midi_event);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n    };\r\n\r\n\tLGMIDIFromFile.prototype.play = function()\r\n\t{\r\n\t\tthis._playing = true;\r\n\t\tthis._current_time = 0;\r\n\t\tif(!this._midi)\r\n\t\t\treturn;\r\n\r\n\t\tfor(var i = 0; i < this._midi.tracks; ++i)\r\n\t\t{\r\n\t\t\tvar track = this._midi.track[i];\r\n\t\t\ttrack._last_pos = 0;\r\n\t\t\ttrack._time = 0;\r\n\t\t}\t\t\r\n\t}\r\n\r\n\tLGMIDIFromFile.prototype.loadMIDIFile = function(url)\r\n\t{\r\n\t\tvar that = this;\r\n\t\tLiteGraph.fetchFile( url, "arraybuffer", function(data)\r\n\t\t{\r\n\t\t\tthat.boxcolor = "#AFA";\r\n\t\t\tthat._midi = MidiParser.parse( new Uint8Array(data) );\r\n\t\t\tif(that.properties.autoplay)\r\n\t\t\t\tthat.play();\r\n\t\t}, function(err){\r\n\t\t\tthat.boxcolor = "#FAA";\r\n\t\t\tthat._midi = null;\r\n\t\t});\r\n\t}\r\n\r\n\tLGMIDIFromFile.prototype.onDropFile = function(file)\r\n\t{\r\n\t\tthis.properties.url = "";\r\n\t\tthis.loadMIDIFile( file );\r\n\t}\r\n\r\n    LiteGraph.registerNodeType("midi/fromFile", LGMIDIFromFile);\r\n\r\n\r\n    function LGMIDIPlay() {\r\n        this.properties = {\r\n            volume: 0.5,\r\n            duration: 1\r\n        };\r\n        this.addInput("note", LiteGraph.ACTION);\r\n        this.addInput("volume", "number");\r\n        this.addInput("duration", "number");\r\n        this.addOutput("note", LiteGraph.EVENT);\r\n\r\n        if (typeof AudioSynth == "undefined") {\r\n            console.error(\r\n                "Audiosynth.js not included, LGMidiPlay requires that library"\r\n            );\r\n            this.boxcolor = "red";\r\n        } else {\r\n            var Synth = (this.synth = new AudioSynth());\r\n            this.instrument = Synth.createInstrument("piano");\r\n        }\r\n    }\r\n\r\n    LGMIDIPlay.title = "MIDI Play";\r\n    LGMIDIPlay.desc = "Plays a MIDI note";\r\n    LGMIDIPlay.color = MIDI_COLOR;\r\n\r\n    LGMIDIPlay.prototype.onAction = function(event, midi_event) {\r\n        if (!midi_event || midi_event.constructor !== MIDIEvent) {\r\n            return;\r\n        }\r\n\r\n        if (this.instrument && midi_event.data[0] == MIDIEvent.NOTEON) {\r\n            var note = midi_event.note; //C#\r\n            if (!note || note == "undefined" || note.constructor !== String) {\r\n                return;\r\n            }\r\n            this.instrument.play(\r\n                note,\r\n                midi_event.octave,\r\n                this.properties.duration,\r\n                this.properties.volume\r\n            );\r\n        }\r\n        this.trigger("note", midi_event);\r\n    };\r\n\r\n    LGMIDIPlay.prototype.onExecute = function() {\r\n        var volume = this.getInputData(1);\r\n        if (volume != null) {\r\n            this.properties.volume = volume;\r\n        }\r\n\r\n        var duration = this.getInputData(2);\r\n        if (duration != null) {\r\n            this.properties.duration = duration;\r\n        }\r\n    };\r\n\r\n    LiteGraph.registerNodeType("midi/play", LGMIDIPlay);\r\n\r\n    function LGMIDIKeys() {\r\n        this.properties = {\r\n            num_octaves: 2,\r\n            start_octave: 2\r\n        };\r\n        this.addInput("note", LiteGraph.ACTION);\r\n        this.addInput("reset", LiteGraph.ACTION);\r\n        this.addOutput("note", LiteGraph.EVENT);\r\n        this.size = [400, 100];\r\n        this.keys = [];\r\n        this._last_key = -1;\r\n    }\r\n\r\n    LGMIDIKeys.title = "MIDI Keys";\r\n    LGMIDIKeys.desc = "Keyboard to play notes";\r\n    LGMIDIKeys.color = MIDI_COLOR;\r\n\r\n    LGMIDIKeys.keys = [\r\n        { x: 0, w: 1, h: 1, t: 0 },\r\n        { x: 0.75, w: 0.5, h: 0.6, t: 1 },\r\n        { x: 1, w: 1, h: 1, t: 0 },\r\n        { x: 1.75, w: 0.5, h: 0.6, t: 1 },\r\n        { x: 2, w: 1, h: 1, t: 0 },\r\n        { x: 2.75, w: 0.5, h: 0.6, t: 1 },\r\n        { x: 3, w: 1, h: 1, t: 0 },\r\n        { x: 4, w: 1, h: 1, t: 0 },\r\n        { x: 4.75, w: 0.5, h: 0.6, t: 1 },\r\n        { x: 5, w: 1, h: 1, t: 0 },\r\n        { x: 5.75, w: 0.5, h: 0.6, t: 1 },\r\n        { x: 6, w: 1, h: 1, t: 0 }\r\n    ];\r\n\r\n    LGMIDIKeys.prototype.onDrawForeground = function(ctx) {\r\n        if (this.flags.collapsed) {\r\n            return;\r\n        }\r\n\r\n        var num_keys = this.properties.num_octaves * 12;\r\n        this.keys.length = num_keys;\r\n        var key_width = this.size[0] / (this.properties.num_octaves * 7);\r\n        var key_height = this.size[1];\r\n\r\n        ctx.globalAlpha = 1;\r\n\r\n        for (\r\n            var k = 0;\r\n            k < 2;\r\n            k++ //draw first whites (0) then blacks (1)\r\n        ) {\r\n            for (var i = 0; i < num_keys; ++i) {\r\n                var key_info = LGMIDIKeys.keys[i % 12];\r\n                if (key_info.t != k) {\r\n                    continue;\r\n                }\r\n                var octave = Math.floor(i / 12);\r\n                var x = octave * 7 * key_width + key_info.x * key_width;\r\n                if (k == 0) {\r\n                    ctx.fillStyle = this.keys[i] ? "#CCC" : "white";\r\n                } else {\r\n                    ctx.fillStyle = this.keys[i] ? "#333" : "black";\r\n                }\r\n                ctx.fillRect(\r\n                    x + 1,\r\n                    0,\r\n                    key_width * key_info.w - 2,\r\n                    key_height * key_info.h\r\n                );\r\n            }\r\n        }\r\n    };\r\n\r\n    LGMIDIKeys.prototype.getKeyIndex = function(pos) {\r\n        var num_keys = this.properties.num_octaves * 12;\r\n        var key_width = this.size[0] / (this.properties.num_octaves * 7);\r\n        var key_height = this.size[1];\r\n\r\n        for (\r\n            var k = 1;\r\n            k >= 0;\r\n            k-- //test blacks first (1) then whites (0)\r\n        ) {\r\n            for (var i = 0; i < this.keys.length; ++i) {\r\n                var key_info = LGMIDIKeys.keys[i % 12];\r\n                if (key_info.t != k) {\r\n                    continue;\r\n                }\r\n                var octave = Math.floor(i / 12);\r\n                var x = octave * 7 * key_width + key_info.x * key_width;\r\n                var w = key_width * key_info.w;\r\n                var h = key_height * key_info.h;\r\n                if (pos[0] < x || pos[0] > x + w || pos[1] > h) {\r\n                    continue;\r\n                }\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    };\r\n\r\n    LGMIDIKeys.prototype.onAction = function(event, params) {\r\n        if (event == "reset") {\r\n            for (var i = 0; i < this.keys.length; ++i) {\r\n                this.keys[i] = false;\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (!params || params.constructor !== MIDIEvent) {\r\n            return;\r\n        }\r\n        var midi_event = params;\r\n        var start_note = (this.properties.start_octave - 1) * 12 + 29;\r\n        var index = midi_event.data[1] - start_note;\r\n        if (index >= 0 && index < this.keys.length) {\r\n            if (midi_event.data[0] == MIDIEvent.NOTEON) {\r\n                this.keys[index] = true;\r\n            } else if (midi_event.data[0] == MIDIEvent.NOTEOFF) {\r\n                this.keys[index] = false;\r\n            }\r\n        }\r\n\r\n        this.trigger("note", midi_event);\r\n    };\r\n\r\n    LGMIDIKeys.prototype.onMouseDown = function(e, pos) {\r\n        if (pos[1] < 0) {\r\n            return;\r\n        }\r\n        var index = this.getKeyIndex(pos);\r\n        this.keys[index] = true;\r\n        this._last_key = index;\r\n        var pitch = (this.properties.start_octave - 1) * 12 + 29 + index;\r\n        var midi_event = new MIDIEvent();\r\n        midi_event.setup([MIDIEvent.NOTEON, pitch, 100]);\r\n        this.trigger("note", midi_event);\r\n        return true;\r\n    };\r\n\r\n    LGMIDIKeys.prototype.onMouseMove = function(e, pos) {\r\n        if (pos[1] < 0 || this._last_key == -1) {\r\n            return;\r\n        }\r\n        this.setDirtyCanvas(true);\r\n        var index = this.getKeyIndex(pos);\r\n        if (this._last_key == index) {\r\n            return true;\r\n        }\r\n        this.keys[this._last_key] = false;\r\n        var pitch =\r\n            (this.properties.start_octave - 1) * 12 + 29 + this._last_key;\r\n        var midi_event = new MIDIEvent();\r\n        midi_event.setup([MIDIEvent.NOTEOFF, pitch, 100]);\r\n        this.trigger("note", midi_event);\r\n\r\n        this.keys[index] = true;\r\n        var pitch = (this.properties.start_octave - 1) * 12 + 29 + index;\r\n        var midi_event = new MIDIEvent();\r\n        midi_event.setup([MIDIEvent.NOTEON, pitch, 100]);\r\n        this.trigger("note", midi_event);\r\n\r\n        this._last_key = index;\r\n        return true;\r\n    };\r\n\r\n    LGMIDIKeys.prototype.onMouseUp = function(e, pos) {\r\n        if (pos[1] < 0) {\r\n            return;\r\n        }\r\n        var index = this.getKeyIndex(pos);\r\n        this.keys[index] = false;\r\n        this._last_key = -1;\r\n        var pitch = (this.properties.start_octave - 1) * 12 + 29 + index;\r\n        var midi_event = new MIDIEvent();\r\n        midi_event.setup([MIDIEvent.NOTEOFF, pitch, 100]);\r\n        this.trigger("note", midi_event);\r\n        return true;\r\n    };\r\n\r\n    LiteGraph.registerNodeType("midi/keys", LGMIDIKeys);\r\n\r\n    function now() {\r\n        return window.performance.now();\r\n    }\r\n})(this);\r\n\n(function(global) {\r\n    var LiteGraph = global.LiteGraph;\r\n\r\n    var LGAudio = {};\r\n    global.LGAudio = LGAudio;\r\n\r\n    LGAudio.getAudioContext = function() {\r\n        if (!this._audio_context) {\r\n            window.AudioContext =\r\n                window.AudioContext || window.webkitAudioContext;\r\n            if (!window.AudioContext) {\r\n                console.error("AudioContext not supported by browser");\r\n                return null;\r\n            }\r\n            this._audio_context = new AudioContext();\r\n            this._audio_context.onmessage = function(msg) {\r\n                console.log("msg", msg);\r\n            };\r\n            this._audio_context.onended = function(msg) {\r\n                console.log("ended", msg);\r\n            };\r\n            this._audio_context.oncomplete = function(msg) {\r\n                console.log("complete", msg);\r\n            };\r\n        }\r\n\r\n        //in case it crashes\r\n        //if(this._audio_context.state == "suspended")\r\n        //\tthis._audio_context.resume();\r\n        return this._audio_context;\r\n    };\r\n\r\n    LGAudio.connect = function(audionodeA, audionodeB) {\r\n        try {\r\n            audionodeA.connect(audionodeB);\r\n        } catch (err) {\r\n            console.warn("LGraphAudio:", err);\r\n        }\r\n    };\r\n\r\n    LGAudio.disconnect = function(audionodeA, audionodeB) {\r\n        try {\r\n            audionodeA.disconnect(audionodeB);\r\n        } catch (err) {\r\n            console.warn("LGraphAudio:", err);\r\n        }\r\n    };\r\n\r\n    LGAudio.changeAllAudiosConnections = function(node, connect) {\r\n        if (node.inputs) {\r\n            for (var i = 0; i < node.inputs.length; ++i) {\r\n                var input = node.inputs[i];\r\n                var link_info = node.graph.links[input.link];\r\n                if (!link_info) {\r\n                    continue;\r\n                }\r\n\r\n                var origin_node = node.graph.getNodeById(link_info.origin_id);\r\n                var origin_audionode = null;\r\n                if (origin_node.getAudioNodeInOutputSlot) {\r\n                    origin_audionode = origin_node.getAudioNodeInOutputSlot(\r\n                        link_info.origin_slot\r\n                    );\r\n                } else {\r\n                    origin_audionode = origin_node.audionode;\r\n                }\r\n\r\n                var target_audionode = null;\r\n                if (node.getAudioNodeInInputSlot) {\r\n                    target_audionode = node.getAudioNodeInInputSlot(i);\r\n                } else {\r\n                    target_audionode = node.audionode;\r\n                }\r\n\r\n                if (connect) {\r\n                    LGAudio.connect(origin_audionode, target_audionode);\r\n                } else {\r\n                    LGAudio.disconnect(origin_audionode, target_audionode);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (node.outputs) {\r\n            for (var i = 0; i < node.outputs.length; ++i) {\r\n                var output = node.outputs[i];\r\n                for (var j = 0; j < output.links.length; ++j) {\r\n                    var link_info = node.graph.links[output.links[j]];\r\n                    if (!link_info) {\r\n                        continue;\r\n                    }\r\n\r\n                    var origin_audionode = null;\r\n                    if (node.getAudioNodeInOutputSlot) {\r\n                        origin_audionode = node.getAudioNodeInOutputSlot(i);\r\n                    } else {\r\n                        origin_audionode = node.audionode;\r\n                    }\r\n\r\n                    var target_node = node.graph.getNodeById(\r\n                        link_info.target_id\r\n                    );\r\n                    var target_audionode = null;\r\n                    if (target_node.getAudioNodeInInputSlot) {\r\n                        target_audionode = target_node.getAudioNodeInInputSlot(\r\n                            link_info.target_slot\r\n                        );\r\n                    } else {\r\n                        target_audionode = target_node.audionode;\r\n                    }\r\n\r\n                    if (connect) {\r\n                        LGAudio.connect(origin_audionode, target_audionode);\r\n                    } else {\r\n                        LGAudio.disconnect(origin_audionode, target_audionode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    //used by many nodes\r\n    LGAudio.onConnectionsChange = function(\r\n        connection,\r\n        slot,\r\n        connected,\r\n        link_info\r\n    ) {\r\n        //only process the outputs events\r\n        if (connection != LiteGraph.OUTPUT) {\r\n            return;\r\n        }\r\n\r\n        var target_node = null;\r\n        if (link_info) {\r\n            target_node = this.graph.getNodeById(link_info.target_id);\r\n        }\r\n\r\n        if (!target_node) {\r\n            return;\r\n        }\r\n\r\n        //get origin audionode\r\n        var local_audionode = null;\r\n        if (this.getAudioNodeInOutputSlot) {\r\n            local_audionode = this.getAudioNodeInOutputSlot(slot);\r\n        } else {\r\n            local_audionode = this.audionode;\r\n        }\r\n\r\n        //get target audionode\r\n        var target_audionode = null;\r\n        if (target_node.getAudioNodeInInputSlot) {\r\n            target_audionode = target_node.getAudioNodeInInputSlot(\r\n                link_info.target_slot\r\n            );\r\n        } else {\r\n            target_audionode = target_node.audionode;\r\n        }\r\n\r\n        //do the connection/disconnection\r\n        if (connected) {\r\n            LGAudio.connect(local_audionode, target_audionode);\r\n        } else {\r\n            LGAudio.disconnect(local_audionode, target_audionode);\r\n        }\r\n    };\r\n\r\n    //this function helps creating wrappers to existing classes\r\n    LGAudio.createAudioNodeWrapper = function(class_object) {\r\n        var old_func = class_object.prototype.onPropertyChanged;\r\n\r\n        class_object.prototype.onPropertyChanged = function(name, value) {\r\n            if (old_func) {\r\n                old_func.call(this, name, value);\r\n            }\r\n\r\n            if (!this.audionode) {\r\n                return;\r\n            }\r\n\r\n            if (this.audionode[name] === undefined) {\r\n                return;\r\n            }\r\n\r\n            if (this.audionode[name].value !== undefined) {\r\n                this.audionode[name].value = value;\r\n            } else {\r\n                this.audionode[name] = value;\r\n            }\r\n        };\r\n\r\n        class_object.prototype.onConnectionsChange =\r\n            LGAudio.onConnectionsChange;\r\n    };\r\n\r\n    //contains the samples decoded of the loaded audios in AudioBuffer format\r\n    LGAudio.cached_audios = {};\r\n\r\n    LGAudio.loadSound = function(url, on_complete, on_error) {\r\n        if (LGAudio.cached_audios[url] && url.indexOf("blob:") == -1) {\r\n            if (on_complete) {\r\n                on_complete(LGAudio.cached_audios[url]);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (LGAudio.onProcessAudioURL) {\r\n            url = LGAudio.onProcessAudioURL(url);\r\n        }\r\n\r\n        //load new sample\r\n        var request = new XMLHttpRequest();\r\n        request.open("GET", url, true);\r\n        request.responseType = "arraybuffer";\r\n\r\n        var context = LGAudio.getAudioContext();\r\n\r\n        // Decode asynchronously\r\n        request.onload = function() {\r\n            console.log("AudioSource loaded");\r\n            context.decodeAudioData(\r\n                request.response,\r\n                function(buffer) {\r\n                    console.log("AudioSource decoded");\r\n                    LGAudio.cached_audios[url] = buffer;\r\n                    if (on_complete) {\r\n                        on_complete(buffer);\r\n                    }\r\n                },\r\n                onError\r\n            );\r\n        };\r\n        request.send();\r\n\r\n        function onError(err) {\r\n            console.log("Audio loading sample error:", err);\r\n            if (on_error) {\r\n                on_error(err);\r\n            }\r\n        }\r\n\r\n        return request;\r\n    };\r\n\r\n    //****************************************************\r\n\r\n    function LGAudioSource() {\r\n        this.properties = {\r\n            src: "",\r\n            gain: 0.5,\r\n            loop: true,\r\n            autoplay: true,\r\n            playbackRate: 1\r\n        };\r\n\r\n        this._loading_audio = false;\r\n        this._audiobuffer = null; //points to AudioBuffer with the audio samples decoded\r\n        this._audionodes = [];\r\n        this._last_sourcenode = null; //the last AudioBufferSourceNode (there could be more if there are several sounds playing)\r\n\r\n        this.addOutput("out", "audio");\r\n        this.addInput("gain", "number");\r\n\r\n        //init context\r\n        var context = LGAudio.getAudioContext();\r\n\r\n        //create gain node to control volume\r\n        this.audionode = context.createGain();\r\n        this.audionode.graphnode = this;\r\n        this.audionode.gain.value = this.properties.gain;\r\n\r\n        //debug\r\n        if (this.properties.src) {\r\n            this.loadSound(this.properties.src);\r\n        }\r\n    }\r\n\r\n\tLGAudioSource.desc = "Plays an audio file";\r\n    LGAudioSource["@src"] = { widget: "resource" };\r\n    LGAudioSource.supported_extensions = ["wav", "ogg", "mp3"];\r\n\r\n    LGAudioSource.prototype.onAdded = function(graph) {\r\n        if (graph.status === LGraph.STATUS_RUNNING) {\r\n            this.onStart();\r\n        }\r\n    };\r\n\r\n    LGAudioSource.prototype.onStart = function() {\r\n        if (!this._audiobuffer) {\r\n            return;\r\n        }\r\n\r\n        if (this.properties.autoplay) {\r\n\t\t\tthis.playBuffer(this._audiobuffer);\r\n        }\r\n    };\r\n\r\n    LGAudioSource.prototype.onStop = function() {\r\n        this.stopAllSounds();\r\n    };\r\n\r\n    LGAudioSource.prototype.onPause = function() {\r\n        this.pauseAllSounds();\r\n    };\r\n\r\n    LGAudioSource.prototype.onUnpause = function() {\r\n        this.unpauseAllSounds();\r\n        //this.onStart();\r\n    };\r\n\r\n    LGAudioSource.prototype.onRemoved = function() {\r\n        this.stopAllSounds();\r\n        if (this._dropped_url) {\r\n            URL.revokeObjectURL(this._url);\r\n        }\r\n    };\r\n\r\n    LGAudioSource.prototype.stopAllSounds = function() {\r\n        //iterate and stop\r\n        for (var i = 0; i < this._audionodes.length; ++i) {\r\n            if (this._audionodes[i].started) {\r\n                this._audionodes[i].started = false;\r\n                this._audionodes[i].stop();\r\n            }\r\n            //this._audionodes[i].disconnect( this.audionode );\r\n        }\r\n        this._audionodes.length = 0;\r\n    };\r\n\r\n    LGAudioSource.prototype.pauseAllSounds = function() {\r\n        LGAudio.getAudioContext().suspend();\r\n    };\r\n\r\n    LGAudioSource.prototype.unpauseAllSounds = function() {\r\n        LGAudio.getAudioContext().resume();\r\n    };\r\n\r\n    LGAudioSource.prototype.onExecute = function() {\r\n        if (this.inputs) {\r\n            for (var i = 0; i < this.inputs.length; ++i) {\r\n                var input = this.inputs[i];\r\n                if (input.link == null) {\r\n                    continue;\r\n                }\r\n                var v = this.getInputData(i);\r\n                if (v === undefined) {\r\n                    continue;\r\n                }\r\n                if (input.name == "gain")\r\n                    this.audionode.gain.value = v;\r\n                else if (input.name == "src") {\r\n                    this.setProperty("src",v);\r\n                } else if (input.name == "playbackRate") {\r\n                    this.properties.playbackRate = v;\r\n                    for (var j = 0; j < this._audionodes.length; ++j) {\r\n                        this._audionodes[j].playbackRate.value = v;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.outputs) {\r\n            for (var i = 0; i < this.outputs.length; ++i) {\r\n                var output = this.outputs[i];\r\n                if (output.name == "buffer" && this._audiobuffer) {\r\n                    this.setOutputData(i, this._audiobuffer);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    LGAudioSource.prototype.onAction = function(event) {\r\n        if (this._audiobuffer) {\r\n            if (event == "Play") {\r\n                this.playBuffer(this._audiobuffer);\r\n            } else if (event == "Stop") {\r\n                this.stopAllSounds();\r\n            }\r\n        }\r\n    };\r\n\r\n    LGAudioSource.prototype.onPropertyChanged = function(name, value) {\r\n        if (name == "src") {\r\n            this.loadSound(value);\r\n        } else if (name == "gain") {\r\n            this.audionode.gain.value = value;\r\n        } else if (name == "playbackRate") {\r\n            for (var j = 0; j < this._audionodes.length; ++j) {\r\n                this._audionodes[j].playbackRate.value = value;\r\n            }\r\n        }\r\n    };\r\n\r\n    LGAudioSource.prototype.playBuffer = function(buffer) {\r\n        var that = this;\r\n        var context = LGAudio.getAudioContext();\r\n\r\n        //create a new audionode (this is mandatory, AudioAPI doesnt like to reuse old ones)\r\n        var audionode = context.createBufferSource(); //create a AudioBufferSourceNode\r\n        this._last_sourcenode = audionode;\r\n        audionode.graphnode = this;\r\n        audionode.buffer = buffer;\r\n        audionode.loop = this.properties.loop;\r\n        audionode.playbackRate.value = this.properties.playbackRate;\r\n        this._audionodes.push(audionode);\r\n        audionode.connect(this.audionode); //connect to gain\r\n\r\n\t\tthis._audionodes.push(audionode);\r\n\r\n\t\tthis.trigger("start");\r\n\r\n        audionode.onended = function() {\r\n            //console.log("ended!");\r\n            that.trigger("ended");\r\n            //remove\r\n            var index = that._audionodes.indexOf(audionode);\r\n            if (index != -1) {\r\n                that._audionodes.splice(index, 1);\r\n            }\r\n        };\r\n\r\n        if (!audionode.started) {\r\n            audionode.started = true;\r\n            audionode.start();\r\n        }\r\n        return audionode;\r\n    };\r\n\r\n    LGAudioSource.prototype.loadSound = function(url) {\r\n        var that = this;\r\n\r\n        //kill previous load\r\n        if (this._request) {\r\n            this._request.abort();\r\n            this._request = null;\r\n        }\r\n\r\n        this._audiobuffer = null; //points to the audiobuffer once the audio is loaded\r\n        this._loading_audio = false;\r\n\r\n        if (!url) {\r\n            return;\r\n        }\r\n\r\n        this._request = LGAudio.loadSound(url, inner);\r\n\r\n        this._loading_audio = true;\r\n        this.boxcolor = "#AA4";\r\n\r\n        function inner(buffer) {\r\n            this.boxcolor = LiteGraph.NODE_DEFAULT_BOXCOLOR;\r\n            that._audiobuffer = buffer;\r\n            that._loading_audio = false;\r\n            //if is playing, then play it\r\n            if (that.graph && that.graph.status === LGraph.STATUS_RUNNING) {\r\n                that.onStart();\r\n            } //this controls the autoplay already\r\n        }\r\n    };\r\n\r\n    //Helps connect/disconnect AudioNodes when new connections are made in the node\r\n    LGAudioSource.prototype.onConnectionsChange = LGAudio.onConnectionsChange;\r\n\r\n    LGAudioSource.prototype.onGetInputs = function() {\r\n        return [\r\n            ["playbackRate", "number"],\r\n\t\t\t["src","string"],\r\n            ["Play", LiteGraph.ACTION],\r\n            ["Stop", LiteGraph.ACTION]\r\n        ];\r\n    };\r\n\r\n    LGAudioSource.prototype.onGetOutputs = function() {\r\n        return [["buffer", "audiobuffer"], ["start", LiteGraph.EVENT], ["ended", LiteGraph.EVENT]];\r\n    };\r\n\r\n    LGAudioSource.prototype.onDropFile = function(file) {\r\n        if (this._dropped_url) {\r\n            URL.revokeObjectURL(this._dropped_url);\r\n        }\r\n        var url = URL.createObjectURL(file);\r\n        this.properties.src = url;\r\n        this.loadSound(url);\r\n        this._dropped_url = url;\r\n    };\r\n\r\n    LGAudioSource.title = "Source";\r\n    LGAudioSource.desc = "Plays audio";\r\n    LiteGraph.registerNodeType("audio/source", LGAudioSource);\r\n\r\n    //****************************************************\r\n\r\n    function LGAudioMediaSource() {\r\n        this.properties = {\r\n            gain: 0.5\r\n        };\r\n\r\n        this._audionodes = [];\r\n        this._media_stream = null;\r\n\r\n        this.addOutput("out", "audio");\r\n        this.addInput("gain", "number");\r\n\r\n        //create gain node to control volume\r\n        var context = LGAudio.getAudioContext();\r\n        this.audionode = context.createGain();\r\n        this.audionode.graphnode = this;\r\n        this.audionode.gain.value = this.properties.gain;\r\n    }\r\n\r\n    LGAudioMediaSource.prototype.onAdded = function(graph) {\r\n        if (graph.status === LGraph.STATUS_RUNNING) {\r\n            this.onStart();\r\n        }\r\n    };\r\n\r\n    LGAudioMediaSource.prototype.onStart = function() {\r\n        if (this._media_stream == null && !this._waiting_confirmation) {\r\n            this.openStream();\r\n        }\r\n    };\r\n\r\n    LGAudioMediaSource.prototype.onStop = function() {\r\n        this.audionode.gain.value = 0;\r\n    };\r\n\r\n    LGAudioMediaSource.prototype.onPause = function() {\r\n        this.audionode.gain.value = 0;\r\n    };\r\n\r\n    LGAudioMediaSource.prototype.onUnpause = function() {\r\n        this.audionode.gain.value = this.properties.gain;\r\n    };\r\n\r\n    LGAudioMediaSource.prototype.onRemoved = function() {\r\n        this.audionode.gain.value = 0;\r\n        if (this.audiosource_node) {\r\n            this.audiosource_node.disconnect(this.audionode);\r\n            this.audiosource_node = null;\r\n        }\r\n        if (this._media_stream) {\r\n            var tracks = this._media_stream.getTracks();\r\n            if (tracks.length) {\r\n                tracks[0].stop();\r\n            }\r\n        }\r\n    };\r\n\r\n    LGAudioMediaSource.prototype.openStream = function() {\r\n        if (!navigator.mediaDevices) {\r\n            console.log(\r\n                "getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags"\r\n            );\r\n            return;\r\n        }\r\n\r\n        this._waiting_confirmation = true;\r\n\r\n        // Not showing vendor prefixes.\r\n        navigator.mediaDevices\r\n            .getUserMedia({ audio: true, video: false })\r\n            .then(this.streamReady.bind(this))\r\n            .catch(onFailSoHard);\r\n\r\n        var that = this;\r\n        function onFailSoHard(err) {\r\n            console.log("Media rejected", err);\r\n            that._media_stream = false;\r\n            that.boxcolor = "red";\r\n        }\r\n    };\r\n\r\n    LGAudioMediaSource.prototype.streamReady = function(localMediaStream) {\r\n        this._media_stream = localMediaStream;\r\n        //this._waiting_confirmation = false;\r\n\r\n        //init context\r\n        if (this.audiosource_node) {\r\n            this.audiosource_node.disconnect(this.audionode);\r\n        }\r\n        var context = LGAudio.getAudioContext();\r\n        this.audiosource_node = context.createMediaStreamSource(\r\n            localMediaStream\r\n        );\r\n        this.audiosource_node.graphnode = this;\r\n        this.audiosource_node.connect(this.audionode);\r\n        this.boxcolor = "white";\r\n    };\r\n\r\n    LGAudioMediaSource.prototype.onExecute = function() {\r\n        if (this._media_stream == null && !this._waiting_confirmation) {\r\n            this.openStream();\r\n        }\r\n\r\n        if (this.inputs) {\r\n            for (var i = 0; i < this.inputs.length; ++i) {\r\n                var input = this.inputs[i];\r\n                if (input.link == null) {\r\n                    continue;\r\n                }\r\n                var v = this.getInputData(i);\r\n                if (v === undefined) {\r\n                    continue;\r\n                }\r\n                if (input.name == "gain") {\r\n                    this.audionode.gain.value = this.properties.gain = v;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    LGAudioMediaSource.prototype.onAction = function(event) {\r\n        if (event == "Play") {\r\n            this.audionode.gain.value = this.properties.gain;\r\n        } else if (event == "Stop") {\r\n            this.audionode.gain.value = 0;\r\n        }\r\n    };\r\n\r\n    LGAudioMediaSource.prototype.onPropertyChanged = function(name, value) {\r\n        if (name == "gain") {\r\n            this.audionode.gain.value = value;\r\n        }\r\n    };\r\n\r\n    //Helps connect/disconnect AudioNodes when new connections are made in the node\r\n    LGAudioMediaSource.prototype.onConnectionsChange =\r\n        LGAudio.onConnectionsChange;\r\n\r\n    LGAudioMediaSource.prototype.onGetInputs = function() {\r\n        return [\r\n            ["playbackRate", "number"],\r\n            ["Play", LiteGraph.ACTION],\r\n            ["Stop", LiteGraph.ACTION]\r\n        ];\r\n    };\r\n\r\n    LGAudioMediaSource.title = "MediaSource";\r\n    LGAudioMediaSource.desc = "Plays microphone";\r\n    LiteGraph.registerNodeType("audio/media_source", LGAudioMediaSource);\r\n\r\n    //*****************************************************\r\n\r\n    function LGAudioAnalyser() {\r\n        this.properties = {\r\n            fftSize: 2048,\r\n            minDecibels: -100,\r\n            maxDecibels: -10,\r\n            smoothingTimeConstant: 0.5\r\n        };\r\n\r\n        var context = LGAudio.getAudioContext();\r\n\r\n        this.audionode = context.createAnalyser();\r\n        this.audionode.graphnode = this;\r\n        this.audionode.fftSize = this.properties.fftSize;\r\n        this.audionode.minDecibels = this.properties.minDecibels;\r\n        this.audionode.maxDecibels = this.properties.maxDecibels;\r\n        this.audionode.smoothingTimeConstant = this.properties.smoothingTimeConstant;\r\n\r\n        this.addInput("in", "audio");\r\n        this.addOutput("freqs", "array");\r\n        this.addOutput("samples", "array");\r\n\r\n        this._freq_bin = null;\r\n        this._time_bin = null;\r\n    }\r\n\r\n    LGAudioAnalyser.prototype.onPropertyChanged = function(name, value) {\r\n        this.audionode[name] = value;\r\n    };\r\n\r\n    LGAudioAnalyser.prototype.onExecute = function() {\r\n        if (this.isOutputConnected(0)) {\r\n            //send FFT\r\n            var bufferLength = this.audionode.frequencyBinCount;\r\n            if (!this._freq_bin || this._freq_bin.length != bufferLength) {\r\n                this._freq_bin = new Uint8Array(bufferLength);\r\n            }\r\n            this.audionode.getByteFrequencyData(this._freq_bin);\r\n            this.setOutputData(0, this._freq_bin);\r\n        }\r\n\r\n        //send analyzer\r\n        if (this.isOutputConnected(1)) {\r\n            //send Samples\r\n            var bufferLength = this.audionode.frequencyBinCount;\r\n            if (!this._time_bin || this._time_bin.length != bufferLength) {\r\n                this._time_bin = new Uint8Array(bufferLength);\r\n            }\r\n            this.audionode.getByteTimeDomainData(this._time_bin);\r\n            this.setOutputData(1, this._time_bin);\r\n        }\r\n\r\n        //properties\r\n        for (var i = 1; i < this.inputs.length; ++i) {\r\n            var input = this.inputs[i];\r\n            if (input.link == null) {\r\n                continue;\r\n            }\r\n            var v = this.getInputData(i);\r\n            if (v !== undefined) {\r\n                this.audionode[input.name].value = v;\r\n            }\r\n        }\r\n\r\n        //time domain\r\n        //this.audionode.getFloatTimeDomainData( dataArray );\r\n    };\r\n\r\n    LGAudioAnalyser.prototype.onGetInputs = function() {\r\n        return [\r\n            ["minDecibels", "number"],\r\n            ["maxDecibels", "number"],\r\n            ["smoothingTimeConstant", "number"]\r\n        ];\r\n    };\r\n\r\n    LGAudioAnalyser.prototype.onGetOutputs = function() {\r\n        return [["freqs", "array"], ["samples", "array"]];\r\n    };\r\n\r\n    LGAudioAnalyser.title = "Analyser";\r\n    LGAudioAnalyser.desc = "Audio Analyser";\r\n    LiteGraph.registerNodeType("audio/analyser", LGAudioAnalyser);\r\n\r\n    //*****************************************************\r\n\r\n    function LGAudioGain() {\r\n        //default\r\n        this.properties = {\r\n            gain: 1\r\n        };\r\n\r\n        this.audionode = LGAudio.getAudioContext().createGain();\r\n        this.addInput("in", "audio");\r\n        this.addInput("gain", "number");\r\n        this.addOutput("out", "audio");\r\n    }\r\n\r\n    LGAudioGain.prototype.onExecute = function() {\r\n        if (!this.inputs || !this.inputs.length) {\r\n            return;\r\n        }\r\n\r\n        for (var i = 1; i < this.inputs.length; ++i) {\r\n            var input = this.inputs[i];\r\n            var v = this.getInputData(i);\r\n            if (v !== undefined) {\r\n                this.audionode[input.name].value = v;\r\n            }\r\n        }\r\n    };\r\n\r\n    LGAudio.createAudioNodeWrapper(LGAudioGain);\r\n\r\n    LGAudioGain.title = "Gain";\r\n    LGAudioGain.desc = "Audio gain";\r\n    LiteGraph.registerNodeType("audio/gain", LGAudioGain);\r\n\r\n    function LGAudioConvolver() {\r\n        //default\r\n        this.properties = {\r\n            impulse_src: "",\r\n            normalize: true\r\n        };\r\n\r\n        this.audionode = LGAudio.getAudioContext().createConvolver();\r\n        this.addInput("in", "audio");\r\n        this.addOutput("out", "audio");\r\n    }\r\n\r\n    LGAudio.createAudioNodeWrapper(LGAudioConvolver);\r\n\r\n    LGAudioConvolver.prototype.onRemove = function() {\r\n        if (this._dropped_url) {\r\n            URL.revokeObjectURL(this._dropped_url);\r\n        }\r\n    };\r\n\r\n    LGAudioConvolver.prototype.onPropertyChanged = function(name, value) {\r\n        if (name == "impulse_src") {\r\n            this.loadImpulse(value);\r\n        } else if (name == "normalize") {\r\n            this.audionode.normalize = value;\r\n        }\r\n    };\r\n\r\n    LGAudioConvolver.prototype.onDropFile = function(file) {\r\n        if (this._dropped_url) {\r\n            URL.revokeObjectURL(this._dropped_url);\r\n        }\r\n        this._dropped_url = URL.createObjectURL(file);\r\n        this.properties.impulse_src = this._dropped_url;\r\n        this.loadImpulse(this._dropped_url);\r\n    };\r\n\r\n    LGAudioConvolver.prototype.loadImpulse = function(url) {\r\n        var that = this;\r\n\r\n        //kill previous load\r\n        if (this._request) {\r\n            this._request.abort();\r\n            this._request = null;\r\n        }\r\n\r\n        this._impulse_buffer = null;\r\n        this._loading_impulse = false;\r\n\r\n        if (!url) {\r\n            return;\r\n        }\r\n\r\n        //load new sample\r\n        this._request = LGAudio.loadSound(url, inner);\r\n        this._loading_impulse = true;\r\n\r\n        // Decode asynchronously\r\n        function inner(buffer) {\r\n            that._impulse_buffer = buffer;\r\n            that.audionode.buffer = buffer;\r\n            console.log("Impulse signal set");\r\n            that._loading_impulse = false;\r\n        }\r\n    };\r\n\r\n    LGAudioConvolver.title = "Convolver";\r\n    LGAudioConvolver.desc = "Convolves the signal (used for reverb)";\r\n    LiteGraph.registerNodeType("audio/convolver", LGAudioConvolver);\r\n\r\n    function LGAudioDynamicsCompressor() {\r\n        //default\r\n        this.properties = {\r\n            threshold: -50,\r\n            knee: 40,\r\n            ratio: 12,\r\n            reduction: -20,\r\n            attack: 0,\r\n            release: 0.25\r\n        };\r\n\r\n        this.audionode = LGAudio.getAudioContext().createDynamicsCompressor();\r\n        this.addInput("in", "audio");\r\n        this.addOutput("out", "audio");\r\n    }\r\n\r\n    LGAudio.createAudioNodeWrapper(LGAudioDynamicsCompressor);\r\n\r\n    LGAudioDynamicsCompressor.prototype.onExecute = function() {\r\n        if (!this.inputs || !this.inputs.length) {\r\n            return;\r\n        }\r\n        for (var i = 1; i < this.inputs.length; ++i) {\r\n            var input = this.inputs[i];\r\n            if (input.link == null) {\r\n                continue;\r\n            }\r\n            var v = this.getInputData(i);\r\n            if (v !== undefined) {\r\n                this.audionode[input.name].value = v;\r\n            }\r\n        }\r\n    };\r\n\r\n    LGAudioDynamicsCompressor.prototype.onGetInputs = function() {\r\n        return [\r\n            ["threshold", "number"],\r\n            ["knee", "number"],\r\n            ["ratio", "number"],\r\n            ["reduction", "number"],\r\n            ["attack", "number"],\r\n            ["release", "number"]\r\n        ];\r\n    };\r\n\r\n    LGAudioDynamicsCompressor.title = "DynamicsCompressor";\r\n    LGAudioDynamicsCompressor.desc = "Dynamics Compressor";\r\n    LiteGraph.registerNodeType(\r\n        "audio/dynamicsCompressor",\r\n        LGAudioDynamicsCompressor\r\n    );\r\n\r\n    function LGAudioWaveShaper() {\r\n        //default\r\n        this.properties = {};\r\n\r\n        this.audionode = LGAudio.getAudioContext().createWaveShaper();\r\n        this.addInput("in", "audio");\r\n        this.addInput("shape", "waveshape");\r\n        this.addOutput("out", "audio");\r\n    }\r\n\r\n    LGAudioWaveShaper.prototype.onExecute = function() {\r\n        if (!this.inputs || !this.inputs.length) {\r\n            return;\r\n        }\r\n        var v = this.getInputData(1);\r\n        if (v === undefined) {\r\n            return;\r\n        }\r\n        this.audionode.curve = v;\r\n    };\r\n\r\n    LGAudioWaveShaper.prototype.setWaveShape = function(shape) {\r\n        this.audionode.curve = shape;\r\n    };\r\n\r\n    LGAudio.createAudioNodeWrapper(LGAudioWaveShaper);\r\n\r\n    /* disabled till I dont find a way to do a wave shape\r\nLGAudioWaveShaper.title = "WaveShaper";\r\nLGAudioWaveShaper.desc = "Distortion using wave shape";\r\nLiteGraph.registerNodeType("audio/waveShaper", LGAudioWaveShaper);\r\n*/\r\n\r\n    function LGAudioMixer() {\r\n        //default\r\n        this.properties = {\r\n            gain1: 0.5,\r\n            gain2: 0.5\r\n        };\r\n\r\n        this.audionode = LGAudio.getAudioContext().createGain();\r\n\r\n        this.audionode1 = LGAudio.getAudioContext().createGain();\r\n        this.audionode1.gain.value = this.properties.gain1;\r\n        this.audionode2 = LGAudio.getAudioContext().createGain();\r\n        this.audionode2.gain.value = this.properties.gain2;\r\n\r\n        this.audionode1.connect(this.audionode);\r\n        this.audionode2.connect(this.audionode);\r\n\r\n        this.addInput("in1", "audio");\r\n        this.addInput("in1 gain", "number");\r\n        this.addInput("in2", "audio");\r\n        this.addInput("in2 gain", "number");\r\n\r\n        this.addOutput("out", "audio");\r\n    }\r\n\r\n    LGAudioMixer.prototype.getAudioNodeInInputSlot = function(slot) {\r\n        if (slot == 0) {\r\n            return this.audionode1;\r\n        } else if (slot == 2) {\r\n            return this.audionode2;\r\n        }\r\n    };\r\n\r\n    LGAudioMixer.prototype.onPropertyChanged = function(name, value) {\r\n        if (name == "gain1") {\r\n            this.audionode1.gain.value = value;\r\n        } else if (name == "gain2") {\r\n            this.audionode2.gain.value = value;\r\n        }\r\n    };\r\n\r\n    LGAudioMixer.prototype.onExecute = function() {\r\n        if (!this.inputs || !this.inputs.length) {\r\n            return;\r\n        }\r\n\r\n        for (var i = 1; i < this.inputs.length; ++i) {\r\n            var input = this.inputs[i];\r\n\r\n            if (input.link == null || input.type == "audio") {\r\n                continue;\r\n            }\r\n\r\n            var v = this.getInputData(i);\r\n            if (v === undefined) {\r\n                continue;\r\n            }\r\n\r\n            if (i == 1) {\r\n                this.audionode1.gain.value = v;\r\n            } else if (i == 3) {\r\n                this.audionode2.gain.value = v;\r\n            }\r\n        }\r\n    };\r\n\r\n    LGAudio.createAudioNodeWrapper(LGAudioMixer);\r\n\r\n    LGAudioMixer.title = "Mixer";\r\n    LGAudioMixer.desc = "Audio mixer";\r\n    LiteGraph.registerNodeType("audio/mixer", LGAudioMixer);\r\n\r\n    function LGAudioADSR() {\r\n        //default\r\n        this.properties = {\r\n            A: 0.1,\r\n            D: 0.1,\r\n            S: 0.1,\r\n            R: 0.1\r\n        };\r\n\r\n        this.audionode = LGAudio.getAudioContext().createGain();\r\n        this.audionode.gain.value = 0;\r\n        this.addInput("in", "audio");\r\n        this.addInput("gate", "boolean");\r\n        this.addOutput("out", "audio");\r\n        this.gate = false;\r\n    }\r\n\r\n    LGAudioADSR.prototype.onExecute = function() {\r\n        var audioContext = LGAudio.getAudioContext();\r\n        var now = audioContext.currentTime;\r\n        var node = this.audionode;\r\n        var gain = node.gain;\r\n        var current_gate = this.getInputData(1);\r\n\r\n        var A = this.getInputOrProperty("A");\r\n        var D = this.getInputOrProperty("D");\r\n        var S = this.getInputOrProperty("S");\r\n        var R = this.getInputOrProperty("R");\r\n\r\n        if (!this.gate && current_gate) {\r\n            gain.cancelScheduledValues(0);\r\n            gain.setValueAtTime(0, now);\r\n            gain.linearRampToValueAtTime(1, now + A);\r\n            gain.linearRampToValueAtTime(S, now + A + D);\r\n        } else if (this.gate && !current_gate) {\r\n            gain.cancelScheduledValues(0);\r\n            gain.setValueAtTime(gain.value, now);\r\n            gain.linearRampToValueAtTime(0, now + R);\r\n        }\r\n\r\n        this.gate = current_gate;\r\n    };\r\n\r\n    LGAudioADSR.prototype.onGetInputs = function() {\r\n        return [\r\n            ["A", "number"],\r\n            ["D", "number"],\r\n            ["S", "number"],\r\n            ["R", "number"]\r\n        ];\r\n    };\r\n\r\n    LGAudio.createAudioNodeWrapper(LGAudioADSR);\r\n\r\n    LGAudioADSR.title = "ADSR";\r\n    LGAudioADSR.desc = "Audio envelope";\r\n    LiteGraph.registerNodeType("audio/adsr", LGAudioADSR);\r\n\r\n    function LGAudioDelay() {\r\n        //default\r\n        this.properties = {\r\n            delayTime: 0.5\r\n        };\r\n\r\n        this.audionode = LGAudio.getAudioContext().createDelay(10);\r\n        this.audionode.delayTime.value = this.properties.delayTime;\r\n        this.addInput("in", "audio");\r\n        this.addInput("time", "number");\r\n        this.addOutput("out", "audio");\r\n    }\r\n\r\n    LGAudio.createAudioNodeWrapper(LGAudioDelay);\r\n\r\n    LGAudioDelay.prototype.onExecute = function() {\r\n        var v = this.getInputData(1);\r\n        if (v !== undefined) {\r\n            this.audionode.delayTime.value = v;\r\n        }\r\n    };\r\n\r\n    LGAudioDelay.title = "Delay";\r\n    LGAudioDelay.desc = "Audio delay";\r\n    LiteGraph.registerNodeType("audio/delay", LGAudioDelay);\r\n\r\n    function LGAudioBiquadFilter() {\r\n        //default\r\n        this.properties = {\r\n            frequency: 350,\r\n            detune: 0,\r\n            Q: 1\r\n        };\r\n        this.addProperty("type", "lowpass", "enum", {\r\n            values: [\r\n                "lowpass",\r\n                "highpass",\r\n                "bandpass",\r\n                "lowshelf",\r\n                "highshelf",\r\n                "peaking",\r\n                "notch",\r\n                "allpass"\r\n            ]\r\n        });\r\n\r\n        //create node\r\n        this.audionode = LGAudio.getAudioContext().createBiquadFilter();\r\n\r\n        //slots\r\n        this.addInput("in", "audio");\r\n        this.addOutput("out", "audio");\r\n    }\r\n\r\n    LGAudioBiquadFilter.prototype.onExecute = function() {\r\n        if (!this.inputs || !this.inputs.length) {\r\n            return;\r\n        }\r\n\r\n        for (var i = 1; i < this.inputs.length; ++i) {\r\n            var input = this.inputs[i];\r\n            if (input.link == null) {\r\n                continue;\r\n            }\r\n            var v = this.getInputData(i);\r\n            if (v !== undefined) {\r\n                this.audionode[input.name].value = v;\r\n            }\r\n        }\r\n    };\r\n\r\n    LGAudioBiquadFilter.prototype.onGetInputs = function() {\r\n        return [["frequency", "number"], ["detune", "number"], ["Q", "number"]];\r\n    };\r\n\r\n    LGAudio.createAudioNodeWrapper(LGAudioBiquadFilter);\r\n\r\n    LGAudioBiquadFilter.title = "BiquadFilter";\r\n    LGAudioBiquadFilter.desc = "Audio filter";\r\n    LiteGraph.registerNodeType("audio/biquadfilter", LGAudioBiquadFilter);\r\n\r\n    function LGAudioOscillatorNode() {\r\n        //default\r\n        this.properties = {\r\n            frequency: 440,\r\n            detune: 0,\r\n            type: "sine"\r\n        };\r\n        this.addProperty("type", "sine", "enum", {\r\n            values: ["sine", "square", "sawtooth", "triangle", "custom"]\r\n        });\r\n\r\n        //create node\r\n        this.audionode = LGAudio.getAudioContext().createOscillator();\r\n\r\n        //slots\r\n        this.addOutput("out", "audio");\r\n    }\r\n\r\n    LGAudioOscillatorNode.prototype.onStart = function() {\r\n        if (!this.audionode.started) {\r\n            this.audionode.started = true;\r\n            try {\r\n                this.audionode.start();\r\n            } catch (err) {}\r\n        }\r\n    };\r\n\r\n    LGAudioOscillatorNode.prototype.onStop = function() {\r\n        if (this.audionode.started) {\r\n            this.audionode.started = false;\r\n            this.audionode.stop();\r\n        }\r\n    };\r\n\r\n    LGAudioOscillatorNode.prototype.onPause = function() {\r\n        this.onStop();\r\n    };\r\n\r\n    LGAudioOscillatorNode.prototype.onUnpause = function() {\r\n        this.onStart();\r\n    };\r\n\r\n    LGAudioOscillatorNode.prototype.onExecute = function() {\r\n        if (!this.inputs || !this.inputs.length) {\r\n            return;\r\n        }\r\n\r\n        for (var i = 0; i < this.inputs.length; ++i) {\r\n            var input = this.inputs[i];\r\n            if (input.link == null) {\r\n                continue;\r\n            }\r\n            var v = this.getInputData(i);\r\n            if (v !== undefined) {\r\n                this.audionode[input.name].value = v;\r\n            }\r\n        }\r\n    };\r\n\r\n    LGAudioOscillatorNode.prototype.onGetInputs = function() {\r\n        return [\r\n            ["frequency", "number"],\r\n            ["detune", "number"],\r\n            ["type", "string"]\r\n        ];\r\n    };\r\n\r\n    LGAudio.createAudioNodeWrapper(LGAudioOscillatorNode);\r\n\r\n    LGAudioOscillatorNode.title = "Oscillator";\r\n    LGAudioOscillatorNode.desc = "Oscillator";\r\n    LiteGraph.registerNodeType("audio/oscillator", LGAudioOscillatorNode);\r\n\r\n    //*****************************************************\r\n\r\n    //EXTRA\r\n\r\n    function LGAudioVisualization() {\r\n        this.properties = {\r\n            continuous: true,\r\n            mark: -1\r\n        };\r\n\r\n        this.addInput("data", "array");\r\n        this.addInput("mark", "number");\r\n        this.size = [300, 200];\r\n        this._last_buffer = null;\r\n    }\r\n\r\n    LGAudioVisualization.prototype.onExecute = function() {\r\n        this._last_buffer = this.getInputData(0);\r\n        var v = this.getInputData(1);\r\n        if (v !== undefined) {\r\n            this.properties.mark = v;\r\n        }\r\n        this.setDirtyCanvas(true, false);\r\n    };\r\n\r\n    LGAudioVisualization.prototype.onDrawForeground = function(ctx) {\r\n        if (!this._last_buffer) {\r\n            return;\r\n        }\r\n\r\n        var buffer = this._last_buffer;\r\n\r\n        //delta represents how many samples we advance per pixel\r\n        var delta = buffer.length / this.size[0];\r\n        var h = this.size[1];\r\n\r\n        ctx.fillStyle = "black";\r\n        ctx.fillRect(0, 0, this.size[0], this.size[1]);\r\n        ctx.strokeStyle = "white";\r\n        ctx.beginPath();\r\n        var x = 0;\r\n\r\n        if (this.properties.continuous) {\r\n            ctx.moveTo(x, h);\r\n            for (var i = 0; i < buffer.length; i += delta) {\r\n                ctx.lineTo(x, h - (buffer[i | 0] / 255) * h);\r\n                x++;\r\n            }\r\n        } else {\r\n            for (var i = 0; i < buffer.length; i += delta) {\r\n                ctx.moveTo(x + 0.5, h);\r\n                ctx.lineTo(x + 0.5, h - (buffer[i | 0] / 255) * h);\r\n                x++;\r\n            }\r\n        }\r\n        ctx.stroke();\r\n\r\n        if (this.properties.mark >= 0) {\r\n            var samplerate = LGAudio.getAudioContext().sampleRate;\r\n            var binfreq = samplerate / buffer.length;\r\n            var x = (2 * (this.properties.mark / binfreq)) / delta;\r\n            if (x >= this.size[0]) {\r\n                x = this.size[0] - 1;\r\n            }\r\n            ctx.strokeStyle = "red";\r\n            ctx.beginPath();\r\n            ctx.moveTo(x, h);\r\n            ctx.lineTo(x, 0);\r\n            ctx.stroke();\r\n        }\r\n    };\r\n\r\n    LGAudioVisualization.title = "Visualization";\r\n    LGAudioVisualization.desc = "Audio Visualization";\r\n    LiteGraph.registerNodeType("audio/visualization", LGAudioVisualization);\r\n\r\n    function LGAudioBandSignal() {\r\n        //default\r\n        this.properties = {\r\n            band: 440,\r\n            amplitude: 1\r\n        };\r\n\r\n        this.addInput("freqs", "array");\r\n        this.addOutput("signal", "number");\r\n    }\r\n\r\n    LGAudioBandSignal.prototype.onExecute = function() {\r\n        this._freqs = this.getInputData(0);\r\n        if (!this._freqs) {\r\n            return;\r\n        }\r\n\r\n        var band = this.properties.band;\r\n        var v = this.getInputData(1);\r\n        if (v !== undefined) {\r\n            band = v;\r\n        }\r\n\r\n        var samplerate = LGAudio.getAudioContext().sampleRate;\r\n        var binfreq = samplerate / this._freqs.length;\r\n        var index = 2 * (band / binfreq);\r\n        var v = 0;\r\n        if (index < 0) {\r\n            v = this._freqs[0];\r\n        }\r\n        if (index >= this._freqs.length) {\r\n            v = this._freqs[this._freqs.length - 1];\r\n        } else {\r\n            var pos = index | 0;\r\n            var v0 = this._freqs[pos];\r\n            var v1 = this._freqs[pos + 1];\r\n            var f = index - pos;\r\n            v = v0 * (1 - f) + v1 * f;\r\n        }\r\n\r\n        this.setOutputData(0, (v / 255) * this.properties.amplitude);\r\n    };\r\n\r\n    LGAudioBandSignal.prototype.onGetInputs = function() {\r\n        return [["band", "number"]];\r\n    };\r\n\r\n    LGAudioBandSignal.title = "Signal";\r\n    LGAudioBandSignal.desc = "extract the signal of some frequency";\r\n    LiteGraph.registerNodeType("audio/signal", LGAudioBandSignal);\r\n\r\n    function LGAudioScript() {\r\n        if (!LGAudioScript.default_code) {\r\n            var code = LGAudioScript.default_function.toString();\r\n            var index = code.indexOf("{") + 1;\r\n            var index2 = code.lastIndexOf("}");\r\n            LGAudioScript.default_code = code.substr(index, index2 - index);\r\n        }\r\n\r\n        //default\r\n        this.properties = {\r\n            code: LGAudioScript.default_code\r\n        };\r\n\r\n        //create node\r\n        var ctx = LGAudio.getAudioContext();\r\n        if (ctx.createScriptProcessor) {\r\n            this.audionode = ctx.createScriptProcessor(4096, 1, 1);\r\n        }\r\n        //buffer size, input channels, output channels\r\n        else {\r\n            console.warn("ScriptProcessorNode deprecated");\r\n            this.audionode = ctx.createGain(); //bypass audio\r\n        }\r\n\r\n        this.processCode();\r\n        if (!LGAudioScript._bypass_function) {\r\n            LGAudioScript._bypass_function = this.audionode.onaudioprocess;\r\n        }\r\n\r\n        //slots\r\n        this.addInput("in", "audio");\r\n        this.addOutput("out", "audio");\r\n    }\r\n\r\n    LGAudioScript.prototype.onAdded = function(graph) {\r\n        if (graph.status == LGraph.STATUS_RUNNING) {\r\n            this.audionode.onaudioprocess = this._callback;\r\n        }\r\n    };\r\n\r\n    LGAudioScript["@code"] = { widget: "code", type: "code" };\r\n\r\n    LGAudioScript.prototype.onStart = function() {\r\n        this.audionode.onaudioprocess = this._callback;\r\n    };\r\n\r\n    LGAudioScript.prototype.onStop = function() {\r\n        this.audionode.onaudioprocess = LGAudioScript._bypass_function;\r\n    };\r\n\r\n    LGAudioScript.prototype.onPause = function() {\r\n        this.audionode.onaudioprocess = LGAudioScript._bypass_function;\r\n    };\r\n\r\n    LGAudioScript.prototype.onUnpause = function() {\r\n        this.audionode.onaudioprocess = this._callback;\r\n    };\r\n\r\n    LGAudioScript.prototype.onExecute = function() {\r\n        //nothing! because we need an onExecute to receive onStart... fix that\r\n    };\r\n\r\n    LGAudioScript.prototype.onRemoved = function() {\r\n        this.audionode.onaudioprocess = LGAudioScript._bypass_function;\r\n    };\r\n\r\n    LGAudioScript.prototype.processCode = function() {\r\n        try {\r\n            var func = new Function("properties", this.properties.code);\r\n            this._script = new func(this.properties);\r\n            this._old_code = this.properties.code;\r\n            this._callback = this._script.onaudioprocess;\r\n        } catch (err) {\r\n            console.error("Error in onaudioprocess code", err);\r\n            this._callback = LGAudioScript._bypass_function;\r\n            this.audionode.onaudioprocess = this._callback;\r\n        }\r\n    };\r\n\r\n    LGAudioScript.prototype.onPropertyChanged = function(name, value) {\r\n        if (name == "code") {\r\n            this.properties.code = value;\r\n            this.processCode();\r\n            if (this.graph && this.graph.status == LGraph.STATUS_RUNNING) {\r\n                this.audionode.onaudioprocess = this._callback;\r\n            }\r\n        }\r\n    };\r\n\r\n    LGAudioScript.default_function = function() {\r\n        this.onaudioprocess = function(audioProcessingEvent) {\r\n            // The input buffer is the song we loaded earlier\r\n            var inputBuffer = audioProcessingEvent.inputBuffer;\r\n\r\n            // The output buffer contains the samples that will be modified and played\r\n            var outputBuffer = audioProcessingEvent.outputBuffer;\r\n\r\n            // Loop through the output channels (in this case there is only one)\r\n            for (\r\n                var channel = 0;\r\n                channel < outputBuffer.numberOfChannels;\r\n                channel++\r\n            ) {\r\n                var inputData = inputBuffer.getChannelData(channel);\r\n                var outputData = outputBuffer.getChannelData(channel);\r\n\r\n                // Loop through the 4096 samples\r\n                for (var sample = 0; sample < inputBuffer.length; sample++) {\r\n                    // make output equal to the same as the input\r\n                    outputData[sample] = inputData[sample];\r\n                }\r\n            }\r\n        };\r\n    };\r\n\r\n    LGAudio.createAudioNodeWrapper(LGAudioScript);\r\n\r\n    LGAudioScript.title = "Script";\r\n    LGAudioScript.desc = "apply script to signal";\r\n    LiteGraph.registerNodeType("audio/script", LGAudioScript);\r\n\r\n    function LGAudioDestination() {\r\n        this.audionode = LGAudio.getAudioContext().destination;\r\n        this.addInput("in", "audio");\r\n    }\r\n\r\n    LGAudioDestination.title = "Destination";\r\n    LGAudioDestination.desc = "Audio output";\r\n    LiteGraph.registerNodeType("audio/destination", LGAudioDestination);\r\n})(this);\r\n\n//event related nodes\r\n(function(global) {\r\n    var LiteGraph = global.LiteGraph;\r\n\r\n    function LGWebSocket() {\r\n        this.size = [60, 20];\r\n        this.addInput("send", LiteGraph.ACTION);\r\n        this.addOutput("received", LiteGraph.EVENT);\r\n        this.addInput("in", 0);\r\n        this.addOutput("out", 0);\r\n        this.properties = {\r\n            url: "",\r\n            room: "lgraph", //allows to filter messages,\r\n            only_send_changes: true\r\n        };\r\n        this._ws = null;\r\n        this._last_sent_data = [];\r\n        this._last_received_data = [];\r\n    }\r\n\r\n    LGWebSocket.title = "WebSocket";\r\n    LGWebSocket.desc = "Send data through a websocket";\r\n\r\n    LGWebSocket.prototype.onPropertyChanged = function(name, value) {\r\n        if (name == "url") {\r\n            this.connectSocket();\r\n        }\r\n    };\r\n\r\n    LGWebSocket.prototype.onExecute = function() {\r\n        if (!this._ws && this.properties.url) {\r\n            this.connectSocket();\r\n        }\r\n\r\n        if (!this._ws || this._ws.readyState != WebSocket.OPEN) {\r\n            return;\r\n        }\r\n\r\n        var room = this.properties.room;\r\n        var only_changes = this.properties.only_send_changes;\r\n\r\n        for (var i = 1; i < this.inputs.length; ++i) {\r\n            var data = this.getInputData(i);\r\n            if (data == null) {\r\n                continue;\r\n            }\r\n            var json;\r\n            try {\r\n                json = JSON.stringify({\r\n                    type: 0,\r\n                    room: room,\r\n                    channel: i,\r\n                    data: data\r\n                });\r\n            } catch (err) {\r\n                continue;\r\n            }\r\n            if (only_changes && this._last_sent_data[i] == json) {\r\n                continue;\r\n            }\r\n\r\n            this._last_sent_data[i] = json;\r\n            this._ws.send(json);\r\n        }\r\n\r\n        for (var i = 1; i < this.outputs.length; ++i) {\r\n            this.setOutputData(i, this._last_received_data[i]);\r\n        }\r\n\r\n        if (this.boxcolor == "#AFA") {\r\n            this.boxcolor = "#6C6";\r\n        }\r\n    };\r\n\r\n    LGWebSocket.prototype.connectSocket = function() {\r\n        var that = this;\r\n        var url = this.properties.url;\r\n        if (url.substr(0, 2) != "ws") {\r\n            url = "ws://" + url;\r\n        }\r\n        this._ws = new WebSocket(url);\r\n        this._ws.onopen = function() {\r\n            console.log("ready");\r\n            that.boxcolor = "#6C6";\r\n        };\r\n        this._ws.onmessage = function(e) {\r\n            that.boxcolor = "#AFA";\r\n            var data = JSON.parse(e.data);\r\n            if (data.room && data.room != that.properties.room) {\r\n                return;\r\n            }\r\n            if (data.type == 1) {\r\n                if (\r\n                    data.data.object_class &&\r\n                    LiteGraph[data.data.object_class]\r\n                ) {\r\n                    var obj = null;\r\n                    try {\r\n                        obj = new LiteGraph[data.data.object_class](data.data);\r\n                        that.triggerSlot(0, obj);\r\n                    } catch (err) {\r\n                        return;\r\n                    }\r\n                } else {\r\n                    that.triggerSlot(0, data.data);\r\n                }\r\n            } else {\r\n                that._last_received_data[data.channel || 0] = data.data;\r\n            }\r\n        };\r\n        this._ws.onerror = function(e) {\r\n            console.log("couldnt connect to websocket");\r\n            that.boxcolor = "#E88";\r\n        };\r\n        this._ws.onclose = function(e) {\r\n            console.log("connection closed");\r\n            that.boxcolor = "#000";\r\n        };\r\n    };\r\n\r\n    LGWebSocket.prototype.send = function(data) {\r\n        if (!this._ws || this._ws.readyState != WebSocket.OPEN) {\r\n            return;\r\n        }\r\n        this._ws.send(JSON.stringify({ type: 1, msg: data }));\r\n    };\r\n\r\n    LGWebSocket.prototype.onAction = function(action, param) {\r\n        if (!this._ws || this._ws.readyState != WebSocket.OPEN) {\r\n            return;\r\n        }\r\n        this._ws.send({\r\n            type: 1,\r\n            room: this.properties.room,\r\n            action: action,\r\n            data: param\r\n        });\r\n    };\r\n\r\n    LGWebSocket.prototype.onGetInputs = function() {\r\n        return [["in", 0]];\r\n    };\r\n\r\n    LGWebSocket.prototype.onGetOutputs = function() {\r\n        return [["out", 0]];\r\n    };\r\n\r\n    LiteGraph.registerNodeType("network/websocket", LGWebSocket);\r\n\r\n    //It is like a websocket but using the SillyServer.js server that bounces packets back to all clients connected:\r\n    //For more information: https://github.com/jagenjo/SillyServer.js\r\n\r\n    function LGSillyClient() {\r\n        //this.size = [60,20];\r\n        this.room_widget = this.addWidget(\r\n            "text",\r\n            "Room",\r\n            "lgraph",\r\n            this.setRoom.bind(this)\r\n        );\r\n        this.addWidget(\r\n            "button",\r\n            "Reconnect",\r\n            null,\r\n            this.connectSocket.bind(this)\r\n        );\r\n\r\n        this.addInput("send", LiteGraph.ACTION);\r\n        this.addOutput("received", LiteGraph.EVENT);\r\n        this.addInput("in", 0);\r\n        this.addOutput("out", 0);\r\n        this.properties = {\r\n            url: "tamats.com:55000",\r\n            room: "lgraph",\r\n            only_send_changes: true\r\n        };\r\n\r\n        this._server = null;\r\n        this.connectSocket();\r\n        this._last_sent_data = [];\r\n        this._last_received_data = [];\r\n\r\n\t\tif(typeof(SillyClient) == "undefined")\r\n\t\t\tconsole.warn("remember to add SillyClient.js to your project: https://tamats.com/projects/sillyserver/src/sillyclient.js");\r\n    }\r\n\r\n    LGSillyClient.title = "SillyClient";\r\n    LGSillyClient.desc = "Connects to SillyServer to broadcast messages";\r\n\r\n    LGSillyClient.prototype.onPropertyChanged = function(name, value) {\r\n        if (name == "room") {\r\n            this.room_widget.value = value;\r\n        }\r\n        this.connectSocket();\r\n    };\r\n\r\n    LGSillyClient.prototype.setRoom = function(room_name) {\r\n        this.properties.room = room_name;\r\n        this.room_widget.value = room_name;\r\n        this.connectSocket();\r\n    };\r\n\r\n    //force label names\r\n    LGSillyClient.prototype.onDrawForeground = function() {\r\n        for (var i = 1; i < this.inputs.length; ++i) {\r\n            var slot = this.inputs[i];\r\n            slot.label = "in_" + i;\r\n        }\r\n        for (var i = 1; i < this.outputs.length; ++i) {\r\n            var slot = this.outputs[i];\r\n            slot.label = "out_" + i;\r\n        }\r\n    };\r\n\r\n    LGSillyClient.prototype.onExecute = function() {\r\n        if (!this._server || !this._server.is_connected) {\r\n            return;\r\n        }\r\n\r\n        var only_send_changes = this.properties.only_send_changes;\r\n\r\n        for (var i = 1; i < this.inputs.length; ++i) {\r\n            var data = this.getInputData(i);\r\n\t\t\tvar prev_data = this._last_sent_data[i];\r\n            if (data != null) {\r\n                if (only_send_changes)\r\n\t\t\t\t{\t\r\n\t\t\t\t\tvar is_equal = true;\r\n\t\t\t\t\tif( data && data.length && prev_data && prev_data.length == data.length && data.constructor !== String)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor(var j = 0; j < data.length; ++j)\r\n\t\t\t\t\t\t\tif( prev_data[j] != data[j] )\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tis_equal = false;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if(this._last_sent_data[i] != data)\r\n\t\t\t\t\t\tis_equal = false;\r\n\t\t\t\t\tif(is_equal)\r\n\t\t\t\t\t\t\tcontinue;\r\n                }\r\n                this._server.sendMessage({ type: 0, channel: i, data: data });\r\n\t\t\t\tif( data.length && data.constructor !== String )\r\n\t\t\t\t{\r\n\t\t\t\t\tif( this._last_sent_data[i] )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis._last_sent_data[i].length = data.length;\r\n\t\t\t\t\t\tfor(var j = 0; j < data.length; ++j)\r\n\t\t\t\t\t\t\tthis._last_sent_data[i][j] = data[j];\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse //create\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(data.constructor === Array)\r\n\t\t\t\t\t\t\tthis._last_sent_data[i] = data.concat();\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tthis._last_sent_data[i] = new data.constructor( data );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t                this._last_sent_data[i] = data; //should be cloned\r\n            }\r\n        }\r\n\r\n        for (var i = 1; i < this.outputs.length; ++i) {\r\n            this.setOutputData(i, this._last_received_data[i]);\r\n        }\r\n\r\n        if (this.boxcolor == "#AFA") {\r\n            this.boxcolor = "#6C6";\r\n        }\r\n    };\r\n\r\n    LGSillyClient.prototype.connectSocket = function() {\r\n        var that = this;\r\n        if (typeof SillyClient == "undefined") {\r\n            if (!this._error) {\r\n                console.error(\r\n                    "SillyClient node cannot be used, you must include SillyServer.js"\r\n                );\r\n            }\r\n            this._error = true;\r\n            return;\r\n        }\r\n\r\n        this._server = new SillyClient();\r\n        this._server.on_ready = function() {\r\n            console.log("ready");\r\n            that.boxcolor = "#6C6";\r\n        };\r\n        this._server.on_message = function(id, msg) {\r\n            var data = null;\r\n            try {\r\n                data = JSON.parse(msg);\r\n            } catch (err) {\r\n                return;\r\n            }\r\n\r\n            if (data.type == 1) {\r\n                //EVENT slot\r\n                if (\r\n                    data.data.object_class &&\r\n                    LiteGraph[data.data.object_class]\r\n                ) {\r\n                    var obj = null;\r\n                    try {\r\n                        obj = new LiteGraph[data.data.object_class](data.data);\r\n                        that.triggerSlot(0, obj);\r\n                    } catch (err) {\r\n                        return;\r\n                    }\r\n                } else {\r\n                    that.triggerSlot(0, data.data);\r\n                }\r\n            } //for FLOW slots\r\n            else {\r\n                that._last_received_data[data.channel || 0] = data.data;\r\n            }\r\n            that.boxcolor = "#AFA";\r\n        };\r\n        this._server.on_error = function(e) {\r\n            console.log("couldnt connect to websocket");\r\n            that.boxcolor = "#E88";\r\n        };\r\n        this._server.on_close = function(e) {\r\n            console.log("connection closed");\r\n            that.boxcolor = "#000";\r\n        };\r\n\r\n        if (this.properties.url && this.properties.room) {\r\n            try {\r\n                this._server.connect(this.properties.url, this.properties.room);\r\n            } catch (err) {\r\n                console.error("SillyServer error: " + err);\r\n                this._server = null;\r\n                return;\r\n            }\r\n            this._final_url = this.properties.url + "/" + this.properties.room;\r\n        }\r\n    };\r\n\r\n    LGSillyClient.prototype.send = function(data) {\r\n        if (!this._server || !this._server.is_connected) {\r\n            return;\r\n        }\r\n        this._server.sendMessage({ type: 1, data: data });\r\n    };\r\n\r\n    LGSillyClient.prototype.onAction = function(action, param) {\r\n        if (!this._server || !this._server.is_connected) {\r\n            return;\r\n        }\r\n        this._server.sendMessage({ type: 1, action: action, data: param });\r\n    };\r\n\r\n    LGSillyClient.prototype.onGetInputs = function() {\r\n        return [["in", 0]];\r\n    };\r\n\r\n    LGSillyClient.prototype.onGetOutputs = function() {\r\n        return [["out", 0]];\r\n    };\r\n\r\n    LiteGraph.registerNodeType("network/sillyclient", LGSillyClient);\r\n\r\n//HTTP Request\r\nfunction HTTPRequestNode() {\r\n\tvar that = this;\r\n\tthis.addInput("request", LiteGraph.ACTION);\r\n\tthis.addInput("url", "string");\r\n\tthis.addProperty("url", "");\r\n\tthis.addOutput("ready", LiteGraph.EVENT);\r\n    this.addOutput("data", "string");\r\n\tthis.addWidget("button", "Fetch", null, this.fetch.bind(this));\r\n\tthis._data = null;\r\n\tthis._fetching = null;\r\n}\r\n\r\nHTTPRequestNode.title = "HTTP Request";\r\nHTTPRequestNode.desc = "Fetch data through HTTP";\r\n\r\nHTTPRequestNode.prototype.fetch = function()\r\n{\r\n\tvar url = this.properties.url;\r\n\tif(!url)\r\n\t\treturn;\r\n\r\n\tthis.boxcolor = "#FF0";\r\n\tvar that = this;\r\n\tthis._fetching = fetch(url)\r\n\t.then(resp=>{\r\n\t\tif(!resp.ok)\r\n\t\t{\r\n\t\t\tthis.boxcolor = "#F00";\r\n\t\t\tthat.trigger("error");\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.boxcolor = "#0F0";\r\n\t\t\treturn resp.text();\r\n\t\t}\r\n\t})\r\n\t.then(data=>{\r\n\t\tthat._data = data;\r\n\t\tthat._fetching = null;\r\n\t\tthat.trigger("ready");\r\n\t});\r\n}\r\n\r\nHTTPRequestNode.prototype.onAction = function(evt)\r\n{\r\n\tif(evt == "request")\r\n\t\tthis.fetch();\r\n}\r\n\r\nHTTPRequestNode.prototype.onExecute = function() {\r\n\tthis.setOutputData(1, this._data);\r\n};\r\n\r\nHTTPRequestNode.prototype.onGetOutputs = function() {\r\n\treturn [["error",LiteGraph.EVENT]];\r\n}\r\n\r\nLiteGraph.registerNodeType("network/httprequest", HTTPRequestNode);\r\n\r\n\r\n\t\r\n})(this);\r\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQ2My5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLHdDQUF3QztBQUN4QyxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLE9BQU87QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakMsa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNB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QTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHVDQUF1Qzs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVB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QTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixHQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxtQ0FBbUM7QUFDbkM7QUFDQSwyQ0FBMkM7QUFDM0MsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUIsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw2QkFBNkI7QUFDN0IsbUNBQW1DO0FBQ25DLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLG1DQUFtQztBQUNuQyxpQ0FBaUM7QUFDakMsMkJBQTJCO0FBQzNCLGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFDbEMsOEJBQThCO0FBQzlCLDZCQUE2Qjs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrRUFBK0U7QUFDL0U7O0FBRUEsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxzRUFBc0U7O0FBRXRFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGtCQUFrQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esc0VBQXNFLE9BQU87QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFFQUFxRSxPQUFPO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsMEJBQTBCO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNC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QUNwRCwrQkFBK0I7QUFDL0IsbUVBQW1FOztBQUVuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLG1CQUFtQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix1RUFBdUU7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdB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Q0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsaUNBQWlDO0FBQ2pDLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTyx3QkFBd0IsNENBQTRDO0FBQzFGLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFFBQVE7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRTs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGVBQWU7O0FBRWhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLE9BQU8sRUFBRSxNQUFNO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixPQUFPLEVBQUUsTUFBTTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsU0FBUztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLE9BQU87QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGlGQUFpRiwrQkFBK0I7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQiwyQkFBMkI7QUFDM0I7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FB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QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxtQkFBbUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0Q7QUFDQSw4Q0FBOEMsZUFBZTtBQUM3RCxTQUFTO0FBQ1Q7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSx5QkFBeUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQixFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSSwwQ0FBMEM7QUFDakQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBb0Q7QUFDOUQsVUFBVSxtREFBbUQ7QUFDN0QsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLGdEQUFnRDs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RCwwQ0FBMEMsY0FBYztBQUN4RCw4Q0FBOEMsY0FBYzs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsR0FBRztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25ELDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7O0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQ0FBZ0M7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUNBQWlDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQ0FBa0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLDRDQUE0Qzs7QUFFM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9EQUFvRDtBQUM5RCxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0RBQXNEO0FBQ2hFLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnREFBZ0Q7QUFDMUQsVUFBVSxnREFBZ0Q7QUFDMUQsVUFBVSxrREFBa0Q7QUFDNUQsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUNBLHdHQUF3RztBQUN4RztBQUNBLGdJQUFnSTtBQUNoSSxvRUFBb0UsT0FBTztBQUMzRSxvR0FBb0csTUFBTTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsdUJBQXVCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQixFQUFFLFNBQVM7QUFDWCxFQUFFLFVBQVU7QUFDWixFQUFFLFdBQVc7QUFDYixFQUFFLGNBQWM7QUFDaEIsYUFBYTtBQUNiLGtCQUFrQjtBQUNsQiwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCLEVBQUUsU0FBUztBQUNYLHlCQUF5QjtBQUN6QixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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dEUscUNBQXFDLGtDQUFrQztBQUN2RSxxQ0FBcUMsa0NBQWtDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0tBQWdLO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDBCQUEwQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0IsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFEO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0JBQXdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQztBQUNBLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsZUFBZSw0REFBNEQ7QUFDM0UsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVJQUF1SSxnQkFBZ0I7QUFDdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0EsaUNBQWlDO0FBQ2pDLGlEQUFpRDtBQUNqRCwyREFBMkQ7QUFDM0QsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDhCQUE4QjtBQUM5QixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3Q0FBd0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx1RUFBdUUsMERBQTBEO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUNBQXlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLCtCQUErQjtBQUN6QyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLCtCQUErQjtBQUN6QyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLCtCQUErQjtBQUN6QyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLCtCQUErQjtBQUN6QyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLCtCQUErQjtBQUN6QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDViw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtB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Q0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl0ZWdyYXBoLWVkaXRvci8uL25vZGVfbW9kdWxlcy9saXRlZ3JhcGguanMvYnVpbGQvbGl0ZWdyYXBoLmpzPzZlMTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy9wYWNrZXIgdmVyc2lvblxuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gICBMaXRlR3JhcGggQ0xBU1MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKioqKioqKlxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIC8qKlxuICAgICAqIFRoZSBHbG9iYWwgU2NvcGUuIEl0IGNvbnRhaW5zIGFsbCB0aGUgcmVnaXN0ZXJlZCBub2RlIGNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgTGl0ZUdyYXBoXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG5cbiAgICB2YXIgTGl0ZUdyYXBoID0gKGdsb2JhbC5MaXRlR3JhcGggPSB7XG4gICAgICAgIFZFUlNJT046IDAuNCxcblxuICAgICAgICBDQU5WQVNfR1JJRF9TSVpFOiAxMCxcblxuICAgICAgICBOT0RFX1RJVExFX0hFSUdIVDogMzAsXG4gICAgICAgIE5PREVfVElUTEVfVEVYVF9ZOiAyMCxcbiAgICAgICAgTk9ERV9TTE9UX0hFSUdIVDogMjAsXG4gICAgICAgIE5PREVfV0lER0VUX0hFSUdIVDogMjAsXG4gICAgICAgIE5PREVfV0lEVEg6IDE0MCxcbiAgICAgICAgTk9ERV9NSU5fV0lEVEg6IDUwLFxuICAgICAgICBOT0RFX0NPTExBUFNFRF9SQURJVVM6IDEwLFxuICAgICAgICBOT0RFX0NPTExBUFNFRF9XSURUSDogODAsXG4gICAgICAgIE5PREVfVElUTEVfQ09MT1I6IFwiIzk5OVwiLFxuICAgICAgICBOT0RFX1NFTEVDVEVEX1RJVExFX0NPTE9SOiBcIiNGRkZcIixcbiAgICAgICAgTk9ERV9URVhUX1NJWkU6IDE0LFxuICAgICAgICBOT0RFX1RFWFRfQ09MT1I6IFwiI0FBQVwiLFxuICAgICAgICBOT0RFX1NVQlRFWFRfU0laRTogMTIsXG4gICAgICAgIE5PREVfREVGQVVMVF9DT0xPUjogXCIjMzMzXCIsXG4gICAgICAgIE5PREVfREVGQVVMVF9CR0NPTE9SOiBcIiMzNTM1MzVcIixcbiAgICAgICAgTk9ERV9ERUZBVUxUX0JPWENPTE9SOiBcIiM2NjZcIixcbiAgICAgICAgTk9ERV9ERUZBVUxUX1NIQVBFOiBcImJveFwiLFxuICAgICAgICBOT0RFX0JPWF9PVVRMSU5FX0NPTE9SOiBcIiNGRkZcIixcbiAgICAgICAgREVGQVVMVF9TSEFET1dfQ09MT1I6IFwicmdiYSgwLDAsMCwwLjUpXCIsXG4gICAgICAgIERFRkFVTFRfR1JPVVBfRk9OVDogMjQsXG5cbiAgICAgICAgV0lER0VUX0JHQ09MT1I6IFwiIzIyMlwiLFxuICAgICAgICBXSURHRVRfT1VUTElORV9DT0xPUjogXCIjNjY2XCIsXG4gICAgICAgIFdJREdFVF9URVhUX0NPTE9SOiBcIiNERERcIixcbiAgICAgICAgV0lER0VUX1NFQ09OREFSWV9URVhUX0NPTE9SOiBcIiM5OTlcIixcblxuICAgICAgICBMSU5LX0NPTE9SOiBcIiM5QTlcIixcbiAgICAgICAgRVZFTlRfTElOS19DT0xPUjogXCIjQTg2XCIsXG4gICAgICAgIENPTk5FQ1RJTkdfTElOS19DT0xPUjogXCIjQUZBXCIsXG5cbiAgICAgICAgTUFYX05VTUJFUl9PRl9OT0RFUzogMTAwMCwgLy9hdm9pZCBpbmZpbml0ZSBsb29wc1xuICAgICAgICBERUZBVUxUX1BPU0lUSU9OOiBbMTAwLCAxMDBdLCAvL2RlZmF1bHQgbm9kZSBwb3NpdGlvblxuICAgICAgICBWQUxJRF9TSEFQRVM6IFtcImRlZmF1bHRcIiwgXCJib3hcIiwgXCJyb3VuZFwiLCBcImNhcmRcIl0sIC8vLFwiY2lyY2xlXCJcblxuICAgICAgICAvL3NoYXBlcyBhcmUgdXNlZCBmb3Igbm9kZXMgYnV0IGFsc28gZm9yIHNsb3RzXG4gICAgICAgIEJPWF9TSEFQRTogMSxcbiAgICAgICAgUk9VTkRfU0hBUEU6IDIsXG4gICAgICAgIENJUkNMRV9TSEFQRTogMyxcbiAgICAgICAgQ0FSRF9TSEFQRTogNCxcbiAgICAgICAgQVJST1dfU0hBUEU6IDUsXG4gICAgICAgIEdSSURfU0hBUEU6IDYsIC8vIGludGVuZGVkIGZvciBzbG90IGFycmF5c1xuXG4gICAgICAgIC8vZW51bXNcbiAgICAgICAgSU5QVVQ6IDEsXG4gICAgICAgIE9VVFBVVDogMixcblxuICAgICAgICBFVkVOVDogLTEsIC8vZm9yIG91dHB1dHNcbiAgICAgICAgQUNUSU9OOiAtMSwgLy9mb3IgaW5wdXRzXG5cbiAgICAgICAgTk9ERV9NT0RFUzogW1wiQWx3YXlzXCIsIFwiT24gRXZlbnRcIiwgXCJOZXZlclwiLCBcIk9uIFRyaWdnZXJcIl0sIC8vIGhlbHBlciwgd2lsbCBhZGQgXCJPbiBSZXF1ZXN0XCIgYW5kIG1vcmUgaW4gdGhlIGZ1dHVyZVxuICAgICAgICBOT0RFX01PREVTX0NPTE9SUzpbXCIjNjY2XCIsXCIjNDIyXCIsXCIjMzMzXCIsXCIjMjI0XCIsXCIjNjI2XCJdLCAvLyB1c2Ugd2l0aCBub2RlX2JveF9jb2xvdXJlZF9ieV9tb2RlXG4gICAgICAgIEFMV0FZUzogMCxcbiAgICAgICAgT05fRVZFTlQ6IDEsXG4gICAgICAgIE5FVkVSOiAyLFxuICAgICAgICBPTl9UUklHR0VSOiAzLFxuXG4gICAgICAgIFVQOiAxLFxuICAgICAgICBET1dOOiAyLFxuICAgICAgICBMRUZUOiAzLFxuICAgICAgICBSSUdIVDogNCxcbiAgICAgICAgQ0VOVEVSOiA1LFxuXG4gICAgICAgIExJTktfUkVOREVSX01PREVTOiBbXCJTdHJhaWdodFwiLCBcIkxpbmVhclwiLCBcIlNwbGluZVwiXSwgLy8gaGVscGVyXG4gICAgICAgIFNUUkFJR0hUX0xJTks6IDAsXG4gICAgICAgIExJTkVBUl9MSU5LOiAxLFxuICAgICAgICBTUExJTkVfTElOSzogMixcblxuICAgICAgICBOT1JNQUxfVElUTEU6IDAsXG4gICAgICAgIE5PX1RJVExFOiAxLFxuICAgICAgICBUUkFOU1BBUkVOVF9USVRMRTogMixcbiAgICAgICAgQVVUT0hJREVfVElUTEU6IDMsXG4gICAgICAgIFZFUlRJQ0FMX0xBWU9VVDogXCJ2ZXJ0aWNhbFwiLCAvLyBhcnJhbmdlIG5vZGVzIHZlcnRpY2FsbHlcblxuICAgICAgICBwcm94eTogbnVsbCwgLy91c2VkIHRvIHJlZGlyZWN0IGNhbGxzXG4gICAgICAgIG5vZGVfaW1hZ2VzX3BhdGg6IFwiXCIsXG5cbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICBjYXRjaF9leGNlcHRpb25zOiB0cnVlLFxuICAgICAgICB0aHJvd19lcnJvcnM6IHRydWUsXG4gICAgICAgIGFsbG93X3NjcmlwdHM6IGZhbHNlLCAvL2lmIHNldCB0byB0cnVlIHNvbWUgbm9kZXMgbGlrZSBGb3JtdWxhIHdvdWxkIGJlIGFsbG93ZWQgdG8gZXZhbHVhdGUgY29kZSB0aGF0IGNvbWVzIGZyb20gdW5zYWZlIHNvdXJjZXMgKGxpa2Ugbm9kZSBjb25maWd1cmF0aW9uKSwgd2hpY2ggY291bGQgbGVhZCB0byBleHBsb2l0c1xuICAgICAgICB1c2VfZGVmZXJyZWRfYWN0aW9uczogdHJ1ZSwgLy9leGVjdXRlcyBhY3Rpb25zIGR1cmluZyB0aGUgZ3JhcGggZXhlY3V0aW9uIGZsb3dcbiAgICAgICAgcmVnaXN0ZXJlZF9ub2RlX3R5cGVzOiB7fSwgLy9ub2RldHlwZXMgYnkgc3RyaW5nXG4gICAgICAgIG5vZGVfdHlwZXNfYnlfZmlsZV9leHRlbnNpb246IHt9LCAvL3VzZWQgZm9yIGRyb3BwaW5nIGZpbGVzIGluIHRoZSBjYW52YXNcbiAgICAgICAgTm9kZXM6IHt9LCAvL25vZGUgdHlwZXMgYnkgY2xhc3NuYW1lXG5cdFx0R2xvYmFsczoge30sIC8vdXNlZCB0byBzdG9yZSB2YXJzIGJldHdlZW4gZ3JhcGhzXG5cbiAgICAgICAgc2VhcmNoYm94X2V4dHJhczoge30sIC8vdXNlZCB0byBhZGQgZXh0cmEgZmVhdHVyZXMgdG8gdGhlIHNlYXJjaCBib3hcbiAgICAgICAgYXV0b19zb3J0X25vZGVfdHlwZXM6IGZhbHNlLCAvLyBbdHJ1ZSFdIElmIHNldCB0byB0cnVlLCB3aWxsIGF1dG9tYXRpY2FsbHkgc29ydCBub2RlIHR5cGVzIC8gY2F0ZWdvcmllcyBpbiB0aGUgY29udGV4dCBtZW51c1xuXHRcdFxuXHRcdG5vZGVfYm94X2NvbG91cmVkX3doZW5fb246IGZhbHNlLCAvLyBbdHJ1ZSFdIHRoaXMgbWFrZSB0aGUgbm9kZXMgYm94ICh0b3AgbGVmdCBjaXJjbGUpIGNvbG91cmVkIHdoZW4gdHJpZ2dlcmVkIChleGVjdXRlL2FjdGlvbiksIHZpc3VhbCBmZWVkYmFja1xuICAgICAgICBub2RlX2JveF9jb2xvdXJlZF9ieV9tb2RlOiBmYWxzZSwgLy8gW3RydWUhXSBub2RlYm94IGJhc2VkIG9uIG5vZGUgbW9kZSwgdmlzdWFsIGZlZWRiYWNrXG4gICAgICAgIFxuICAgICAgICBkaWFsb2dfY2xvc2Vfb25fbW91c2VfbGVhdmU6IHRydWUsIC8vIFtmYWxzZSBvbiBtb2JpbGVdIGJldHRlciB0cnVlIGlmIG5vdCB0b3VjaCBkZXZpY2UsIFRPRE8gYWRkIGFuIGhlbHBlci9saXN0ZW5lciB0byBjbG9zZSBpZiBmYWxzZVxuICAgICAgICBkaWFsb2dfY2xvc2Vfb25fbW91c2VfbGVhdmVfZGVsYXk6IDUwMCxcbiAgICAgICAgXG4gICAgICAgIHNoaWZ0X2NsaWNrX2RvX2JyZWFrX2xpbmtfZnJvbTogZmFsc2UsIC8vIFtmYWxzZSFdIHByZWZlciBmYWxzZSBpZiByZXN1bHRzIHRvbyBlYXN5IHRvIGJyZWFrIGxpbmtzIC0gaW1wbGVtZW50IHdpdGggQUxUIG9yIFRPRE8gY3VzdG9tIGtleXNcbiAgICAgICAgY2xpY2tfZG9fYnJlYWtfbGlua190bzogZmFsc2UsIC8vIFtmYWxzZSFdcHJlZmVyIGZhbHNlLCB3YXkgdG9vIGVhc3kgdG8gYnJlYWsgbGlua3NcbiAgICAgICAgXG4gICAgICAgIHNlYXJjaF9oaWRlX29uX21vdXNlX2xlYXZlOiB0cnVlLCAvLyBbZmFsc2Ugb24gbW9iaWxlXSBiZXR0ZXIgdHJ1ZSBpZiBub3QgdG91Y2ggZGV2aWNlLCBUT0RPIGFkZCBhbiBoZWxwZXIvbGlzdGVuZXIgdG8gY2xvc2UgaWYgZmFsc2VcbiAgICAgICAgc2VhcmNoX2ZpbHRlcl9lbmFibGVkOiBmYWxzZSwgLy8gW3RydWUhXSBlbmFibGUgZmlsdGVyaW5nIHNsb3RzIHR5cGUgaW4gdGhlIHNlYXJjaCB3aWRnZXQsICFyZXF1aXJlcyBhdXRvX2xvYWRfc2xvdF90eXBlcyBvciBtYW51YWwgc2V0IHJlZ2lzdGVyZWRfc2xvdF9baW4vb3V0XV90eXBlcyBhbmQgc2xvdF90eXBlc19baW4vb3V0XVxuICAgICAgICBzZWFyY2hfc2hvd19hbGxfb25fb3BlbjogdHJ1ZSwgLy8gW3RydWUhXSBvcGVucyB0aGUgcmVzdWx0cyBsaXN0IHdoZW4gb3BlbmluZyB0aGUgc2VhcmNoIHdpZGdldFxuICAgICAgICBcbiAgICAgICAgYXV0b19sb2FkX3Nsb3RfdHlwZXM6IGZhbHNlLCAvLyBbaWYgd2FudCBmYWxzZSwgdXNlIHRydWUsIHJ1biwgZ2V0IHZhcnMgdmFsdWVzIHRvIGJlIHN0YXRpY2FsbHkgc2V0LCB0aGFuIGRpc2FibGVdIG5vZGVzIHR5cGVzIGFuZCBub2RlY2xhc3MgYXNzb2NpYXRpb24gd2l0aCBub2RlIHR5cGVzIG5lZWQgdG8gYmUgY2FsY3VsYXRlZCwgaWYgZG9udCB3YW50IHRoaXMsIGNhbGN1bGF0ZSBvbmNlIGFuZCBzZXQgcmVnaXN0ZXJlZF9zbG90X1tpbi9vdXRdX3R5cGVzIGFuZCBzbG90X3R5cGVzX1tpbi9vdXRdXG4gICAgICAgIFxuXHRcdC8vIHNldCB0aGVzZSB2YWx1ZXMgaWYgbm90IHVzaW5nIGF1dG9fbG9hZF9zbG90X3R5cGVzXG4gICAgICAgIHJlZ2lzdGVyZWRfc2xvdF9pbl90eXBlczoge30sIC8vIHNsb3QgdHlwZXMgZm9yIG5vZGVjbGFzc1xuICAgICAgICByZWdpc3RlcmVkX3Nsb3Rfb3V0X3R5cGVzOiB7fSwgLy8gc2xvdCB0eXBlcyBmb3Igbm9kZWNsYXNzXG4gICAgICAgIHNsb3RfdHlwZXNfaW46IFtdLCAvLyBzbG90IHR5cGVzIElOXG4gICAgICAgIHNsb3RfdHlwZXNfb3V0OiBbXSwgLy8gc2xvdCB0eXBlcyBPVVRcbiAgICAgICAgc2xvdF90eXBlc19kZWZhdWx0X2luOiBbXSwgLy8gc3BlY2lmeSBmb3IgZWFjaCBJTiBzbG90IHR5cGUgYSgvbWFueSkgZGVmYXVsdCBub2RlKHMpLCB1c2Ugc2luZ2xlIHN0cmluZywgYXJyYXksIG9yIG9iamVjdCAod2l0aCBub2RlLCB0aXRsZSwgcGFyYW1ldGVycywgLi4pIGxpa2UgZm9yIHNlYXJjaFxuXHRcdHNsb3RfdHlwZXNfZGVmYXVsdF9vdXQ6IFtdLCAvLyBzcGVjaWZ5IGZvciBlYWNoIE9VVCBzbG90IHR5cGUgYSgvbWFueSkgZGVmYXVsdCBub2RlKHMpLCB1c2Ugc2luZ2xlIHN0cmluZywgYXJyYXksIG9yIG9iamVjdCAod2l0aCBub2RlLCB0aXRsZSwgcGFyYW1ldGVycywgLi4pIGxpa2UgZm9yIHNlYXJjaFxuXHRcdFxuXHRcdGFsdF9kcmFnX2RvX2Nsb25lX25vZGVzOiBmYWxzZSwgLy8gW3RydWUhXSB2ZXJ5IGhhbmR5LCBBTFQgY2xpY2sgdG8gY2xvbmUgYW5kIGRyYWcgdGhlIG5ldyBub2RlXG5cblx0XHRkb19hZGRfdHJpZ2dlcnNfc2xvdHM6IGZhbHNlLCAvLyBbdHJ1ZSFdIHdpbGwgY3JlYXRlIGFuZCBjb25uZWN0IGV2ZW50IHNsb3RzIHdoZW4gdXNpbmcgYWN0aW9uL2V2ZW50cyBjb25uZWN0aW9ucywgIVdJTEwgQ0hBTkdFIG5vZGUgbW9kZSB3aGVuIHVzaW5nIG9uVHJpZ2dlciAoZW5hYmxlIG1vZGUgY29sb3JzKSwgb25FeGVjdXRlZCBkb2VzIG5vdCBuZWVkIHRoaXNcblx0XHRcblx0XHRhbGxvd19tdWx0aV9vdXRwdXRfZm9yX2V2ZW50czogdHJ1ZSwgLy8gW2ZhbHNlIV0gYmVpbmcgZXZlbnRzLCBpdCBpcyBzdHJvbmdseSByZWNjb21lbmRlZCB0byB1c2UgdGhlbSBzZXF1ZW50aWFsbHksIG9uZSBieSBvbmVcblxuXHRcdG1pZGRsZV9jbGlja19zbG90X2FkZF9kZWZhdWx0X25vZGU6IGZhbHNlLCAvL1t0cnVlIV0gYWxsb3dzIHRvIGNyZWF0ZSBhbmQgY29ubmVjdCBhIG5kb2UgY2xpY2tpbmcgd2l0aCB0aGUgdGhpcmQgYnV0dG9uICh3aGVlbClcblx0XHRcblx0XHRyZWxlYXNlX2xpbmtfb25fZW1wdHlfc2hvd3NfbWVudTogZmFsc2UsIC8vW3RydWUhXSBkcmFnZ2luZyBhIGxpbmsgdG8gZW1wdHkgc3BhY2Ugd2lsbCBvcGVuIGEgbWVudSwgYWRkIGZyb20gbGlzdCwgc2VhcmNoIG9yIGRlZmF1bHRzXG5cdFx0XG4gICAgICAgIHBvaW50ZXJldmVudHNfbWV0aG9kOiBcIm1vdXNlXCIsIC8vIFwibW91c2VcInxcInBvaW50ZXJcIiB1c2UgbW91c2UgZm9yIHJldHJvY29tcGF0aWJpbGl0eSBpc3N1ZXM/IChub25lIGZvdW5kIEAgbm93KVxuICAgICAgICAvLyBUT0RPIGltcGxlbWVudCBwb2ludGVyY2FuY2VsLCBnb3Rwb2ludGVyY2FwdHVyZSwgbG9zdHBvaW50ZXJjYXB0dXJlLCAocG9pbnRlcm92ZXIsIHBvaW50ZXJvdXQgaWYgbmVjZXNzYXJ5KVxuXG4gICAgICAgIGN0cmxfc2hpZnRfdl9wYXN0ZV9jb25uZWN0X3Vuc2VsZWN0ZWRfb3V0cHV0czogZmFsc2UsIC8vW3RydWUhXSBhbGxvd3MgY3RybCArIHNoaWZ0ICsgdiB0byBwYXN0ZSBub2RlcyB3aXRoIHRoZSBvdXRwdXRzIG9mIHRoZSB1bnNlbGVjdGVkIG5vZGVzIGNvbm5lY3RlZCB3aXRoIHRoZSBpbnB1dHMgb2YgdGhlIG5ld2x5IHBhc3RlZCBub2Rlc1xuXG4gICAgICAgIC8vIGlmIHRydWUsIGFsbCBuZXdseSBjcmVhdGVkIG5vZGVzL2xpbmtzIHdpbGwgdXNlIHN0cmluZyBVVUlEcyBmb3IgdGhlaXIgaWQgZmllbGRzIGluc3RlYWQgb2YgaW50ZWdlcnMuXG4gICAgICAgIC8vIHVzZSB0aGlzIGlmIHlvdSBtdXN0IGhhdmUgbm9kZSBJRHMgdGhhdCBhcmUgdW5pcXVlIGFjcm9zcyBhbGwgZ3JhcGhzIGFuZCBzdWJncmFwaHMuXG4gICAgICAgIHVzZV91dWlkczogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGEgbm9kZSBjbGFzcyBzbyBpdCBjYW4gYmUgbGlzdGVkIHdoZW4gdGhlIHVzZXIgd2FudHMgdG8gY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyTm9kZVR5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgbmFtZSBvZiB0aGUgbm9kZSBhbmQgcGF0aFxuICAgICAgICAgKiBAcGFyYW0ge0NsYXNzfSBiYXNlX2NsYXNzIGNsYXNzIGNvbnRhaW5pbmcgdGhlIHN0cnVjdHVyZSBvZiBhIG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgICAgcmVnaXN0ZXJOb2RlVHlwZTogZnVuY3Rpb24odHlwZSwgYmFzZV9jbGFzcykge1xuICAgICAgICAgICAgaWYgKCFiYXNlX2NsYXNzLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiQ2Fubm90IHJlZ2lzdGVyIGEgc2ltcGxlIG9iamVjdCwgaXQgbXVzdCBiZSBhIGNsYXNzIHdpdGggYSBwcm90b3R5cGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2VfY2xhc3MudHlwZSA9IHR5cGU7XG5cbiAgICAgICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vZGUgcmVnaXN0ZXJlZDogXCIgKyB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2xhc3NuYW1lID0gYmFzZV9jbGFzcy5uYW1lO1xuXG4gICAgICAgICAgICBjb25zdCBwb3MgPSB0eXBlLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICAgICAgICAgIGJhc2VfY2xhc3MuY2F0ZWdvcnkgPSB0eXBlLnN1YnN0cmluZygwLCBwb3MpO1xuXG4gICAgICAgICAgICBpZiAoIWJhc2VfY2xhc3MudGl0bGUpIHtcbiAgICAgICAgICAgICAgICBiYXNlX2NsYXNzLnRpdGxlID0gY2xhc3NuYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2V4dGVuZCBjbGFzc1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBMR3JhcGhOb2RlLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICghYmFzZV9jbGFzcy5wcm90b3R5cGVbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZV9jbGFzcy5wcm90b3R5cGVbaV0gPSBMR3JhcGhOb2RlLnByb3RvdHlwZVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLnJlZ2lzdGVyZWRfbm9kZV90eXBlc1t0eXBlXTtcbiAgICAgICAgICAgIGlmKHByZXYpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlcGxhY2luZyBub2RlIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiggIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggYmFzZV9jbGFzcy5wcm90b3R5cGUsIFwic2hhcGVcIikgKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGJhc2VfY2xhc3MucHJvdG90eXBlLCBcInNoYXBlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fc2hhcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib3hcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hhcGUgPSBMaXRlR3JhcGguQk9YX1NIQVBFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicm91bmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hhcGUgPSBMaXRlR3JhcGguUk9VTkRfU0hBUEU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaXJjbGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hhcGUgPSBMaXRlR3JhcGguQ0lSQ0xFX1NIQVBFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2FyZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaGFwZSA9IExpdGVHcmFwaC5DQVJEX1NIQVBFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaGFwZSA9IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hhcGU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgLy91c2VkIHRvIGtub3cgd2hpY2ggbm9kZXMgdG8gY3JlYXRlIHdoZW4gZHJhZ2dpbmcgZmlsZXMgdG8gdGhlIGNhbnZhc1xuICAgICAgICAgICAgICAgIGlmIChiYXNlX2NsYXNzLnN1cHBvcnRlZF9leHRlbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gYmFzZV9jbGFzcy5zdXBwb3J0ZWRfZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0ID0gYmFzZV9jbGFzcy5zdXBwb3J0ZWRfZXh0ZW5zaW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGV4dCAmJiBleHQuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZV90eXBlc19ieV9maWxlX2V4dGVuc2lvblsgZXh0LnRvTG93ZXJDYXNlKCkgXSA9IGJhc2VfY2xhc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZF9ub2RlX3R5cGVzW3R5cGVdID0gYmFzZV9jbGFzcztcbiAgICAgICAgICAgIGlmIChiYXNlX2NsYXNzLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLk5vZGVzW2NsYXNzbmFtZV0gPSBiYXNlX2NsYXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5vbk5vZGVUeXBlUmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgICAgIExpdGVHcmFwaC5vbk5vZGVUeXBlUmVnaXN0ZXJlZCh0eXBlLCBiYXNlX2NsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2ICYmIExpdGVHcmFwaC5vbk5vZGVUeXBlUmVwbGFjZWQpIHtcbiAgICAgICAgICAgICAgICBMaXRlR3JhcGgub25Ob2RlVHlwZVJlcGxhY2VkKHR5cGUsIGJhc2VfY2xhc3MsIHByZXYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3dhcm5pbmdzXG4gICAgICAgICAgICBpZiAoYmFzZV9jbGFzcy5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgXCJMaXRlR3JhcGggbm9kZSBjbGFzcyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGhhcyBvblByb3BlcnR5Q2hhbmdlIG1ldGhvZCwgaXQgbXVzdCBiZSBjYWxsZWQgb25Qcm9wZXJ0eUNoYW5nZWQgd2l0aCBkIGF0IHRoZSBlbmRcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFRPRE8gb25lIHdvdWxkIHdhbnQgdG8ga25vdyBpbnB1dCBhbmQgb3VwdXQgOjogdGhpcyB3b3VsZCBhbGxvdyB0aHJvdWdoIHJlZ2lzdGVyTm9kZUFuZFNsb3RUeXBlIHRvIGdldCBhbGwgdGhlIHNsb3RzIHR5cGVzXG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvX2xvYWRfc2xvdF90eXBlcykge1xuICAgICAgICAgICAgICAgIG5ldyBiYXNlX2NsYXNzKGJhc2VfY2xhc3MudGl0bGUgfHwgXCJ0bXBub2RlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZW1vdmVzIGEgbm9kZSB0eXBlIGZyb20gdGhlIHN5c3RlbVxuICAgICAgICAgKiBAbWV0aG9kIHVucmVnaXN0ZXJOb2RlVHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHR5cGUgbmFtZSBvZiB0aGUgbm9kZSBvciB0aGUgbm9kZSBjb25zdHJ1Y3RvciBpdHNlbGZcbiAgICAgICAgICovXG4gICAgICAgIHVucmVnaXN0ZXJOb2RlVHlwZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgY29uc3QgYmFzZV9jbGFzcyA9XG4gICAgICAgICAgICAgICAgdHlwZS5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5yZWdpc3RlcmVkX25vZGVfdHlwZXNbdHlwZV1cbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlO1xuICAgICAgICAgICAgaWYgKCFiYXNlX2NsYXNzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJub2RlIHR5cGUgbm90IGZvdW5kOiBcIiArIHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5yZWdpc3RlcmVkX25vZGVfdHlwZXNbYmFzZV9jbGFzcy50eXBlXTtcbiAgICAgICAgICAgIGlmIChiYXNlX2NsYXNzLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5Ob2Rlc1tiYXNlX2NsYXNzLmNvbnN0cnVjdG9yLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIFNhdmUgYSBzbG90IHR5cGUgYW5kIGhpcyBub2RlXG4gICAgICAgICogQG1ldGhvZCByZWdpc3RlclNsb3RUeXBlXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB0eXBlIG5hbWUgb2YgdGhlIG5vZGUgb3IgdGhlIG5vZGUgY29uc3RydWN0b3IgaXRzZWxmXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNsb3RfdHlwZSBuYW1lIG9mIHRoZSBzbG90IHR5cGUgKHZhcmlhYmxlIHR5cGUpLCBlZy4gc3RyaW5nLCBudW1iZXIsIGFycmF5LCBib29sZWFuLCAuLlxuICAgICAgICAqL1xuICAgICAgICByZWdpc3Rlck5vZGVBbmRTbG90VHlwZTogZnVuY3Rpb24odHlwZSwgc2xvdF90eXBlLCBvdXQpe1xuICAgICAgICAgICAgb3V0ID0gb3V0IHx8IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgYmFzZV9jbGFzcyA9XG4gICAgICAgICAgICAgICAgdHlwZS5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nICYmXG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkX25vZGVfdHlwZXNbdHlwZV0gIT09IFwiYW5vbnltb3VzXCJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnJlZ2lzdGVyZWRfbm9kZV90eXBlc1t0eXBlXVxuICAgICAgICAgICAgICAgICAgICA6IHR5cGU7XG5cbiAgICAgICAgICAgIGNvbnN0IGNsYXNzX3R5cGUgPSBiYXNlX2NsYXNzLmNvbnN0cnVjdG9yLnR5cGU7XG5cbiAgICAgICAgICAgIGxldCBhbGxUeXBlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzbG90X3R5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBhbGxUeXBlcyA9IHNsb3RfdHlwZS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNsb3RfdHlwZSA9PSB0aGlzLkVWRU5UIHx8IHNsb3RfdHlwZSA9PSB0aGlzLkFDVElPTikge1xuICAgICAgICAgICAgICAgIGFsbFR5cGVzID0gW1wiX2V2ZW50X1wiXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxsVHlwZXMgPSBbXCIqXCJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbFR5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNsb3RUeXBlID0gYWxsVHlwZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHNsb3RUeXBlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3RUeXBlID0gXCIqXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2lzdGVyVG8gPSBvdXRcbiAgICAgICAgICAgICAgICAgICAgPyBcInJlZ2lzdGVyZWRfc2xvdF9vdXRfdHlwZXNcIlxuICAgICAgICAgICAgICAgICAgICA6IFwicmVnaXN0ZXJlZF9zbG90X2luX3R5cGVzXCI7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbcmVnaXN0ZXJUb11bc2xvdFR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tyZWdpc3RlclRvXVtzbG90VHlwZV0gPSB7IG5vZGVzOiBbXSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXNbcmVnaXN0ZXJUb11bc2xvdFR5cGVdLm5vZGVzLmluY2x1ZGVzKGNsYXNzX3R5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcmVnaXN0ZXJUb11bc2xvdFR5cGVdLm5vZGVzLnB1c2goY2xhc3NfdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXMgYSBuZXcgdHlwZVxuICAgICAgICAgICAgICAgIGlmICghb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zbG90X3R5cGVzX2luLmluY2x1ZGVzKHNsb3RUeXBlLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNsb3RfdHlwZXNfaW4ucHVzaChzbG90VHlwZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2xvdF90eXBlc19pbi5zb3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2xvdF90eXBlc19vdXQuaW5jbHVkZXMoc2xvdFR5cGUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2xvdF90eXBlc19vdXQucHVzaChzbG90VHlwZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2xvdF90eXBlc19vdXQuc29ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBub2RldHlwZSBieSBwYXNzaW5nIGFuIG9iamVjdCB3aXRoIHNvbWUgcHJvcGVydGllc1xuICAgICAgICAgKiBsaWtlIG9uQ3JlYXRlLCBpbnB1dHM6QXJyYXksIG91dHB1dHM6QXJyYXksIHByb3BlcnRpZXMsIG9uRXhlY3V0ZVxuICAgICAgICAgKiBAbWV0aG9kIGJ1aWxkTm9kZUNsYXNzRnJvbU9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBub2RlIG5hbWUgd2l0aCBuYW1lc3BhY2UgKHAuZS46ICdtYXRoL3N1bScpXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgbWV0aG9kcyBleHBlY3RlZCBvbkNyZWF0ZSwgaW5wdXRzLCBvdXRwdXRzLCBwcm9wZXJ0aWVzLCBvbkV4ZWN1dGVcbiAgICAgICAgICovXG4gICAgICAgICBidWlsZE5vZGVDbGFzc0Zyb21PYmplY3Q6IGZ1bmN0aW9uKFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG9iamVjdFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBjdG9yX2NvZGUgPSBcIlwiO1xuICAgICAgICAgICAgaWYob2JqZWN0LmlucHV0cylcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpIDwgb2JqZWN0LmlucHV0cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgX25hbWUgPSBvYmplY3QuaW5wdXRzW2ldWzBdO1xuICAgICAgICAgICAgICAgIHZhciBfdHlwZSA9IG9iamVjdC5pbnB1dHNbaV1bMV07XG4gICAgICAgICAgICAgICAgaWYoX3R5cGUgJiYgX3R5cGUuY29uc3RydWN0b3IgPT09IFN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgX3R5cGUgPSAnXCInK190eXBlKydcIic7XG4gICAgICAgICAgICAgICAgY3Rvcl9jb2RlICs9IFwidGhpcy5hZGRJbnB1dCgnXCIrX25hbWUrXCInLFwiK190eXBlK1wiKTtcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG9iamVjdC5vdXRwdXRzKVxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBvYmplY3Qub3V0cHV0cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgX25hbWUgPSBvYmplY3Qub3V0cHV0c1tpXVswXTtcbiAgICAgICAgICAgICAgICB2YXIgX3R5cGUgPSBvYmplY3Qub3V0cHV0c1tpXVsxXTtcbiAgICAgICAgICAgICAgICBpZihfdHlwZSAmJiBfdHlwZS5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBfdHlwZSA9ICdcIicrX3R5cGUrJ1wiJztcbiAgICAgICAgICAgICAgICBjdG9yX2NvZGUgKz0gXCJ0aGlzLmFkZE91dHB1dCgnXCIrX25hbWUrXCInLFwiK190eXBlK1wiKTtcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG9iamVjdC5wcm9wZXJ0aWVzKVxuICAgICAgICAgICAgZm9yKHZhciBpIGluIG9iamVjdC5wcm9wZXJ0aWVzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gb2JqZWN0LnByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgaWYocHJvcCAmJiBwcm9wLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIHByb3AgPSAnXCInK3Byb3ArJ1wiJztcbiAgICAgICAgICAgICAgICBjdG9yX2NvZGUgKz0gXCJ0aGlzLmFkZFByb3BlcnR5KCdcIitpK1wiJyxcIitwcm9wK1wiKTtcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0b3JfY29kZSArPSBcImlmKHRoaXMub25DcmVhdGUpdGhpcy5vbkNyZWF0ZSgpXCI7XG4gICAgICAgICAgICB2YXIgY2xhc3NvYmogPSBGdW5jdGlvbihjdG9yX2NvZGUpO1xuICAgICAgICAgICAgZm9yKHZhciBpIGluIG9iamVjdClcbiAgICAgICAgICAgICAgICBpZihpIT1cImlucHV0c1wiICYmIGkhPVwib3V0cHV0c1wiICYmIGkhPVwicHJvcGVydGllc1wiKVxuICAgICAgICAgICAgICAgICAgICBjbGFzc29iai5wcm90b3R5cGVbaV0gPSBvYmplY3RbaV07XG4gICAgICAgICAgICBjbGFzc29iai50aXRsZSA9IG9iamVjdC50aXRsZSB8fCBuYW1lLnNwbGl0KFwiL1wiKS5wb3AoKTtcbiAgICAgICAgICAgIGNsYXNzb2JqLmRlc2MgPSBvYmplY3QuZGVzYyB8fCBcIkdlbmVyYXRlZCBmcm9tIG9iamVjdFwiO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck5vZGVUeXBlKG5hbWUsIGNsYXNzb2JqKTtcbiAgICAgICAgICAgIHJldHVybiBjbGFzc29iajtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgbm9kZXR5cGUgYnkgcGFzc2luZyBhIGZ1bmN0aW9uLCBpdCB3cmFwcyBpdCB3aXRoIGEgcHJvcGVyIGNsYXNzIGFuZCBnZW5lcmF0ZXMgaW5wdXRzIGFjY29yZGluZyB0byB0aGUgcGFyYW1ldGVycyBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAqIFVzZWZ1bCB0byB3cmFwIHNpbXBsZSBtZXRob2RzIHRoYXQgZG8gbm90IHJlcXVpcmUgcHJvcGVydGllcywgYW5kIHRoYXQgb25seSBwcm9jZXNzIHNvbWUgaW5wdXQgdG8gZ2VuZXJhdGUgYW4gb3V0cHV0LlxuICAgICAgICAgKiBAbWV0aG9kIHdyYXBGdW5jdGlvbkFzTm9kZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBub2RlIG5hbWUgd2l0aCBuYW1lc3BhY2UgKHAuZS46ICdtYXRoL3N1bScpXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1fdHlwZXMgW29wdGlvbmFsXSBhbiBhcnJheSBjb250YWluaW5nIHRoZSB0eXBlIG9mIGV2ZXJ5IHBhcmFtZXRlciwgb3RoZXJ3aXNlIHBhcmFtZXRlcnMgd2lsbCBhY2NlcHQgYW55IHR5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHJldHVybl90eXBlIFtvcHRpb25hbF0gc3RyaW5nIHdpdGggdGhlIHJldHVybiB0eXBlLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBnZW5lcmljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIFtvcHRpb25hbF0gcHJvcGVydGllcyB0byBiZSBjb25maWd1cmFibGVcbiAgICAgICAgICovXG4gICAgICAgIHdyYXBGdW5jdGlvbkFzTm9kZTogZnVuY3Rpb24oXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZnVuYyxcbiAgICAgICAgICAgIHBhcmFtX3R5cGVzLFxuICAgICAgICAgICAgcmV0dXJuX3R5cGUsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IEFycmF5KGZ1bmMubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBjb2RlID0gXCJcIjtcbiAgICAgICAgICAgIGlmKHBhcmFtX3R5cGVzICE9PSBudWxsKSAvL251bGwgbWVhbnMgbm8gaW5wdXRzXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVzID0gTGl0ZUdyYXBoLmdldFBhcmFtZXRlck5hbWVzKGZ1bmMpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZihwYXJhbV90eXBlcylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy90eXBlID0gcGFyYW1fdHlwZXNbaV0gIT0gbnVsbCA/IFwiJ1wiICsgcGFyYW1fdHlwZXNbaV0gKyBcIidcIiA6IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHBhcmFtX3R5cGVzW2ldICE9IG51bGwgJiYgcGFyYW1fdHlwZXNbaV0uY29uc3RydWN0b3IgPT09IFN0cmluZyApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwiJ1wiICsgcGFyYW1fdHlwZXNbaV0gKyBcIidcIiA7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKCBwYXJhbV90eXBlc1tpXSAhPSBudWxsIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gcGFyYW1fdHlwZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgIGNvZGUgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGhpcy5hZGRJbnB1dCgnXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNbaV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCInLFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIpO1xcblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHJldHVybl90eXBlICE9PSBudWxsKSAvL251bGwgbWVhbnMgbm8gb3V0cHV0XG4gICAgICAgICAgICBjb2RlICs9XG4gICAgICAgICAgICAgICAgXCJ0aGlzLmFkZE91dHB1dCgnb3V0JyxcIiArXG4gICAgICAgICAgICAgICAgKHJldHVybl90eXBlICE9IG51bGwgPyAocmV0dXJuX3R5cGUuY29uc3RydWN0b3IgPT09IFN0cmluZyA/IFwiJ1wiICsgcmV0dXJuX3R5cGUgKyBcIidcIiA6IHJldHVybl90eXBlKSA6IDApICtcbiAgICAgICAgICAgICAgICBcIik7XFxuXCI7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGNvZGUgKz1cbiAgICAgICAgICAgICAgICAgICAgXCJ0aGlzLnByb3BlcnRpZXMgPSBcIiArIEpTT04uc3RyaW5naWZ5KHByb3BlcnRpZXMpICsgXCI7XFxuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2xhc3NvYmogPSBGdW5jdGlvbihjb2RlKTtcbiAgICAgICAgICAgIGNsYXNzb2JqLnRpdGxlID0gbmFtZS5zcGxpdChcIi9cIikucG9wKCk7XG4gICAgICAgICAgICBjbGFzc29iai5kZXNjID0gXCJHZW5lcmF0ZWQgZnJvbSBcIiArIGZ1bmMubmFtZTtcbiAgICAgICAgICAgIGNsYXNzb2JqLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbiBvbkV4ZWN1dGUoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zW2ldID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByID0gZnVuYy5hcHBseSh0aGlzLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCByKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyTm9kZVR5cGUobmFtZSwgY2xhc3NvYmopO1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzb2JqO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgbm9kZSdzIHR5cGVzXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhclJlZ2lzdGVyZWRUeXBlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRfbm9kZV90eXBlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5ub2RlX3R5cGVzX2J5X2ZpbGVfZXh0ZW5zaW9uID0ge307XG4gICAgICAgICAgICB0aGlzLk5vZGVzID0ge307XG4gICAgICAgICAgICB0aGlzLnNlYXJjaGJveF9leHRyYXMgPSB7fTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyB0aGlzIG1ldGhvZCB0byBhbGwgbm9kZXR5cGVzLCBleGlzdGluZyBhbmQgdG8gYmUgY3JlYXRlZFxuICAgICAgICAgKiAoWW91IGNhbiBhZGQgaXQgdG8gTEdyYXBoTm9kZS5wcm90b3R5cGUgYnV0IHRoZW4gZXhpc3Rpbmcgbm9kZSB0eXBlcyB3b250IGhhdmUgaXQpXG4gICAgICAgICAqIEBtZXRob2QgYWRkTm9kZU1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAgICAgICAqL1xuICAgICAgICBhZGROb2RlTWV0aG9kOiBmdW5jdGlvbihuYW1lLCBmdW5jKSB7XG4gICAgICAgICAgICBMR3JhcGhOb2RlLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmM7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMucmVnaXN0ZXJlZF9ub2RlX3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnJlZ2lzdGVyZWRfbm9kZV90eXBlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5wcm90b3R5cGVbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZS5wcm90b3R5cGVbXCJfXCIgKyBuYW1lXSA9IHR5cGUucHJvdG90eXBlW25hbWVdO1xuICAgICAgICAgICAgICAgIH0gLy9rZWVwIG9sZCBpbiBjYXNlIG9mIHJlcGxhY2luZ1xuICAgICAgICAgICAgICAgIHR5cGUucHJvdG90eXBlW25hbWVdID0gZnVuYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbm9kZSBvZiBhIGdpdmVuIHR5cGUgd2l0aCBhIG5hbWUuIFRoZSBub2RlIGlzIG5vdCBhdHRhY2hlZCB0byBhbnkgZ3JhcGggeWV0LlxuICAgICAgICAgKiBAbWV0aG9kIGNyZWF0ZU5vZGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgZnVsbCBuYW1lIG9mIHRoZSBub2RlIGNsYXNzLiBwLmUuIFwibWF0aC9zaW5cIlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBhIG5hbWUgdG8gZGlzdGluZ3Vpc2ggZnJvbSBvdGhlciBub2Rlc1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0byBzZXQgb3B0aW9uc1xuICAgICAgICAgKi9cblxuICAgICAgICBjcmVhdGVOb2RlOiBmdW5jdGlvbih0eXBlLCB0aXRsZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGJhc2VfY2xhc3MgPSB0aGlzLnJlZ2lzdGVyZWRfbm9kZV90eXBlc1t0eXBlXTtcbiAgICAgICAgICAgIGlmICghYmFzZV9jbGFzcykge1xuICAgICAgICAgICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAnR3JhcGhOb2RlIHR5cGUgXCInICsgdHlwZSArICdcIiBub3QgcmVnaXN0ZXJlZC4nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJvdG90eXBlID0gYmFzZV9jbGFzcy5wcm90b3R5cGUgfHwgYmFzZV9jbGFzcztcblxuICAgICAgICAgICAgdGl0bGUgPSB0aXRsZSB8fCBiYXNlX2NsYXNzLnRpdGxlIHx8IHR5cGU7XG5cbiAgICAgICAgICAgIHZhciBub2RlID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5jYXRjaF9leGNlcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBiYXNlX2NsYXNzKHRpdGxlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgYmFzZV9jbGFzcyh0aXRsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUudHlwZSA9IHR5cGU7XG5cbiAgICAgICAgICAgIGlmICghbm9kZS50aXRsZSAmJiB0aXRsZSkge1xuICAgICAgICAgICAgICAgIG5vZGUudGl0bGUgPSB0aXRsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbm9kZS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5vZGUucHJvcGVydGllc19pbmZvKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzX2luZm8gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbm9kZS5mbGFncykge1xuICAgICAgICAgICAgICAgIG5vZGUuZmxhZ3MgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbm9kZS5zaXplKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zaXplID0gbm9kZS5jb21wdXRlU2l6ZSgpO1xuXHRcdFx0XHQvL2NhbGwgb25yZXNpemU/XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5vZGUucG9zKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wb3MgPSBMaXRlR3JhcGguREVGQVVMVF9QT1NJVElPTi5jb25jYXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbm9kZS5tb2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5tb2RlID0gTGl0ZUdyYXBoLkFMV0FZUztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9leHRyYSBvcHRpb25zXG4gICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBub2RlW2ldID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblx0XHRcdC8vIGNhbGxiYWNrXG4gICAgICAgICAgICBpZiAoIG5vZGUub25Ob2RlQ3JlYXRlZCApIHtcbiAgICAgICAgICAgICAgICBub2RlLm9uTm9kZUNyZWF0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSByZWdpc3RlcmVkIG5vZGUgdHlwZSB3aXRoIGEgZ2l2ZW4gbmFtZVxuICAgICAgICAgKiBAbWV0aG9kIGdldE5vZGVUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIGZ1bGwgbmFtZSBvZiB0aGUgbm9kZSBjbGFzcy4gcC5lLiBcIm1hdGgvc2luXCJcbiAgICAgICAgICogQHJldHVybiB7Q2xhc3N9IHRoZSBub2RlIGNsYXNzXG4gICAgICAgICAqL1xuICAgICAgICBnZXROb2RlVHlwZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJlZF9ub2RlX3R5cGVzW3R5cGVdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub2RlIHR5cGVzIG1hdGNoaW5nIG9uZSBjYXRlZ29yeVxuICAgICAgICAgKiBAbWV0aG9kIGdldE5vZGVUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYXRlZ29yeSBjYXRlZ29yeSBuYW1lXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBhcnJheSB3aXRoIGFsbCB0aGUgbm9kZSBjbGFzc2VzXG4gICAgICAgICAqL1xuXG4gICAgICAgIGdldE5vZGVUeXBlc0luQ2F0ZWdvcnk6IGZ1bmN0aW9uKGNhdGVnb3J5LCBmaWx0ZXIpIHtcbiAgICAgICAgICAgIHZhciByID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMucmVnaXN0ZXJlZF9ub2RlX3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnJlZ2lzdGVyZWRfbm9kZV90eXBlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5maWx0ZXIgIT0gZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjYXRlZ29yeSA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLmNhdGVnb3J5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIucHVzaCh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZS5jYXRlZ29yeSA9PSBjYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgICAgICByLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvX3NvcnRfbm9kZV90eXBlcykge1xuICAgICAgICAgICAgICAgIHIuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLnRpdGxlLmxvY2FsZUNvbXBhcmUoYi50aXRsZSl9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IHdpdGggYWxsIHRoZSBub2RlIHR5cGUgY2F0ZWdvcmllc1xuICAgICAgICAgKiBAbWV0aG9kIGdldE5vZGVUeXBlc0NhdGVnb3JpZXNcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbHRlciBvbmx5IG5vZGVzIHdpdGggY3Rvci5maWx0ZXIgZXF1YWwgY2FuIGJlIHNob3duXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBhcnJheSB3aXRoIGFsbCB0aGUgbmFtZXMgb2YgdGhlIGNhdGVnb3JpZXNcbiAgICAgICAgICovXG4gICAgICAgIGdldE5vZGVUeXBlc0NhdGVnb3JpZXM6IGZ1bmN0aW9uKCBmaWx0ZXIgKSB7XG4gICAgICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IHsgXCJcIjogMSB9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnJlZ2lzdGVyZWRfbm9kZV90eXBlcykge1xuXHRcdFx0XHR2YXIgdHlwZSA9IHRoaXMucmVnaXN0ZXJlZF9ub2RlX3R5cGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICggdHlwZS5jYXRlZ29yeSAmJiAhdHlwZS5za2lwX2xpc3QgKVxuICAgICAgICAgICAgICAgIHtcblx0XHRcdFx0XHRpZih0eXBlLmZpbHRlciAhPSBmaWx0ZXIpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllc1t0eXBlLmNhdGVnb3J5XSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBjYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRvX3NvcnRfbm9kZV90eXBlcyA/IHJlc3VsdC5zb3J0KCkgOiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9kZWJ1ZyBwdXJwb3NlczogcmVsb2FkcyBhbGwgdGhlIGpzIHNjcmlwdHMgdGhhdCBtYXRjaGVzIGEgd2lsZGNhcmRcbiAgICAgICAgcmVsb2FkTm9kZXM6IGZ1bmN0aW9uKGZvbGRlcl93aWxkY2FyZCkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgLy93ZWlyZCwgdGhpcyBhcnJheSBjaGFuZ2VzIGJ5IGl0cyBvd24sIHNvIHdlIHVzZSBhIGNvcHlcbiAgICAgICAgICAgIHZhciBzY3JpcHRfZmlsZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaSA8IHRtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNjcmlwdF9maWxlcy5wdXNoKHRtcFtpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkb2NIZWFkT2JqID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuICAgICAgICAgICAgZm9sZGVyX3dpbGRjYXJkID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZiArIGZvbGRlcl93aWxkY2FyZDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgc2NyaXB0X2ZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNyYyA9IHNjcmlwdF9maWxlc1tpXS5zcmM7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhc3JjIHx8XG4gICAgICAgICAgICAgICAgICAgIHNyYy5zdWJzdHIoMCwgZm9sZGVyX3dpbGRjYXJkLmxlbmd0aCkgIT0gZm9sZGVyX3dpbGRjYXJkXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVsb2FkaW5nOiBcIiArIHNyYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGR5bmFtaWNTY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljU2NyaXB0LnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljU2NyaXB0LnNyYyA9IHNyYztcbiAgICAgICAgICAgICAgICAgICAgZG9jSGVhZE9iai5hcHBlbmRDaGlsZChkeW5hbWljU2NyaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgZG9jSGVhZE9iai5yZW1vdmVDaGlsZChzY3JpcHRfZmlsZXNbaV0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLnRocm93X2Vycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3Igd2hpbGUgcmVsb2FkaW5nIFwiICsgc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm9kZXMgcmVsb2FkZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9zZXBhcmF0ZWQganVzdCB0byBpbXByb3ZlIGlmIGl0IGRvZXNuJ3Qgd29ya1xuICAgICAgICBjbG9uZU9iamVjdDogZnVuY3Rpb24ob2JqLCB0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHIgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiByKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gcltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamVkLzk4Mjg4Mz9wZXJtYWxpbmtfY29tbWVudF9pZD04NTI2NzAjZ2lzdGNvbW1lbnQtODUyNjcwXG4gICAgICAgICAqL1xuICAgICAgICB1dWlkdjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIChbMWU3XSstMWUzKy00ZTMrLThlMystMWUxMSkucmVwbGFjZSgvWzAxOF0vZyxhPT4oYV5NYXRoLnJhbmRvbSgpKjE2Pj5hLzQpLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgaWYgdGhlIHR5cGVzIG9mIHR3byBzbG90cyBhcmUgY29tcGF0aWJsZSAodGFraW5nIGludG8gYWNjb3VudCB3aWxkY2FyZHMsIGV0YylcbiAgICAgICAgICogQG1ldGhvZCBpc1ZhbGlkQ29ubmVjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZV9hXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlX2JcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGV5IGNhbiBiZSBjb25uZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlzVmFsaWRDb25uZWN0aW9uOiBmdW5jdGlvbih0eXBlX2EsIHR5cGVfYikge1xuXHRcdFx0aWYgKHR5cGVfYT09XCJcIiB8fCB0eXBlX2E9PT1cIipcIikgdHlwZV9hID0gMDtcblx0XHRcdGlmICh0eXBlX2I9PVwiXCIgfHwgdHlwZV9iPT09XCIqXCIpIHR5cGVfYiA9IDA7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXR5cGVfYSAvL2dlbmVyaWMgb3V0cHV0XG4gICAgICAgICAgICAgICAgfHwgIXR5cGVfYiAvLyBnZW5lcmljIGlucHV0XG4gICAgICAgICAgICAgICAgfHwgdHlwZV9hID09IHR5cGVfYiAvL3NhbWUgdHlwZSAoaXMgdmFsaWQgZm9yIHRyaWdnZXJzKVxuICAgICAgICAgICAgICAgIHx8ICh0eXBlX2EgPT0gTGl0ZUdyYXBoLkVWRU5UICYmIHR5cGVfYiA9PSBMaXRlR3JhcGguQUNUSU9OKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVuZm9yY2Ugc3RyaW5nIHR5cGUgdG8gaGFuZGxlIHRvTG93ZXJDYXNlIGNhbGwgKC0xIG51bWJlciBub3Qgb2spXG4gICAgICAgICAgICB0eXBlX2EgPSBTdHJpbmcodHlwZV9hKTtcbiAgICAgICAgICAgIHR5cGVfYiA9IFN0cmluZyh0eXBlX2IpO1xuICAgICAgICAgICAgdHlwZV9hID0gdHlwZV9hLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0eXBlX2IgPSB0eXBlX2IudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgLy8gRm9yIG5vZGVzIHN1cHBvcnRpbmcgbXVsdGlwbGUgY29ubmVjdGlvbiB0eXBlc1xuICAgICAgICAgICAgaWYgKHR5cGVfYS5pbmRleE9mKFwiLFwiKSA9PSAtMSAmJiB0eXBlX2IuaW5kZXhPZihcIixcIikgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZV9hID09IHR5cGVfYjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgYWxsIHBlcm11dGF0aW9ucyB0byBzZWUgaWYgb25lIGlzIHZhbGlkXG4gICAgICAgICAgICB2YXIgc3VwcG9ydGVkX3R5cGVzX2EgPSB0eXBlX2Euc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgdmFyIHN1cHBvcnRlZF90eXBlc19iID0gdHlwZV9iLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VwcG9ydGVkX3R5cGVzX2EubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1cHBvcnRlZF90eXBlc19iLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuaXNWYWxpZENvbm5lY3Rpb24oc3VwcG9ydGVkX3R5cGVzX2FbaV0sc3VwcG9ydGVkX3R5cGVzX2Jbal0pKXtcblx0XHRcdFx0XHQvL2lmIChzdXBwb3J0ZWRfdHlwZXNfYVtpXSA9PSBzdXBwb3J0ZWRfdHlwZXNfYltqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBzdHJpbmcgaW4gdGhlIHNlYXJjaCBib3ggc28gd2hlbiB0aGUgdXNlciB0eXBlcyBpdCBpdCB3aWxsIHJlY29tbWVuZCB0aGlzIG5vZGVcbiAgICAgICAgICogQG1ldGhvZCByZWdpc3RlclNlYXJjaGJveEV4dHJhXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBub2RlX3R5cGUgdGhlIG5vZGUgcmVjb21tZW5kZWRcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGRlc2NyaXB0aW9uIHRleHQgdG8gc2hvdyBuZXh0IHRvIGl0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIGl0IGNvdWxkIGNvbnRhaW4gaW5mbyBvZiBob3cgdGhlIG5vZGUgc2hvdWxkIGJlIGNvbmZpZ3VyZWRcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGV5IGNhbiBiZSBjb25uZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlZ2lzdGVyU2VhcmNoYm94RXh0cmE6IGZ1bmN0aW9uKG5vZGVfdHlwZSwgZGVzY3JpcHRpb24sIGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoYm94X2V4dHJhc1tkZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpXSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBub2RlX3R5cGUsXG4gICAgICAgICAgICAgICAgZGVzYzogZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV3JhcHBlciB0byBsb2FkIGZpbGVzIChmcm9tIHVybCB1c2luZyBmZXRjaCBvciBmcm9tIGZpbGUgdXNpbmcgRmlsZVJlYWRlcilcbiAgICAgICAgICogQG1ldGhvZCBmZXRjaEZpbGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8RmlsZXxCbG9ifSB1cmwgdGhlIHVybCBvZiB0aGUgZmlsZSAob3IgdGhlIGZpbGUgaXRzZWxmKVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBhbiBzdHJpbmcgdG8ga25vdyBob3cgdG8gZmV0Y2ggaXQ6IFwidGV4dFwiLFwiYXJyYXlidWZmZXJcIixcImpzb25cIixcImJsb2JcIlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbl9jb21wbGV0ZSBjYWxsYmFjayhkYXRhKVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbl9lcnJvciBpbiBjYXNlIG9mIGFuIGVycm9yXG4gICAgICAgICAqIEByZXR1cm4ge0ZpbGVSZWFkZXJ8UHJvbWlzZX0gcmV0dXJucyB0aGUgb2JqZWN0IHVzZWQgdG8gXG4gICAgICAgICAqL1xuXHRcdGZldGNoRmlsZTogZnVuY3Rpb24oIHVybCwgdHlwZSwgb25fY29tcGxldGUsIG9uX2Vycm9yICkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0aWYoIXVybClcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwidGV4dFwiO1xuXHRcdFx0aWYoIHVybC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nIClcblx0XHRcdHtcblx0XHRcdFx0aWYgKHVybC5zdWJzdHIoMCwgNCkgPT0gXCJodHRwXCIgJiYgTGl0ZUdyYXBoLnByb3h5KSB7XG5cdFx0XHRcdFx0dXJsID0gTGl0ZUdyYXBoLnByb3h5ICsgdXJsLnN1YnN0cih1cmwuaW5kZXhPZihcIjpcIikgKyAzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmV0Y2godXJsKVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuXHRcdFx0XHRcdGlmKCFyZXNwb25zZS5vaylcblx0XHRcdFx0XHRcdCB0aHJvdyBuZXcgRXJyb3IoXCJGaWxlIG5vdCBmb3VuZFwiKTsgLy9pdCB3aWxsIGJlIGNhdGNoIGJlbG93XG5cdFx0XHRcdFx0aWYodHlwZSA9PSBcImFycmF5YnVmZmVyXCIpXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcblx0XHRcdFx0XHRlbHNlIGlmKHR5cGUgPT0gXCJ0ZXh0XCIgfHwgdHlwZSA9PSBcInN0cmluZ1wiKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcblx0XHRcdFx0XHRlbHNlIGlmKHR5cGUgPT0gXCJqc29uXCIpXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuXHRcdFx0XHRcdGVsc2UgaWYodHlwZSA9PSBcImJsb2JcIilcblx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZS5ibG9iKCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0XHRpZihvbl9jb21wbGV0ZSlcblx0XHRcdFx0XHRcdG9uX2NvbXBsZXRlKGRhdGEpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFwiZXJyb3IgZmV0Y2hpbmcgZmlsZTpcIix1cmwpO1xuXHRcdFx0XHRcdGlmKG9uX2Vycm9yKVxuXHRcdFx0XHRcdFx0b25fZXJyb3IoZXJyb3IpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoIHVybC5jb25zdHJ1Y3RvciA9PT0gRmlsZSB8fCB1cmwuY29uc3RydWN0b3IgPT09IEJsb2IpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciB2ID0gZS50YXJnZXQucmVzdWx0O1xuXHRcdFx0XHRcdGlmKCB0eXBlID09IFwianNvblwiIClcblx0XHRcdFx0XHRcdHYgPSBKU09OLnBhcnNlKHYpO1xuXHRcdFx0XHRcdGlmKG9uX2NvbXBsZXRlKVxuXHRcdFx0XHRcdFx0b25fY29tcGxldGUodik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodHlwZSA9PSBcImFycmF5YnVmZmVyXCIpXG5cdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcih1cmwpO1xuXHRcdFx0XHRlbHNlIGlmKHR5cGUgPT0gXCJ0ZXh0XCIgfHwgdHlwZSA9PSBcImpzb25cIilcblx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyLnJlYWRBc1RleHQodXJsKTtcblx0XHRcdFx0ZWxzZSBpZih0eXBlID09IFwiYmxvYlwiKVxuXHRcdFx0XHRcdHJldHVybiByZWFkZXIucmVhZEFzQmluYXJ5U3RyaW5nKHVybCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG4gICAgfSk7XG5cbiAgICAvL3RpbWVyIHRoYXQgd29ya3MgZXZlcnl3aGVyZVxuICAgIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBMaXRlR3JhcGguZ2V0VGltZSA9IHBlcmZvcm1hbmNlLm5vdy5iaW5kKHBlcmZvcm1hbmNlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBEYXRlICE9IFwidW5kZWZpbmVkXCIgJiYgRGF0ZS5ub3cpIHtcbiAgICAgICAgTGl0ZUdyYXBoLmdldFRpbWUgPSBEYXRlLm5vdy5iaW5kKERhdGUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBMaXRlR3JhcGguZ2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHQgPSBwcm9jZXNzLmhydGltZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRbMF0gKiAwLjAwMSArIHRbMV0gKiAxZS02O1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIExpdGVHcmFwaC5nZXRUaW1lID0gZnVuY3Rpb24gZ2V0VGltZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vIExHcmFwaCBDTEFTU1xuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICAvKipcbiAgICAgKiBMR3JhcGggaXMgdGhlIGNsYXNzIHRoYXQgY29udGFpbiBhIGZ1bGwgZ3JhcGguIFdlIGluc3RhbnRpYXRlIG9uZSBhbmQgYWRkIG5vZGVzIHRvIGl0LCBhbmQgdGhlbiB3ZSBjYW4gcnVuIHRoZSBleGVjdXRpb24gbG9vcC5cblx0ICogc3VwcG9ydGVkIGNhbGxiYWNrczpcblx0XHQrIG9uTm9kZUFkZGVkOiB3aGVuIGEgbmV3IG5vZGUgaXMgYWRkZWQgdG8gdGhlIGdyYXBoXG5cdFx0KyBvbk5vZGVSZW1vdmVkOiB3aGVuIGEgbm9kZSBpbnNpZGUgdGhpcyBncmFwaCBpcyByZW1vdmVkXG5cdFx0KyBvbk5vZGVDb25uZWN0aW9uQ2hhbmdlOiBzb21lIGNvbm5lY3Rpb24gaGFzIGNoYW5nZWQgaW4gdGhlIGdyYXBoIChjb25uZWN0ZWQgb3IgZGlzY29ubmVjdGVkKVxuICAgICAqXG4gICAgICogQGNsYXNzIExHcmFwaFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvIGRhdGEgZnJvbSBwcmV2aW91cyBzZXJpYWxpemF0aW9uIFtvcHRpb25hbF1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIExHcmFwaChvKSB7XG4gICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiR3JhcGggY3JlYXRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3Rfb2ZfZ3JhcGhjYW52YXMgPSBudWxsO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKG8pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2xvYmFsLkxHcmFwaCA9IExpdGVHcmFwaC5MR3JhcGggPSBMR3JhcGg7XG5cbiAgICAvL2RlZmF1bHQgc3VwcG9ydGVkIHR5cGVzXG4gICAgTEdyYXBoLnN1cHBvcnRlZF90eXBlcyA9IFtcIm51bWJlclwiLCBcInN0cmluZ1wiLCBcImJvb2xlYW5cIl07XG5cbiAgICAvL3VzZWQgdG8ga25vdyB3aGljaCB0eXBlcyBvZiBjb25uZWN0aW9ucyBzdXBwb3J0IHRoaXMgZ3JhcGggKHNvbWUgZ3JhcGhzIGRvIG5vdCBhbGxvdyBjZXJ0YWluIHR5cGVzKVxuICAgIExHcmFwaC5wcm90b3R5cGUuZ2V0U3VwcG9ydGVkVHlwZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwcG9ydGVkX3R5cGVzIHx8IExHcmFwaC5zdXBwb3J0ZWRfdHlwZXM7XG4gICAgfTtcblxuICAgIExHcmFwaC5TVEFUVVNfU1RPUFBFRCA9IDE7XG4gICAgTEdyYXBoLlNUQVRVU19SVU5OSU5HID0gMjtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIG5vZGVzIGZyb20gdGhpcyBncmFwaFxuICAgICAqIEBtZXRob2QgY2xlYXJcbiAgICAgKi9cblxuICAgIExHcmFwaC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gTEdyYXBoLlNUQVRVU19TVE9QUEVEO1xuXG4gICAgICAgIHRoaXMubGFzdF9ub2RlX2lkID0gMDtcbiAgICAgICAgdGhpcy5sYXN0X2xpbmtfaWQgPSAwO1xuXG4gICAgICAgIHRoaXMuX3ZlcnNpb24gPSAtMTsgLy91c2VkIHRvIGRldGVjdCBjaGFuZ2VzXG5cbiAgICAgICAgLy9zYWZlIGNsZWFyXG4gICAgICAgIGlmICh0aGlzLl9ub2Rlcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUub25SZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUub25SZW1vdmVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9ub2Rlc1xuICAgICAgICB0aGlzLl9ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLl9ub2Rlc19ieV9pZCA9IHt9O1xuICAgICAgICB0aGlzLl9ub2Rlc19pbl9vcmRlciA9IFtdOyAvL25vZGVzIHNvcnRlZCBpbiBleGVjdXRpb24gb3JkZXJcbiAgICAgICAgdGhpcy5fbm9kZXNfZXhlY3V0YWJsZSA9IG51bGw7IC8vbm9kZXMgdGhhdCBjb250YWluIG9uRXhlY3V0ZSBzb3J0ZWQgaW4gZXhlY3V0aW9uIG9yZGVyXG5cbiAgICAgICAgLy9vdGhlciBzY2VuZSBzdHVmZlxuICAgICAgICB0aGlzLl9ncm91cHMgPSBbXTtcblxuICAgICAgICAvL2xpbmtzXG4gICAgICAgIHRoaXMubGlua3MgPSB7fTsgLy9jb250YWluZXIgd2l0aCBhbGwgdGhlIGxpbmtzXG5cbiAgICAgICAgLy9pdGVyYXRpb25zXG4gICAgICAgIHRoaXMuaXRlcmF0aW9uID0gMDtcblxuICAgICAgICAvL2N1c3RvbSBkYXRhXG4gICAgICAgIHRoaXMuY29uZmlnID0ge307XG5cdFx0dGhpcy52YXJzID0ge307XG5cdFx0dGhpcy5leHRyYSA9IHt9OyAvL3RvIHN0b3JlIGN1c3RvbSBkYXRhXG5cbiAgICAgICAgLy90aW1pbmdcbiAgICAgICAgdGhpcy5nbG9iYWx0aW1lID0gMDtcbiAgICAgICAgdGhpcy5ydW5uaW5ndGltZSA9IDA7XG4gICAgICAgIHRoaXMuZml4ZWR0aW1lID0gMDtcbiAgICAgICAgdGhpcy5maXhlZHRpbWVfbGFwc2UgPSAwLjAxO1xuICAgICAgICB0aGlzLmVsYXBzZWRfdGltZSA9IDAuMDE7XG4gICAgICAgIHRoaXMubGFzdF91cGRhdGVfdGltZSA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnR0aW1lID0gMDtcblxuICAgICAgICB0aGlzLmNhdGNoX2Vycm9ycyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5ub2Rlc19leGVjdXRpbmcgPSBbXTtcbiAgICAgICAgdGhpcy5ub2Rlc19hY3Rpb25pbmcgPSBbXTtcbiAgICAgICAgdGhpcy5ub2Rlc19leGVjdXRlZEFjdGlvbiA9IFtdO1xuICAgICAgICBcbiAgICAgICAgLy9zdWJncmFwaF9kYXRhXG4gICAgICAgIHRoaXMuaW5wdXRzID0ge307XG4gICAgICAgIHRoaXMub3V0cHV0cyA9IHt9O1xuXG4gICAgICAgIC8vbm90aWZ5IGNhbnZhcyB0byByZWRyYXdcbiAgICAgICAgdGhpcy5jaGFuZ2UoKTtcblxuICAgICAgICB0aGlzLnNlbmRBY3Rpb25Ub0NhbnZhcyhcImNsZWFyXCIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggQ2FudmFzIHRvIHRoaXMgZ3JhcGhcbiAgICAgKiBAbWV0aG9kIGF0dGFjaENhbnZhc1xuICAgICAqIEBwYXJhbSB7R3JhcGhDYW52YXN9IGdyYXBoX2NhbnZhc1xuICAgICAqL1xuXG4gICAgTEdyYXBoLnByb3RvdHlwZS5hdHRhY2hDYW52YXMgPSBmdW5jdGlvbihncmFwaGNhbnZhcykge1xuICAgICAgICBpZiAoZ3JhcGhjYW52YXMuY29uc3RydWN0b3IgIT0gTEdyYXBoQ2FudmFzKSB7XG4gICAgICAgICAgICB0aHJvdyBcImF0dGFjaENhbnZhcyBleHBlY3RzIGEgTEdyYXBoQ2FudmFzIGluc3RhbmNlXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyYXBoY2FudmFzLmdyYXBoICYmIGdyYXBoY2FudmFzLmdyYXBoICE9IHRoaXMpIHtcbiAgICAgICAgICAgIGdyYXBoY2FudmFzLmdyYXBoLmRldGFjaENhbnZhcyhncmFwaGNhbnZhcyk7XG4gICAgICAgIH1cblxuICAgICAgICBncmFwaGNhbnZhcy5ncmFwaCA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCF0aGlzLmxpc3Rfb2ZfZ3JhcGhjYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdF9vZl9ncmFwaGNhbnZhcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdF9vZl9ncmFwaGNhbnZhcy5wdXNoKGdyYXBoY2FudmFzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGV0YWNoIENhbnZhcyBmcm9tIHRoaXMgZ3JhcGhcbiAgICAgKiBAbWV0aG9kIGRldGFjaENhbnZhc1xuICAgICAqIEBwYXJhbSB7R3JhcGhDYW52YXN9IGdyYXBoX2NhbnZhc1xuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuZGV0YWNoQ2FudmFzID0gZnVuY3Rpb24oZ3JhcGhjYW52YXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpc3Rfb2ZfZ3JhcGhjYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmxpc3Rfb2ZfZ3JhcGhjYW52YXMuaW5kZXhPZihncmFwaGNhbnZhcyk7XG4gICAgICAgIGlmIChwb3MgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBncmFwaGNhbnZhcy5ncmFwaCA9IG51bGw7XG4gICAgICAgIHRoaXMubGlzdF9vZl9ncmFwaGNhbnZhcy5zcGxpY2UocG9zLCAxKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHJ1bm5pbmcgdGhpcyBncmFwaCBldmVyeSBpbnRlcnZhbCBtaWxsaXNlY29uZHMuXG4gICAgICogQG1ldGhvZCBzdGFydFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbCBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIGJldHdlZW4gZXhlY3V0aW9ucywgaWYgMCB0aGVuIGl0IHJlbmRlcnMgdG8gdGhlIG1vbml0b3IgcmVmcmVzaCByYXRlXG4gICAgICovXG5cbiAgICBMR3JhcGgucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09IExHcmFwaC5TVEFUVVNfUlVOTklORykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdHVzID0gTEdyYXBoLlNUQVRVU19SVU5OSU5HO1xuXG4gICAgICAgIGlmICh0aGlzLm9uUGxheUV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLm9uUGxheUV2ZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlbmRFdmVudFRvQWxsTm9kZXMoXCJvblN0YXJ0XCIpO1xuXG4gICAgICAgIC8vbGF1bmNoXG4gICAgICAgIHRoaXMuc3RhcnR0aW1lID0gTGl0ZUdyYXBoLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5sYXN0X3VwZGF0ZV90aW1lID0gdGhpcy5zdGFydHRpbWU7XG4gICAgICAgIGludGVydmFsID0gaW50ZXJ2YWwgfHwgMDtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0Ly9leGVjdXRlIG9uY2UgcGVyIGZyYW1lXG4gICAgICAgIGlmICggaW50ZXJ2YWwgPT0gMCAmJiB0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uX2ZyYW1lKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGF0LmV4ZWN1dGlvbl90aW1lcl9pZCAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUob25fZnJhbWUpO1xuXHRcdFx0XHRpZih0aGF0Lm9uQmVmb3JlU3RlcClcblx0XHRcdFx0XHR0aGF0Lm9uQmVmb3JlU3RlcCgpO1xuICAgICAgICAgICAgICAgIHRoYXQucnVuU3RlcCgxLCAhdGhhdC5jYXRjaF9lcnJvcnMpO1xuXHRcdFx0XHRpZih0aGF0Lm9uQWZ0ZXJTdGVwKVxuXHRcdFx0XHRcdHRoYXQub25BZnRlclN0ZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXhlY3V0aW9uX3RpbWVyX2lkID0gLTE7XG4gICAgICAgICAgICBvbl9mcmFtZSgpO1xuICAgICAgICB9IGVsc2UgeyAvL2V4ZWN1dGUgZXZlcnkgJ2ludGVydmFsJyBtc1xuICAgICAgICAgICAgdGhpcy5leGVjdXRpb25fdGltZXJfaWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvL2V4ZWN1dGVcblx0XHRcdFx0aWYodGhhdC5vbkJlZm9yZVN0ZXApXG5cdFx0XHRcdFx0dGhhdC5vbkJlZm9yZVN0ZXAoKTtcbiAgICAgICAgICAgICAgICB0aGF0LnJ1blN0ZXAoMSwgIXRoYXQuY2F0Y2hfZXJyb3JzKTtcblx0XHRcdFx0aWYodGhhdC5vbkFmdGVyU3RlcClcblx0XHRcdFx0XHR0aGF0Lm9uQWZ0ZXJTdGVwKCk7XG4gICAgICAgICAgICB9LCBpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIGV4ZWN1dGlvbiBsb29wIG9mIHRoZSBncmFwaFxuICAgICAqIEBtZXRob2Qgc3RvcCBleGVjdXRpb25cbiAgICAgKi9cblxuICAgIExHcmFwaC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT0gTEdyYXBoLlNUQVRVU19TVE9QUEVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXR1cyA9IExHcmFwaC5TVEFUVVNfU1RPUFBFRDtcblxuICAgICAgICBpZiAodGhpcy5vblN0b3BFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5vblN0b3BFdmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uX3RpbWVyX2lkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4ZWN1dGlvbl90aW1lcl9pZCAhPSAtMSkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5leGVjdXRpb25fdGltZXJfaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5leGVjdXRpb25fdGltZXJfaWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZW5kRXZlbnRUb0FsbE5vZGVzKFwib25TdG9wXCIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSdW4gTiBzdGVwcyAoY3ljbGVzKSBvZiB0aGUgZ3JhcGhcbiAgICAgKiBAbWV0aG9kIHJ1blN0ZXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtIG51bWJlciBvZiBzdGVwcyB0byBydW4sIGRlZmF1bHQgaXMgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZG9fbm90X2NhdGNoX2Vycm9ycyBbb3B0aW9uYWxdIGlmIHlvdSB3YW50IHRvIHRyeS9jYXRjaCBlcnJvcnMgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IG1heCBudW1iZXIgb2Ygbm9kZXMgdG8gZXhlY3V0ZSAodXNlZCB0byBleGVjdXRlIGZyb20gc3RhcnQgdG8gYSBub2RlKVxuICAgICAqL1xuXG4gICAgTEdyYXBoLnByb3RvdHlwZS5ydW5TdGVwID0gZnVuY3Rpb24obnVtLCBkb19ub3RfY2F0Y2hfZXJyb3JzLCBsaW1pdCApIHtcbiAgICAgICAgbnVtID0gbnVtIHx8IDE7XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gTGl0ZUdyYXBoLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5nbG9iYWx0aW1lID0gMC4wMDEgKiAoc3RhcnQgLSB0aGlzLnN0YXJ0dGltZSk7XG5cbiAgICAgICAgLy9ub3Qgb3B0aW1hbDogZXhlY3V0ZXMgcG9zc2libGUgcGVuZGluZyBhY3Rpb25zIGluIG5vZGUsIHByb2JsZW0gaXMgaXQgaXMgbm90IG9wdGltaXplZFxuICAgICAgICAvL2l0IGlzIGRvbmUgaGVyZSBhcyBpZiBpdCB3YXMgZG9uZSBpbiB0aGUgbGF0ZXIgbG9vcCBpdCB3b250IGJlIGNhbGxlZCBpbiB0aGUgbm9kZSBtaXNzZWQgdGhlIG9uRXhlY3V0ZVxuICAgICAgICBcbiAgICAgICAgLy9mcm9tIG5vdyBvbiBpdCB3aWxsIGl0ZXJhdGUgb25seSBvbiBleGVjdXRhYmxlIG5vZGVzIHdoaWNoIGlzIGZhc3RlclxuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLl9ub2Rlc19leGVjdXRhYmxlXG4gICAgICAgICAgICA/IHRoaXMuX25vZGVzX2V4ZWN1dGFibGVcbiAgICAgICAgICAgIDogdGhpcy5fbm9kZXM7XG4gICAgICAgIGlmICghbm9kZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cdFx0bGltaXQgPSBsaW1pdCB8fCBub2Rlcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGRvX25vdF9jYXRjaF9lcnJvcnMpIHtcbiAgICAgICAgICAgIC8vaXRlcmF0aW9uc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGltaXQ7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZihMaXRlR3JhcGgudXNlX2RlZmVycmVkX2FjdGlvbnMgJiYgbm9kZS5fd2FpdGluZ19hY3Rpb25zICYmIG5vZGUuX3dhaXRpbmdfYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmV4ZWN1dGVQZW5kaW5nQWN0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5tb2RlID09IExpdGVHcmFwaC5BTFdBWVMgJiYgbm9kZS5vbkV4ZWN1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vd3JhcCBub2RlLm9uRXhlY3V0ZSgpO1xuXHRcdFx0XHRcdFx0bm9kZS5kb0V4ZWN1dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZml4ZWR0aW1lICs9IHRoaXMuZml4ZWR0aW1lX2xhcHNlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uRXhlY3V0ZVN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkV4ZWN1dGVTdGVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vbkFmdGVyRXhlY3V0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25BZnRlckV4ZWN1dGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy9jYXRjaCBlcnJvcnNcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy9pdGVyYXRpb25zXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbWl0OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihMaXRlR3JhcGgudXNlX2RlZmVycmVkX2FjdGlvbnMgJiYgbm9kZS5fd2FpdGluZ19hY3Rpb25zICYmIG5vZGUuX3dhaXRpbmdfYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5leGVjdXRlUGVuZGluZ0FjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm1vZGUgPT0gTGl0ZUdyYXBoLkFMV0FZUyAmJiBub2RlLm9uRXhlY3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUub25FeGVjdXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpeGVkdGltZSArPSB0aGlzLmZpeGVkdGltZV9sYXBzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub25FeGVjdXRlU3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkV4ZWN1dGVTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkFmdGVyRXhlY3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQWZ0ZXJFeGVjdXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzX2luX2V4ZWN1dGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnNfaW5fZXhlY3V0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLnRocm93X2Vycm9ycykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBkdXJpbmcgZXhlY3V0aW9uOiBcIiArIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vdyA9IExpdGVHcmFwaC5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBlbGFwc2VkID0gbm93IC0gc3RhcnQ7XG4gICAgICAgIGlmIChlbGFwc2VkID09IDApIHtcbiAgICAgICAgICAgIGVsYXBzZWQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uX3RpbWUgPSAwLjAwMSAqIGVsYXBzZWQ7XG4gICAgICAgIHRoaXMuZ2xvYmFsdGltZSArPSAwLjAwMSAqIGVsYXBzZWQ7XG4gICAgICAgIHRoaXMuaXRlcmF0aW9uICs9IDE7XG4gICAgICAgIHRoaXMuZWxhcHNlZF90aW1lID0gKG5vdyAtIHRoaXMubGFzdF91cGRhdGVfdGltZSkgKiAwLjAwMTtcbiAgICAgICAgdGhpcy5sYXN0X3VwZGF0ZV90aW1lID0gbm93O1xuICAgICAgICB0aGlzLm5vZGVzX2V4ZWN1dGluZyA9IFtdO1xuICAgICAgICB0aGlzLm5vZGVzX2FjdGlvbmluZyA9IFtdO1xuICAgICAgICB0aGlzLm5vZGVzX2V4ZWN1dGVkQWN0aW9uID0gW107XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdyYXBoIGV4ZWN1dGlvbiBvcmRlciBhY2NvcmRpbmcgdG8gcmVsZXZhbmNlIG9mIHRoZSBub2RlcyAobm9kZXMgd2l0aCBvbmx5IG91dHB1dHMgaGF2ZSBtb3JlIHJlbGV2YW5jZSB0aGFuXG4gICAgICogbm9kZXMgd2l0aCBvbmx5IGlucHV0cy5cbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUV4ZWN1dGlvbk9yZGVyXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS51cGRhdGVFeGVjdXRpb25PcmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9ub2Rlc19pbl9vcmRlciA9IHRoaXMuY29tcHV0ZUV4ZWN1dGlvbk9yZGVyKGZhbHNlKTtcbiAgICAgICAgdGhpcy5fbm9kZXNfZXhlY3V0YWJsZSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX25vZGVzX2luX29yZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbm9kZXNfaW5fb3JkZXJbaV0ub25FeGVjdXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZXNfZXhlY3V0YWJsZS5wdXNoKHRoaXMuX25vZGVzX2luX29yZGVyW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL1RoaXMgaXMgbW9yZSBpbnRlcm5hbCwgaXQgY29tcHV0ZXMgdGhlIGV4ZWN1dGFibGUgbm9kZXMgaW4gb3JkZXIgYW5kIHJldHVybnMgaXRcbiAgICBMR3JhcGgucHJvdG90eXBlLmNvbXB1dGVFeGVjdXRpb25PcmRlciA9IGZ1bmN0aW9uKFxuICAgICAgICBvbmx5X29uRXhlY3V0ZSxcbiAgICAgICAgc2V0X2xldmVsXG4gICAgKSB7XG4gICAgICAgIHZhciBMID0gW107XG4gICAgICAgIHZhciBTID0gW107XG4gICAgICAgIHZhciBNID0ge307XG4gICAgICAgIHZhciB2aXNpdGVkX2xpbmtzID0ge307IC8vdG8gYXZvaWQgcmVwZWF0aW5nIGxpbmtzXG4gICAgICAgIHZhciByZW1haW5pbmdfbGlua3MgPSB7fTsgLy90byBhXG5cbiAgICAgICAgLy9zZWFyY2ggZm9yIHRoZSBub2RlcyB3aXRob3V0IGlucHV0cyAoc3RhcnRpbmcgbm9kZXMpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fbm9kZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKG9ubHlfb25FeGVjdXRlICYmICFub2RlLm9uRXhlY3V0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBNW25vZGUuaWRdID0gbm9kZTsgLy9hZGQgdG8gcGVuZGluZyBub2Rlc1xuXG4gICAgICAgICAgICB2YXIgbnVtID0gMDsgLy9udW0gb2YgaW5wdXQgY29ubmVjdGlvbnNcbiAgICAgICAgICAgIGlmIChub2RlLmlucHV0cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsMiA9IG5vZGUuaW5wdXRzLmxlbmd0aDsgaiA8IGwyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaW5wdXRzW2pdICYmIG5vZGUuaW5wdXRzW2pdLmxpbmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChudW0gPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vaXMgYSBzdGFydGluZyBub2RlXG4gICAgICAgICAgICAgICAgUy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChzZXRfbGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fbGV2ZWwgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy9udW0gb2YgaW5wdXQgbGlua3NcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzZXRfbGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fbGV2ZWwgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW1haW5pbmdfbGlua3Nbbm9kZS5pZF0gPSBudW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKFMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9nZXQgYW4gc3RhcnRpbmcgbm9kZVxuICAgICAgICAgICAgdmFyIG5vZGUgPSBTLnNoaWZ0KCk7XG4gICAgICAgICAgICBMLnB1c2gobm9kZSk7IC8vYWRkIHRvIG9yZGVyZWQgbGlzdFxuICAgICAgICAgICAgZGVsZXRlIE1bbm9kZS5pZF07IC8vcmVtb3ZlIGZyb20gdGhlIHBlbmRpbmcgbm9kZXNcblxuICAgICAgICAgICAgaWYgKCFub2RlLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9mb3IgZXZlcnkgb3V0cHV0XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUub3V0cHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBub2RlLm91dHB1dHNbaV07XG4gICAgICAgICAgICAgICAgLy9ub3QgY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQubGlua3MgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQubGlua3MubGVuZ3RoID09IDBcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9mb3IgZXZlcnkgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3V0cHV0LmxpbmtzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5rX2lkID0gb3V0cHV0LmxpbmtzW2pdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluayA9IHRoaXMubGlua3NbbGlua19pZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL2FscmVhZHkgdmlzaXRlZCBsaW5rIChpZ25vcmUgaXQpXG4gICAgICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkX2xpbmtzW2xpbmsuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRfbm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5SWQobGluay50YXJnZXRfaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0X25vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZF9saW5rc1tsaW5rLmlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldF9sZXZlbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCF0YXJnZXRfbm9kZS5fbGV2ZWwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRfbm9kZS5fbGV2ZWwgPD0gbm9kZS5fbGV2ZWwpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X25vZGUuX2xldmVsID0gbm9kZS5fbGV2ZWwgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZF9saW5rc1tsaW5rLmlkXSA9IHRydWU7IC8vbWFyayBhcyB2aXNpdGVkXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ19saW5rc1t0YXJnZXRfbm9kZS5pZF0gLT0gMTsgLy9yZWR1Y2UgdGhlIG51bWJlciBvZiBsaW5rcyByZW1haW5pbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZ19saW5rc1t0YXJnZXRfbm9kZS5pZF0gPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUy5wdXNoKHRhcmdldF9ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSAvL2lmIG5vIG1vcmUgbGlua3MsIHRoZW4gYWRkIHRvIHN0YXJ0ZXJzIGFycmF5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy90aGUgcmVtYWluaW5nIG9uZXMgKGxvb3BzKVxuICAgICAgICBmb3IgKHZhciBpIGluIE0pIHtcbiAgICAgICAgICAgIEwucHVzaChNW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChMLmxlbmd0aCAhPSB0aGlzLl9ub2Rlcy5sZW5ndGggJiYgTGl0ZUdyYXBoLmRlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJzb21ldGhpbmcgd2VudCB3cm9uZywgbm9kZXMgbWlzc2luZ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsID0gTC5sZW5ndGg7XG5cbiAgICAgICAgLy9zYXZlIG9yZGVyIG51bWJlciBpbiB0aGUgbm9kZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgTFtpXS5vcmRlciA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICAvL3NvcnQgbm93IGJ5IHByaW9yaXR5XG4gICAgICAgIEwgPSBMLnNvcnQoZnVuY3Rpb24oQSwgQikge1xuICAgICAgICAgICAgdmFyIEFwID0gQS5jb25zdHJ1Y3Rvci5wcmlvcml0eSB8fCBBLnByaW9yaXR5IHx8IDA7XG4gICAgICAgICAgICB2YXIgQnAgPSBCLmNvbnN0cnVjdG9yLnByaW9yaXR5IHx8IEIucHJpb3JpdHkgfHwgMDtcbiAgICAgICAgICAgIGlmIChBcCA9PSBCcCkge1xuICAgICAgICAgICAgICAgIC8vaWYgc2FtZSBwcmlvcml0eSwgc29ydCBieSBvcmRlclxuICAgICAgICAgICAgICAgIHJldHVybiBBLm9yZGVyIC0gQi5vcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBcCAtIEJwOyAvL3NvcnQgYnkgcHJpb3JpdHlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9zYXZlIG9yZGVyIG51bWJlciBpbiB0aGUgbm9kZSwgYWdhaW4uLi5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIExbaV0ub3JkZXIgPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIHRoZSBub2RlcyB0aGF0IGNvdWxkIGFmZmVjdCB0aGlzIG9uZSAoYW5jZXN0b3JzKSBieSBjcmF3bGluZyBhbGwgdGhlIGlucHV0cyByZWN1cnNpdmVseS5cbiAgICAgKiBJdCBkb2Vzbid0IGluY2x1ZGUgdGhlIG5vZGUgaXRzZWxmXG4gICAgICogQG1ldGhvZCBnZXRBbmNlc3RvcnNcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgd2l0aCBhbGwgdGhlIExHcmFwaE5vZGVzIHRoYXQgYWZmZWN0IHRoaXMgbm9kZSwgaW4gb3JkZXIgb2YgZXhlY3V0aW9uXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5nZXRBbmNlc3RvcnMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBhbmNlc3RvcnMgPSBbXTtcbiAgICAgICAgdmFyIHBlbmRpbmcgPSBbbm9kZV07XG4gICAgICAgIHZhciB2aXNpdGVkID0ge307XG5cbiAgICAgICAgd2hpbGUgKHBlbmRpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHBlbmRpbmcuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICghY3VycmVudC5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtjdXJyZW50LmlkXSAmJiBjdXJyZW50ICE9IG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2aXNpdGVkW2N1cnJlbnQuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhbmNlc3RvcnMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyZW50LmlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IGN1cnJlbnQuZ2V0SW5wdXROb2RlKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCAmJiBhbmNlc3RvcnMuaW5kZXhPZihpbnB1dCkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZy5wdXNoKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhbmNlc3RvcnMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYW5jZXN0b3JzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbnMgZXZlcnkgbm9kZSBpbiBhIG1vcmUgcmVhZGFibGUgbWFubmVyXG4gICAgICogQG1ldGhvZCBhcnJhbmdlXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5hcnJhbmdlID0gZnVuY3Rpb24gKG1hcmdpbiwgbGF5b3V0KSB7XG4gICAgICAgIG1hcmdpbiA9IG1hcmdpbiB8fCAxMDA7XG5cbiAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLmNvbXB1dGVFeGVjdXRpb25PcmRlcihmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgY29uc3QgY29sID0gbm9kZS5fbGV2ZWwgfHwgMTtcbiAgICAgICAgICAgIGlmICghY29sdW1uc1tjb2xdKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uc1tjb2xdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2x1bW5zW2NvbF0ucHVzaChub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB4ID0gbWFyZ2luO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgY29sdW1uID0gY29sdW1uc1tpXTtcbiAgICAgICAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbWF4X3NpemUgPSAxMDA7XG4gICAgICAgICAgICBsZXQgeSA9IG1hcmdpbiArIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNvbHVtbltqXTtcbiAgICAgICAgICAgICAgICBub2RlLnBvc1swXSA9IChsYXlvdXQgPT0gTGl0ZUdyYXBoLlZFUlRJQ0FMX0xBWU9VVCkgPyB5IDogeDtcbiAgICAgICAgICAgICAgICBub2RlLnBvc1sxXSA9IChsYXlvdXQgPT0gTGl0ZUdyYXBoLlZFUlRJQ0FMX0xBWU9VVCkgPyB4IDogeTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhfc2l6ZV9pbmRleCA9IChsYXlvdXQgPT0gTGl0ZUdyYXBoLlZFUlRJQ0FMX0xBWU9VVCkgPyAxIDogMDtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5zaXplW21heF9zaXplX2luZGV4XSA+IG1heF9zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heF9zaXplID0gbm9kZS5zaXplW21heF9zaXplX2luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZV9zaXplX2luZGV4ID0gKGxheW91dCA9PSBMaXRlR3JhcGguVkVSVElDQUxfTEFZT1VUKSA/IDAgOiAxO1xuICAgICAgICAgICAgICAgIHkgKz0gbm9kZS5zaXplW25vZGVfc2l6ZV9pbmRleF0gKyBtYXJnaW4gKyBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ICs9IG1heF9zaXplICsgbWFyZ2luO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYW1vdW50IG9mIHRpbWUgdGhlIGdyYXBoIGhhcyBiZWVuIHJ1bm5pbmcgaW4gbWlsbGlzZWNvbmRzXG4gICAgICogQG1ldGhvZCBnZXRUaW1lXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoZSBncmFwaCBoYXMgYmVlbiBydW5uaW5nXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5nZXRUaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdsb2JhbHRpbWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFtb3VudCBvZiB0aW1lIGFjY3VtdWxhdGVkIHVzaW5nIHRoZSBmaXhlZHRpbWVfbGFwc2UgdmFyLiBUaGlzIGlzIHVzZWQgaW4gY29udGV4dCB3aGVyZSB0aGUgdGltZSBpbmNyZW1lbnRzIHNob3VsZCBiZSBjb25zdGFudFxuICAgICAqIEBtZXRob2QgZ2V0Rml4ZWRUaW1lXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoZSBncmFwaCBoYXMgYmVlbiBydW5uaW5nXG4gICAgICovXG5cbiAgICBMR3JhcGgucHJvdG90eXBlLmdldEZpeGVkVGltZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maXhlZHRpbWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFtb3VudCBvZiB0aW1lIGl0IHRvb2sgdG8gY29tcHV0ZSB0aGUgbGF0ZXN0IGl0ZXJhdGlvbi4gVGFrZSBpbnRvIGFjY291bnQgdGhhdCB0aGlzIG51bWJlciBjb3VsZCBiZSBub3QgY29ycmVjdFxuICAgICAqIGlmIHRoZSBub2RlcyBhcmUgdXNpbmcgZ3JhcGhpY2FsIGFjdGlvbnNcbiAgICAgKiBAbWV0aG9kIGdldEVsYXBzZWRUaW1lXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgdGhlIGxhc3QgY3ljbGVcbiAgICAgKi9cblxuICAgIExHcmFwaC5wcm90b3R5cGUuZ2V0RWxhcHNlZFRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxhcHNlZF90aW1lO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhbiBldmVudCB0byBhbGwgdGhlIG5vZGVzLCB1c2VmdWwgdG8gdHJpZ2dlciBzdHVmZlxuICAgICAqIEBtZXRob2Qgc2VuZEV2ZW50VG9BbGxOb2Rlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudG5hbWUgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IChmdW5jdGlvbiB0byBiZSBjYWxsZWQpXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIHBhcmFtZXRlcnMgaW4gYXJyYXkgZm9ybWF0XG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5zZW5kRXZlbnRUb0FsbE5vZGVzID0gZnVuY3Rpb24oZXZlbnRuYW1lLCBwYXJhbXMsIG1vZGUpIHtcbiAgICAgICAgbW9kZSA9IG1vZGUgfHwgTGl0ZUdyYXBoLkFMV0FZUztcblxuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLl9ub2Rlc19pbl9vcmRlciA/IHRoaXMuX25vZGVzX2luX29yZGVyIDogdGhpcy5fbm9kZXM7XG4gICAgICAgIGlmICghbm9kZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBqIDwgbDsgKytqKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2pdO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbm9kZS5jb25zdHJ1Y3RvciA9PT0gTGl0ZUdyYXBoLlN1YmdyYXBoICYmXG4gICAgICAgICAgICAgICAgZXZlbnRuYW1lICE9IFwib25FeGVjdXRlXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm1vZGUgPT0gbW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNlbmRFdmVudFRvQWxsTm9kZXMoZXZlbnRuYW1lLCBwYXJhbXMsIG1vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFub2RlW2V2ZW50bmFtZV0gfHwgbm9kZS5tb2RlICE9IG1vZGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5vZGVbZXZlbnRuYW1lXSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMgJiYgcGFyYW1zLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgICAgIG5vZGVbZXZlbnRuYW1lXS5hcHBseShub2RlLCBwYXJhbXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlW2V2ZW50bmFtZV0ocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMR3JhcGgucHJvdG90eXBlLnNlbmRBY3Rpb25Ub0NhbnZhcyA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW1zKSB7XG4gICAgICAgIGlmICghdGhpcy5saXN0X29mX2dyYXBoY2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdF9vZl9ncmFwaGNhbnZhcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmxpc3Rfb2ZfZ3JhcGhjYW52YXNbaV07XG4gICAgICAgICAgICBpZiAoY1thY3Rpb25dKSB7XG4gICAgICAgICAgICAgICAgY1thY3Rpb25dLmFwcGx5KGMsIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBub2RlIGluc3RhbmNlIHRvIHRoaXMgZ3JhcGhcbiAgICAgKiBAbWV0aG9kIGFkZFxuICAgICAqIEBwYXJhbSB7TEdyYXBoTm9kZX0gbm9kZSB0aGUgaW5zdGFuY2Ugb2YgdGhlIG5vZGVcbiAgICAgKi9cblxuICAgIExHcmFwaC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obm9kZSwgc2tpcF9jb21wdXRlX29yZGVyKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9ncm91cHNcbiAgICAgICAgaWYgKG5vZGUuY29uc3RydWN0b3IgPT09IExHcmFwaEdyb3VwKSB7XG4gICAgICAgICAgICB0aGlzLl9ncm91cHMucHVzaChub2RlKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZSgpO1xuICAgICAgICAgICAgbm9kZS5ncmFwaCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl92ZXJzaW9uKys7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL25vZGVzXG4gICAgICAgIGlmIChub2RlLmlkICE9IC0xICYmIHRoaXMuX25vZGVzX2J5X2lkW25vZGUuaWRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcIkxpdGVHcmFwaDogdGhlcmUgaXMgYWxyZWFkeSBhIG5vZGUgd2l0aCB0aGlzIElELCBjaGFuZ2luZyBpdFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKExpdGVHcmFwaC51c2VfdXVpZHMpIHtcbiAgICAgICAgICAgICAgICBub2RlLmlkID0gTGl0ZUdyYXBoLnV1aWR2NCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS5pZCA9ICsrdGhpcy5sYXN0X25vZGVfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbm9kZXMubGVuZ3RoID49IExpdGVHcmFwaC5NQVhfTlVNQkVSX09GX05PREVTKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkxpdGVHcmFwaDogbWF4IG51bWJlciBvZiBub2RlcyBpbiBhIGdyYXBoIHJlYWNoZWRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZ2l2ZSBoaW0gYW4gaWRcbiAgICAgICAgaWYgKExpdGVHcmFwaC51c2VfdXVpZHMpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlkID09IG51bGwgfHwgbm9kZS5pZCA9PSAtMSlcbiAgICAgICAgICAgICAgICBub2RlLmlkID0gTGl0ZUdyYXBoLnV1aWR2NCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT0gbnVsbCB8fCBub2RlLmlkID09IC0xKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5pZCA9ICsrdGhpcy5sYXN0X25vZGVfaWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFzdF9ub2RlX2lkIDwgbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdF9ub2RlX2lkID0gbm9kZS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuZ3JhcGggPSB0aGlzO1xuICAgICAgICB0aGlzLl92ZXJzaW9uKys7XG5cbiAgICAgICAgdGhpcy5fbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5fbm9kZXNfYnlfaWRbbm9kZS5pZF0gPSBub2RlO1xuXG4gICAgICAgIGlmIChub2RlLm9uQWRkZWQpIHtcbiAgICAgICAgICAgIG5vZGUub25BZGRlZCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5hbGlnbl90b19ncmlkKSB7XG4gICAgICAgICAgICBub2RlLmFsaWduVG9HcmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNraXBfY29tcHV0ZV9vcmRlcikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFeGVjdXRpb25PcmRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub25Ob2RlQWRkZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25Ob2RlQWRkZWQobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUpO1xuICAgICAgICB0aGlzLmNoYW5nZSgpO1xuXG4gICAgICAgIHJldHVybiBub2RlOyAvL3RvIGNoYWluIGFjdGlvbnNcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGUgZ3JhcGhcbiAgICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgICAqIEBwYXJhbSB7TEdyYXBoTm9kZX0gbm9kZSB0aGUgaW5zdGFuY2Ugb2YgdGhlIG5vZGVcbiAgICAgKi9cblxuICAgIExHcmFwaC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAobm9kZS5jb25zdHJ1Y3RvciA9PT0gTGl0ZUdyYXBoLkxHcmFwaEdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9ncm91cHMuaW5kZXhPZihub2RlKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dyb3Vwcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5ncmFwaCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl92ZXJzaW9uKys7XG4gICAgICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ub2Rlc19ieV9pZFtub2RlLmlkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy9ub3QgZm91bmRcblxuICAgICAgICBpZiAobm9kZS5pZ25vcmVfcmVtb3ZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy9jYW5ub3QgYmUgcmVtb3ZlZFxuXG5cdFx0dGhpcy5iZWZvcmVDaGFuZ2UoKTsgLy9zdXJlPyAtIGFsbW9zdCBzdXJlIGlzIHdyb25nXG5cbiAgICAgICAgLy9kaXNjb25uZWN0IGlucHV0c1xuICAgICAgICBpZiAobm9kZS5pbnB1dHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5pbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IG5vZGUuaW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzbG90LmxpbmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmRpc2Nvbm5lY3RJbnB1dChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2Rpc2Nvbm5lY3Qgb3V0cHV0c1xuICAgICAgICBpZiAobm9kZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUub3V0cHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzbG90ID0gbm9kZS5vdXRwdXRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzbG90LmxpbmtzICE9IG51bGwgJiYgc2xvdC5saW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kaXNjb25uZWN0T3V0cHV0KGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vbm9kZS5pZCA9IC0xOyAvL3doeT9cblxuICAgICAgICAvL2NhbGxiYWNrXG4gICAgICAgIGlmIChub2RlLm9uUmVtb3ZlZCkge1xuICAgICAgICAgICAgbm9kZS5vblJlbW92ZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuZ3JhcGggPSBudWxsO1xuICAgICAgICB0aGlzLl92ZXJzaW9uKys7XG5cbiAgICAgICAgLy9yZW1vdmUgZnJvbSBjYW52YXMgcmVuZGVyXG4gICAgICAgIGlmICh0aGlzLmxpc3Rfb2ZfZ3JhcGhjYW52YXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0X29mX2dyYXBoY2FudmFzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMubGlzdF9vZl9ncmFwaGNhbnZhc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FudmFzLnNlbGVjdGVkX25vZGVzW25vZGUuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYW52YXMuc2VsZWN0ZWRfbm9kZXNbbm9kZS5pZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYW52YXMubm9kZV9kcmFnZ2VkID09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLm5vZGVfZHJhZ2dlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9yZW1vdmUgZnJvbSBjb250YWluZXJzXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLl9ub2Rlcy5pbmRleE9mKG5vZGUpO1xuICAgICAgICBpZiAocG9zICE9IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5zcGxpY2UocG9zLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fbm9kZXNfYnlfaWRbbm9kZS5pZF07XG5cbiAgICAgICAgaWYgKHRoaXMub25Ob2RlUmVtb3ZlZCkge1xuICAgICAgICAgICAgdGhpcy5vbk5vZGVSZW1vdmVkKG5vZGUpO1xuICAgICAgICB9XG5cblx0XHQvL2Nsb3NlIHBhbmVsc1xuXHRcdHRoaXMuc2VuZEFjdGlvblRvQ2FudmFzKFwiY2hlY2tQYW5lbHNcIik7XG5cbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcblx0XHR0aGlzLmFmdGVyQ2hhbmdlKCk7IC8vc3VyZT8gLSBhbG1vc3Qgc3VyZSBpcyB3cm9uZ1xuICAgICAgICB0aGlzLmNoYW5nZSgpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRXhlY3V0aW9uT3JkZXIoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5vZGUgYnkgaXRzIGlkLlxuICAgICAqIEBtZXRob2QgZ2V0Tm9kZUJ5SWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWRcbiAgICAgKi9cblxuICAgIExHcmFwaC5wcm90b3R5cGUuZ2V0Tm9kZUJ5SWQgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVzX2J5X2lkW2lkXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm9kZXMgdGhhdCBtYXRjaGVzIGEgY2xhc3NcbiAgICAgKiBAbWV0aG9kIGZpbmROb2Rlc0J5Q2xhc3NcbiAgICAgKiBAcGFyYW0ge0NsYXNzfSBjbGFzc09iamVjdCB0aGUgY2xhc3MgaXRzZWxmIChub3QgYW4gc3RyaW5nKVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhIGxpc3Qgd2l0aCBhbGwgdGhlIG5vZGVzIG9mIHRoaXMgdHlwZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuZmluZE5vZGVzQnlDbGFzcyA9IGZ1bmN0aW9uKGNsYXNzT2JqZWN0LCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuICAgICAgICByZXN1bHQubGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ub2Rlc1tpXS5jb25zdHJ1Y3RvciA9PT0gY2xhc3NPYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLl9ub2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm9kZXMgdGhhdCBtYXRjaGVzIGEgdHlwZVxuICAgICAqIEBtZXRob2QgZmluZE5vZGVzQnlUeXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG5hbWUgb2YgdGhlIG5vZGUgdHlwZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhIGxpc3Qgd2l0aCBhbGwgdGhlIG5vZGVzIG9mIHRoaXMgdHlwZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuZmluZE5vZGVzQnlUeXBlID0gZnVuY3Rpb24odHlwZSwgcmVzdWx0KSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XG4gICAgICAgIHJlc3VsdC5sZW5ndGggPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX25vZGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25vZGVzW2ldLnR5cGUudG9Mb3dlckNhc2UoKSA9PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5fbm9kZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IG5vZGUgdGhhdCBtYXRjaGVzIGEgbmFtZSBpbiBpdHMgdGl0bGVcbiAgICAgKiBAbWV0aG9kIGZpbmROb2RlQnlUaXRsZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBub2RlIHRvIHNlYXJjaFxuICAgICAqIEByZXR1cm4ge05vZGV9IHRoZSBub2RlIG9yIG51bGxcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLmZpbmROb2RlQnlUaXRsZSA9IGZ1bmN0aW9uKHRpdGxlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fbm9kZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbm9kZXNbaV0udGl0bGUgPT0gdGl0bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vZGVzIHRoYXQgbWF0Y2hlcyBhIG5hbWVcbiAgICAgKiBAbWV0aG9kIGZpbmROb2Rlc0J5VGl0bGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgbm9kZSB0byBzZWFyY2hcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYSBsaXN0IHdpdGggYWxsIHRoZSBub2RlcyB3aXRoIHRoaXMgbmFtZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuZmluZE5vZGVzQnlUaXRsZSA9IGZ1bmN0aW9uKHRpdGxlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ub2Rlc1tpXS50aXRsZSA9PSB0aXRsZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuX25vZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0b3AtbW9zdCBub2RlIGluIHRoaXMgcG9zaXRpb24gb2YgdGhlIGNhbnZhc1xuICAgICAqIEBtZXRob2QgZ2V0Tm9kZU9uUG9zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggdGhlIHggY29vcmRpbmF0ZSBpbiBjYW52YXMgc3BhY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSB0aGUgeSBjb29yZGluYXRlIGluIGNhbnZhcyBzcGFjZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG5vZGVzX2xpc3QgYSBsaXN0IHdpdGggYWxsIHRoZSBub2RlcyB0byBzZWFyY2ggZnJvbSwgYnkgZGVmYXVsdCBpcyBhbGwgdGhlIG5vZGVzIGluIHRoZSBncmFwaFxuICAgICAqIEByZXR1cm4ge0xHcmFwaE5vZGV9IHRoZSBub2RlIGF0IHRoaXMgcG9zaXRpb24gb3IgbnVsbFxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuZ2V0Tm9kZU9uUG9zID0gZnVuY3Rpb24oeCwgeSwgbm9kZXNfbGlzdCwgbWFyZ2luKSB7XG4gICAgICAgIG5vZGVzX2xpc3QgPSBub2Rlc19saXN0IHx8IHRoaXMuX25vZGVzO1xuXHRcdHZhciBuUmV0ID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IG5vZGVzX2xpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBuID0gbm9kZXNfbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChuLmlzUG9pbnRJbnNpZGUoeCwgeSwgbWFyZ2luKSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBsZXNzZXIgaW50ZXJlc3Qgbm9kZXMgKFRPRE8gY2hlY2sgZm9yIG92ZXJsYXBwaW5nLCB1c2UgdGhlIHRvcClcblx0XHRcdFx0LyppZiAodHlwZW9mIG4gPT0gXCJMR3JhcGhHcm91cFwiKXtcblx0XHRcdFx0XHRuUmV0ID0gbjtcblx0XHRcdFx0fWVsc2V7Ki9cblx0XHRcdFx0XHRyZXR1cm4gbjtcblx0XHRcdFx0Lyp9Ki9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gblJldDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG9wLW1vc3QgZ3JvdXAgaW4gdGhhdCBwb3NpdGlvblxuICAgICAqIEBtZXRob2QgZ2V0R3JvdXBPblBvc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHRoZSB4IGNvb3JkaW5hdGUgaW4gY2FudmFzIHNwYWNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgdGhlIHkgY29vcmRpbmF0ZSBpbiBjYW52YXMgc3BhY2VcbiAgICAgKiBAcmV0dXJuIHtMR3JhcGhHcm91cH0gdGhlIGdyb3VwIG9yIG51bGxcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLmdldEdyb3VwT25Qb3MgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9ncm91cHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBnID0gdGhpcy5fZ3JvdXBzW2ldO1xuICAgICAgICAgICAgaWYgKGcuaXNQb2ludEluc2lkZSh4LCB5LCAyLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhhdCB0aGUgbm9kZSB0eXBlIG1hdGNoZXMgdGhlIG5vZGUgdHlwZSByZWdpc3RlcmVkLCB1c2VkIHdoZW4gcmVwbGFjaW5nIGEgbm9kZXR5cGUgYnkgYSBuZXdlciB2ZXJzaW9uIGR1cmluZyBleGVjdXRpb25cbiAgICAgKiB0aGlzIHJlcGxhY2VzIHRoZSBvbmVzIHVzaW5nIHRoZSBvbGQgdmVyc2lvbiB3aXRoIHRoZSBuZXcgdmVyc2lvblxuICAgICAqIEBtZXRob2QgY2hlY2tOb2RlVHlwZXNcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLmNoZWNrTm9kZVR5cGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZXNbaV07XG4gICAgICAgICAgICB2YXIgY3RvciA9IExpdGVHcmFwaC5yZWdpc3RlcmVkX25vZGVfdHlwZXNbbm9kZS50eXBlXTtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbnN0cnVjdG9yID09IGN0b3IpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibm9kZSBiZWluZyByZXBsYWNlZCBieSBuZXdlciB2ZXJzaW9uOiBcIiArIG5vZGUudHlwZSk7XG4gICAgICAgICAgICB2YXIgbmV3bm9kZSA9IExpdGVHcmFwaC5jcmVhdGVOb2RlKG5vZGUudHlwZSk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX25vZGVzW2ldID0gbmV3bm9kZTtcbiAgICAgICAgICAgIG5ld25vZGUuY29uZmlndXJlKG5vZGUuc2VyaWFsaXplKCkpO1xuICAgICAgICAgICAgbmV3bm9kZS5ncmFwaCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlc19ieV9pZFtuZXdub2RlLmlkXSA9IG5ld25vZGU7XG4gICAgICAgICAgICBpZiAobm9kZS5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBuZXdub2RlLmlucHV0cyA9IG5vZGUuaW5wdXRzLmNvbmNhdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUub3V0cHV0cykge1xuICAgICAgICAgICAgICAgIG5ld25vZGUub3V0cHV0cyA9IG5vZGUub3V0cHV0cy5jb25jYXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUV4ZWN1dGlvbk9yZGVyKCk7XG4gICAgfTtcblxuICAgIC8vICoqKioqKioqKiogR0xPQkFMUyAqKioqKioqKioqKioqKioqKlxuXG4gICAgTEdyYXBoLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5faW5wdXRfbm9kZXMgPSB0aGlzLmZpbmROb2Rlc0J5Q2xhc3MoXG4gICAgICAgICAgICBMaXRlR3JhcGguR3JhcGhJbnB1dCxcbiAgICAgICAgICAgIHRoaXMuX2lucHV0X25vZGVzXG4gICAgICAgICk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW5wdXRfbm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5faW5wdXRfbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobm9kZS5wcm9wZXJ0aWVzLm5hbWUgIT0gYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3dyYXAgbm9kZS5vbkFjdGlvbihhY3Rpb24sIHBhcmFtKTtcbiAgICAgICAgICAgIG5vZGUuYWN0aW9uRG8oYWN0aW9uLCBwYXJhbSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMR3JhcGgucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XG4gICAgICAgIGlmICh0aGlzLm9uVHJpZ2dlcikge1xuICAgICAgICAgICAgdGhpcy5vblRyaWdnZXIoYWN0aW9uLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVsbCB0aGlzIGdyYXBoIGl0IGhhcyBhIGdsb2JhbCBncmFwaCBpbnB1dCBvZiB0aGlzIHR5cGVcbiAgICAgKiBAbWV0aG9kIGFkZEdsb2JhbElucHV0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgW29wdGlvbmFsXVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuYWRkSW5wdXQgPSBmdW5jdGlvbihuYW1lLCB0eXBlLCB2YWx1ZSkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tuYW1lXTtcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAvL2FscmVhZHkgZXhpc3RcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cdFx0dGhpcy5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5pbnB1dHNbbmFtZV0gPSB7IG5hbWU6IG5hbWUsIHR5cGU6IHR5cGUsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICB0aGlzLl92ZXJzaW9uKys7XG5cdFx0dGhpcy5hZnRlckNoYW5nZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLm9uSW5wdXRBZGRlZCkge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0QWRkZWQobmFtZSwgdHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vbklucHV0c091dHB1dHNDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25JbnB1dHNPdXRwdXRzQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXNzaWduIGEgZGF0YSB0byB0aGUgZ2xvYmFsIGdyYXBoIGlucHV0XG4gICAgICogQG1ldGhvZCBzZXRHbG9iYWxJbnB1dERhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuc2V0SW5wdXREYXRhID0gZnVuY3Rpb24obmFtZSwgZGF0YSkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tuYW1lXTtcbiAgICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0LnZhbHVlID0gZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIGdsb2JhbCBncmFwaCBpbnB1dFxuICAgICAqIEBtZXRob2QgZ2V0SW5wdXREYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHsqfSB0aGUgZGF0YVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuZ2V0SW5wdXREYXRhID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tuYW1lXTtcbiAgICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnZhbHVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBuYW1lIG9mIGEgZ2xvYmFsIGdyYXBoIGlucHV0XG4gICAgICogQG1ldGhvZCByZW5hbWVJbnB1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRfbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuZXdfbmFtZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUucmVuYW1lSW5wdXQgPSBmdW5jdGlvbihvbGRfbmFtZSwgbmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PSBvbGRfbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmlucHV0c1tvbGRfbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlucHV0c1tuYW1lXSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcInRoZXJlIGlzIGFscmVhZHkgb25lIGlucHV0IHdpdGggdGhhdCBuYW1lXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnB1dHNbbmFtZV0gPSB0aGlzLmlucHV0c1tvbGRfbmFtZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmlucHV0c1tvbGRfbmFtZV07XG4gICAgICAgIHRoaXMuX3ZlcnNpb24rKztcblxuICAgICAgICBpZiAodGhpcy5vbklucHV0UmVuYW1lZCkge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0UmVuYW1lZChvbGRfbmFtZSwgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vbklucHV0c091dHB1dHNDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25JbnB1dHNPdXRwdXRzQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgdHlwZSBvZiBhIGdsb2JhbCBncmFwaCBpbnB1dFxuICAgICAqIEBtZXRob2QgY2hhbmdlSW5wdXRUeXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuY2hhbmdlSW5wdXRUeXBlID0gZnVuY3Rpb24obmFtZSwgdHlwZSkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzW25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmlucHV0c1tuYW1lXS50eXBlICYmXG4gICAgICAgICAgICBTdHJpbmcodGhpcy5pbnB1dHNbbmFtZV0udHlwZSkudG9Mb3dlckNhc2UoKSA9PVxuICAgICAgICAgICAgICAgIFN0cmluZyh0eXBlKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnB1dHNbbmFtZV0udHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX3ZlcnNpb24rKztcbiAgICAgICAgaWYgKHRoaXMub25JbnB1dFR5cGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLm9uSW5wdXRUeXBlQ2hhbmdlZChuYW1lLCB0eXBlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgZ2xvYmFsIGdyYXBoIGlucHV0XG4gICAgICogQG1ldGhvZCByZW1vdmVJbnB1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLnJlbW92ZUlucHV0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzW25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgdGhpcy5pbnB1dHNbbmFtZV07XG4gICAgICAgIHRoaXMuX3ZlcnNpb24rKztcblxuICAgICAgICBpZiAodGhpcy5vbklucHV0UmVtb3ZlZCkge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0UmVtb3ZlZChuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9uSW5wdXRzT3V0cHV0c0NoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0c091dHB1dHNDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGdsb2JhbCBncmFwaCBvdXRwdXRcbiAgICAgKiBAbWV0aG9kIGFkZE91dHB1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5hZGRPdXRwdXQgPSBmdW5jdGlvbihuYW1lLCB0eXBlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm91dHB1dHNbbmFtZV0gPSB7IG5hbWU6IG5hbWUsIHR5cGU6IHR5cGUsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICB0aGlzLl92ZXJzaW9uKys7XG5cbiAgICAgICAgaWYgKHRoaXMub25PdXRwdXRBZGRlZCkge1xuICAgICAgICAgICAgdGhpcy5vbk91dHB1dEFkZGVkKG5hbWUsIHR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub25JbnB1dHNPdXRwdXRzQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLm9uSW5wdXRzT3V0cHV0c0NoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFzc2lnbiBhIGRhdGEgdG8gdGhlIGdsb2JhbCBvdXRwdXRcbiAgICAgKiBAbWV0aG9kIHNldE91dHB1dERhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuc2V0T3V0cHV0RGF0YSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbbmFtZV07XG4gICAgICAgIGlmICghb3V0cHV0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnZhbHVlID0gdmFsdWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBnbG9iYWwgZ3JhcGggb3V0cHV0XG4gICAgICogQG1ldGhvZCBnZXRPdXRwdXREYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHsqfSB0aGUgZGF0YVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuZ2V0T3V0cHV0RGF0YSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tuYW1lXTtcbiAgICAgICAgaWYgKCFvdXRwdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQudmFsdWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmFtZXMgYSBnbG9iYWwgZ3JhcGggb3V0cHV0XG4gICAgICogQG1ldGhvZCByZW5hbWVPdXRwdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkX25hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3X25hbWVcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLnJlbmFtZU91dHB1dCA9IGZ1bmN0aW9uKG9sZF9uYW1lLCBuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRzW29sZF9uYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0c1tuYW1lXSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcInRoZXJlIGlzIGFscmVhZHkgb25lIG91dHB1dCB3aXRoIHRoYXQgbmFtZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3V0cHV0c1tuYW1lXSA9IHRoaXMub3V0cHV0c1tvbGRfbmFtZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLm91dHB1dHNbb2xkX25hbWVdO1xuICAgICAgICB0aGlzLl92ZXJzaW9uKys7XG5cbiAgICAgICAgaWYgKHRoaXMub25PdXRwdXRSZW5hbWVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uT3V0cHV0UmVuYW1lZChvbGRfbmFtZSwgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vbklucHV0c091dHB1dHNDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25JbnB1dHNPdXRwdXRzQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgdHlwZSBvZiBhIGdsb2JhbCBncmFwaCBvdXRwdXRcbiAgICAgKiBAbWV0aG9kIGNoYW5nZU91dHB1dFR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICovXG4gICAgTEdyYXBoLnByb3RvdHlwZS5jaGFuZ2VPdXRwdXRUeXBlID0gZnVuY3Rpb24obmFtZSwgdHlwZSkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0c1tuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5vdXRwdXRzW25hbWVdLnR5cGUgJiZcbiAgICAgICAgICAgIFN0cmluZyh0aGlzLm91dHB1dHNbbmFtZV0udHlwZSkudG9Mb3dlckNhc2UoKSA9PVxuICAgICAgICAgICAgICAgIFN0cmluZyh0eXBlKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vdXRwdXRzW25hbWVdLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl92ZXJzaW9uKys7XG4gICAgICAgIGlmICh0aGlzLm9uT3V0cHV0VHlwZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25PdXRwdXRUeXBlQ2hhbmdlZChuYW1lLCB0eXBlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgZ2xvYmFsIGdyYXBoIG91dHB1dFxuICAgICAqIEBtZXRob2QgcmVtb3ZlT3V0cHV0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLnJlbW92ZU91dHB1dCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm91dHB1dHNbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5vdXRwdXRzW25hbWVdO1xuICAgICAgICB0aGlzLl92ZXJzaW9uKys7XG5cbiAgICAgICAgaWYgKHRoaXMub25PdXRwdXRSZW1vdmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uT3V0cHV0UmVtb3ZlZChuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9uSW5wdXRzT3V0cHV0c0NoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0c091dHB1dHNDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgTEdyYXBoLnByb3RvdHlwZS50cmlnZ2VySW5wdXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmZpbmROb2Rlc0J5VGl0bGUobmFtZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5vZGVzW2ldLm9uVHJpZ2dlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTEdyYXBoLnByb3RvdHlwZS5zZXRDYWxsYmFjayA9IGZ1bmN0aW9uKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5maW5kTm9kZXNCeVRpdGxlKG5hbWUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBub2Rlc1tpXS5zZXRUcmlnZ2VyKGZ1bmMpO1xuICAgICAgICB9XG4gICAgfTtcblxuXHQvL3VzZWQgZm9yIHVuZG8sIGNhbGxlZCBiZWZvcmUgYW55IGNoYW5nZSBpcyBtYWRlIHRvIHRoZSBncmFwaFxuICAgIExHcmFwaC5wcm90b3R5cGUuYmVmb3JlQ2hhbmdlID0gZnVuY3Rpb24oaW5mbykge1xuICAgICAgICBpZiAodGhpcy5vbkJlZm9yZUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vbkJlZm9yZUNoYW5nZSh0aGlzLGluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZEFjdGlvblRvQ2FudmFzKFwib25CZWZvcmVDaGFuZ2VcIiwgdGhpcyk7XG4gICAgfTtcblxuXHQvL3VzZWQgdG8gcmVzZW5kIGFjdGlvbnMsIGNhbGxlZCBhZnRlciBhbnkgY2hhbmdlIGlzIG1hZGUgdG8gdGhlIGdyYXBoXG4gICAgTEdyYXBoLnByb3RvdHlwZS5hZnRlckNoYW5nZSA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgICAgaWYgKHRoaXMub25BZnRlckNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vbkFmdGVyQ2hhbmdlKHRoaXMsaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kQWN0aW9uVG9DYW52YXMoXCJvbkFmdGVyQ2hhbmdlXCIsIHRoaXMpO1xuICAgIH07XG5cbiAgICBMR3JhcGgucHJvdG90eXBlLmNvbm5lY3Rpb25DaGFuZ2UgPSBmdW5jdGlvbihub2RlLCBsaW5rX2luZm8pIHtcbiAgICAgICAgdGhpcy51cGRhdGVFeGVjdXRpb25PcmRlcigpO1xuICAgICAgICBpZiAodGhpcy5vbkNvbm5lY3Rpb25DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uQ2hhbmdlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZlcnNpb24rKztcbiAgICAgICAgdGhpcy5zZW5kQWN0aW9uVG9DYW52YXMoXCJvbkNvbm5lY3Rpb25DaGFuZ2VcIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgaWYgdGhlIGdyYXBoIGlzIGluIGxpdmUgbW9kZVxuICAgICAqIEBtZXRob2QgaXNMaXZlXG4gICAgICovXG5cbiAgICBMR3JhcGgucHJvdG90eXBlLmlzTGl2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMubGlzdF9vZl9ncmFwaGNhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3Rfb2ZfZ3JhcGhjYW52YXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5saXN0X29mX2dyYXBoY2FudmFzW2ldO1xuICAgICAgICAgICAgaWYgKGMubGl2ZV9tb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjbGVhcnMgdGhlIHRyaWdnZXJlZCBzbG90IGFuaW1hdGlvbiBpbiBhbGwgbGlua3MgKHN0b3AgdmlzdWFsIGFuaW1hdGlvbilcbiAgICAgKiBAbWV0aG9kIGNsZWFyVHJpZ2dlcmVkU2xvdHNcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLmNsZWFyVHJpZ2dlcmVkU2xvdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmxpbmtzKSB7XG4gICAgICAgICAgICB2YXIgbGlua19pbmZvID0gdGhpcy5saW5rc1tpXTtcbiAgICAgICAgICAgIGlmICghbGlua19pbmZvKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGlua19pbmZvLl9sYXN0X3RpbWUpIHtcbiAgICAgICAgICAgICAgICBsaW5rX2luZm8uX2xhc3RfdGltZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyogQ2FsbGVkIHdoZW4gc29tZXRoaW5nIHZpc3VhbGx5IGNoYW5nZWQgKG5vdCB0aGUgZ3JhcGghKSAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiR3JhcGggY2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbmRBY3Rpb25Ub0NhbnZhcyhcInNldERpcnR5XCIsIFt0cnVlLCB0cnVlXSk7XG4gICAgICAgIGlmICh0aGlzLm9uX2NoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vbl9jaGFuZ2UodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTEdyYXBoLnByb3RvdHlwZS5zZXREaXJ0eUNhbnZhcyA9IGZ1bmN0aW9uKGZnLCBiZykge1xuICAgICAgICB0aGlzLnNlbmRBY3Rpb25Ub0NhbnZhcyhcInNldERpcnR5XCIsIFtmZywgYmddKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYSBsaW5rXG4gICAgICogQG1ldGhvZCByZW1vdmVMaW5rXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmtfaWRcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLnJlbW92ZUxpbmsgPSBmdW5jdGlvbihsaW5rX2lkKSB7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5saW5rc1tsaW5rX2lkXTtcbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldE5vZGVCeUlkKGxpbmsudGFyZ2V0X2lkKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuZGlzY29ubmVjdElucHV0KGxpbmsudGFyZ2V0X3Nsb3QpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vc2F2ZSBhbmQgcmVjb3ZlciBhcHAgc3RhdGUgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgaW5mbyBhYm91dCB0aGlzIGdyYXBoLCBpdCBjYW4gYmUgc2VyaWFsaXplZFxuICAgICAqIEBtZXRob2Qgc2VyaWFsaXplXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB2YWx1ZSBvZiB0aGUgbm9kZVxuICAgICAqL1xuICAgIExHcmFwaC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub2Rlc19pbmZvID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fbm9kZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBub2Rlc19pbmZvLnB1c2godGhpcy5fbm9kZXNbaV0uc2VyaWFsaXplKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9wYWNrIGxpbmsgaW5mbyBpbnRvIGEgbm9uLXZlcmJvc2UgZm9ybWF0XG4gICAgICAgIHZhciBsaW5rcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMubGlua3MpIHtcbiAgICAgICAgICAgIC8vbGlua3MgaXMgYW4gT0JKRUNUXG4gICAgICAgICAgICB2YXIgbGluayA9IHRoaXMubGlua3NbaV07XG4gICAgICAgICAgICBpZiAoIWxpbmsuc2VyaWFsaXplKSB7XG4gICAgICAgICAgICAgICAgLy93ZWlyZCBidWcgSSBoYXZlbnQgc29sdmVkIHlldFxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgXCJ3ZWlyZCBMTGluayBidWcsIGxpbmsgaW5mbyBpcyBub3QgYSBMTGluayBidXQgYSByZWd1bGFyIG9iamVjdFwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgbGluazIgPSBuZXcgTExpbmsoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqIGluIGxpbmspIHsgXG4gICAgICAgICAgICAgICAgICAgIGxpbmsyW2pdID0gbGlua1tqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5saW5rc1tpXSA9IGxpbmsyO1xuICAgICAgICAgICAgICAgIGxpbmsgPSBsaW5rMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGlua3MucHVzaChsaW5rLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncm91cHNfaW5mbyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dyb3Vwcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgZ3JvdXBzX2luZm8ucHVzaCh0aGlzLl9ncm91cHNbaV0uc2VyaWFsaXplKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBsYXN0X25vZGVfaWQ6IHRoaXMubGFzdF9ub2RlX2lkLFxuICAgICAgICAgICAgbGFzdF9saW5rX2lkOiB0aGlzLmxhc3RfbGlua19pZCxcbiAgICAgICAgICAgIG5vZGVzOiBub2Rlc19pbmZvLFxuICAgICAgICAgICAgbGlua3M6IGxpbmtzLFxuICAgICAgICAgICAgZ3JvdXBzOiBncm91cHNfaW5mbyxcbiAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG5cdFx0XHRleHRyYTogdGhpcy5leHRyYSxcbiAgICAgICAgICAgIHZlcnNpb246IExpdGVHcmFwaC5WRVJTSU9OXG4gICAgICAgIH07XG5cblx0XHRpZih0aGlzLm9uU2VyaWFsaXplKVxuXHRcdFx0dGhpcy5vblNlcmlhbGl6ZShkYXRhKTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIGEgZ3JhcGggZnJvbSBhIEpTT04gc3RyaW5nXG4gICAgICogQG1ldGhvZCBjb25maWd1cmVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIGNvbmZpZ3VyZSBhIGdyYXBoIGZyb20gYSBKU09OIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJucyBpZiB0aGVyZSB3YXMgYW55IGVycm9yIHBhcnNpbmdcbiAgICAgKi9cbiAgICBMR3JhcGgucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uKGRhdGEsIGtlZXBfb2xkKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZWVwX29sZCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGVzID0gZGF0YS5ub2RlcztcblxuICAgICAgICAvL2RlY29kZSBsaW5rcyBpbmZvICh0aGV5IGFyZSB2ZXJ5IHZlcmJvc2UpXG4gICAgICAgIGlmIChkYXRhLmxpbmtzICYmIGRhdGEubGlua3MuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICB2YXIgbGlua3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5saW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5rX2RhdGEgPSBkYXRhLmxpbmtzW2ldO1xuXHRcdFx0XHRpZighbGlua19kYXRhKSAvL3dlaXJkIGJ1Z1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKFwic2VyaWFsaXplZCBncmFwaCBsaW5rIGRhdGEgY29udGFpbnMgZXJyb3JzLCBza2lwcGluZy5cIik7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cbiAgICAgICAgICAgICAgICB2YXIgbGluayA9IG5ldyBMTGluaygpO1xuICAgICAgICAgICAgICAgIGxpbmsuY29uZmlndXJlKGxpbmtfZGF0YSk7XG4gICAgICAgICAgICAgICAgbGlua3NbbGluay5pZF0gPSBsaW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YS5saW5rcyA9IGxpbmtzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jb3B5IGFsbCBzdG9yZWQgZmllbGRzXG4gICAgICAgIGZvciAodmFyIGkgaW4gZGF0YSkge1xuXHRcdFx0aWYoaSA9PSBcIm5vZGVzXCIgfHwgaSA9PSBcImdyb3Vwc1wiICkgLy9saW5rcyBtdXN0IGJlIGFjY2VwdGVkXG5cdFx0XHRcdGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpc1tpXSA9IGRhdGFbaV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXJyb3IgPSBmYWxzZTtcblxuICAgICAgICAvL2NyZWF0ZSBub2Rlc1xuICAgICAgICB0aGlzLl9ub2RlcyA9IFtdO1xuICAgICAgICBpZiAobm9kZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5faW5mbyA9IG5vZGVzW2ldOyAvL3N0b3JlZCBpbmZvXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZShuX2luZm8udHlwZSwgbl9pbmZvLnRpdGxlKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJOb2RlIG5vdCBmb3VuZCBvciBoYXMgZXJyb3JzOiBcIiArIG5faW5mby50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9pbiBjYXNlIG9mIGVycm9yIHdlIGNyZWF0ZSBhIHJlcGxhY2VtZW50IG5vZGUgdG8gYXZvaWQgbG9zaW5nIGluZm9cbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBMR3JhcGhOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGFzdF9zZXJpYWxpemF0aW9uID0gbl9pbmZvO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmhhc19lcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZS5pZCA9IG5faW5mby5pZDsgLy9pZCBpdCBvciBpdCB3aWxsIGNyZWF0ZSBhIG5ldyBpZFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKG5vZGUsIHRydWUpOyAvL2FkZCBiZWZvcmUgY29uZmlndXJlLCBvdGhlcndpc2UgY29uZmlndXJlIGNhbm5vdCBjcmVhdGUgbGlua3NcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9jb25maWd1cmUgbm9kZXMgYWZ0ZXJ3YXJkcyBzbyB0aGV5IGNhbiByZWFjaCBlYWNoIG90aGVyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBuX2luZm8gPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5SWQobl9pbmZvLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNvbmZpZ3VyZShuX2luZm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vZ3JvdXBzXG4gICAgICAgIHRoaXMuX2dyb3Vwcy5sZW5ndGggPSAwO1xuICAgICAgICBpZiAoZGF0YS5ncm91cHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5ncm91cHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgTGl0ZUdyYXBoLkxHcmFwaEdyb3VwKCk7XG4gICAgICAgICAgICAgICAgZ3JvdXAuY29uZmlndXJlKGRhdGEuZ3JvdXBzW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChncm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZUV4ZWN1dGlvbk9yZGVyKCk7XG5cblx0XHR0aGlzLmV4dHJhID0gZGF0YS5leHRyYSB8fCB7fTtcblxuXHRcdGlmKHRoaXMub25Db25maWd1cmUpXG5cdFx0XHR0aGlzLm9uQ29uZmlndXJlKGRhdGEpO1xuXG4gICAgICAgIHRoaXMuX3ZlcnNpb24rKztcbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH07XG5cbiAgICBMR3JhcGgucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuXHRcdC8vZnJvbSBmaWxlXG5cdFx0aWYodXJsLmNvbnN0cnVjdG9yID09PSBGaWxlIHx8IHVybC5jb25zdHJ1Y3RvciA9PT0gQmxvYilcblx0XHR7XG5cdFx0XHR2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0XHRcdHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuXHRcdFx0XHR0aGF0LmNvbmZpZ3VyZShkYXRhKTtcblx0XHRcdFx0aWYoY2FsbGJhY2spXG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZWFkZXIucmVhZEFzVGV4dCh1cmwpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vaXMgYSBzdHJpbmcsIHRoZW4gYW4gVVJMXG4gICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxLm9wZW4oXCJHRVRcIiwgdXJsLCB0cnVlKTtcbiAgICAgICAgcmVxLnNlbmQobnVsbCk7XG4gICAgICAgIHJlcS5vbmxvYWQgPSBmdW5jdGlvbihvRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgbG9hZGluZyBncmFwaDpcIiwgcmVxLnN0YXR1cywgcmVxLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoIHJlcS5yZXNwb25zZSApO1xuICAgICAgICAgICAgdGhhdC5jb25maWd1cmUoZGF0YSk7XG5cdFx0XHRpZihjYWxsYmFjaylcblx0XHRcdFx0Y2FsbGJhY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGdyYXBoOlwiLCBlcnIpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBMR3JhcGgucHJvdG90eXBlLm9uTm9kZVRyYWNlID0gZnVuY3Rpb24obm9kZSwgbXNnLCBjb2xvcikge1xuICAgICAgICAvL1RPRE9cbiAgICB9O1xuXG4gICAgLy90aGlzIGlzIHRoZSBjbGFzcyBpbiBjaGFyZ2Ugb2Ygc3RvcmluZyBsaW5rIGluZm9ybWF0aW9uXG4gICAgZnVuY3Rpb24gTExpbmsoaWQsIHR5cGUsIG9yaWdpbl9pZCwgb3JpZ2luX3Nsb3QsIHRhcmdldF9pZCwgdGFyZ2V0X3Nsb3QpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm9yaWdpbl9pZCA9IG9yaWdpbl9pZDtcbiAgICAgICAgdGhpcy5vcmlnaW5fc2xvdCA9IG9yaWdpbl9zbG90O1xuICAgICAgICB0aGlzLnRhcmdldF9pZCA9IHRhcmdldF9pZDtcbiAgICAgICAgdGhpcy50YXJnZXRfc2xvdCA9IHRhcmdldF9zbG90O1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLl9wb3MgPSBuZXcgRmxvYXQzMkFycmF5KDIpOyAvL2NlbnRlclxuICAgIH1cblxuICAgIExMaW5rLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIGlmIChvLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IG9bMF07XG4gICAgICAgICAgICB0aGlzLm9yaWdpbl9pZCA9IG9bMV07XG4gICAgICAgICAgICB0aGlzLm9yaWdpbl9zbG90ID0gb1syXTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0X2lkID0gb1szXTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0X3Nsb3QgPSBvWzRdO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gb1s1XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBvLmlkO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gby50eXBlO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5faWQgPSBvLm9yaWdpbl9pZDtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luX3Nsb3QgPSBvLm9yaWdpbl9zbG90O1xuICAgICAgICAgICAgdGhpcy50YXJnZXRfaWQgPSBvLnRhcmdldF9pZDtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0X3Nsb3QgPSBvLnRhcmdldF9zbG90O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExMaW5rLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuaWQsXG4gICAgICAgICAgICB0aGlzLm9yaWdpbl9pZCxcbiAgICAgICAgICAgIHRoaXMub3JpZ2luX3Nsb3QsXG4gICAgICAgICAgICB0aGlzLnRhcmdldF9pZCxcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0X3Nsb3QsXG4gICAgICAgICAgICB0aGlzLnR5cGVcbiAgICAgICAgXTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLkxMaW5rID0gTExpbms7XG5cbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gICBOb2RlIENMQVNTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKioqKioqKlxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIC8qXG5cdHRpdGxlOiBzdHJpbmdcblx0cG9zOiBbeCx5XVxuXHRzaXplOiBbeCx5XVxuXG5cdGlucHV0fG91dHB1dDogZXZlcnkgY29ubmVjdGlvblxuXHRcdCsgIHsgbmFtZTpzdHJpbmcsIHR5cGU6c3RyaW5nLCBwb3M6IFt4LHldPU9wdGlvbmFsLCBkaXJlY3Rpb246IFwiaW5wdXRcInxcIm91dHB1dFwiLCBsaW5rczogQXJyYXkgfSk7XG5cblx0Z2VuZXJhbCBwcm9wZXJ0aWVzOlxuXHRcdCsgY2xpcF9hcmVhOiBpZiB5b3UgcmVuZGVyIG91dHNpZGUgdGhlIG5vZGUsIGl0IHdpbGwgYmUgY2xpcHBlZFxuXHRcdCsgdW5zYWZlX2V4ZWN1dGlvbjogbm90IGFsbG93ZWQgZm9yIHNhZmUgZXhlY3V0aW9uXG5cdFx0KyBza2lwX3JlcGVhdGVkX291dHB1dHM6IHdoZW4gYWRkaW5nIG5ldyBvdXRwdXRzLCBpdCB3b250IHNob3cgaWYgdGhlcmUgaXMgb25lIGFscmVhZHkgY29ubmVjdGVkXG5cdFx0KyByZXNpemFibGU6IGlmIHNldCB0byBmYWxzZSBpdCB3b250IGJlIHJlc2l6YWJsZSB3aXRoIHRoZSBtb3VzZVxuXHRcdCsgaG9yaXpvbnRhbDogc2xvdHMgYXJlIGRpc3RyaWJ1dGVkIGhvcml6b250YWxseVxuXHRcdCsgd2lkZ2V0c19zdGFydF95OiB3aWRnZXRzIHN0YXJ0IGF0IHkgZGlzdGFuY2UgZnJvbSB0aGUgdG9wIG9mIHRoZSBub2RlXG5cdFxuXHRmbGFncyBvYmplY3Q6XG5cdFx0KyBjb2xsYXBzZWQ6IGlmIGl0IGlzIGNvbGxhcHNlZFxuXG5cdHN1cHBvcnRlZCBjYWxsYmFja3M6XG5cdFx0KyBvbkFkZGVkOiB3aGVuIGFkZGVkIHRvIGdyYXBoICh3YXJuaW5nOiB0aGlzIGlzIGNhbGxlZCBCRUZPUkUgdGhlIG5vZGUgaXMgY29uZmlndXJlZCB3aGVuIGxvYWRpbmcpXG5cdFx0KyBvblJlbW92ZWQ6IHdoZW4gcmVtb3ZlZCBmcm9tIGdyYXBoXG5cdFx0KyBvblN0YXJ0Olx0d2hlbiB0aGUgZ3JhcGggc3RhcnRzIHBsYXlpbmdcblx0XHQrIG9uU3RvcDpcdHdoZW4gdGhlIGdyYXBoIHN0b3BzIHBsYXlpbmdcblx0XHQrIG9uRHJhd0ZvcmVncm91bmQ6IHJlbmRlciB0aGUgaW5zaWRlIHdpZGdldHMgaW5zaWRlIHRoZSBub2RlXG5cdFx0KyBvbkRyYXdCYWNrZ3JvdW5kOiByZW5kZXIgdGhlIGJhY2tncm91bmQgYXJlYSBpbnNpZGUgdGhlIG5vZGUgKG9ubHkgaW4gZWRpdCBtb2RlKVxuXHRcdCsgb25Nb3VzZURvd25cblx0XHQrIG9uTW91c2VNb3ZlXG5cdFx0KyBvbk1vdXNlVXBcblx0XHQrIG9uTW91c2VFbnRlclxuXHRcdCsgb25Nb3VzZUxlYXZlXG5cdFx0KyBvbkV4ZWN1dGU6IGV4ZWN1dGUgdGhlIG5vZGVcblx0XHQrIG9uUHJvcGVydHlDaGFuZ2VkOiB3aGVuIGEgcHJvcGVydHkgaXMgY2hhbmdlZCBpbiB0aGUgcGFuZWwgKHJldHVybiB0cnVlIHRvIHNraXAgZGVmYXVsdCBiZWhhdmlvdXIpXG5cdFx0KyBvbkdldElucHV0czogcmV0dXJucyBhbiBhcnJheSBvZiBwb3NzaWJsZSBpbnB1dHNcblx0XHQrIG9uR2V0T3V0cHV0czogcmV0dXJucyBhbiBhcnJheSBvZiBwb3NzaWJsZSBvdXRwdXRzXG5cdFx0KyBvbkJvdW5kaW5nOiBpbiBjYXNlIHRoaXMgbm9kZSBoYXMgYSBiaWdnZXIgYm91bmRpbmcgdGhhbiB0aGUgbm9kZSBpdHNlbGYgKHRoZSBjYWxsYmFjayByZWNlaXZlcyB0aGUgYm91bmRpbmcgYXMgW3gseSx3LGhdKVxuXHRcdCsgb25EYmxDbGljazogZG91YmxlIGNsaWNrZWQgaW4gdGhlIG5vZGVcblx0XHQrIG9uSW5wdXREYmxDbGljazogaW5wdXQgc2xvdCBkb3VibGUgY2xpY2tlZCAoY2FuIGJlIHVzZWQgdG8gYXV0b21hdGljYWxseSBjcmVhdGUgYSBub2RlIGNvbm5lY3RlZClcblx0XHQrIG9uT3V0cHV0RGJsQ2xpY2s6IG91dHB1dCBzbG90IGRvdWJsZSBjbGlja2VkIChjYW4gYmUgdXNlZCB0byBhdXRvbWF0aWNhbGx5IGNyZWF0ZSBhIG5vZGUgY29ubmVjdGVkKVxuXHRcdCsgb25Db25maWd1cmU6IGNhbGxlZCBhZnRlciB0aGUgbm9kZSBoYXMgYmVlbiBjb25maWd1cmVkXG5cdFx0KyBvblNlcmlhbGl6ZTogdG8gYWRkIGV4dHJhIGluZm8gd2hlbiBzZXJpYWxpemluZyAodGhlIGNhbGxiYWNrIHJlY2VpdmVzIHRoZSBvYmplY3QgdGhhdCBzaG91bGQgYmUgZmlsbGVkIHdpdGggdGhlIGRhdGEpXG5cdFx0KyBvblNlbGVjdGVkXG5cdFx0KyBvbkRlc2VsZWN0ZWRcblx0XHQrIG9uRHJvcEl0ZW0gOiBET00gaXRlbSBkcm9wcGVkIG92ZXIgdGhlIG5vZGVcblx0XHQrIG9uRHJvcEZpbGUgOiBmaWxlIGRyb3BwZWQgb3ZlciB0aGUgbm9kZVxuXHRcdCsgb25Db25uZWN0SW5wdXQgOiBpZiByZXR1cm5zIGZhbHNlIHRoZSBpbmNvbWluZyBjb25uZWN0aW9uIHdpbGwgYmUgY2FuY2VsZWRcblx0XHQrIG9uQ29ubmVjdGlvbnNDaGFuZ2UgOiBhIGNvbm5lY3Rpb24gY2hhbmdlZCAobmV3IG9uZSBvciByZW1vdmVkKSAoTGl0ZUdyYXBoLklOUFVUIG9yIExpdGVHcmFwaC5PVVRQVVQsIHNsb3QsIHRydWUgaWYgY29ubmVjdGVkLCBsaW5rX2luZm8sIGlucHV0X2luZm8gKVxuXHRcdCsgb25BY3Rpb246IGFjdGlvbiBzbG90IHRyaWdnZXJlZFxuXHRcdCsgZ2V0RXh0cmFNZW51T3B0aW9uczogdG8gYWRkIG9wdGlvbiB0byBjb250ZXh0IG1lbnVcbiovXG5cbiAgICAvKipcbiAgICAgKiBCYXNlIENsYXNzIGZvciBhbGwgdGhlIG5vZGUgdHlwZSBjbGFzc2VzXG4gICAgICogQGNsYXNzIExHcmFwaE5vZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBhIG5hbWUgZm9yIHRoZSBub2RlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBMR3JhcGhOb2RlKHRpdGxlKSB7XG4gICAgICAgIHRoaXMuX2N0b3IodGl0bGUpO1xuICAgIH1cblxuICAgIGdsb2JhbC5MR3JhcGhOb2RlID0gTGl0ZUdyYXBoLkxHcmFwaE5vZGUgPSBMR3JhcGhOb2RlO1xuXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuX2N0b3IgPSBmdW5jdGlvbih0aXRsZSkge1xuICAgICAgICB0aGlzLnRpdGxlID0gdGl0bGUgfHwgXCJVbm5hbWVkXCI7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFtMaXRlR3JhcGguTk9ERV9XSURUSCwgNjBdO1xuICAgICAgICB0aGlzLmdyYXBoID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9wb3MgPSBuZXcgRmxvYXQzMkFycmF5KDEwLCAxMCk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicG9zXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIGlmICghdiB8fCB2Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NbMF0gPSB2WzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc1sxXSA9IHZbMV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKExpdGVHcmFwaC51c2VfdXVpZHMpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBMaXRlR3JhcGgudXVpZHY0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gLTE7IC8vbm90IGtub3cgdGlsbCBub3QgYWRkZWRcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR5cGUgPSBudWxsO1xuXG4gICAgICAgIC8vaW5wdXRzIGF2YWlsYWJsZTogYXJyYXkgb2YgaW5wdXRzXG4gICAgICAgIHRoaXMuaW5wdXRzID0gW107XG4gICAgICAgIHRoaXMub3V0cHV0cyA9IFtdO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zID0gW107XG5cbiAgICAgICAgLy9sb2NhbCBkYXRhXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHt9OyAvL2ZvciB0aGUgdmFsdWVzXG4gICAgICAgIHRoaXMucHJvcGVydGllc19pbmZvID0gW107IC8vZm9yIHRoZSBpbmZvXG5cbiAgICAgICAgdGhpcy5mbGFncyA9IHt9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjb25maWd1cmUgYSBub2RlIGZyb20gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNlcmlhbGl6ZWQgaW5mb1xuICAgICAqIEBtZXRob2QgY29uZmlndXJlXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24oaW5mbykge1xuICAgICAgICBpZiAodGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5fdmVyc2lvbisrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGogaW4gaW5mbykge1xuICAgICAgICAgICAgaWYgKGogPT0gXCJwcm9wZXJ0aWVzXCIpIHtcbiAgICAgICAgICAgICAgICAvL2kgZG9uJ3Qgd2FudCB0byBjbG9uZSBwcm9wZXJ0aWVzLCBJIHdhbnQgdG8gcmV1c2UgdGhlIG9sZCBjb250YWluZXJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGluZm8ucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNba10gPSBpbmZvLnByb3BlcnRpZXNba107XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uUHJvcGVydHlDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUHJvcGVydHlDaGFuZ2VkKCBrLCBpbmZvLnByb3BlcnRpZXNba10gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluZm9bal0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5mb1tqXSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgLy9vYmplY3RcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tqXSAmJiB0aGlzW2pdLmNvbmZpZ3VyZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2pdLmNvbmZpZ3VyZShpbmZvW2pdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2pdID0gTGl0ZUdyYXBoLmNsb25lT2JqZWN0KGluZm9bal0sIHRoaXNbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy92YWx1ZVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tqXSA9IGluZm9bal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWluZm8udGl0bGUpIHtcbiAgICAgICAgICAgIHRoaXMudGl0bGUgPSB0aGlzLmNvbnN0cnVjdG9yLnRpdGxlO1xuICAgICAgICB9XG5cblx0XHRpZiAodGhpcy5pbnB1dHMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XG5cdFx0XHRcdHZhciBsaW5rX2luZm8gPSB0aGlzLmdyYXBoID8gdGhpcy5ncmFwaC5saW5rc1tpbnB1dC5saW5rXSA6IG51bGw7XG5cdFx0XHRcdGlmICh0aGlzLm9uQ29ubmVjdGlvbnNDaGFuZ2UpXG5cdFx0XHRcdFx0dGhpcy5vbkNvbm5lY3Rpb25zQ2hhbmdlKCBMaXRlR3JhcGguSU5QVVQsIGksIHRydWUsIGxpbmtfaW5mbywgaW5wdXQgKTsgLy9saW5rX2luZm8gaGFzIGJlZW4gY3JlYXRlZCBub3csIHNvIGl0cyB1cGRhdGVkXG5cblx0XHRcdFx0aWYoIHRoaXMub25JbnB1dEFkZGVkIClcblx0XHRcdFx0XHR0aGlzLm9uSW5wdXRBZGRlZChpbnB1dCk7XG5cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5vdXRwdXRzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW2ldO1xuXHRcdFx0XHRpZiAoIW91dHB1dC5saW5rcykge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgb3V0cHV0LmxpbmtzLmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdFx0dmFyIGxpbmtfaW5mbyA9IHRoaXMuZ3JhcGggXHQ/IHRoaXMuZ3JhcGgubGlua3Nbb3V0cHV0LmxpbmtzW2pdXSA6IG51bGw7XG5cdFx0XHRcdFx0aWYgKHRoaXMub25Db25uZWN0aW9uc0NoYW5nZSlcblx0XHRcdFx0XHRcdHRoaXMub25Db25uZWN0aW9uc0NoYW5nZSggTGl0ZUdyYXBoLk9VVFBVVCwgaSwgdHJ1ZSwgbGlua19pbmZvLCBvdXRwdXQgKTsgLy9saW5rX2luZm8gaGFzIGJlZW4gY3JlYXRlZCBub3csIHNvIGl0cyB1cGRhdGVkXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiggdGhpcy5vbk91dHB1dEFkZGVkIClcblx0XHRcdFx0XHR0aGlzLm9uT3V0cHV0QWRkZWQob3V0cHV0KTtcblx0XHRcdH1cbiAgICAgICAgfVxuXG5cdFx0aWYoIHRoaXMud2lkZ2V0cyApXG5cdFx0e1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndpZGdldHMubGVuZ3RoOyArK2kpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciB3ID0gdGhpcy53aWRnZXRzW2ldO1xuXHRcdFx0XHRpZighdylcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0aWYody5vcHRpb25zICYmIHcub3B0aW9ucy5wcm9wZXJ0eSAmJiAodGhpcy5wcm9wZXJ0aWVzWyB3Lm9wdGlvbnMucHJvcGVydHkgXSAhPSB1bmRlZmluZWQpKVxuXHRcdFx0XHRcdHcudmFsdWUgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggdGhpcy5wcm9wZXJ0aWVzWyB3Lm9wdGlvbnMucHJvcGVydHkgXSApICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaW5mby53aWRnZXRzX3ZhbHVlcykge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGluZm8ud2lkZ2V0c192YWx1ZXMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRpZiAodGhpcy53aWRnZXRzW2ldKSB7XG5cdFx0XHRcdFx0XHR0aGlzLndpZGdldHNbaV0udmFsdWUgPSBpbmZvLndpZGdldHNfdmFsdWVzW2ldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuICAgICAgICBpZiAodGhpcy5vbkNvbmZpZ3VyZSkge1xuICAgICAgICAgICAgdGhpcy5vbkNvbmZpZ3VyZShpbmZvKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXJpYWxpemUgdGhlIGNvbnRlbnRcbiAgICAgKiBAbWV0aG9kIHNlcmlhbGl6ZVxuICAgICAqL1xuXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vY3JlYXRlIHNlcmlhbGl6YXRpb24gb2JqZWN0XG4gICAgICAgIHZhciBvID0ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBwb3M6IHRoaXMucG9zLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5zaXplLFxuICAgICAgICAgICAgZmxhZ3M6IExpdGVHcmFwaC5jbG9uZU9iamVjdCh0aGlzLmZsYWdzKSxcblx0XHRcdG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgbW9kZTogdGhpcy5tb2RlXG4gICAgICAgIH07XG5cbiAgICAgICAgLy9zcGVjaWFsIGNhc2UgZm9yIHdoZW4gdGhlcmUgd2VyZSBlcnJvcnNcbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IExHcmFwaE5vZGUgJiYgdGhpcy5sYXN0X3NlcmlhbGl6YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3Rfc2VyaWFsaXphdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlucHV0cykge1xuICAgICAgICAgICAgby5pbnB1dHMgPSB0aGlzLmlucHV0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgIC8vY2xlYXIgb3V0cHV0cyBsYXN0IGRhdGEgKGJlY2F1c2UgZGF0YSBpbiBjb25uZWN0aW9ucyBpcyBuZXZlciBzZXJpYWxpemVkIGJ1dCBzdG9yZWQgaW5zaWRlIHRoZSBvdXRwdXRzIGluZm8pXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm91dHB1dHNbaV0uX2RhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvLm91dHB1dHMgPSB0aGlzLm91dHB1dHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50aXRsZSAmJiB0aGlzLnRpdGxlICE9IHRoaXMuY29uc3RydWN0b3IudGl0bGUpIHtcbiAgICAgICAgICAgIG8udGl0bGUgPSB0aGlzLnRpdGxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcykge1xuICAgICAgICAgICAgby5wcm9wZXJ0aWVzID0gTGl0ZUdyYXBoLmNsb25lT2JqZWN0KHRoaXMucHJvcGVydGllcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy53aWRnZXRzICYmIHRoaXMuc2VyaWFsaXplX3dpZGdldHMpIHtcbiAgICAgICAgICAgIG8ud2lkZ2V0c192YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy53aWRnZXRzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGlmKHRoaXMud2lkZ2V0c1tpXSlcblx0ICAgICAgICAgICAgICAgIG8ud2lkZ2V0c192YWx1ZXNbaV0gPSB0aGlzLndpZGdldHNbaV0udmFsdWU7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRvLndpZGdldHNfdmFsdWVzW2ldID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghby50eXBlKSB7XG4gICAgICAgICAgICBvLnR5cGUgPSB0aGlzLmNvbnN0cnVjdG9yLnR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb2xvcikge1xuICAgICAgICAgICAgby5jb2xvciA9IHRoaXMuY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYmdjb2xvcikge1xuICAgICAgICAgICAgby5iZ2NvbG9yID0gdGhpcy5iZ2NvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJveGNvbG9yKSB7XG4gICAgICAgICAgICBvLmJveGNvbG9yID0gdGhpcy5ib3hjb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaGFwZSkge1xuICAgICAgICAgICAgby5zaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vblNlcmlhbGl6ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub25TZXJpYWxpemUobykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAgIFwibm9kZSBvblNlcmlhbGl6ZSBzaG91bGRudCByZXR1cm4gYW55dGhpbmcsIGRhdGEgc2hvdWxkIGJlIHN0b3JlZCBpbiB0aGUgb2JqZWN0IHBhc3MgaW4gdGhlIGZpcnN0IHBhcmFtZXRlclwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG5cbiAgICAvKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBub2RlICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZSh0aGlzLnR5cGUpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy93ZSBjbG9uZSBpdCBiZWNhdXNlIHNlcmlhbGl6ZSByZXR1cm5zIHNoYXJlZCBjb250YWluZXJzXG4gICAgICAgIHZhciBkYXRhID0gTGl0ZUdyYXBoLmNsb25lT2JqZWN0KHRoaXMuc2VyaWFsaXplKCkpO1xuXG4gICAgICAgIC8vcmVtb3ZlIGxpbmtzXG4gICAgICAgIGlmIChkYXRhLmlucHV0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGRhdGEuaW5wdXRzW2ldLmxpbmsgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEub3V0cHV0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5vdXRwdXRzW2ldLmxpbmtzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEub3V0cHV0c1tpXS5saW5rcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBkYXRhW1wiaWRcIl07XG5cbiAgICAgICAgaWYgKExpdGVHcmFwaC51c2VfdXVpZHMpIHtcbiAgICAgICAgICAgIGRhdGFbXCJpZFwiXSA9IExpdGVHcmFwaC51dWlkdjQoKVxuICAgICAgICB9XG5cbiAgICAgICAgLy9yZW1vdmUgbGlua3NcbiAgICAgICAgbm9kZS5jb25maWd1cmUoZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNlcmlhbGl6ZSBhbmQgc3RyaW5naWZ5XG4gICAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgICAqL1xuXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuc2VyaWFsaXplKCkpO1xuICAgIH07XG4gICAgLy9MR3JhcGhOb2RlLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGluZm8pIHt9IC8vdGhpcyBjYW5ub3QgYmUgZG9uZSBmcm9tIHdpdGhpbiwgbXVzdCBiZSBkb25lIGluIExpdGVHcmFwaFxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB0aXRsZSBzdHJpbmdcbiAgICAgKiBAbWV0aG9kIGdldFRpdGxlXG4gICAgICovXG5cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aXRsZSB8fCB0aGlzLmNvbnN0cnVjdG9yLnRpdGxlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5XG4gICAgICogQG1ldGhvZCBzZXRQcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLnNldFByb3BlcnR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xuICAgICAgICB9XG5cdFx0aWYoIHZhbHVlID09PSB0aGlzLnByb3BlcnRpZXNbbmFtZV0gKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBwcmV2X3ZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzW25hbWVdO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMub25Qcm9wZXJ0eUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmKCB0aGlzLm9uUHJvcGVydHlDaGFuZ2VkKG5hbWUsIHZhbHVlLCBwcmV2X3ZhbHVlKSA9PT0gZmFsc2UgKSAvL2Fib3J0IGNoYW5nZVxuXHRcdFx0XHR0aGlzLnByb3BlcnRpZXNbbmFtZV0gPSBwcmV2X3ZhbHVlO1xuICAgICAgICB9XG5cdFx0aWYodGhpcy53aWRnZXRzKSAvL3dpZGdldHMgY291bGQgYmUgbGlua2VkIHRvIHByb3BlcnRpZXNcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLndpZGdldHMubGVuZ3RoOyArK2kpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciB3ID0gdGhpcy53aWRnZXRzW2ldO1xuXHRcdFx0XHRpZighdylcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0aWYody5vcHRpb25zLnByb3BlcnR5ID09IG5hbWUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR3LnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cbiAgICB9O1xuXG4gICAgLy8gRXhlY3V0aW9uICoqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvKipcbiAgICAgKiBzZXRzIHRoZSBvdXRwdXQgZGF0YVxuICAgICAqIEBtZXRob2Qgc2V0T3V0cHV0RGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbG90XG4gICAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuc2V0T3V0cHV0RGF0YSA9IGZ1bmN0aW9uKHNsb3QsIGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGhpcyBtYXliZSBzbG93IGFuZCBhIG5pY2hlIGNhc2VcbiAgICAgICAgLy9pZihzbG90ICYmIHNsb3QuY29uc3RydWN0b3IgPT09IFN0cmluZylcbiAgICAgICAgLy9cdHNsb3QgPSB0aGlzLmZpbmRPdXRwdXRTbG90KHNsb3QpO1xuXG4gICAgICAgIGlmIChzbG90ID09IC0xIHx8IHNsb3QgPj0gdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dF9pbmZvID0gdGhpcy5vdXRwdXRzW3Nsb3RdO1xuICAgICAgICBpZiAoIW91dHB1dF9pbmZvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL3N0b3JlIGRhdGEgaW4gdGhlIG91dHB1dCBpdHNlbGYgaW4gY2FzZSB3ZSB3YW50IHRvIGRlYnVnXG4gICAgICAgIG91dHB1dF9pbmZvLl9kYXRhID0gZGF0YTtcblxuICAgICAgICAvL2lmIHRoZXJlIGFyZSBjb25uZWN0aW9ucywgcGFzcyB0aGUgZGF0YSB0byB0aGUgY29ubmVjdGlvbnNcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0c1tzbG90XS5saW5rcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHNbc2xvdF0ubGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlua19pZCA9IHRoaXMub3V0cHV0c1tzbG90XS5saW5rc1tpXTtcblx0XHRcdFx0dmFyIGxpbmsgPSB0aGlzLmdyYXBoLmxpbmtzW2xpbmtfaWRdO1xuXHRcdFx0XHRpZihsaW5rKVxuXHRcdFx0XHRcdGxpbmsuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0cyB0aGUgb3V0cHV0IGRhdGEgdHlwZSwgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gYmUgYWJsZSB0byBvdmVyd3JpdGUgdGhlIGRhdGEgdHlwZVxuICAgICAqIEBtZXRob2Qgc2V0T3V0cHV0RGF0YVR5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhdHlwZVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLnNldE91dHB1dERhdGFUeXBlID0gZnVuY3Rpb24oc2xvdCwgdHlwZSkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbG90ID09IC0xIHx8IHNsb3QgPj0gdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRfaW5mbyA9IHRoaXMub3V0cHV0c1tzbG90XTtcbiAgICAgICAgaWYgKCFvdXRwdXRfaW5mbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vc3RvcmUgZGF0YSBpbiB0aGUgb3V0cHV0IGl0c2VsZiBpbiBjYXNlIHdlIHdhbnQgdG8gZGVidWdcbiAgICAgICAgb3V0cHV0X2luZm8udHlwZSA9IHR5cGU7XG5cbiAgICAgICAgLy9pZiB0aGVyZSBhcmUgY29ubmVjdGlvbnMsIHBhc3MgdGhlIGRhdGEgdG8gdGhlIGNvbm5lY3Rpb25zXG4gICAgICAgIGlmICh0aGlzLm91dHB1dHNbc2xvdF0ubGlua3MpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzW3Nsb3RdLmxpbmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtfaWQgPSB0aGlzLm91dHB1dHNbc2xvdF0ubGlua3NbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5saW5rc1tsaW5rX2lkXS50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGlucHV0IGRhdGEgKGRhdGEgdHJhdmVsaW5nIHRocm91Z2ggdGhlIGNvbm5lY3Rpb24pIGZyb20gb25lIHNsb3RcbiAgICAgKiBAbWV0aG9kIGdldElucHV0RGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbG90XG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZV91cGRhdGUgaWYgc2V0IHRvIHRydWUgaXQgd2lsbCBmb3JjZSB0aGUgY29ubmVjdGVkIG5vZGUgb2YgdGhpcyBzbG90IHRvIG91dHB1dCBkYXRhIGludG8gdGhpcyBsaW5rXG4gICAgICogQHJldHVybiB7Kn0gZGF0YSBvciBpZiBpdCBpcyBub3QgY29ubmVjdGVkIHJldHVybnMgdW5kZWZpbmVkXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZ2V0SW5wdXREYXRhID0gZnVuY3Rpb24oc2xvdCwgZm9yY2VfdXBkYXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvL3VuZGVmaW5lZDtcblxuICAgICAgICBpZiAoc2xvdCA+PSB0aGlzLmlucHV0cy5sZW5ndGggfHwgdGhpcy5pbnB1dHNbc2xvdF0ubGluayA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGlua19pZCA9IHRoaXMuaW5wdXRzW3Nsb3RdLmxpbms7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5ncmFwaC5saW5rc1tsaW5rX2lkXTtcbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICAvL2J1Zzogd2VpcmQgY2FzZSBidXQgaXQgaGFwcGVucyBzb21ldGltZXNcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmb3JjZV91cGRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5rLmRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICAvL3NwZWNpYWwgY2FzZTogdXNlZCB0byBleHRyYWN0IGRhdGEgZnJvbSB0aGUgaW5jb21pbmcgY29ubmVjdGlvbiBiZWZvcmUgdGhlIGdyYXBoIGhhcyBiZWVuIGV4ZWN1dGVkXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ncmFwaC5nZXROb2RlQnlJZChsaW5rLm9yaWdpbl9pZCk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmsuZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLnVwZGF0ZU91dHB1dERhdGEpIHtcbiAgICAgICAgICAgIG5vZGUudXBkYXRlT3V0cHV0RGF0YShsaW5rLm9yaWdpbl9zbG90KTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLm9uRXhlY3V0ZSkge1xuICAgICAgICAgICAgbm9kZS5vbkV4ZWN1dGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW5rLmRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgaW5wdXQgZGF0YSB0eXBlIChpbiBjYXNlIHRoaXMgc3VwcG9ydHMgbXVsdGlwbGUgaW5wdXQgdHlwZXMpXG4gICAgICogQG1ldGhvZCBnZXRJbnB1dERhdGFUeXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3RcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGRhdGF0eXBlIGluIHN0cmluZyBmb3JtYXRcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRJbnB1dERhdGFUeXBlID0gZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSAvL3VuZGVmaW5lZDtcblxuICAgICAgICBpZiAoc2xvdCA+PSB0aGlzLmlucHV0cy5sZW5ndGggfHwgdGhpcy5pbnB1dHNbc2xvdF0ubGluayA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlua19pZCA9IHRoaXMuaW5wdXRzW3Nsb3RdLmxpbms7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5ncmFwaC5saW5rc1tsaW5rX2lkXTtcbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICAvL2J1Zzogd2VpcmQgY2FzZSBidXQgaXQgaGFwcGVucyBzb21ldGltZXNcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ncmFwaC5nZXROb2RlQnlJZChsaW5rLm9yaWdpbl9pZCk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmsudHlwZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0X2luZm8gPSBub2RlLm91dHB1dHNbbGluay5vcmlnaW5fc2xvdF07XG4gICAgICAgIGlmIChvdXRwdXRfaW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dF9pbmZvLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgaW5wdXQgZGF0YSBmcm9tIG9uZSBzbG90IHVzaW5nIGl0cyBuYW1lIGluc3RlYWQgb2Ygc2xvdCBudW1iZXJcbiAgICAgKiBAbWV0aG9kIGdldElucHV0RGF0YUJ5TmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzbG90X25hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlX3VwZGF0ZSBpZiBzZXQgdG8gdHJ1ZSBpdCB3aWxsIGZvcmNlIHRoZSBjb25uZWN0ZWQgbm9kZSBvZiB0aGlzIHNsb3QgdG8gb3V0cHV0IGRhdGEgaW50byB0aGlzIGxpbmtcbiAgICAgKiBAcmV0dXJuIHsqfSBkYXRhIG9yIGlmIGl0IGlzIG5vdCBjb25uZWN0ZWQgcmV0dXJucyBudWxsXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZ2V0SW5wdXREYXRhQnlOYW1lID0gZnVuY3Rpb24oXG4gICAgICAgIHNsb3RfbmFtZSxcbiAgICAgICAgZm9yY2VfdXBkYXRlXG4gICAgKSB7XG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5maW5kSW5wdXRTbG90KHNsb3RfbmFtZSk7XG4gICAgICAgIGlmIChzbG90ID09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnB1dERhdGEoc2xvdCwgZm9yY2VfdXBkYXRlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdGVsbHMgeW91IGlmIHRoZXJlIGlzIGEgY29ubmVjdGlvbiBpbiBvbmUgaW5wdXQgc2xvdFxuICAgICAqIEBtZXRob2QgaXNJbnB1dENvbm5lY3RlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbG90XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5pc0lucHV0Q29ubmVjdGVkID0gZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNsb3QgPCB0aGlzLmlucHV0cy5sZW5ndGggJiYgdGhpcy5pbnB1dHNbc2xvdF0ubGluayAhPSBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB0ZWxscyB5b3UgaW5mbyBhYm91dCBhbiBpbnB1dCBjb25uZWN0aW9uICh3aGljaCBub2RlLCB0eXBlLCBldGMpXG4gICAgICogQG1ldGhvZCBnZXRJbnB1dEluZm9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IG9yIG51bGwgeyBsaW5rOiBpZCwgbmFtZTogc3RyaW5nLCB0eXBlOiBzdHJpbmcgb3IgMCB9XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZ2V0SW5wdXRJbmZvID0gZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2xvdCA8IHRoaXMuaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRzW3Nsb3RdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaW5rIGluZm8gaW4gdGhlIGNvbm5lY3Rpb24gb2YgYW4gaW5wdXQgc2xvdFxuICAgICAqIEBtZXRob2QgZ2V0SW5wdXRMaW5rXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3RcbiAgICAgKiBAcmV0dXJuIHtMTGlua30gb2JqZWN0IG9yIG51bGxcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRJbnB1dExpbmsgPSBmdW5jdGlvbihzbG90KSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbG90IDwgdGhpcy5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc2xvdF9pbmZvID0gdGhpcy5pbnB1dHNbc2xvdF07XG5cdFx0XHRyZXR1cm4gdGhpcy5ncmFwaC5saW5rc1sgc2xvdF9pbmZvLmxpbmsgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgbm9kZSBjb25uZWN0ZWQgaW4gdGhlIGlucHV0IHNsb3RcbiAgICAgKiBAbWV0aG9kIGdldElucHV0Tm9kZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbG90XG4gICAgICogQHJldHVybiB7TEdyYXBoTm9kZX0gbm9kZSBvciBudWxsXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZ2V0SW5wdXROb2RlID0gZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2xvdCA+PSB0aGlzLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW3Nsb3RdO1xuICAgICAgICBpZiAoIWlucHV0IHx8IGlucHV0LmxpbmsgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5rX2luZm8gPSB0aGlzLmdyYXBoLmxpbmtzW2lucHV0LmxpbmtdO1xuICAgICAgICBpZiAoIWxpbmtfaW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhcGguZ2V0Tm9kZUJ5SWQobGlua19pbmZvLm9yaWdpbl9pZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIHZhbHVlIG9mIGFuIGlucHV0IHdpdGggdGhpcyBuYW1lLCBvdGhlcndpc2UgY2hlY2tzIGlmIHRoZXJlIGlzIGEgcHJvcGVydHkgd2l0aCB0aGF0IG5hbWVcbiAgICAgKiBAbWV0aG9kIGdldElucHV0T3JQcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRJbnB1dE9yUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMgfHwgIXRoaXMuaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllcyA/IHRoaXMucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdmFyIGlucHV0X2luZm8gPSB0aGlzLmlucHV0c1tpXTtcbiAgICAgICAgICAgIGlmIChuYW1lID09IGlucHV0X2luZm8ubmFtZSAmJiBpbnB1dF9pbmZvLmxpbmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5rID0gdGhpcy5ncmFwaC5saW5rc1tpbnB1dF9pbmZvLmxpbmtdO1xuICAgICAgICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5rLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXNbbmFtZV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHRlbGxzIHlvdSB0aGUgbGFzdCBvdXRwdXQgZGF0YSB0aGF0IHdlbnQgaW4gdGhhdCBzbG90XG4gICAgICogQG1ldGhvZCBnZXRPdXRwdXREYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICBvYmplY3Qgb3IgbnVsbFxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmdldE91dHB1dERhdGEgPSBmdW5jdGlvbihzbG90KSB7XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2xvdCA+PSB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmZvID0gdGhpcy5vdXRwdXRzW3Nsb3RdO1xuICAgICAgICByZXR1cm4gaW5mby5fZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdGVsbHMgeW91IGluZm8gYWJvdXQgYW4gb3V0cHV0IGNvbm5lY3Rpb24gKHdoaWNoIG5vZGUsIHR5cGUsIGV0YylcbiAgICAgKiBAbWV0aG9kIGdldE91dHB1dEluZm9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gIG9iamVjdCBvciBudWxsIHsgbmFtZTogc3RyaW5nLCB0eXBlOiBzdHJpbmcsIGxpbmtzOiBbIGlkcyBvZiBsaW5rcyBpbiBudW1iZXIgXSB9XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZ2V0T3V0cHV0SW5mbyA9IGZ1bmN0aW9uKHNsb3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbG90IDwgdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0c1tzbG90XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdGVsbHMgeW91IGlmIHRoZXJlIGlzIGEgY29ubmVjdGlvbiBpbiBvbmUgb3V0cHV0IHNsb3RcbiAgICAgKiBAbWV0aG9kIGlzT3V0cHV0Q29ubmVjdGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmlzT3V0cHV0Q29ubmVjdGVkID0gZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBzbG90IDwgdGhpcy5vdXRwdXRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgdGhpcy5vdXRwdXRzW3Nsb3RdLmxpbmtzICYmXG4gICAgICAgICAgICB0aGlzLm91dHB1dHNbc2xvdF0ubGlua3MubGVuZ3RoXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHRlbGxzIHlvdSBpZiB0aGVyZSBpcyBhbnkgY29ubmVjdGlvbiBpbiB0aGUgb3V0cHV0IHNsb3RzXG4gICAgICogQG1ldGhvZCBpc0FueU91dHB1dENvbm5lY3RlZFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuaXNBbnlPdXRwdXRDb25uZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0c1tpXS5saW5rcyAmJiB0aGlzLm91dHB1dHNbaV0ubGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZXRyaWV2ZXMgYWxsIHRoZSBub2RlcyBjb25uZWN0ZWQgdG8gdGhpcyBvdXRwdXQgc2xvdFxuICAgICAqIEBtZXRob2QgZ2V0T3V0cHV0Tm9kZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvdFxuICAgICAqIEByZXR1cm4ge2FycmF5fVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmdldE91dHB1dE5vZGVzID0gZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0cyB8fCB0aGlzLm91dHB1dHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNsb3QgPj0gdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW3Nsb3RdO1xuICAgICAgICBpZiAoIW91dHB1dC5saW5rcyB8fCBvdXRwdXQubGlua3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXQubGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsaW5rX2lkID0gb3V0cHV0LmxpbmtzW2ldO1xuICAgICAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmdyYXBoLmxpbmtzW2xpbmtfaWRdO1xuICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0X25vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVCeUlkKGxpbmsudGFyZ2V0X2lkKTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0X25vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgci5wdXNoKHRhcmdldF9ub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmFkZE9uVHJpZ2dlcklucHV0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHRyaWdTID0gdGhpcy5maW5kSW5wdXRTbG90KFwib25UcmlnZ2VyXCIpO1xuICAgICAgICBpZiAodHJpZ1MgPT0gLTEpeyAvLyF0cmlnUyB8fCBcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuYWRkSW5wdXQoXCJvblRyaWdnZXJcIiwgTGl0ZUdyYXBoLkVWRU5ULCB7b3B0aW9uYWw6IHRydWUsIG5hbWVMb2NrZWQ6IHRydWV9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRJbnB1dFNsb3QoXCJvblRyaWdnZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyaWdTO1xuICAgIH1cbiAgICBcbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5hZGRPbkV4ZWN1dGVkT3V0cHV0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHRyaWdTID0gdGhpcy5maW5kT3V0cHV0U2xvdChcIm9uRXhlY3V0ZWRcIik7XG4gICAgICAgIGlmICh0cmlnUyA9PSAtMSl7IC8vIXRyaWdTIHx8IFxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuYWRkT3V0cHV0KFwib25FeGVjdXRlZFwiLCBMaXRlR3JhcGguQUNUSU9OLCB7b3B0aW9uYWw6IHRydWUsIG5hbWVMb2NrZWQ6IHRydWV9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRPdXRwdXRTbG90KFwib25FeGVjdXRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJpZ1M7XG4gICAgfVxuICAgIFxuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLm9uQWZ0ZXJFeGVjdXRlTm9kZSA9IGZ1bmN0aW9uKHBhcmFtLCBvcHRpb25zKXtcbiAgICAgICAgdmFyIHRyaWdTID0gdGhpcy5maW5kT3V0cHV0U2xvdChcIm9uRXhlY3V0ZWRcIik7XG4gICAgICAgIGlmICh0cmlnUyAhPSAtMSl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vY29uc29sZS5kZWJ1Zyh0aGlzLmlkK1wiOlwiK3RoaXMub3JkZXIrXCIgdHJpZ2dlcmluZyBzbG90IG9uQWZ0ZXJFeGVjdXRlXCIpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmRlYnVnKHBhcmFtKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5kZWJ1ZyhvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlclNsb3QodHJpZ1MsIHBhcmFtLCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgfSAgICBcbiAgICBcbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5jaGFuZ2VNb2RlID0gZnVuY3Rpb24obW9kZVRvKXtcbiAgICAgICAgc3dpdGNoKG1vZGVUbyl7XG4gICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5PTl9FVkVOVDpcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmFkZE9uRXhlY3V0ZWRPdXRwdXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLk9OX1RSSUdHRVI6XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRPblRyaWdnZXJJbnB1dCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkT25FeGVjdXRlZE91dHB1dCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguTkVWRVI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5BTFdBWVM6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5PTl9SRVFVRVNUOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlVG87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyB0aGUgZXhlY3V0aW9uIG9mIGFjdGlvbnMgdGhhdCB3ZXJlIGRlZmVycmVkIHdoZW4gdGhlIGFjdGlvbiB3YXMgdHJpZ2dlcmVkXG4gICAgICogQG1ldGhvZCBleGVjdXRlUGVuZGluZ0FjdGlvbnNcbiAgICAgKi8gICAgXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZXhlY3V0ZVBlbmRpbmdBY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKCF0aGlzLl93YWl0aW5nX2FjdGlvbnMgfHwgIXRoaXMuX3dhaXRpbmdfYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl93YWl0aW5nX2FjdGlvbnMubGVuZ3RoOysraSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLl93YWl0aW5nX2FjdGlvbnNbaV07XG4gICAgICAgICAgICB0aGlzLm9uQWN0aW9uKHBbMF0scFsxXSxwWzJdLHBbM10scFs0XSk7XG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICB0aGlzLl93YWl0aW5nX2FjdGlvbnMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyB0aGUgbm9kZSBjb2RlIGV4ZWN1dGlvbiwgcGxhY2UgYSBib29sZWFuL2NvdW50ZXIgdG8gbWFyayB0aGUgbm9kZSBhcyBiZWluZyBleGVjdXRlZFxuICAgICAqIEBtZXRob2QgZG9FeGVjdXRlXG4gICAgICogQHBhcmFtIHsqfSBwYXJhbVxuICAgICAqIEBwYXJhbSB7Kn0gb3B0aW9uc1xuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmRvRXhlY3V0ZSA9IGZ1bmN0aW9uKHBhcmFtLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAodGhpcy5vbkV4ZWN1dGUpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBlbmFibGUgdGhpcyB0byBnaXZlIHRoZSBldmVudCBhbiBJRFxuXHRcdFx0aWYgKCFvcHRpb25zLmFjdGlvbl9jYWxsKSBvcHRpb25zLmFjdGlvbl9jYWxsID0gdGhpcy5pZCtcIl9leGVjX1wiK01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo5OTk5KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5ncmFwaC5ub2Rlc19leGVjdXRpbmdbdGhpcy5pZF0gPSB0cnVlOyAvLy5wdXNoKHRoaXMuaWQpO1xuXG4gICAgICAgICAgICB0aGlzLm9uRXhlY3V0ZShwYXJhbSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ3JhcGgubm9kZXNfZXhlY3V0aW5nW3RoaXMuaWRdID0gZmFsc2U7IC8vLnBvcCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBzYXZlIGV4ZWN1dGlvbi9hY3Rpb24gcmVmXG4gICAgICAgICAgICB0aGlzLmV4ZWNfdmVyc2lvbiA9IHRoaXMuZ3JhcGguaXRlcmF0aW9uO1xuICAgICAgICAgICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLmFjdGlvbl9jYWxsKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbl9jYWxsID0gb3B0aW9ucy5hY3Rpb25fY2FsbDsgLy8gaWYgKHBhcmFtKVxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGgubm9kZXNfZXhlY3V0ZWRBY3Rpb25bdGhpcy5pZF0gPSBvcHRpb25zLmFjdGlvbl9jYWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhlY3V0ZV90cmlnZ2VyZWQgPSAyOyAvLyB0aGUgbkZyYW1lcyBpdCB3aWxsIGJlIHVzZWQgKC0tIGVhY2ggc3RlcCksIG1lYW5zIFwiaG93IG9sZFwiIGlzIHRoZSBldmVudFxuICAgICAgICBpZih0aGlzLm9uQWZ0ZXJFeGVjdXRlTm9kZSkgdGhpcy5vbkFmdGVyRXhlY3V0ZU5vZGUocGFyYW0sIG9wdGlvbnMpOyAvLyBjYWxsYmFja1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYW4gYWN0aW9uLCB3cmFwcGVkIGJ5IGxvZ2ljcyB0byBjb250cm9sIGV4ZWN1dGlvbiBmbG93XG4gICAgICogQG1ldGhvZCBhY3Rpb25Eb1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gcGFyYW1cbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5hY3Rpb25EbyA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0sIG9wdGlvbnMsIGFjdGlvbl9zbG90ICkge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgaWYgKHRoaXMub25BY3Rpb24pe1xuICAgICAgICAgICAgXG5cdFx0XHQvLyBlbmFibGUgdGhpcyB0byBnaXZlIHRoZSBldmVudCBhbiBJRFxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmFjdGlvbl9jYWxsKSBvcHRpb25zLmFjdGlvbl9jYWxsID0gdGhpcy5pZCtcIl9cIisoYWN0aW9uP2FjdGlvbjpcImFjdGlvblwiKStcIl9cIitNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqOTk5OSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ3JhcGgubm9kZXNfYWN0aW9uaW5nW3RoaXMuaWRdID0gKGFjdGlvbj9hY3Rpb246XCJhY3Rpb25pbmdcIik7IC8vLnB1c2godGhpcy5pZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMub25BY3Rpb24oYWN0aW9uLCBwYXJhbSwgb3B0aW9ucywgYWN0aW9uX3Nsb3QpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdyYXBoLm5vZGVzX2FjdGlvbmluZ1t0aGlzLmlkXSA9IGZhbHNlOyAvLy5wb3AoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gc2F2ZSBleGVjdXRpb24vYWN0aW9uIHJlZlxuICAgICAgICAgICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLmFjdGlvbl9jYWxsKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbl9jYWxsID0gb3B0aW9ucy5hY3Rpb25fY2FsbDsgLy8gaWYgKHBhcmFtKVxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGgubm9kZXNfZXhlY3V0ZWRBY3Rpb25bdGhpcy5pZF0gPSBvcHRpb25zLmFjdGlvbl9jYWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aW9uX3RyaWdnZXJlZCA9IDI7IC8vIHRoZSBuRnJhbWVzIGl0IHdpbGwgYmUgdXNlZCAoLS0gZWFjaCBzdGVwKSwgbWVhbnMgXCJob3cgb2xkXCIgaXMgdGhlIGV2ZW50XG4gICAgICAgIGlmKHRoaXMub25BZnRlckV4ZWN1dGVOb2RlKSB0aGlzLm9uQWZ0ZXJFeGVjdXRlTm9kZShwYXJhbSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhbiBldmVudCBpbiB0aGlzIG5vZGUsIHRoaXMgd2lsbCB0cmlnZ2VyIGFueSBvdXRwdXQgd2l0aCB0aGUgc2FtZSBuYW1lXG4gICAgICogQG1ldGhvZCB0cmlnZ2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWUgKCBcIm9uX3BsYXlcIiwgLi4uICkgaWYgYWN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gZmFsc2UgdGhlbiB0aGUgZXZlbnQgaXMgc2VuZCB0byBhbGxcbiAgICAgKiBAcGFyYW0geyp9IHBhcmFtXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLm91dHB1dHMgfHwgIXRoaXMub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoKVxuICAgICAgICAgICAgdGhpcy5ncmFwaC5fbGFzdF90cmlnZ2VyX3RpbWUgPSBMaXRlR3JhcGguZ2V0VGltZSgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW2ldO1xuICAgICAgICAgICAgaWYgKCAhb3V0cHV0IHx8IG91dHB1dC50eXBlICE9PSBMaXRlR3JhcGguRVZFTlQgfHwgKGFjdGlvbiAmJiBvdXRwdXQubmFtZSAhPSBhY3Rpb24pIClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlclNsb3QoaSwgcGFyYW0sIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGEgc2xvdCBldmVudCBpbiB0aGlzIG5vZGU6IGN5Y2xlIG91dHB1dCBzbG90cyBhbmQgbGF1bmNoIGV4ZWN1dGUvYWN0aW9uIG9uIGNvbm5lY3RlZCBub2Rlc1xuICAgICAqIEBtZXRob2QgdHJpZ2dlclNsb3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2xvdCB0aGUgaW5kZXggb2YgdGhlIG91dHB1dCBzbG90XG4gICAgICogQHBhcmFtIHsqfSBwYXJhbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5rX2lkIFtvcHRpb25hbF0gaW4gY2FzZSB5b3Ugd2FudCB0byB0cmlnZ2VyIGFuZCBzcGVjaWZpYyBvdXRwdXQgbGluayBpbiBhIHNsb3RcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS50cmlnZ2VyU2xvdCA9IGZ1bmN0aW9uKHNsb3QsIHBhcmFtLCBsaW5rX2lkLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cblx0XHRpZihzbG90ID09IG51bGwpXG5cdFx0e1xuXHRcdFx0Y29uc29sZS5lcnJvcihcInNsb3QgbXVzdCBiZSBhIG51bWJlclwiKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZihzbG90LmNvbnN0cnVjdG9yICE9PSBOdW1iZXIpXG5cdFx0XHRjb25zb2xlLndhcm4oXCJzbG90IG11c3QgYmUgYSBudW1iZXIsIHVzZSBub2RlLnRyaWdnZXIoJ25hbWUnKSBpZiB5b3Ugd2FudCB0byB1c2UgYSBzdHJpbmdcIik7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tzbG90XTtcbiAgICAgICAgaWYgKCFvdXRwdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5rcyA9IG91dHB1dC5saW5rcztcbiAgICAgICAgaWYgKCFsaW5rcyB8fCAhbGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgdGhpcy5ncmFwaC5fbGFzdF90cmlnZ2VyX3RpbWUgPSBMaXRlR3JhcGguZ2V0VGltZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9mb3IgZXZlcnkgbGluayBhdHRhY2hlZCBoZXJlXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGlua3MubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICAgIHZhciBpZCA9IGxpbmtzW2tdO1xuICAgICAgICAgICAgaWYgKGxpbmtfaWQgIT0gbnVsbCAmJiBsaW5rX2lkICE9IGlkKSB7XG4gICAgICAgICAgICAgICAgLy90byBza2lwIGxpbmtzXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGlua19pbmZvID0gdGhpcy5ncmFwaC5saW5rc1tsaW5rc1trXV07XG4gICAgICAgICAgICBpZiAoIWxpbmtfaW5mbykge1xuICAgICAgICAgICAgICAgIC8vbm90IGNvbm5lY3RlZFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlua19pbmZvLl9sYXN0X3RpbWUgPSBMaXRlR3JhcGguZ2V0VGltZSgpO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVCeUlkKGxpbmtfaW5mby50YXJnZXRfaWQpO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgLy9ub2RlIG5vdCBmb3VuZD9cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy91c2VkIHRvIG1hcmsgZXZlbnRzIGluIGdyYXBoXG4gICAgICAgICAgICB2YXIgdGFyZ2V0X2Nvbm5lY3Rpb24gPSBub2RlLmlucHV0c1tsaW5rX2luZm8udGFyZ2V0X3Nsb3RdO1xuXG5cdFx0XHRpZiAobm9kZS5tb2RlID09PSBMaXRlR3JhcGguT05fVFJJR0dFUilcblx0XHRcdHtcblx0XHRcdFx0Ly8gZ2VuZXJhdGUgdW5pcXVlIHRyaWdnZXIgSUQgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0aWYgKCFvcHRpb25zLmFjdGlvbl9jYWxsKSBvcHRpb25zLmFjdGlvbl9jYWxsID0gdGhpcy5pZCtcIl90cmlnZ19cIitNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqOTk5OSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUub25FeGVjdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC0tIHdyYXBwaW5nIG5vZGUub25FeGVjdXRlKHBhcmFtKTsgLS1cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kb0V4ZWN1dGUocGFyYW0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKG5vZGUub25BY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBnZW5lcmF0ZSB1bmlxdWUgYWN0aW9uIElEIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdGlmICghb3B0aW9ucy5hY3Rpb25fY2FsbCkgb3B0aW9ucy5hY3Rpb25fY2FsbCA9IHRoaXMuaWQrXCJfYWN0X1wiK01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo5OTk5KTtcbiAgICAgICAgICAgICAgICAvL3Bhc3MgdGhlIGFjdGlvbiBuYW1lXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldF9jb25uZWN0aW9uID0gbm9kZS5pbnB1dHNbbGlua19pbmZvLnRhcmdldF9zbG90XTtcblxuICAgICAgICAgICAgICAgIC8vaW5zdGVhZCBvZiBleGVjdXRpbmcgdGhlbSBub3csIGl0IHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIG5leHQgZ3JhcGggbG9vcCwgdG8gZW5zdXJlIGRhdGEgZmxvd1xuICAgICAgICAgICAgICAgIGlmKExpdGVHcmFwaC51c2VfZGVmZXJyZWRfYWN0aW9ucyAmJiBub2RlLm9uRXhlY3V0ZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmKCFub2RlLl93YWl0aW5nX2FjdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLl93YWl0aW5nX2FjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fd2FpdGluZ19hY3Rpb25zLnB1c2goW3RhcmdldF9jb25uZWN0aW9uLm5hbWUsIHBhcmFtLCBvcHRpb25zLCBsaW5rX2luZm8udGFyZ2V0X3Nsb3RdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd3JhcCBub2RlLm9uQWN0aW9uKHRhcmdldF9jb25uZWN0aW9uLm5hbWUsIHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hY3Rpb25EbyggdGFyZ2V0X2Nvbm5lY3Rpb24ubmFtZSwgcGFyYW0sIG9wdGlvbnMsIGxpbmtfaW5mby50YXJnZXRfc2xvdCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjbGVhcnMgdGhlIHRyaWdnZXIgc2xvdCBhbmltYXRpb25cbiAgICAgKiBAbWV0aG9kIGNsZWFyVHJpZ2dlcmVkU2xvdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzbG90IHRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IHNsb3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGlua19pZCBbb3B0aW9uYWxdIGluIGNhc2UgeW91IHdhbnQgdG8gdHJpZ2dlciBhbmQgc3BlY2lmaWMgb3V0cHV0IGxpbmsgaW4gYSBzbG90XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuY2xlYXJUcmlnZ2VyZWRTbG90ID0gZnVuY3Rpb24oc2xvdCwgbGlua19pZCkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tzbG90XTtcbiAgICAgICAgaWYgKCFvdXRwdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5rcyA9IG91dHB1dC5saW5rcztcbiAgICAgICAgaWYgKCFsaW5rcyB8fCAhbGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL2ZvciBldmVyeSBsaW5rIGF0dGFjaGVkIGhlcmVcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsaW5rcy5sZW5ndGg7ICsraykge1xuICAgICAgICAgICAgdmFyIGlkID0gbGlua3Nba107XG4gICAgICAgICAgICBpZiAobGlua19pZCAhPSBudWxsICYmIGxpbmtfaWQgIT0gaWQpIHtcbiAgICAgICAgICAgICAgICAvL3RvIHNraXAgbGlua3NcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaW5rX2luZm8gPSB0aGlzLmdyYXBoLmxpbmtzW2xpbmtzW2tdXTtcbiAgICAgICAgICAgIGlmICghbGlua19pbmZvKSB7XG4gICAgICAgICAgICAgICAgLy9ub3QgY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5rX2luZm8uX2xhc3RfdGltZSA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY2hhbmdlcyBub2RlIHNpemUgYW5kIHRyaWdnZXJzIGNhbGxiYWNrXG4gICAgICogQG1ldGhvZCBzZXRTaXplXG4gICAgICogQHBhcmFtIHt2ZWMyfSBzaXplXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uKHNpemUpXG5cdHtcblx0XHR0aGlzLnNpemUgPSBzaXplO1xuXHRcdGlmKHRoaXMub25SZXNpemUpXG5cdFx0XHR0aGlzLm9uUmVzaXplKHRoaXMuc2l6ZSk7XG5cdH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhIG5ldyBwcm9wZXJ0eSB0byB0aGlzIG5vZGVcbiAgICAgKiBAbWV0aG9kIGFkZFByb3BlcnR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IGRlZmF1bHRfdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBzdHJpbmcgZGVmaW5pbmcgdGhlIG91dHB1dCB0eXBlIChcInZlYzNcIixcIm51bWJlclwiLC4uLilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmFfaW5mbyB0aGlzIGNhbiBiZSB1c2VkIHRvIGhhdmUgc3BlY2lhbCBwcm9wZXJ0aWVzIG9mIHRoZSBwcm9wZXJ0eSAobGlrZSB2YWx1ZXMsIGV0YylcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5hZGRQcm9wZXJ0eSA9IGZ1bmN0aW9uKFxuICAgICAgICBuYW1lLFxuICAgICAgICBkZWZhdWx0X3ZhbHVlLFxuICAgICAgICB0eXBlLFxuICAgICAgICBleHRyYV9pbmZvXG4gICAgKSB7XG4gICAgICAgIHZhciBvID0geyBuYW1lOiBuYW1lLCB0eXBlOiB0eXBlLCBkZWZhdWx0X3ZhbHVlOiBkZWZhdWx0X3ZhbHVlIH07XG4gICAgICAgIGlmIChleHRyYV9pbmZvKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGV4dHJhX2luZm8pIHtcbiAgICAgICAgICAgICAgICBvW2ldID0gZXh0cmFfaW5mb1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucHJvcGVydGllc19pbmZvKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNfaW5mbyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcGVydGllc19pbmZvLnB1c2gobyk7XG4gICAgICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3BlcnRpZXNbbmFtZV0gPSBkZWZhdWx0X3ZhbHVlO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgLy9jb25uZWN0aW9uc1xuXG4gICAgLyoqXG4gICAgICogYWRkIGEgbmV3IG91dHB1dCBzbG90IHRvIHVzZSBpbiB0aGlzIG5vZGVcbiAgICAgKiBAbWV0aG9kIGFkZE91dHB1dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgc3RyaW5nIGRlZmluaW5nIHRoZSBvdXRwdXQgdHlwZSAoXCJ2ZWMzXCIsXCJudW1iZXJcIiwuLi4pXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhX2luZm8gdGhpcyBjYW4gYmUgdXNlZCB0byBoYXZlIHNwZWNpYWwgcHJvcGVydGllcyBvZiBhbiBvdXRwdXQgKGxhYmVsLCBzcGVjaWFsIGNvbG9yLCBwb3NpdGlvbiwgZXRjKVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmFkZE91dHB1dCA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUsIGV4dHJhX2luZm8pIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHsgbmFtZTogbmFtZSwgdHlwZTogdHlwZSwgbGlua3M6IG51bGwgfTtcbiAgICAgICAgaWYgKGV4dHJhX2luZm8pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gZXh0cmFfaW5mbykge1xuICAgICAgICAgICAgICAgIG91dHB1dFtpXSA9IGV4dHJhX2luZm9baV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRzLnB1c2gob3V0cHV0KTtcbiAgICAgICAgaWYgKHRoaXMub25PdXRwdXRBZGRlZCkge1xuICAgICAgICAgICAgdGhpcy5vbk91dHB1dEFkZGVkKG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChMaXRlR3JhcGguYXV0b19sb2FkX3Nsb3RfdHlwZXMpIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVBbmRTbG90VHlwZSh0aGlzLHR5cGUsdHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnNldFNpemUoIHRoaXMuY29tcHV0ZVNpemUoKSApO1xuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSBuZXcgb3V0cHV0IHNsb3QgdG8gdXNlIGluIHRoaXMgbm9kZVxuICAgICAqIEBtZXRob2QgYWRkT3V0cHV0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIHRyaXBsZXRzIGxpa2UgW1tuYW1lLHR5cGUsZXh0cmFfaW5mb10sWy4uLl1dXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuYWRkT3V0cHV0cyA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpbmZvID0gYXJyYXlbaV07XG4gICAgICAgICAgICB2YXIgbyA9IHsgbmFtZTogaW5mb1swXSwgdHlwZTogaW5mb1sxXSwgbGluazogbnVsbCB9O1xuICAgICAgICAgICAgaWYgKGFycmF5WzJdKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiBpbiBpbmZvWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgIG9bal0gPSBpbmZvWzJdW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3V0cHV0cy5wdXNoKG8pO1xuICAgICAgICAgICAgaWYgKHRoaXMub25PdXRwdXRBZGRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25PdXRwdXRBZGRlZChvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5hdXRvX2xvYWRfc2xvdF90eXBlcykgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZUFuZFNsb3RUeXBlKHRoaXMsaW5mb1sxXSx0cnVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTaXplKCB0aGlzLmNvbXB1dGVTaXplKCkgKTtcbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGFuIGV4aXN0aW5nIG91dHB1dCBzbG90XG4gICAgICogQG1ldGhvZCByZW1vdmVPdXRwdXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvdFxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLnJlbW92ZU91dHB1dCA9IGZ1bmN0aW9uKHNsb3QpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0T3V0cHV0KHNsb3QpO1xuICAgICAgICB0aGlzLm91dHB1dHMuc3BsaWNlKHNsb3QsIDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gc2xvdDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm91dHB1dHNbaV0gfHwgIXRoaXMub3V0cHV0c1tpXS5saW5rcykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpbmtzID0gdGhpcy5vdXRwdXRzW2ldLmxpbmtzO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5rcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciBsaW5rID0gdGhpcy5ncmFwaC5saW5rc1tsaW5rc1tqXV07XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5rLm9yaWdpbl9zbG90IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFNpemUoIHRoaXMuY29tcHV0ZVNpemUoKSApO1xuICAgICAgICBpZiAodGhpcy5vbk91dHB1dFJlbW92ZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25PdXRwdXRSZW1vdmVkKHNsb3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFkZCBhIG5ldyBpbnB1dCBzbG90IHRvIHVzZSBpbiB0aGlzIG5vZGVcbiAgICAgKiBAbWV0aG9kIGFkZElucHV0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBzdHJpbmcgZGVmaW5pbmcgdGhlIGlucHV0IHR5cGUgKFwidmVjM1wiLFwibnVtYmVyXCIsLi4uKSwgaXQgaXRzIGEgZ2VuZXJpYyBvbmUgdXNlIDBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmFfaW5mbyB0aGlzIGNhbiBiZSB1c2VkIHRvIGhhdmUgc3BlY2lhbCBwcm9wZXJ0aWVzIG9mIGFuIGlucHV0IChsYWJlbCwgY29sb3IsIHBvc2l0aW9uLCBldGMpXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuYWRkSW5wdXQgPSBmdW5jdGlvbihuYW1lLCB0eXBlLCBleHRyYV9pbmZvKSB7XG4gICAgICAgIHR5cGUgPSB0eXBlIHx8IDA7XG4gICAgICAgIHZhciBpbnB1dCA9IHsgbmFtZTogbmFtZSwgdHlwZTogdHlwZSwgbGluazogbnVsbCB9O1xuICAgICAgICBpZiAoZXh0cmFfaW5mbykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBleHRyYV9pbmZvKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRbaV0gPSBleHRyYV9pbmZvW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmlucHV0cykge1xuICAgICAgICAgICAgdGhpcy5pbnB1dHMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5wdXRzLnB1c2goaW5wdXQpO1xuICAgICAgICB0aGlzLnNldFNpemUoIHRoaXMuY29tcHV0ZVNpemUoKSApO1xuXG4gICAgICAgIGlmICh0aGlzLm9uSW5wdXRBZGRlZCkge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0QWRkZWQoaW5wdXQpO1xuXHRcdH1cbiAgICAgICAgXG4gICAgICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVBbmRTbG90VHlwZSh0aGlzLHR5cGUpO1xuXG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYWRkIHNldmVyYWwgbmV3IGlucHV0IHNsb3RzIGluIHRoaXMgbm9kZVxuICAgICAqIEBtZXRob2QgYWRkSW5wdXRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgdHJpcGxldHMgbGlrZSBbW25hbWUsdHlwZSxleHRyYV9pbmZvXSxbLi4uXV1cbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5hZGRJbnB1dHMgPSBmdW5jdGlvbihhcnJheSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IGFycmF5W2ldO1xuICAgICAgICAgICAgdmFyIG8gPSB7IG5hbWU6IGluZm9bMF0sIHR5cGU6IGluZm9bMV0sIGxpbms6IG51bGwgfTtcbiAgICAgICAgICAgIGlmIChhcnJheVsyXSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogaW4gaW5mb1syXSkge1xuICAgICAgICAgICAgICAgICAgICBvW2pdID0gaW5mb1syXVtqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnB1dHMucHVzaChvKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uSW5wdXRBZGRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25JbnB1dEFkZGVkKG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlQW5kU2xvdFR5cGUodGhpcyxpbmZvWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0U2l6ZSggdGhpcy5jb21wdXRlU2l6ZSgpICk7XG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhbiBleGlzdGluZyBpbnB1dCBzbG90XG4gICAgICogQG1ldGhvZCByZW1vdmVJbnB1dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbG90XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUucmVtb3ZlSW5wdXQgPSBmdW5jdGlvbihzbG90KSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdElucHV0KHNsb3QpO1xuICAgICAgICB2YXIgc2xvdF9pbmZvID0gdGhpcy5pbnB1dHMuc3BsaWNlKHNsb3QsIDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gc2xvdDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5wdXRzW2ldKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGluayA9IHRoaXMuZ3JhcGgubGlua3NbdGhpcy5pbnB1dHNbaV0ubGlua107XG4gICAgICAgICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmsudGFyZ2V0X3Nsb3QgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNpemUoIHRoaXMuY29tcHV0ZVNpemUoKSApO1xuICAgICAgICBpZiAodGhpcy5vbklucHV0UmVtb3ZlZCkge1xuICAgICAgICAgICAgdGhpcy5vbklucHV0UmVtb3ZlZChzbG90LCBzbG90X2luZm9bMF0gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYW4gc3BlY2lhbCBjb25uZWN0aW9uIHRvIHRoaXMgbm9kZSAodXNlZCBmb3Igc3BlY2lhbCBraW5kcyBvZiBncmFwaHMpXG4gICAgICogQG1ldGhvZCBhZGRDb25uZWN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBzdHJpbmcgZGVmaW5pbmcgdGhlIGlucHV0IHR5cGUgKFwidmVjM1wiLFwibnVtYmVyXCIsLi4uKVxuICAgICAqIEBwYXJhbSB7W3gseV19IHBvcyBwb3NpdGlvbiBvZiB0aGUgY29ubmVjdGlvbiBpbnNpZGUgdGhlIG5vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uIGlmIGlzIGlucHV0IG9yIG91dHB1dFxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmFkZENvbm5lY3Rpb24gPSBmdW5jdGlvbihuYW1lLCB0eXBlLCBwb3MsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgbyA9IHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgcG9zOiBwb3MsXG4gICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgICAgICAgIGxpbmtzOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnMucHVzaChvKTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNvbXB1dGVzIHRoZSBtaW5pbXVtIHNpemUgb2YgYSBub2RlIGFjY29yZGluZyB0byBpdHMgaW5wdXRzIGFuZCBvdXRwdXQgc2xvdHNcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVTaXplXG4gICAgICogQHBhcmFtIHt2ZWMyfSBtaW5IZWlnaHRcbiAgICAgKiBAcmV0dXJuIHt2ZWMyfSB0aGUgdG90YWwgc2l6ZVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmNvbXB1dGVTaXplID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnNpemUuY29uY2F0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm93cyA9IE1hdGgubWF4KFxuICAgICAgICAgICAgdGhpcy5pbnB1dHMgPyB0aGlzLmlucHV0cy5sZW5ndGggOiAxLFxuICAgICAgICAgICAgdGhpcy5vdXRwdXRzID8gdGhpcy5vdXRwdXRzLmxlbmd0aCA6IDFcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIHNpemUgPSBvdXQgfHwgbmV3IEZsb2F0MzJBcnJheShbMCwgMF0pO1xuICAgICAgICByb3dzID0gTWF0aC5tYXgocm93cywgMSk7XG4gICAgICAgIHZhciBmb250X3NpemUgPSBMaXRlR3JhcGguTk9ERV9URVhUX1NJWkU7IC8vYWx0aG91Z2ggaXQgc2hvdWxkIGJlIGdyYXBoY2FudmFzLmlubmVyX3RleHRfZm9udCBzaXplXG5cbiAgICAgICAgdmFyIHRpdGxlX3dpZHRoID0gY29tcHV0ZV90ZXh0X3NpemUodGhpcy50aXRsZSk7XG4gICAgICAgIHZhciBpbnB1dF93aWR0aCA9IDA7XG4gICAgICAgIHZhciBvdXRwdXRfd2lkdGggPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmlucHV0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmlucHV0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGlucHV0LmxhYmVsIHx8IGlucHV0Lm5hbWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dF93aWR0aCA9IGNvbXB1dGVfdGV4dF9zaXplKHRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dF93aWR0aCA8IHRleHRfd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRfd2lkdGggPSB0ZXh0X3dpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5vdXRwdXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBvdXRwdXQubGFiZWwgfHwgb3V0cHV0Lm5hbWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dF93aWR0aCA9IGNvbXB1dGVfdGV4dF9zaXplKHRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXRfd2lkdGggPCB0ZXh0X3dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dF93aWR0aCA9IHRleHRfd2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2l6ZVswXSA9IE1hdGgubWF4KGlucHV0X3dpZHRoICsgb3V0cHV0X3dpZHRoICsgMTAsIHRpdGxlX3dpZHRoKTtcbiAgICAgICAgc2l6ZVswXSA9IE1hdGgubWF4KHNpemVbMF0sIExpdGVHcmFwaC5OT0RFX1dJRFRIKTtcbiAgICAgICAgaWYgKHRoaXMud2lkZ2V0cyAmJiB0aGlzLndpZGdldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzaXplWzBdID0gTWF0aC5tYXgoc2l6ZVswXSwgTGl0ZUdyYXBoLk5PREVfV0lEVEggKiAxLjUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2l6ZVsxXSA9ICh0aGlzLmNvbnN0cnVjdG9yLnNsb3Rfc3RhcnRfeSB8fCAwKSArIHJvd3MgKiBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVDtcblxuICAgICAgICB2YXIgd2lkZ2V0c19oZWlnaHQgPSAwO1xuICAgICAgICBpZiAodGhpcy53aWRnZXRzICYmIHRoaXMud2lkZ2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy53aWRnZXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLndpZGdldHNbaV0uY29tcHV0ZVNpemUpXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldHNfaGVpZ2h0ICs9IHRoaXMud2lkZ2V0c1tpXS5jb21wdXRlU2l6ZShzaXplWzBdKVsxXSArIDQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB3aWRnZXRzX2hlaWdodCArPSBMaXRlR3JhcGguTk9ERV9XSURHRVRfSEVJR0hUICsgNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpZGdldHNfaGVpZ2h0ICs9IDg7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbXB1dGUgaGVpZ2h0IHVzaW5nIHdpZGdldHMgaGVpZ2h0XG4gICAgICAgIGlmKCB0aGlzLndpZGdldHNfdXAgKVxuICAgICAgICAgICAgc2l6ZVsxXSA9IE1hdGgubWF4KCBzaXplWzFdLCB3aWRnZXRzX2hlaWdodCApO1xuICAgICAgICBlbHNlIGlmKCB0aGlzLndpZGdldHNfc3RhcnRfeSAhPSBudWxsIClcbiAgICAgICAgICAgIHNpemVbMV0gPSBNYXRoLm1heCggc2l6ZVsxXSwgd2lkZ2V0c19oZWlnaHQgKyB0aGlzLndpZGdldHNfc3RhcnRfeSApO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzaXplWzFdICs9IHdpZGdldHNfaGVpZ2h0O1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVfdGV4dF9zaXplKHRleHQpIHtcbiAgICAgICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvbnRfc2l6ZSAqIHRleHQubGVuZ3RoICogMC42O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5taW5faGVpZ2h0ICYmXG4gICAgICAgICAgICBzaXplWzFdIDwgdGhpcy5jb25zdHJ1Y3Rvci5taW5faGVpZ2h0XG4gICAgICAgICkge1xuICAgICAgICAgICAgc2l6ZVsxXSA9IHRoaXMuY29uc3RydWN0b3IubWluX2hlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpemVbMV0gKz0gNjsgLy9tYXJnaW5cblxuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBhbGwgdGhlIGluZm8gYXZhaWxhYmxlIGFib3V0IGEgcHJvcGVydHkgb2YgdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRQcm9wZXJ0eUluZm9cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBvYmplY3Qgd2l0aCBhbGwgdGhlIGF2YWlsYWJsZSBpbmZvXG4gICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUluZm8gPSBmdW5jdGlvbiggcHJvcGVydHkgKVxuXHR7XG4gICAgICAgIHZhciBpbmZvID0gbnVsbDtcblxuXHRcdC8vdGhlcmUgYXJlIHNldmVyYWwgd2F5cyB0byBkZWZpbmUgaW5mbyBhYm91dCBhIHByb3BlcnR5XG5cdFx0Ly9sZWdhY3kgbW9kZVxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXNfaW5mbykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByb3BlcnRpZXNfaW5mby5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXNfaW5mb1tpXS5uYW1lID09IHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm8gPSB0aGlzLnByb3BlcnRpZXNfaW5mb1tpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cdFx0Ly9saXRlc2NlbmUgbW9kZSB1c2luZyB0aGUgY29uc3RydWN0b3Jcblx0XHRpZih0aGlzLmNvbnN0cnVjdG9yW1wiQFwiICsgcHJvcGVydHldKVxuXHRcdFx0aW5mbyA9IHRoaXMuY29uc3RydWN0b3JbXCJAXCIgKyBwcm9wZXJ0eV07XG5cblx0XHRpZih0aGlzLmNvbnN0cnVjdG9yLndpZGdldHNfaW5mbyAmJiB0aGlzLmNvbnN0cnVjdG9yLndpZGdldHNfaW5mb1twcm9wZXJ0eV0pXG5cdFx0XHRpbmZvID0gdGhpcy5jb25zdHJ1Y3Rvci53aWRnZXRzX2luZm9bcHJvcGVydHldO1xuXG5cdFx0Ly9saXRlc2NlbmUgbW9kZSB1c2luZyB0aGUgY29uc3RydWN0b3Jcblx0XHRpZiAoIWluZm8gJiYgdGhpcy5vbkdldFByb3BlcnR5SW5mbykge1xuICAgICAgICAgICAgaW5mbyA9IHRoaXMub25HZXRQcm9wZXJ0eUluZm8ocHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgaW5mbyA9IHt9O1xuXHRcdGlmKCFpbmZvLnR5cGUpXG5cdFx0XHRpbmZvLnR5cGUgPSB0eXBlb2YgdGhpcy5wcm9wZXJ0aWVzW3Byb3BlcnR5XTtcblx0XHRpZihpbmZvLndpZGdldCA9PSBcImNvbWJvXCIpXG5cdFx0XHRpbmZvLnR5cGUgPSBcImVudW1cIjtcblxuXHRcdHJldHVybiBpbmZvO1xuXHR9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgd2lkZ2V0IGluc2lkZSB0aGUgbm9kZSwgaXQgd2lsbCBiZSByZW5kZXJlZCBvbiB0b3Agb2YgdGhlIG5vZGUsIHlvdSBjYW4gY29udHJvbCBsb3RzIG9mIHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBtZXRob2QgYWRkV2lkZ2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHdpZGdldCB0eXBlIChjb3VsZCBiZSBcIm51bWJlclwiLFwic3RyaW5nXCIsXCJjb21ib1wiXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIHRleHQgdG8gc2hvdyBvbiB0aGUgd2lkZ2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBpdCBjaGFuZ2VzIChvcHRpb25hbGx5LCBpdCBjYW4gYmUgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIG1vZGlmeSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb2JqZWN0IHRoYXQgY29udGFpbnMgc3BlY2lhbCBwcm9wZXJ0aWVzIG9mIHRoaXMgd2lkZ2V0IFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGNyZWF0ZWQgd2lkZ2V0IG9iamVjdFxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmFkZFdpZGdldCA9IGZ1bmN0aW9uKCB0eXBlLCBuYW1lLCB2YWx1ZSwgY2FsbGJhY2ssIG9wdGlvbnMgKVxuXHR7XG4gICAgICAgIGlmICghdGhpcy53aWRnZXRzKSB7XG4gICAgICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgfVxuXG5cdFx0aWYoIW9wdGlvbnMgJiYgY2FsbGJhY2sgJiYgY2FsbGJhY2suY29uc3RydWN0b3IgPT09IE9iamVjdClcblx0XHR7XG5cdFx0XHRvcHRpb25zID0gY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIC8vb3B0aW9ucyBjYW4gYmUgdGhlIHByb3BlcnR5IG5hbWVcblx0XHRcdG9wdGlvbnMgPSB7IHByb3BlcnR5OiBvcHRpb25zIH07XG5cblx0XHRpZihjYWxsYmFjayAmJiBjYWxsYmFjay5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSAvL2NhbGxiYWNrIGNhbiBiZSB0aGUgcHJvcGVydHkgbmFtZVxuXHRcdHtcblx0XHRcdGlmKCFvcHRpb25zKVxuXHRcdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHRvcHRpb25zLnByb3BlcnR5ID0gY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYoY2FsbGJhY2sgJiYgY2FsbGJhY2suY29uc3RydWN0b3IgIT09IEZ1bmN0aW9uKVxuXHRcdHtcblx0XHRcdGNvbnNvbGUud2FybihcImFkZFdpZGdldDogY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuXHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdH1cblxuICAgICAgICB2YXIgdyA9IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zIHx8IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHcub3B0aW9ucy55ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHcueSA9IHcub3B0aW9ucy55O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjYWxsYmFjayAmJiAhdy5vcHRpb25zLmNhbGxiYWNrICYmICF3Lm9wdGlvbnMucHJvcGVydHkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkxpdGVHcmFwaCBhZGRXaWRnZXQoLi4uKSB3aXRob3V0IGEgY2FsbGJhY2sgb3IgcHJvcGVydHkgYXNzaWduZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT0gXCJjb21ib1wiICYmICF3Lm9wdGlvbnMudmFsdWVzKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkxpdGVHcmFwaCBhZGRXaWRnZXQoJ2NvbWJvJywuLi4pIHJlcXVpcmVzIHRvIHBhc3MgdmFsdWVzIGluIG9wdGlvbnM6IHsgdmFsdWVzOlsncmVkJywnYmx1ZSddIH1cIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpZGdldHMucHVzaCh3KTtcblx0XHR0aGlzLnNldFNpemUoIHRoaXMuY29tcHV0ZVNpemUoKSApO1xuICAgICAgICByZXR1cm4gdztcbiAgICB9O1xuXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuYWRkQ3VzdG9tV2lkZ2V0ID0gZnVuY3Rpb24oY3VzdG9tX3dpZGdldCkge1xuICAgICAgICBpZiAoIXRoaXMud2lkZ2V0cykge1xuICAgICAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aWRnZXRzLnB1c2goY3VzdG9tX3dpZGdldCk7XG4gICAgICAgIHJldHVybiBjdXN0b21fd2lkZ2V0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBib3VuZGluZyBvZiB0aGUgb2JqZWN0LCB1c2VkIGZvciByZW5kZXJpbmcgcHVycG9zZXNcbiAgICAgKiBAbWV0aG9kIGdldEJvdW5kaW5nXG4gICAgICogQHBhcmFtIG91dCB7RmxvYXQzMkFycmF5WzRdP30gW29wdGlvbmFsXSBhIHBsYWNlIHRvIHN0b3JlIHRoZSBvdXRwdXQsIHRvIGZyZWUgZ2FyYmFnZVxuICAgICAqIEBwYXJhbSBjb21wdXRlX291dGVyIHtib29sZWFuP30gW29wdGlvbmFsXSBzZXQgdG8gdHJ1ZSB0byBpbmNsdWRlIHRoZSBzaGFkb3cgYW5kIGNvbm5lY3Rpb24gcG9pbnRzIGluIHRoZSBib3VuZGluZyBjYWxjdWxhdGlvblxuICAgICAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheVs0XX0gdGhlIGJvdW5kaW5nIGJveCBpbiBmb3JtYXQgb2YgW3RvcGxlZnRfY29ybmVyeCwgdG9wbGVmdF9jb3JuZXJ5LCB3aWR0aCwgaGVpZ2h0XVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmdldEJvdW5kaW5nID0gZnVuY3Rpb24ob3V0LCBjb21wdXRlX291dGVyKSB7XG4gICAgICAgIG91dCA9IG91dCB8fCBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICBjb25zdCBub2RlUG9zID0gdGhpcy5wb3M7XG4gICAgICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gdGhpcy5mbGFncy5jb2xsYXBzZWQ7XG4gICAgICAgIGNvbnN0IG5vZGVTaXplID0gdGhpcy5zaXplO1xuICAgICAgICBcbiAgICAgICAgbGV0IGxlZnRfb2Zmc2V0ID0gMDtcbiAgICAgICAgLy8gMSBvZmZzZXQgZHVlIHRvIGhvdyBub2RlcyBhcmUgcmVuZGVyZWRcbiAgICAgICAgbGV0IHJpZ2h0X29mZnNldCA9ICAxIDtcbiAgICAgICAgbGV0IHRvcF9vZmZzZXQgPSAwO1xuICAgICAgICBsZXQgYm90dG9tX29mZnNldCA9IDA7XG4gICAgICAgIFxuICAgICAgICBpZiAoY29tcHV0ZV9vdXRlcikge1xuICAgICAgICAgICAgLy8gNCBvZmZzZXQgZm9yIGNvbGxhcHNlZCBub2RlIGNvbm5lY3Rpb24gcG9pbnRzXG4gICAgICAgICAgICBsZWZ0X29mZnNldCA9IDQ7XG4gICAgICAgICAgICAvLyA2IG9mZnNldCBmb3IgcmlnaHQgc2hhZG93IGFuZCBjb2xsYXBzZWQgbm9kZSBjb25uZWN0aW9uIHBvaW50c1xuICAgICAgICAgICAgcmlnaHRfb2Zmc2V0ID0gNiArIGxlZnRfb2Zmc2V0O1xuICAgICAgICAgICAgLy8gNCBvZmZzZXQgZm9yIGNvbGxhcHNlZCBub2RlcyB0b3AgY29ubmVjdGlvbiBwb2ludHNcbiAgICAgICAgICAgIHRvcF9vZmZzZXQgPSA0O1xuICAgICAgICAgICAgLy8gNSBvZmZzZXQgZm9yIGJvdHRvbSBzaGFkb3cgYW5kIGNvbGxhcHNlZCBub2RlIGNvbm5lY3Rpb24gcG9pbnRzXG4gICAgICAgICAgICBib3R0b21fb2Zmc2V0ID0gNSArIHRvcF9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIG91dFswXSA9IG5vZGVQb3NbMF0gLSBsZWZ0X29mZnNldDtcbiAgICAgICAgb3V0WzFdID0gbm9kZVBvc1sxXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCAtIHRvcF9vZmZzZXQ7XG4gICAgICAgIG91dFsyXSA9IGlzQ29sbGFwc2VkID9cbiAgICAgICAgICAgICh0aGlzLl9jb2xsYXBzZWRfd2lkdGggfHwgTGl0ZUdyYXBoLk5PREVfQ09MTEFQU0VEX1dJRFRIKSArIHJpZ2h0X29mZnNldCA6XG4gICAgICAgICAgICBub2RlU2l6ZVswXSArIHJpZ2h0X29mZnNldDtcbiAgICAgICAgb3V0WzNdID0gaXNDb2xsYXBzZWQgP1xuICAgICAgICAgICAgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICsgYm90dG9tX29mZnNldCA6XG4gICAgICAgICAgICBub2RlU2l6ZVsxXSArIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCArIGJvdHRvbV9vZmZzZXQ7XG5cbiAgICAgICAgaWYgKHRoaXMub25Cb3VuZGluZykge1xuICAgICAgICAgICAgdGhpcy5vbkJvdW5kaW5nKG91dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY2hlY2tzIGlmIGEgcG9pbnQgaXMgaW5zaWRlIHRoZSBzaGFwZSBvZiBhIG5vZGVcbiAgICAgKiBAbWV0aG9kIGlzUG9pbnRJbnNpZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5pc1BvaW50SW5zaWRlID0gZnVuY3Rpb24oeCwgeSwgbWFyZ2luLCBza2lwX3RpdGxlKSB7XG4gICAgICAgIG1hcmdpbiA9IG1hcmdpbiB8fCAwO1xuXG4gICAgICAgIHZhciBtYXJnaW5fdG9wID0gdGhpcy5ncmFwaCAmJiB0aGlzLmdyYXBoLmlzTGl2ZSgpID8gMCA6IExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVDtcbiAgICAgICAgaWYgKHNraXBfdGl0bGUpIHtcbiAgICAgICAgICAgIG1hcmdpbl90b3AgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZsYWdzICYmIHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAvL2lmICggZGlzdGFuY2UoW3gseV0sIFt0aGlzLnBvc1swXSArIHRoaXMuc2l6ZVswXSowLjUsIHRoaXMucG9zWzFdICsgdGhpcy5zaXplWzFdKjAuNV0pIDwgTGl0ZUdyYXBoLk5PREVfQ09MTEFQU0VEX1JBRElVUylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpc0luc2lkZVJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NbMF0gLSBtYXJnaW4sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zWzFdIC0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUIC0gbWFyZ2luLFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5fY29sbGFwc2VkX3dpZHRoIHx8IExpdGVHcmFwaC5OT0RFX0NPTExBUFNFRF9XSURUSCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgMiAqIG1hcmdpbixcbiAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICsgMiAqIG1hcmdpblxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgdGhpcy5wb3NbMF0gLSA0IC0gbWFyZ2luIDwgeCAmJlxuICAgICAgICAgICAgdGhpcy5wb3NbMF0gKyB0aGlzLnNpemVbMF0gKyA0ICsgbWFyZ2luID4geCAmJlxuICAgICAgICAgICAgdGhpcy5wb3NbMV0gLSBtYXJnaW5fdG9wIC0gbWFyZ2luIDwgeSAmJlxuICAgICAgICAgICAgdGhpcy5wb3NbMV0gKyB0aGlzLnNpemVbMV0gKyBtYXJnaW4gPiB5XG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjaGVja3MgaWYgYSBwb2ludCBpcyBpbnNpZGUgYSBub2RlIHNsb3QsIGFuZCByZXR1cm5zIGluZm8gYWJvdXQgd2hpY2ggc2xvdFxuICAgICAqIEBtZXRob2QgZ2V0U2xvdEluUG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBpZiBmb3VuZCB0aGUgb2JqZWN0IGNvbnRhaW5zIHsgaW5wdXR8b3V0cHV0OiBzbG90IG9iamVjdCwgc2xvdDogbnVtYmVyLCBsaW5rX3BvczogW3gseV0gfVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmdldFNsb3RJblBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAvL3NlYXJjaCBmb3IgaW5wdXRzXG4gICAgICAgIHZhciBsaW5rX3BvcyA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG4gICAgICAgIGlmICh0aGlzLmlucHV0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmlucHV0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdldENvbm5lY3Rpb25Qb3ModHJ1ZSwgaSwgbGlua19wb3MpO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgaXNJbnNpZGVSZWN0YW5nbGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfcG9zWzBdIC0gMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX3Bvc1sxXSAtIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAyMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaW5wdXQ6IGlucHV0LCBzbG90OiBpLCBsaW5rX3BvczogbGlua19wb3MgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vdXRwdXRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMub3V0cHV0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29ubmVjdGlvblBvcyhmYWxzZSwgaSwgbGlua19wb3MpO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgaXNJbnNpZGVSZWN0YW5nbGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfcG9zWzBdIC0gMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX3Bvc1sxXSAtIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAyMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgb3V0cHV0OiBvdXRwdXQsIHNsb3Q6IGksIGxpbmtfcG9zOiBsaW5rX3BvcyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBpbnB1dCBzbG90IHdpdGggYSBnaXZlbiBuYW1lICh1c2VkIGZvciBkeW5hbWljIHNsb3RzKSwgLTEgaWYgbm90IGZvdW5kXG4gICAgICogQG1ldGhvZCBmaW5kSW5wdXRTbG90XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIHNsb3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJldHVybk9iaiBpZiB0aGUgb2JqIGl0c2VsZiB3YW50ZWRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJfb3Jfb2JqZWN0fSB0aGUgc2xvdCAoLTEgaWYgbm90IGZvdW5kKVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmZpbmRJbnB1dFNsb3QgPSBmdW5jdGlvbihuYW1lLCAgcmV0dXJuT2JqKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT0gdGhpcy5pbnB1dHNbaV0ubmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhcmV0dXJuT2JqID8gaSA6IHRoaXMuaW5wdXRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgb3V0cHV0IHNsb3Qgd2l0aCBhIGdpdmVuIG5hbWUgKHVzZWQgZm9yIGR5bmFtaWMgc2xvdHMpLCAtMSBpZiBub3QgZm91bmRcbiAgICAgKiBAbWV0aG9kIGZpbmRPdXRwdXRTbG90XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIHNsb3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJldHVybk9iaiBpZiB0aGUgb2JqIGl0c2VsZiB3YW50ZWRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJfb3Jfb2JqZWN0fSB0aGUgc2xvdCAoLTEgaWYgbm90IGZvdW5kKVxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmZpbmRPdXRwdXRTbG90ID0gZnVuY3Rpb24obmFtZSwgcmV0dXJuT2JqKSB7XG4gICAgICAgIHJldHVybk9iaiA9IHJldHVybk9iaiB8fCBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMub3V0cHV0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09IHRoaXMub3V0cHV0c1tpXS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFyZXR1cm5PYmogPyBpIDogdGhpcy5vdXRwdXRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIFxuICAgIC8vIFRPRE8gcmVmYWN0b3I6IFVTRSBTSU5HTEUgZmluZElucHV0L2ZpbmRPdXRwdXQgZnVuY3Rpb25zISA6OiBtZXJnZSBvcHRpb25zXG4gICAgXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgZmlyc3QgZnJlZSBpbnB1dCBzbG90XG4gICAgICogQG1ldGhvZCBmaW5kSW5wdXRTbG90RnJlZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7bnVtYmVyX29yX29iamVjdH0gdGhlIHNsb3QgKC0xIGlmIG5vdCBmb3VuZClcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5maW5kSW5wdXRTbG90RnJlZSA9IGZ1bmN0aW9uKG9wdHNJbikge1xuICAgICAgICB2YXIgb3B0c0luID0gb3B0c0luIHx8IHt9O1xuICAgICAgICB2YXIgb3B0c0RlZiA9IHtyZXR1cm5PYmo6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAsdHlwZXNOb3RBY2NlcHRlZDogW11cbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICB2YXIgb3B0cyA9IE9iamVjdC5hc3NpZ24ob3B0c0RlZixvcHRzSW4pO1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmlucHV0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0c1tpXS5saW5rICYmIHRoaXMuaW5wdXRzW2ldLmxpbmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMudHlwZXNOb3RBY2NlcHRlZCAmJiBvcHRzLnR5cGVzTm90QWNjZXB0ZWQuaW5jbHVkZXMgJiYgb3B0cy50eXBlc05vdEFjY2VwdGVkLmluY2x1ZGVzKHRoaXMuaW5wdXRzW2ldLnR5cGUpKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhb3B0cy5yZXR1cm5PYmogPyBpIDogdGhpcy5pbnB1dHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBmaXJzdCBvdXRwdXQgc2xvdCBmcmVlXG4gICAgICogQG1ldGhvZCBmaW5kT3V0cHV0U2xvdEZyZWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge251bWJlcl9vcl9vYmplY3R9IHRoZSBzbG90ICgtMSBpZiBub3QgZm91bmQpXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZmluZE91dHB1dFNsb3RGcmVlID0gZnVuY3Rpb24ob3B0c0luKSB7XG4gICAgICAgIHZhciBvcHRzSW4gPSBvcHRzSW4gfHwge307XG4gICAgICAgIHZhciBvcHRzRGVmID0geyByZXR1cm5PYmo6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAsdHlwZXNOb3RBY2NlcHRlZDogW11cbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICB2YXIgb3B0cyA9IE9iamVjdC5hc3NpZ24ob3B0c0RlZixvcHRzSW4pO1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0cykge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5vdXRwdXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0c1tpXS5saW5rcyAmJiB0aGlzLm91dHB1dHNbaV0ubGlua3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMudHlwZXNOb3RBY2NlcHRlZCAmJiBvcHRzLnR5cGVzTm90QWNjZXB0ZWQuaW5jbHVkZXMgJiYgb3B0cy50eXBlc05vdEFjY2VwdGVkLmluY2x1ZGVzKHRoaXMub3V0cHV0c1tpXS50eXBlKSl7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIW9wdHMucmV0dXJuT2JqID8gaSA6IHRoaXMub3V0cHV0c1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBmaW5kU2xvdEJ5VHlwZSBmb3IgSU5QVVRTXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZmluZElucHV0U2xvdEJ5VHlwZSA9IGZ1bmN0aW9uKHR5cGUsIHJldHVybk9iaiwgcHJlZmVyRnJlZVNsb3QsIGRvTm90VXNlT2NjdXBpZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFNsb3RCeVR5cGUodHJ1ZSwgdHlwZSwgcmV0dXJuT2JqLCBwcmVmZXJGcmVlU2xvdCwgZG9Ob3RVc2VPY2N1cGllZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGZpbmRTbG90QnlUeXBlIGZvciBPVVRQVVRTXG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZmluZE91dHB1dFNsb3RCeVR5cGUgPSBmdW5jdGlvbih0eXBlLCByZXR1cm5PYmosIHByZWZlckZyZWVTbG90LCBkb05vdFVzZU9jY3VwaWVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRTbG90QnlUeXBlKGZhbHNlLCB0eXBlLCByZXR1cm5PYmosIHByZWZlckZyZWVTbG90LCBkb05vdFVzZU9jY3VwaWVkKTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIG91dHB1dCAob3IgaW5wdXQpIHNsb3Qgd2l0aCBhIGdpdmVuIHR5cGUsIC0xIGlmIG5vdCBmb3VuZFxuICAgICAqIEBtZXRob2QgZmluZFNsb3RCeVR5cGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlucHV0IHVpc2UgaW5wdXRzIGluc3RlYWQgb2Ygb3V0cHV0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBzbG90XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXR1cm5PYmogaWYgdGhlIG9iaiBpdHNlbGYgd2FudGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwcmVmZXJGcmVlU2xvdCBpZiB3ZSB3YW50IGEgZnJlZSBzbG90IChpZiBub3QgZm91bmQsIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBvZiB0aGUgdHlwZSBhbnl3YXkpXG4gICAgICogQHJldHVybiB7bnVtYmVyX29yX29iamVjdH0gdGhlIHNsb3QgKC0xIGlmIG5vdCBmb3VuZClcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5maW5kU2xvdEJ5VHlwZSA9IGZ1bmN0aW9uKGlucHV0LCB0eXBlLCByZXR1cm5PYmosIHByZWZlckZyZWVTbG90LCBkb05vdFVzZU9jY3VwaWVkKSB7XG4gICAgICAgIGlucHV0ID0gaW5wdXQgfHwgZmFsc2U7XG4gICAgICAgIHJldHVybk9iaiA9IHJldHVybk9iaiB8fCBmYWxzZTtcbiAgICAgICAgcHJlZmVyRnJlZVNsb3QgPSBwcmVmZXJGcmVlU2xvdCB8fCBmYWxzZTtcbiAgICAgICAgZG9Ob3RVc2VPY2N1cGllZCA9IGRvTm90VXNlT2NjdXBpZWQgfHwgZmFsc2U7XG4gICAgICAgIHZhciBhU2xvdHMgPSBpbnB1dCA/IHRoaXMuaW5wdXRzIDogdGhpcy5vdXRwdXRzO1xuICAgICAgICBpZiAoIWFTbG90cykge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cdFx0Ly8gISEgZW1wdHkgc3RyaW5nIHR5cGUgaXMgY29uc2lkZXJlZCAwLCAqICEhXG5cdFx0aWYgKHR5cGUgPT0gXCJcIiB8fCB0eXBlID09IFwiKlwiKSB0eXBlID0gMDsgXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYVNsb3RzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdmFyIHRGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGFTb3VyY2UgPSAodHlwZStcIlwiKS50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgIHZhciBhRGVzdCA9IGFTbG90c1tpXS50eXBlPT1cIjBcInx8YVNsb3RzW2ldLnR5cGU9PVwiKlwiP1wiMFwiOmFTbG90c1tpXS50eXBlO1xuXHRcdFx0YURlc3QgPSAoYURlc3QrXCJcIikudG9Mb3dlckNhc2UoKS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICBmb3IodmFyIHNJPTA7c0k8YVNvdXJjZS5sZW5ndGg7c0krKyl7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBkST0wO2RJPGFEZXN0Lmxlbmd0aDtkSSsrKXtcblx0XHRcdFx0XHRpZiAoYVNvdXJjZVtzSV09PVwiX2V2ZW50X1wiKSBhU291cmNlW3NJXSA9IExpdGVHcmFwaC5FVkVOVDtcblx0XHRcdFx0XHRpZiAoYURlc3Rbc0ldPT1cIl9ldmVudF9cIikgYURlc3Rbc0ldID0gTGl0ZUdyYXBoLkVWRU5UO1xuXHRcdFx0XHRcdGlmIChhU291cmNlW3NJXT09XCIqXCIpIGFTb3VyY2Vbc0ldID0gMDtcblx0XHRcdFx0XHRpZiAoYURlc3Rbc0ldPT1cIipcIikgYURlc3Rbc0ldID0gMDtcblx0XHRcdFx0XHRpZiAoYVNvdXJjZVtzSV0gPT0gYURlc3RbZEldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZmVyRnJlZVNsb3QgJiYgYVNsb3RzW2ldLmxpbmtzICYmIGFTbG90c1tpXS5saW5rcyAhPT0gbnVsbCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXJldHVybk9iaiA/IGkgOiBhU2xvdHNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgZGlkbnQgZmluZCBzb21lLCBzdG9wIGNoZWNraW5nIGZvciBmcmVlIHNsb3RzXG4gICAgICAgIGlmIChwcmVmZXJGcmVlU2xvdCAmJiAhZG9Ob3RVc2VPY2N1cGllZCl7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFTbG90cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgdEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGFTb3VyY2UgPSAodHlwZStcIlwiKS50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgYURlc3QgPSBhU2xvdHNbaV0udHlwZT09XCIwXCJ8fGFTbG90c1tpXS50eXBlPT1cIipcIj9cIjBcIjphU2xvdHNbaV0udHlwZTtcblx0XHRcdFx0YURlc3QgPSAoYURlc3QrXCJcIikudG9Mb3dlckNhc2UoKS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBzST0wO3NJPGFTb3VyY2UubGVuZ3RoO3NJKyspe1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGRJPTA7ZEk8YURlc3QubGVuZ3RoO2RJKyspe1xuXHRcdFx0XHRcdFx0aWYgKGFTb3VyY2Vbc0ldPT1cIipcIikgYVNvdXJjZVtzSV0gPSAwO1xuXHRcdFx0XHRcdFx0aWYgKGFEZXN0W3NJXT09XCIqXCIpIGFEZXN0W3NJXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYVNvdXJjZVtzSV0gPT0gYURlc3RbZEldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFyZXR1cm5PYmogPyBpIDogYVNsb3RzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY29ubmVjdCB0aGlzIG5vZGUgb3V0cHV0IHRvIHRoZSBpbnB1dCBvZiBhbm90aGVyIG5vZGUgQlkgVFlQRVxuICAgICAqIEBtZXRob2QgY29ubmVjdEJ5VHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyX29yX3N0cmluZ30gc2xvdCAoY291bGQgYmUgdGhlIG51bWJlciBvZiB0aGUgc2xvdCBvciB0aGUgc3RyaW5nIHdpdGggdGhlIG5hbWUgb2YgdGhlIHNsb3QpXG4gICAgICogQHBhcmFtIHtMR3JhcGhOb2RlfSBub2RlIHRoZSB0YXJnZXQgbm9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRfdHlwZSB0aGUgaW5wdXQgc2xvdCB0eXBlIG9mIHRoZSB0YXJnZXQgbm9kZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGxpbmtfaW5mbyBpcyBjcmVhdGVkLCBvdGhlcndpc2UgbnVsbFxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmNvbm5lY3RCeVR5cGUgPSBmdW5jdGlvbihzbG90LCB0YXJnZXRfbm9kZSwgdGFyZ2V0X3Nsb3RUeXBlLCBvcHRzSW4pIHtcbiAgICAgICAgdmFyIG9wdHNJbiA9IG9wdHNJbiB8fCB7fTtcbiAgICAgICAgdmFyIG9wdHNEZWYgPSB7IGNyZWF0ZUV2ZW50SW5DYXNlOiB0cnVlXG5cdFx0XHRcdFx0ICAgXHQsZmlyc3RGcmVlSWZPdXRwdXRHZW5lcmFsSW5DYXNlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAsZ2VuZXJhbFR5cGVJbkNhc2U6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICB2YXIgb3B0cyA9IE9iamVjdC5hc3NpZ24ob3B0c0RlZixvcHRzSW4pO1xuICAgICAgICBpZiAodGFyZ2V0X25vZGUgJiYgdGFyZ2V0X25vZGUuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuICAgICAgICAgICAgdGFyZ2V0X25vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVCeUlkKHRhcmdldF9ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFyZ2V0X3Nsb3QgPSB0YXJnZXRfbm9kZS5maW5kSW5wdXRTbG90QnlUeXBlKHRhcmdldF9zbG90VHlwZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICBpZiAodGFyZ2V0X3Nsb3QgPj0gMCAmJiB0YXJnZXRfc2xvdCAhPT0gbnVsbCl7XG4gICAgICAgICAgICAvL2NvbnNvbGUuZGVidWcoXCJDT05OYnlUWVBFIHR5cGUgXCIrdGFyZ2V0X3Nsb3RUeXBlK1wiIGZvciBcIit0YXJnZXRfc2xvdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Qoc2xvdCwgdGFyZ2V0X25vZGUsIHRhcmdldF9zbG90KTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwidHlwZSBcIit0YXJnZXRfc2xvdFR5cGUrXCIgbm90IGZvdW5kIG9yIG5vdCBmcmVlP1wiKVxuICAgICAgICAgICAgaWYgKG9wdHMuY3JlYXRlRXZlbnRJbkNhc2UgJiYgdGFyZ2V0X3Nsb3RUeXBlID09IExpdGVHcmFwaC5FVkVOVCl7XG4gICAgICAgICAgICAgICAgLy8gV0lMTCBDUkVBVEUgVEhFIG9uVHJpZ2dlciBJTiBTTE9UXG5cdFx0XHRcdC8vY29uc29sZS5kZWJ1ZyhcImNvbm5lY3QgV0lMTCBDUkVBVEUgVEhFIG9uVHJpZ2dlciBcIit0YXJnZXRfc2xvdFR5cGUrXCIgdG8gXCIrdGFyZ2V0X25vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Qoc2xvdCwgdGFyZ2V0X25vZGUsIC0xKTtcbiAgICAgICAgICAgIH1cblx0XHRcdC8vIGNvbm5lY3QgdG8gdGhlIGZpcnN0IGdlbmVyYWwgb3V0cHV0IHNsb3QgaWYgbm90IGZvdW5kIGEgc3BlY2lmaWMgdHlwZSBhbmQgXG4gICAgICAgICAgICBpZiAob3B0cy5nZW5lcmFsVHlwZUluQ2FzZSl7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldF9zbG90ID0gdGFyZ2V0X25vZGUuZmluZElucHV0U2xvdEJ5VHlwZSgwLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdC8vY29uc29sZS5kZWJ1ZyhcImNvbm5lY3QgVE8gYSBnZW5lcmFsIHR5cGUgKCosIDApLCBpZiBub3QgZm91bmQgdGhlIHNwZWNpZmljIHR5cGUgXCIsdGFyZ2V0X3Nsb3RUeXBlLFwiIHRvIFwiLHRhcmdldF9ub2RlLFwiUkVTX1NMT1Q6XCIsdGFyZ2V0X3Nsb3QpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRfc2xvdCA+PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdChzbG90LCB0YXJnZXRfbm9kZSwgdGFyZ2V0X3Nsb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbm5lY3QgdG8gdGhlIGZpcnN0IGZyZWUgaW5wdXQgc2xvdCBpZiBub3QgZm91bmQgYSBzcGVjaWZpYyB0eXBlIGFuZCB0aGlzIG91dHB1dCBpcyBnZW5lcmFsXG4gICAgICAgICAgICBpZiAob3B0cy5maXJzdEZyZWVJZk91dHB1dEdlbmVyYWxJbkNhc2UgJiYgKHRhcmdldF9zbG90VHlwZSA9PSAwIHx8IHRhcmdldF9zbG90VHlwZSA9PSBcIipcIiB8fCB0YXJnZXRfc2xvdFR5cGUgPT0gXCJcIikpe1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRfc2xvdCA9IHRhcmdldF9ub2RlLmZpbmRJbnB1dFNsb3RGcmVlKHt0eXBlc05vdEFjY2VwdGVkOiBbTGl0ZUdyYXBoLkVWRU5UXSB9KTtcblx0XHRcdFx0Ly9jb25zb2xlLmRlYnVnKFwiY29ubmVjdCBUTyBUaGVGaXJzdEZSRUUgXCIsdGFyZ2V0X3Nsb3RUeXBlLFwiIHRvIFwiLHRhcmdldF9ub2RlLFwiUkVTX1NMT1Q6XCIsdGFyZ2V0X3Nsb3QpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRfc2xvdCA+PSAwKXtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jb25uZWN0KHNsb3QsIHRhcmdldF9ub2RlLCB0YXJnZXRfc2xvdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXHRcdFx0XG5cdFx0XHRjb25zb2xlLmRlYnVnKFwibm8gd2F5IHRvIGNvbm5lY3QgdHlwZTogXCIsdGFyZ2V0X3Nsb3RUeXBlLFwiIHRvIHRhcmdldE5PREUgXCIsdGFyZ2V0X25vZGUpO1xuXHRcdFx0Ly9UT0RPIGZpbHRlclxuXHRcdFx0XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBjb25uZWN0IHRoaXMgbm9kZSBpbnB1dCB0byB0aGUgb3V0cHV0IG9mIGFub3RoZXIgbm9kZSBCWSBUWVBFXG4gICAgICogQG1ldGhvZCBjb25uZWN0QnlUeXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJfb3Jfc3RyaW5nfSBzbG90IChjb3VsZCBiZSB0aGUgbnVtYmVyIG9mIHRoZSBzbG90IG9yIHRoZSBzdHJpbmcgd2l0aCB0aGUgbmFtZSBvZiB0aGUgc2xvdClcbiAgICAgKiBAcGFyYW0ge0xHcmFwaE5vZGV9IG5vZGUgdGhlIHRhcmdldCBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldF90eXBlIHRoZSBvdXRwdXQgc2xvdCB0eXBlIG9mIHRoZSB0YXJnZXQgbm9kZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGxpbmtfaW5mbyBpcyBjcmVhdGVkLCBvdGhlcndpc2UgbnVsbFxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmNvbm5lY3RCeVR5cGVPdXRwdXQgPSBmdW5jdGlvbihzbG90LCBzb3VyY2Vfbm9kZSwgc291cmNlX3Nsb3RUeXBlLCBvcHRzSW4pIHtcbiAgICAgICAgdmFyIG9wdHNJbiA9IG9wdHNJbiB8fCB7fTtcbiAgICAgICAgdmFyIG9wdHNEZWYgPSB7IGNyZWF0ZUV2ZW50SW5DYXNlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAsZmlyc3RGcmVlSWZJbnB1dEdlbmVyYWxJbkNhc2U6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICxnZW5lcmFsVHlwZUluQ2FzZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmFzc2lnbihvcHRzRGVmLG9wdHNJbik7XG4gICAgICAgIGlmIChzb3VyY2Vfbm9kZSAmJiBzb3VyY2Vfbm9kZS5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKSB7XG4gICAgICAgICAgICBzb3VyY2Vfbm9kZSA9IHRoaXMuZ3JhcGguZ2V0Tm9kZUJ5SWQoc291cmNlX25vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzb3VyY2Vfc2xvdCA9IHNvdXJjZV9ub2RlLmZpbmRPdXRwdXRTbG90QnlUeXBlKHNvdXJjZV9zbG90VHlwZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICBpZiAoc291cmNlX3Nsb3QgPj0gMCAmJiBzb3VyY2Vfc2xvdCAhPT0gbnVsbCl7XG4gICAgICAgICAgICAvL2NvbnNvbGUuZGVidWcoXCJDT05OYnlUWVBFIE9VVCEgdHlwZSBcIitzb3VyY2Vfc2xvdFR5cGUrXCIgZm9yIFwiK3NvdXJjZV9zbG90KVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZV9ub2RlLmNvbm5lY3Qoc291cmNlX3Nsb3QsIHRoaXMsIHNsb3QpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gY29ubmVjdCB0byB0aGUgZmlyc3QgZ2VuZXJhbCBvdXRwdXQgc2xvdCBpZiBub3QgZm91bmQgYSBzcGVjaWZpYyB0eXBlIGFuZCBcbiAgICAgICAgICAgIGlmIChvcHRzLmdlbmVyYWxUeXBlSW5DYXNlKXtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlX3Nsb3QgPSBzb3VyY2Vfbm9kZS5maW5kT3V0cHV0U2xvdEJ5VHlwZSgwLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZV9zbG90ID49IDApe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlX25vZGUuY29ubmVjdChzb3VyY2Vfc2xvdCwgdGhpcywgc2xvdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAob3B0cy5jcmVhdGVFdmVudEluQ2FzZSAmJiBzb3VyY2Vfc2xvdFR5cGUgPT0gTGl0ZUdyYXBoLkVWRU5UKXtcbiAgICAgICAgICAgICAgICAvLyBXSUxMIENSRUFURSBUSEUgb25FeGVjdXRlZCBPVVQgU0xPVFxuXHRcdFx0XHRpZiAoTGl0ZUdyYXBoLmRvX2FkZF90cmlnZ2Vyc19zbG90cyl7XG5cdFx0XHRcdFx0dmFyIHNvdXJjZV9zbG90ID0gc291cmNlX25vZGUuYWRkT25FeGVjdXRlZE91dHB1dCgpO1xuXHRcdFx0XHRcdHJldHVybiBzb3VyY2Vfbm9kZS5jb25uZWN0KHNvdXJjZV9zbG90LCB0aGlzLCBzbG90KTtcblx0XHRcdFx0fVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29ubmVjdCB0byB0aGUgZmlyc3QgZnJlZSBvdXRwdXQgc2xvdCBpZiBub3QgZm91bmQgYSBzcGVjaWZpYyB0eXBlIGFuZCB0aGlzIGlucHV0IGlzIGdlbmVyYWxcbiAgICAgICAgICAgIGlmIChvcHRzLmZpcnN0RnJlZUlmSW5wdXRHZW5lcmFsSW5DYXNlICYmIChzb3VyY2Vfc2xvdFR5cGUgPT0gMCB8fCBzb3VyY2Vfc2xvdFR5cGUgPT0gXCIqXCIgfHwgc291cmNlX3Nsb3RUeXBlID09IFwiXCIpKXtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlX3Nsb3QgPSBzb3VyY2Vfbm9kZS5maW5kT3V0cHV0U2xvdEZyZWUoe3R5cGVzTm90QWNjZXB0ZWQ6IFtMaXRlR3JhcGguRVZFTlRdIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Vfc2xvdCA+PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZV9ub2RlLmNvbm5lY3Qoc291cmNlX3Nsb3QsIHRoaXMsIHNsb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuXHRcdFx0Y29uc29sZS5kZWJ1ZyhcIm5vIHdheSB0byBjb25uZWN0IGJ5T1VUIHR5cGU6IFwiLHNvdXJjZV9zbG90VHlwZSxcIiB0byBzb3VyY2VOT0RFIFwiLHNvdXJjZV9ub2RlKTtcblx0XHRcdC8vVE9ETyBmaWx0ZXJcblx0XHRcdFxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInR5cGUgT1VUISBcIitzb3VyY2Vfc2xvdFR5cGUrXCIgbm90IGZvdW5kIG9yIG5vdCBmcmVlP1wiKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogY29ubmVjdCB0aGlzIG5vZGUgb3V0cHV0IHRvIHRoZSBpbnB1dCBvZiBhbm90aGVyIG5vZGVcbiAgICAgKiBAbWV0aG9kIGNvbm5lY3RcbiAgICAgKiBAcGFyYW0ge251bWJlcl9vcl9zdHJpbmd9IHNsb3QgKGNvdWxkIGJlIHRoZSBudW1iZXIgb2YgdGhlIHNsb3Qgb3IgdGhlIHN0cmluZyB3aXRoIHRoZSBuYW1lIG9mIHRoZSBzbG90KVxuICAgICAqIEBwYXJhbSB7TEdyYXBoTm9kZX0gbm9kZSB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcl9vcl9zdHJpbmd9IHRhcmdldF9zbG90IHRoZSBpbnB1dCBzbG90IG9mIHRoZSB0YXJnZXQgbm9kZSAoY291bGQgYmUgdGhlIG51bWJlciBvZiB0aGUgc2xvdCBvciB0aGUgc3RyaW5nIHdpdGggdGhlIG5hbWUgb2YgdGhlIHNsb3QsIG9yIC0xIHRvIGNvbm5lY3QgYSB0cmlnZ2VyKVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGxpbmtfaW5mbyBpcyBjcmVhdGVkLCBvdGhlcndpc2UgbnVsbFxuICAgICAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihzbG90LCB0YXJnZXRfbm9kZSwgdGFyZ2V0X3Nsb3QpIHtcbiAgICAgICAgdGFyZ2V0X3Nsb3QgPSB0YXJnZXRfc2xvdCB8fCAwO1xuXG4gICAgICAgIGlmICghdGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgLy9jb3VsZCBiZSBjb25uZWN0ZWQgYmVmb3JlIGFkZGluZyBpdCB0byBhIGdyYXBoXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBcIkNvbm5lY3Q6IEVycm9yLCBub2RlIGRvZXNuJ3QgYmVsb25nIHRvIGFueSBncmFwaC4gTm9kZXMgbXVzdCBiZSBhZGRlZCBmaXJzdCB0byBhIGdyYXBoIGJlZm9yZSBjb25uZWN0aW5nIHRoZW0uXCJcbiAgICAgICAgICAgICk7IC8vZHVlIHRvIGxpbmsgaWRzIGJlaW5nIGFzc29jaWF0ZWQgd2l0aCBncmFwaHNcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9zZWVrIGZvciB0aGUgb3V0cHV0IHNsb3RcbiAgICAgICAgaWYgKHNsb3QuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgICAgICAgc2xvdCA9IHRoaXMuZmluZE91dHB1dFNsb3Qoc2xvdCk7XG4gICAgICAgICAgICBpZiAoc2xvdCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0OiBFcnJvciwgbm8gc2xvdCBvZiBuYW1lIFwiICsgc2xvdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm91dHB1dHMgfHwgc2xvdCA+PSB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0OiBFcnJvciwgc2xvdCBudW1iZXIgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0X25vZGUgJiYgdGFyZ2V0X25vZGUuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuICAgICAgICAgICAgdGFyZ2V0X25vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVCeUlkKHRhcmdldF9ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhcmdldF9ub2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBcInRhcmdldCBub2RlIGlzIG51bGxcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYXZvaWQgbG9vcGJhY2tcbiAgICAgICAgaWYgKHRhcmdldF9ub2RlID09IHRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy95b3UgY2FuIHNwZWNpZnkgdGhlIHNsb3QgYnkgbmFtZVxuICAgICAgICBpZiAodGFyZ2V0X3Nsb3QuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgICAgICAgdGFyZ2V0X3Nsb3QgPSB0YXJnZXRfbm9kZS5maW5kSW5wdXRTbG90KHRhcmdldF9zbG90KTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRfc2xvdCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkNvbm5lY3Q6IEVycm9yLCBubyBzbG90IG9mIG5hbWUgXCIgKyB0YXJnZXRfc2xvdFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRfc2xvdCA9PT0gTGl0ZUdyYXBoLkVWRU5UKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChMaXRlR3JhcGguZG9fYWRkX3RyaWdnZXJzX3Nsb3RzKXtcblx0ICAgICAgICAgICAgLy9zZWFyY2ggZm9yIGZpcnN0IHNsb3Qgd2l0aCBldmVudD8gOjogTk8gdGhpcyBpcyBkb25lIG91dHNpZGVcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIkNvbm5lY3Q6IENyZWF0aW5nIHRyaWdnZXJFdmVudFwiKTtcblx0ICAgICAgICAgICAgLy8gZm9yY2UgbW9kZVxuXHQgICAgICAgICAgICB0YXJnZXRfbm9kZS5jaGFuZ2VNb2RlKExpdGVHcmFwaC5PTl9UUklHR0VSKTtcblx0ICAgICAgICAgICAgdGFyZ2V0X3Nsb3QgPSB0YXJnZXRfbm9kZS5maW5kSW5wdXRTbG90KFwib25UcmlnZ2VyXCIpO1xuICAgICAgICBcdH1lbHNle1xuICAgICAgICAgICAgXHRyZXR1cm4gbnVsbDsgLy8gLS0gYnJlYWsgLS1cblx0XHRcdH1cbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICF0YXJnZXRfbm9kZS5pbnB1dHMgfHxcbiAgICAgICAgICAgIHRhcmdldF9zbG90ID49IHRhcmdldF9ub2RlLmlucHV0cy5sZW5ndGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0OiBFcnJvciwgc2xvdCBudW1iZXIgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuXHRcdHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGlucHV0ID0gdGFyZ2V0X25vZGUuaW5wdXRzW3RhcmdldF9zbG90XTtcbiAgICAgICAgdmFyIGxpbmtfaW5mbyA9IG51bGw7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbc2xvdF07XG4gICAgICAgIFxuICAgICAgICBpZiAoIXRoaXMub3V0cHV0c1tzbG90XSl7XG4gICAgICAgICAgICAvKmNvbnNvbGUuZGVidWcoXCJJbnZhbGlkIHNsb3QgcGFzc2VkOiBcIitzbG90KTtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcodGhpcy5vdXRwdXRzKTsqL1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbGxvdyB0YXJnZXQgbm9kZSB0byBjaGFuZ2Ugc2xvdFxuICAgICAgICBpZiAodGFyZ2V0X25vZGUub25CZWZvcmVDb25uZWN0SW5wdXQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgd2F5IG5vZGUgY2FuIGNob29zZSBhbm90aGVyIHNsb3QgKG9yIG1ha2UgYSBuZXcgb25lPylcbiAgICAgICAgICAgIHRhcmdldF9zbG90ID0gdGFyZ2V0X25vZGUub25CZWZvcmVDb25uZWN0SW5wdXQodGFyZ2V0X3Nsb3QpOyAvL2NhbGxiYWNrXG4gICAgICAgIH1cblxuXHRcdC8vY2hlY2sgdGFyZ2V0X3Nsb3QgYW5kIGNoZWNrIGNvbm5lY3Rpb24gdHlwZXNcbiAgICAgICAgaWYgKHRhcmdldF9zbG90PT09ZmFsc2UgfHwgdGFyZ2V0X3Nsb3Q9PT1udWxsIHx8ICFMaXRlR3JhcGguaXNWYWxpZENvbm5lY3Rpb24ob3V0cHV0LnR5cGUsIGlucHV0LnR5cGUpKVxuXHRcdHtcblx0ICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKGZhbHNlLCB0cnVlKTtcblx0XHRcdGlmKGNoYW5nZWQpXG5cdFx0ICAgICAgICB0aGlzLmdyYXBoLmNvbm5lY3Rpb25DaGFuZ2UodGhpcywgbGlua19pbmZvKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1lbHNle1xuXHRcdFx0Ly9jb25zb2xlLmRlYnVnKFwidmFsaWQgY29ubmVjdGlvblwiLG91dHB1dC50eXBlLCBpbnB1dC50eXBlKTtcblx0XHR9XG5cbiAgICAgICAgLy9hbGxvd3Mgbm9kZXMgdG8gYmxvY2sgY29ubmVjdGlvbiwgY2FsbGJhY2tcbiAgICAgICAgaWYgKHRhcmdldF9ub2RlLm9uQ29ubmVjdElucHV0KSB7XG4gICAgICAgICAgICBpZiAoIHRhcmdldF9ub2RlLm9uQ29ubmVjdElucHV0KHRhcmdldF9zbG90LCBvdXRwdXQudHlwZSwgb3V0cHV0LCB0aGlzLCBzbG90KSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub25Db25uZWN0T3V0cHV0KSB7IC8vIGNhbGxiYWNrXG4gICAgICAgICAgICBpZiAoIHRoaXMub25Db25uZWN0T3V0cHV0KHNsb3QsIGlucHV0LnR5cGUsIGlucHV0LCB0YXJnZXRfbm9kZSwgdGFyZ2V0X3Nsb3QpID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdGhlcmUgaXMgc29tZXRoaW5nIGFscmVhZHkgcGx1Z2dlZCB0aGVyZSwgZGlzY29ubmVjdFxuICAgICAgICBpZiAodGFyZ2V0X25vZGUuaW5wdXRzW3RhcmdldF9zbG90XSAmJiB0YXJnZXRfbm9kZS5pbnB1dHNbdGFyZ2V0X3Nsb3RdLmxpbmsgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgICAgIHRhcmdldF9ub2RlLmRpc2Nvbm5lY3RJbnB1dCh0YXJnZXRfc2xvdCwge2RvUHJvY2Vzc0NoYW5nZTogZmFsc2V9KTtcblx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXRwdXQubGlua3MgIT09IG51bGwgJiYgb3V0cHV0LmxpbmtzLmxlbmd0aCl7XG4gICAgICAgICAgICBzd2l0Y2gob3V0cHV0LnR5cGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLkVWRU5UOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIUxpdGVHcmFwaC5hbGxvd19tdWx0aV9vdXRwdXRfZm9yX2V2ZW50cyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLmJlZm9yZUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0T3V0cHV0KHNsb3QsIGZhbHNlLCB7ZG9Qcm9jZXNzQ2hhbmdlOiBmYWxzZX0pOyAvLyBJbnB1dCh0YXJnZXRfc2xvdCwge2RvUHJvY2Vzc0NoYW5nZTogZmFsc2V9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0SWRcbiAgICAgICAgaWYgKExpdGVHcmFwaC51c2VfdXVpZHMpXG4gICAgICAgICAgICBuZXh0SWQgPSBMaXRlR3JhcGgudXVpZHY0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5leHRJZCA9ICsrdGhpcy5ncmFwaC5sYXN0X2xpbmtfaWQ7XG4gICAgICAgIFxuXHRcdC8vY3JlYXRlIGxpbmsgY2xhc3Ncblx0XHRsaW5rX2luZm8gPSBuZXcgTExpbmsoXG5cdFx0XHRuZXh0SWQsXG5cdFx0XHRpbnB1dC50eXBlIHx8IG91dHB1dC50eXBlLFxuXHRcdFx0dGhpcy5pZCxcblx0XHRcdHNsb3QsXG5cdFx0XHR0YXJnZXRfbm9kZS5pZCxcblx0XHRcdHRhcmdldF9zbG90XG5cdFx0KTtcblxuXHRcdC8vYWRkIHRvIGdyYXBoIGxpbmtzIGxpc3Rcblx0XHR0aGlzLmdyYXBoLmxpbmtzW2xpbmtfaW5mby5pZF0gPSBsaW5rX2luZm87XG5cblx0XHQvL2Nvbm5lY3QgaW4gb3V0cHV0XG5cdFx0aWYgKG91dHB1dC5saW5rcyA9PSBudWxsKSB7XG5cdFx0XHRvdXRwdXQubGlua3MgPSBbXTtcblx0XHR9XG5cdFx0b3V0cHV0LmxpbmtzLnB1c2gobGlua19pbmZvLmlkKTtcblx0XHQvL2Nvbm5lY3QgaW4gaW5wdXRcblx0XHR0YXJnZXRfbm9kZS5pbnB1dHNbdGFyZ2V0X3Nsb3RdLmxpbmsgPSBsaW5rX2luZm8uaWQ7XG5cdFx0aWYgKHRoaXMuZ3JhcGgpIHtcblx0XHRcdHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcblx0XHR9XG5cdFx0aWYgKHRoaXMub25Db25uZWN0aW9uc0NoYW5nZSkge1xuXHRcdFx0dGhpcy5vbkNvbm5lY3Rpb25zQ2hhbmdlKFxuXHRcdFx0XHRMaXRlR3JhcGguT1VUUFVULFxuXHRcdFx0XHRzbG90LFxuXHRcdFx0XHR0cnVlLFxuXHRcdFx0XHRsaW5rX2luZm8sXG5cdFx0XHRcdG91dHB1dFxuXHRcdFx0KTtcblx0XHR9IC8vbGlua19pbmZvIGhhcyBiZWVuIGNyZWF0ZWQgbm93LCBzbyBpdHMgdXBkYXRlZFxuXHRcdGlmICh0YXJnZXRfbm9kZS5vbkNvbm5lY3Rpb25zQ2hhbmdlKSB7XG5cdFx0XHR0YXJnZXRfbm9kZS5vbkNvbm5lY3Rpb25zQ2hhbmdlKFxuXHRcdFx0XHRMaXRlR3JhcGguSU5QVVQsXG5cdFx0XHRcdHRhcmdldF9zbG90LFxuXHRcdFx0XHR0cnVlLFxuXHRcdFx0XHRsaW5rX2luZm8sXG5cdFx0XHRcdGlucHV0XG5cdFx0XHQpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5ncmFwaCAmJiB0aGlzLmdyYXBoLm9uTm9kZUNvbm5lY3Rpb25DaGFuZ2UpIHtcblx0XHRcdHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZShcblx0XHRcdFx0TGl0ZUdyYXBoLklOUFVULFxuXHRcdFx0XHR0YXJnZXRfbm9kZSxcblx0XHRcdFx0dGFyZ2V0X3Nsb3QsXG5cdFx0XHRcdHRoaXMsXG5cdFx0XHRcdHNsb3Rcblx0XHRcdCk7XG5cdFx0XHR0aGlzLmdyYXBoLm9uTm9kZUNvbm5lY3Rpb25DaGFuZ2UoXG5cdFx0XHRcdExpdGVHcmFwaC5PVVRQVVQsXG5cdFx0XHRcdHRoaXMsXG5cdFx0XHRcdHNsb3QsXG5cdFx0XHRcdHRhcmdldF9ub2RlLFxuXHRcdFx0XHR0YXJnZXRfc2xvdFxuXHRcdFx0KTtcblx0XHR9XG5cbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyhmYWxzZSwgdHJ1ZSk7XG5cdFx0dGhpcy5ncmFwaC5hZnRlckNoYW5nZSgpO1xuXHRcdHRoaXMuZ3JhcGguY29ubmVjdGlvbkNoYW5nZSh0aGlzLCBsaW5rX2luZm8pO1xuXG4gICAgICAgIHJldHVybiBsaW5rX2luZm87XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGRpc2Nvbm5lY3Qgb25lIG91dHB1dCB0byBhbiBzcGVjaWZpYyBub2RlXG4gICAgICogQG1ldGhvZCBkaXNjb25uZWN0T3V0cHV0XG4gICAgICogQHBhcmFtIHtudW1iZXJfb3Jfc3RyaW5nfSBzbG90IChjb3VsZCBiZSB0aGUgbnVtYmVyIG9mIHRoZSBzbG90IG9yIHRoZSBzdHJpbmcgd2l0aCB0aGUgbmFtZSBvZiB0aGUgc2xvdClcbiAgICAgKiBAcGFyYW0ge0xHcmFwaE5vZGV9IHRhcmdldF9ub2RlIHRoZSB0YXJnZXQgbm9kZSB0byB3aGljaCB0aGlzIHNsb3QgaXMgY29ubmVjdGVkIFtPcHRpb25hbCwgaWYgbm90IHRhcmdldF9ub2RlIGlzIHNwZWNpZmllZCBhbGwgbm9kZXMgd2lsbCBiZSBkaXNjb25uZWN0ZWRdXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gaWYgaXQgd2FzIGRpc2Nvbm5lY3RlZCBzdWNjZXNzZnVsbHlcbiAgICAgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5kaXNjb25uZWN0T3V0cHV0ID0gZnVuY3Rpb24oc2xvdCwgdGFyZ2V0X25vZGUpIHtcbiAgICAgICAgaWYgKHNsb3QuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgICAgICAgc2xvdCA9IHRoaXMuZmluZE91dHB1dFNsb3Qoc2xvdCk7XG4gICAgICAgICAgICBpZiAoc2xvdCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChMaXRlR3JhcGguZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0OiBFcnJvciwgbm8gc2xvdCBvZiBuYW1lIFwiICsgc2xvdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vdXRwdXRzIHx8IHNsb3QgPj0gdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdDogRXJyb3IsIHNsb3QgbnVtYmVyIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZ2V0IG91dHB1dCBzbG90XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbc2xvdF07XG4gICAgICAgIGlmICghb3V0cHV0IHx8ICFvdXRwdXQubGlua3MgfHwgb3V0cHV0LmxpbmtzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvL29uZSBvZiB0aGUgb3V0cHV0IGxpbmtzIGluIHRoaXMgc2xvdFxuICAgICAgICBpZiAodGFyZ2V0X25vZGUpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRfbm9kZS5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0X25vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVCeUlkKHRhcmdldF9ub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFyZ2V0X25vZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlRhcmdldCBOb2RlIG5vdCBmb3VuZFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG91dHB1dC5saW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlua19pZCA9IG91dHB1dC5saW5rc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgbGlua19pbmZvID0gdGhpcy5ncmFwaC5saW5rc1tsaW5rX2lkXTtcblxuICAgICAgICAgICAgICAgIC8vaXMgdGhlIGxpbmsgd2UgYXJlIHNlYXJjaGluZyBmb3IuLi5cbiAgICAgICAgICAgICAgICBpZiAobGlua19pbmZvLnRhcmdldF9pZCA9PSB0YXJnZXRfbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQubGlua3Muc3BsaWNlKGksIDEpOyAvL3JlbW92ZSBoZXJlXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRhcmdldF9ub2RlLmlucHV0c1tsaW5rX2luZm8udGFyZ2V0X3Nsb3RdO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5saW5rID0gbnVsbDsgLy9yZW1vdmUgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZ3JhcGgubGlua3NbbGlua19pZF07IC8vcmVtb3ZlIHRoZSBsaW5rIGZyb20gdGhlIGxpbmtzIHBvb2xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0X25vZGUub25Db25uZWN0aW9uc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X25vZGUub25Db25uZWN0aW9uc0NoYW5nZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguSU5QVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLnRhcmdldF9zbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSAvL2xpbmtfaW5mbyBoYXNuJ3QgYmVlbiBtb2RpZmllZCBzbyBpdHMgb2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub25Db25uZWN0aW9uc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25zQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5PVVRQVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyYXBoICYmIHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5vbk5vZGVDb25uZWN0aW9uQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5PVVRQVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyYXBoICYmIHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5vbk5vZGVDb25uZWN0aW9uQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5PVVRQVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG90XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5vbk5vZGVDb25uZWN0aW9uQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5JTlBVVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRfbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8udGFyZ2V0X3Nsb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vYWxsIHRoZSBsaW5rcyBpbiB0aGlzIG91dHB1dCBzbG90XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvdXRwdXQubGlua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtfaWQgPSBvdXRwdXQubGlua3NbaV07XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtfaW5mbyA9IHRoaXMuZ3JhcGgubGlua3NbbGlua19pZF07XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5rX2luZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy9idWc6IGl0IGhhcHBlbnMgc29tZXRpbWVzXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRfbm9kZSA9IHRoaXMuZ3JhcGguZ2V0Tm9kZUJ5SWQobGlua19pbmZvLnRhcmdldF9pZCk7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLl92ZXJzaW9uKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRfbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IHRhcmdldF9ub2RlLmlucHV0c1tsaW5rX2luZm8udGFyZ2V0X3Nsb3RdO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5saW5rID0gbnVsbDsgLy9yZW1vdmUgb3RoZXIgc2lkZSBsaW5rXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRfbm9kZS5vbkNvbm5lY3Rpb25zQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRfbm9kZS5vbkNvbm5lY3Rpb25zQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5JTlBVVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8udGFyZ2V0X3Nsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9IC8vbGlua19pbmZvIGhhc24ndCBiZWVuIG1vZGlmaWVkIHNvIGl0cyBva1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmFwaCAmJiB0aGlzLmdyYXBoLm9uTm9kZUNvbm5lY3Rpb25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguSU5QVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X25vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLnRhcmdldF9zbG90XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmdyYXBoLmxpbmtzW2xpbmtfaWRdOyAvL3JlbW92ZSB0aGUgbGluayBmcm9tIHRoZSBsaW5rcyBwb29sXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25Db25uZWN0aW9uc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ29ubmVjdGlvbnNDaGFuZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguT1VUUFVULFxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyYXBoICYmIHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLm9uTm9kZUNvbm5lY3Rpb25DaGFuZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguT1VUUFVULFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5vbk5vZGVDb25uZWN0aW9uQ2hhbmdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLklOUFVULFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X25vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8udGFyZ2V0X3Nsb3RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQubGlua3MgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyhmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZ3JhcGguY29ubmVjdGlvbkNoYW5nZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGRpc2Nvbm5lY3Qgb25lIGlucHV0XG4gICAgICogQG1ldGhvZCBkaXNjb25uZWN0SW5wdXRcbiAgICAgKiBAcGFyYW0ge251bWJlcl9vcl9zdHJpbmd9IHNsb3QgKGNvdWxkIGJlIHRoZSBudW1iZXIgb2YgdGhlIHNsb3Qgb3IgdGhlIHN0cmluZyB3aXRoIHRoZSBuYW1lIG9mIHRoZSBzbG90KVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGlmIGl0IHdhcyBkaXNjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuZGlzY29ubmVjdElucHV0ID0gZnVuY3Rpb24oc2xvdCkge1xuICAgICAgICAvL3NlZWsgZm9yIHRoZSBvdXRwdXQgc2xvdFxuICAgICAgICBpZiAoc2xvdC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XG4gICAgICAgICAgICBzbG90ID0gdGhpcy5maW5kSW5wdXRTbG90KHNsb3QpO1xuICAgICAgICAgICAgaWYgKHNsb3QgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdDogRXJyb3IsIG5vIHNsb3Qgb2YgbmFtZSBcIiArIHNsb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaW5wdXRzIHx8IHNsb3QgPj0gdGhpcy5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0OiBFcnJvciwgc2xvdCBudW1iZXIgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbc2xvdF07XG4gICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5rX2lkID0gdGhpcy5pbnB1dHNbc2xvdF0ubGluaztcblx0XHRpZihsaW5rX2lkICE9IG51bGwpXG5cdFx0e1xuXHRcdFx0dGhpcy5pbnB1dHNbc2xvdF0ubGluayA9IG51bGw7XG5cblx0XHRcdC8vcmVtb3ZlIG90aGVyIHNpZGVcblx0XHRcdHZhciBsaW5rX2luZm8gPSB0aGlzLmdyYXBoLmxpbmtzW2xpbmtfaWRdO1xuXHRcdFx0aWYgKGxpbmtfaW5mbykge1xuXHRcdFx0XHR2YXIgdGFyZ2V0X25vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVCeUlkKGxpbmtfaW5mby5vcmlnaW5faWQpO1xuXHRcdFx0XHRpZiAoIXRhcmdldF9ub2RlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG91dHB1dCA9IHRhcmdldF9ub2RlLm91dHB1dHNbbGlua19pbmZvLm9yaWdpbl9zbG90XTtcblx0XHRcdFx0aWYgKCFvdXRwdXQgfHwgIW91dHB1dC5saW5rcyB8fCBvdXRwdXQubGlua3MubGVuZ3RoID09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL3NlYXJjaCBpbiB0aGUgaW5wdXRzIGxpc3QgZm9yIHRoaXMgbGlua1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG91dHB1dC5saW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRpZiAob3V0cHV0LmxpbmtzW2ldID09IGxpbmtfaWQpIHtcblx0XHRcdFx0XHRcdG91dHB1dC5saW5rcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgdGhpcy5ncmFwaC5saW5rc1tsaW5rX2lkXTsgLy9yZW1vdmUgZnJvbSB0aGUgcG9vbFxuXHRcdFx0XHRpZiAodGhpcy5ncmFwaCkge1xuXHRcdFx0XHRcdHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5vbkNvbm5lY3Rpb25zQ2hhbmdlKSB7XG5cdFx0XHRcdFx0dGhpcy5vbkNvbm5lY3Rpb25zQ2hhbmdlKFxuXHRcdFx0XHRcdFx0TGl0ZUdyYXBoLklOUFVULFxuXHRcdFx0XHRcdFx0c2xvdCxcblx0XHRcdFx0XHRcdGZhbHNlLFxuXHRcdFx0XHRcdFx0bGlua19pbmZvLFxuXHRcdFx0XHRcdFx0aW5wdXRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0YXJnZXRfbm9kZS5vbkNvbm5lY3Rpb25zQ2hhbmdlKSB7XG5cdFx0XHRcdFx0dGFyZ2V0X25vZGUub25Db25uZWN0aW9uc0NoYW5nZShcblx0XHRcdFx0XHRcdExpdGVHcmFwaC5PVVRQVVQsXG5cdFx0XHRcdFx0XHRpLFxuXHRcdFx0XHRcdFx0ZmFsc2UsXG5cdFx0XHRcdFx0XHRsaW5rX2luZm8sXG5cdFx0XHRcdFx0XHRvdXRwdXRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLmdyYXBoICYmIHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZSkge1xuXHRcdFx0XHRcdHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZShcblx0XHRcdFx0XHRcdExpdGVHcmFwaC5PVVRQVVQsXG5cdFx0XHRcdFx0XHR0YXJnZXRfbm9kZSxcblx0XHRcdFx0XHRcdGlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHRoaXMuZ3JhcGgub25Ob2RlQ29ubmVjdGlvbkNoYW5nZShMaXRlR3JhcGguSU5QVVQsIHRoaXMsIHNsb3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSAvL2xpbmsgIT0gbnVsbFxuXG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXMoZmFsc2UsIHRydWUpO1xuXHRcdGlmKHRoaXMuZ3JhcGgpXG5cdCAgICAgICAgdGhpcy5ncmFwaC5jb25uZWN0aW9uQ2hhbmdlKHRoaXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgY2VudGVyIG9mIGEgY29ubmVjdGlvbiBwb2ludCBpbiBjYW52YXMgY29vcmRzXG4gICAgICogQG1ldGhvZCBnZXRDb25uZWN0aW9uUG9zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc19pbnB1dCB0cnVlIGlmIGlmIGEgaW5wdXQgc2xvdCwgZmFsc2UgaWYgaXQgaXMgYW4gb3V0cHV0XG4gICAgICogQHBhcmFtIHtudW1iZXJfb3Jfc3RyaW5nfSBzbG90IChjb3VsZCBiZSB0aGUgbnVtYmVyIG9mIHRoZSBzbG90IG9yIHRoZSBzdHJpbmcgd2l0aCB0aGUgbmFtZSBvZiB0aGUgc2xvdClcbiAgICAgKiBAcGFyYW0ge3ZlYzJ9IG91dCBbb3B0aW9uYWxdIGEgcGxhY2UgdG8gc3RvcmUgdGhlIG91dHB1dCwgdG8gZnJlZSBnYXJiYWdlXG4gICAgICogQHJldHVybiB7W3gseV19IHRoZSBwb3NpdGlvblxuICAgICAqKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5nZXRDb25uZWN0aW9uUG9zID0gZnVuY3Rpb24oXG4gICAgICAgIGlzX2lucHV0LFxuICAgICAgICBzbG90X251bWJlcixcbiAgICAgICAgb3V0XG4gICAgKSB7XG4gICAgICAgIG91dCA9IG91dCB8fCBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgICAgICB2YXIgbnVtX3Nsb3RzID0gMDtcbiAgICAgICAgaWYgKGlzX2lucHV0ICYmIHRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICBudW1fc2xvdHMgPSB0aGlzLmlucHV0cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc19pbnB1dCAmJiB0aGlzLm91dHB1dHMpIHtcbiAgICAgICAgICAgIG51bV9zbG90cyA9IHRoaXMub3V0cHV0cy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2Zmc2V0ID0gTGl0ZUdyYXBoLk5PREVfU0xPVF9IRUlHSFQgKiAwLjU7XG5cbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICB2YXIgdyA9IHRoaXMuX2NvbGxhcHNlZF93aWR0aCB8fCBMaXRlR3JhcGguTk9ERV9DT0xMQVBTRURfV0lEVEg7XG4gICAgICAgICAgICBpZiAodGhpcy5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgb3V0WzBdID0gdGhpcy5wb3NbMF0gKyB3ICogMC41O1xuICAgICAgICAgICAgICAgIGlmIChpc19pbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRbMV0gPSB0aGlzLnBvc1sxXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRbMV0gPSB0aGlzLnBvc1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc19pbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRbMF0gPSB0aGlzLnBvc1swXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRbMF0gPSB0aGlzLnBvc1swXSArIHc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dFsxXSA9IHRoaXMucG9zWzFdIC0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICogMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vd2VpcmQgZmVhdHVyZSB0aGF0IG5ldmVyIGdvdCBmaW5pc2hlZFxuICAgICAgICBpZiAoaXNfaW5wdXQgJiYgc2xvdF9udW1iZXIgPT0gLTEpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHRoaXMucG9zWzBdICsgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICogMC41O1xuICAgICAgICAgICAgb3V0WzFdID0gdGhpcy5wb3NbMV0gKyBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgKiAwLjU7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9oYXJkLWNvZGVkIHBvc1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBpc19pbnB1dCAmJlxuICAgICAgICAgICAgbnVtX3Nsb3RzID4gc2xvdF9udW1iZXIgJiZcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzW3Nsb3RfbnVtYmVyXS5wb3NcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB0aGlzLnBvc1swXSArIHRoaXMuaW5wdXRzW3Nsb3RfbnVtYmVyXS5wb3NbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB0aGlzLnBvc1sxXSArIHRoaXMuaW5wdXRzW3Nsb3RfbnVtYmVyXS5wb3NbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgIWlzX2lucHV0ICYmXG4gICAgICAgICAgICBudW1fc2xvdHMgPiBzbG90X251bWJlciAmJlxuICAgICAgICAgICAgdGhpcy5vdXRwdXRzW3Nsb3RfbnVtYmVyXS5wb3NcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB0aGlzLnBvc1swXSArIHRoaXMub3V0cHV0c1tzbG90X251bWJlcl0ucG9zWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdGhpcy5wb3NbMV0gKyB0aGlzLm91dHB1dHNbc2xvdF9udW1iZXJdLnBvc1sxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvL2hvcml6b250YWwgZGlzdHJpYnV0ZWQgc2xvdHNcbiAgICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgb3V0WzBdID1cbiAgICAgICAgICAgICAgICB0aGlzLnBvc1swXSArIChzbG90X251bWJlciArIDAuNSkgKiAodGhpcy5zaXplWzBdIC8gbnVtX3Nsb3RzKTtcbiAgICAgICAgICAgIGlmIChpc19pbnB1dCkge1xuICAgICAgICAgICAgICAgIG91dFsxXSA9IHRoaXMucG9zWzFdIC0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRbMV0gPSB0aGlzLnBvc1sxXSArIHRoaXMuc2l6ZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvL2RlZmF1bHQgdmVydGljYWwgc2xvdHNcbiAgICAgICAgaWYgKGlzX2lucHV0KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB0aGlzLnBvc1swXSArIG9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dFswXSA9IHRoaXMucG9zWzBdICsgdGhpcy5zaXplWzBdICsgMSAtIG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBvdXRbMV0gPVxuICAgICAgICAgICAgdGhpcy5wb3NbMV0gK1xuICAgICAgICAgICAgKHNsb3RfbnVtYmVyICsgMC43KSAqIExpdGVHcmFwaC5OT0RFX1NMT1RfSEVJR0hUICtcbiAgICAgICAgICAgICh0aGlzLmNvbnN0cnVjdG9yLnNsb3Rfc3RhcnRfeSB8fCAwKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgLyogRm9yY2UgYWxpZ24gdG8gZ3JpZCAqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmFsaWduVG9HcmlkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucG9zWzBdID1cbiAgICAgICAgICAgIExpdGVHcmFwaC5DQU5WQVNfR1JJRF9TSVpFICpcbiAgICAgICAgICAgIE1hdGgucm91bmQodGhpcy5wb3NbMF0gLyBMaXRlR3JhcGguQ0FOVkFTX0dSSURfU0laRSk7XG4gICAgICAgIHRoaXMucG9zWzFdID1cbiAgICAgICAgICAgIExpdGVHcmFwaC5DQU5WQVNfR1JJRF9TSVpFICpcbiAgICAgICAgICAgIE1hdGgucm91bmQodGhpcy5wb3NbMV0gLyBMaXRlR3JhcGguQ0FOVkFTX0dSSURfU0laRSk7XG4gICAgfTtcblxuICAgIC8qIENvbnNvbGUgb3V0cHV0ICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUudHJhY2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnNvbGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc29sZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25zb2xlLnB1c2gobXNnKTtcbiAgICAgICAgaWYgKHRoaXMuY29uc29sZS5sZW5ndGggPiBMR3JhcGhOb2RlLk1BWF9DT05TT0xFKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnNvbGUuc2hpZnQoKTtcbiAgICAgICAgfVxuXG5cdFx0aWYodGhpcy5ncmFwaC5vbk5vZGVUcmFjZSlcblx0ICAgICAgICB0aGlzLmdyYXBoLm9uTm9kZVRyYWNlKHRoaXMsIG1zZyk7XG4gICAgfTtcblxuICAgIC8qIEZvcmNlcyB0byByZWRyYXcgb3IgdGhlIG1haW4gY2FudmFzIChMR3JhcGhOb2RlKSBvciB0aGUgYmcgY2FudmFzIChsaW5rcykgKi9cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5zZXREaXJ0eUNhbnZhcyA9IGZ1bmN0aW9uKFxuICAgICAgICBkaXJ0eV9mb3JlZ3JvdW5kLFxuICAgICAgICBkaXJ0eV9iYWNrZ3JvdW5kXG4gICAgKSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JhcGguc2VuZEFjdGlvblRvQ2FudmFzKFwic2V0RGlydHlcIiwgW1xuICAgICAgICAgICAgZGlydHlfZm9yZWdyb3VuZCxcbiAgICAgICAgICAgIGRpcnR5X2JhY2tncm91bmRcbiAgICAgICAgXSk7XG4gICAgfTtcblxuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltZy5zcmMgPSBMaXRlR3JhcGgubm9kZV9pbWFnZXNfcGF0aCArIHVybDtcbiAgICAgICAgaW1nLnJlYWR5ID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoYXQuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpbWc7XG4gICAgfTtcblxuICAgIC8vc2FmZSBMR3JhcGhOb2RlIGFjdGlvbiBleGVjdXRpb24gKG5vdCBzdXJlIGlmIHNhZmUpXG4gICAgLypcbkxHcmFwaE5vZGUucHJvdG90eXBlLmV4ZWN1dGVBY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24pXG57XG5cdGlmKGFjdGlvbiA9PSBcIlwiKSByZXR1cm4gZmFsc2U7XG5cblx0aWYoIGFjdGlvbi5pbmRleE9mKFwiO1wiKSAhPSAtMSB8fCBhY3Rpb24uaW5kZXhPZihcIn1cIikgIT0gLTEpXG5cdHtcblx0XHR0aGlzLnRyYWNlKFwiRXJyb3I6IEFjdGlvbiBjb250YWlucyB1bnNhZmUgY2hhcmFjdGVyc1wiKTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgdG9rZW5zID0gYWN0aW9uLnNwbGl0KFwiKFwiKTtcblx0dmFyIGZ1bmNfbmFtZSA9IHRva2Vuc1swXTtcblx0aWYoIHR5cGVvZih0aGlzW2Z1bmNfbmFtZV0pICE9IFwiZnVuY3Rpb25cIilcblx0e1xuXHRcdHRoaXMudHJhY2UoXCJFcnJvcjogQWN0aW9uIG5vdCBmb3VuZCBvbiBub2RlOiBcIiArIGZ1bmNfbmFtZSk7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dmFyIGNvZGUgPSBhY3Rpb247XG5cblx0dHJ5XG5cdHtcblx0XHR2YXIgX2ZvbyA9IGV2YWw7XG5cdFx0ZXZhbCA9IG51bGw7XG5cdFx0KG5ldyBGdW5jdGlvbihcIndpdGgodGhpcykgeyBcIiArIGNvZGUgKyBcIn1cIikpLmNhbGwodGhpcyk7XG5cdFx0ZXZhbCA9IF9mb287XG5cdH1cblx0Y2F0Y2ggKGVycilcblx0e1xuXHRcdHRoaXMudHJhY2UoXCJFcnJvciBleGVjdXRpbmcgYWN0aW9uIHtcIiArIGFjdGlvbiArIFwifSA6XCIgKyBlcnIpO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0cnVlO1xufVxuKi9cblxuICAgIC8qIEFsbG93cyB0byBnZXQgb25Nb3VzZU1vdmUgYW5kIG9uTW91c2VVcCBldmVudHMgZXZlbiBpZiB0aGUgbW91c2UgaXMgb3V0IG9mIGZvY3VzICovXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUuY2FwdHVyZUlucHV0ID0gZnVuY3Rpb24odikge1xuICAgICAgICBpZiAoIXRoaXMuZ3JhcGggfHwgIXRoaXMuZ3JhcGgubGlzdF9vZl9ncmFwaGNhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLmdyYXBoLmxpc3Rfb2ZfZ3JhcGhjYW52YXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGxpc3RbaV07XG4gICAgICAgICAgICAvL3JlbGVhc2luZyBzb21lYm9keSBlbHNlcyBjYXB0dXJlPyFcbiAgICAgICAgICAgIGlmICghdiAmJiBjLm5vZGVfY2FwdHVyaW5nX2lucHV0ICE9IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9jaGFuZ2VcbiAgICAgICAgICAgIGMubm9kZV9jYXB0dXJpbmdfaW5wdXQgPSB2ID8gdGhpcyA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2UgdGhlIG5vZGUgdG8gbWFrZSBpdCBzbWFsbGVyIG9uIHRoZSBjYW52YXNcbiAgICAgKiBAbWV0aG9kIGNvbGxhcHNlXG4gICAgICoqL1xuICAgIExHcmFwaE5vZGUucHJvdG90eXBlLmNvbGxhcHNlID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgdGhpcy5ncmFwaC5fdmVyc2lvbisrO1xuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5jb2xsYXBzYWJsZSA9PT0gZmFsc2UgJiYgIWZvcmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgdGhpcy5mbGFncy5jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mbGFncy5jb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdGhlIG5vZGUgdG8gZG8gbm90IG1vdmUgb3IgcmVhbGlnbiBvbiBaXG4gICAgICogQG1ldGhvZCBwaW5cbiAgICAgKiovXG5cbiAgICBMR3JhcGhOb2RlLnByb3RvdHlwZS5waW4gPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5mbGFncy5waW5uZWQgPSAhdGhpcy5mbGFncy5waW5uZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZsYWdzLnBpbm5lZCA9IHY7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTEdyYXBoTm9kZS5wcm90b3R5cGUubG9jYWxUb1NjcmVlbiA9IGZ1bmN0aW9uKHgsIHksIGdyYXBoY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAoeCArIHRoaXMucG9zWzBdKSAqIGdyYXBoY2FudmFzLnNjYWxlICsgZ3JhcGhjYW52YXMub2Zmc2V0WzBdLFxuICAgICAgICAgICAgKHkgKyB0aGlzLnBvc1sxXSkgKiBncmFwaGNhbnZhcy5zY2FsZSArIGdyYXBoY2FudmFzLm9mZnNldFsxXVxuICAgICAgICBdO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBMR3JhcGhHcm91cCh0aXRsZSkge1xuICAgICAgICB0aGlzLl9jdG9yKHRpdGxlKTtcbiAgICB9XG5cbiAgICBnbG9iYWwuTEdyYXBoR3JvdXAgPSBMaXRlR3JhcGguTEdyYXBoR3JvdXAgPSBMR3JhcGhHcm91cDtcblxuICAgIExHcmFwaEdyb3VwLnByb3RvdHlwZS5fY3RvciA9IGZ1bmN0aW9uKHRpdGxlKSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSB0aXRsZSB8fCBcIkdyb3VwXCI7XG4gICAgICAgIHRoaXMuZm9udF9zaXplID0gMjQ7XG4gICAgICAgIHRoaXMuY29sb3IgPSBMR3JhcGhDYW52YXMubm9kZV9jb2xvcnMucGFsZV9ibHVlXG4gICAgICAgICAgICA/IExHcmFwaENhbnZhcy5ub2RlX2NvbG9ycy5wYWxlX2JsdWUuZ3JvdXBjb2xvclxuICAgICAgICAgICAgOiBcIiNBQUFcIjtcbiAgICAgICAgdGhpcy5fYm91bmRpbmcgPSBuZXcgRmxvYXQzMkFycmF5KFsxMCwgMTAsIDE0MCwgODBdKTtcbiAgICAgICAgdGhpcy5fcG9zID0gdGhpcy5fYm91bmRpbmcuc3ViYXJyYXkoMCwgMik7XG4gICAgICAgIHRoaXMuX3NpemUgPSB0aGlzLl9ib3VuZGluZy5zdWJhcnJheSgyLCA0KTtcbiAgICAgICAgdGhpcy5fbm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5ncmFwaCA9IG51bGw7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicG9zXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIGlmICghdiB8fCB2Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NbMF0gPSB2WzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc1sxXSA9IHZbMV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2l6ZVwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXYgfHwgdi5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc2l6ZVswXSA9IE1hdGgubWF4KDE0MCwgdlswXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2l6ZVsxXSA9IE1hdGgubWF4KDgwLCB2WzFdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIExHcmFwaEdyb3VwLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSBvLnRpdGxlO1xuICAgICAgICB0aGlzLl9ib3VuZGluZy5zZXQoby5ib3VuZGluZyk7XG4gICAgICAgIHRoaXMuY29sb3IgPSBvLmNvbG9yO1xuICAgICAgICB0aGlzLmZvbnRfc2l6ZSA9IG8uZm9udF9zaXplO1xuICAgIH07XG5cbiAgICBMR3JhcGhHcm91cC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5fYm91bmRpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0aXRsZTogdGhpcy50aXRsZSxcbiAgICAgICAgICAgIGJvdW5kaW5nOiBbXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZChiWzBdKSxcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKGJbMV0pLFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoYlsyXSksXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZChiWzNdKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICAgICAgZm9udF9zaXplOiB0aGlzLmZvbnRfc2l6ZVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBMR3JhcGhHcm91cC5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKGRlbHRheCwgZGVsdGF5LCBpZ25vcmVfbm9kZXMpIHtcbiAgICAgICAgdGhpcy5fcG9zWzBdICs9IGRlbHRheDtcbiAgICAgICAgdGhpcy5fcG9zWzFdICs9IGRlbHRheTtcbiAgICAgICAgaWYgKGlnbm9yZV9ub2Rlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZXNbaV07XG4gICAgICAgICAgICBub2RlLnBvc1swXSArPSBkZWx0YXg7XG4gICAgICAgICAgICBub2RlLnBvc1sxXSArPSBkZWx0YXk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTEdyYXBoR3JvdXAucHJvdG90eXBlLnJlY29tcHV0ZUluc2lkZU5vZGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX25vZGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuZ3JhcGguX25vZGVzO1xuICAgICAgICB2YXIgbm9kZV9ib3VuZGluZyA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIG5vZGUuZ2V0Qm91bmRpbmcobm9kZV9ib3VuZGluZyk7XG4gICAgICAgICAgICBpZiAoIW92ZXJsYXBCb3VuZGluZyh0aGlzLl9ib3VuZGluZywgbm9kZV9ib3VuZGluZykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy9vdXQgb2YgdGhlIHZpc2libGUgYXJlYVxuICAgICAgICAgICAgdGhpcy5fbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMR3JhcGhHcm91cC5wcm90b3R5cGUuaXNQb2ludEluc2lkZSA9IExHcmFwaE5vZGUucHJvdG90eXBlLmlzUG9pbnRJbnNpZGU7XG4gICAgTEdyYXBoR3JvdXAucHJvdG90eXBlLnNldERpcnR5Q2FudmFzID0gTEdyYXBoTm9kZS5wcm90b3R5cGUuc2V0RGlydHlDYW52YXM7XG5cbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIC8vU2NhbGUgYW5kIE9mZnNldFxuICAgIGZ1bmN0aW9uIERyYWdBbmRTY2FsZShlbGVtZW50LCBza2lwX2V2ZW50cykge1xuICAgICAgICB0aGlzLm9mZnNldCA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDBdKTtcbiAgICAgICAgdGhpcy5zY2FsZSA9IDE7XG4gICAgICAgIHRoaXMubWF4X3NjYWxlID0gMTA7XG4gICAgICAgIHRoaXMubWluX3NjYWxlID0gMC4xO1xuICAgICAgICB0aGlzLm9ucmVkcmF3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sYXN0X21vdXNlID0gWzAsIDBdO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnZpc2libGVfYXJlYSA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG5cbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoIXNraXBfZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kRXZlbnRzKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgTGl0ZUdyYXBoLkRyYWdBbmRTY2FsZSA9IERyYWdBbmRTY2FsZTtcblxuICAgIERyYWdBbmRTY2FsZS5wcm90b3R5cGUuYmluZEV2ZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5sYXN0X21vdXNlID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcblxuICAgICAgICB0aGlzLl9iaW5kZWRfbW91c2VfY2FsbGJhY2sgPSB0aGlzLm9uTW91c2UuYmluZCh0aGlzKTtcblxuXHRcdExpdGVHcmFwaC5wb2ludGVyTGlzdGVuZXJBZGQoZWxlbWVudCxcImRvd25cIiwgdGhpcy5fYmluZGVkX21vdXNlX2NhbGxiYWNrKTtcblx0XHRMaXRlR3JhcGgucG9pbnRlckxpc3RlbmVyQWRkKGVsZW1lbnQsXCJtb3ZlXCIsIHRoaXMuX2JpbmRlZF9tb3VzZV9jYWxsYmFjayk7XG5cdFx0TGl0ZUdyYXBoLnBvaW50ZXJMaXN0ZW5lckFkZChlbGVtZW50LFwidXBcIiwgdGhpcy5fYmluZGVkX21vdXNlX2NhbGxiYWNrKTtcblxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBcIm1vdXNld2hlZWxcIixcbiAgICAgICAgICAgIHRoaXMuX2JpbmRlZF9tb3VzZV9jYWxsYmFjayxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMuX2JpbmRlZF9tb3VzZV9jYWxsYmFjaywgZmFsc2UpO1xuICAgIH07XG5cbiAgICBEcmFnQW5kU2NhbGUucHJvdG90eXBlLmNvbXB1dGVWaXNpYmxlQXJlYSA9IGZ1bmN0aW9uKCB2aWV3cG9ydCApIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZV9hcmVhWzBdID0gdGhpcy52aXNpYmxlX2FyZWFbMV0gPSB0aGlzLnZpc2libGVfYXJlYVsyXSA9IHRoaXMudmlzaWJsZV9hcmVhWzNdID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmVsZW1lbnQud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmVsZW1lbnQuaGVpZ2h0O1xuICAgICAgICB2YXIgc3RhcnR4ID0gLXRoaXMub2Zmc2V0WzBdO1xuICAgICAgICB2YXIgc3RhcnR5ID0gLXRoaXMub2Zmc2V0WzFdO1xuXHRcdGlmKCB2aWV3cG9ydCApXG5cdFx0e1xuXHRcdFx0c3RhcnR4ICs9IHZpZXdwb3J0WzBdIC8gdGhpcy5zY2FsZTtcblx0XHRcdHN0YXJ0eSArPSB2aWV3cG9ydFsxXSAvIHRoaXMuc2NhbGU7XG5cdFx0XHR3aWR0aCA9IHZpZXdwb3J0WzJdO1xuXHRcdFx0aGVpZ2h0ID0gdmlld3BvcnRbM107XG5cdFx0fVxuICAgICAgICB2YXIgZW5keCA9IHN0YXJ0eCArIHdpZHRoIC8gdGhpcy5zY2FsZTtcbiAgICAgICAgdmFyIGVuZHkgPSBzdGFydHkgKyBoZWlnaHQgLyB0aGlzLnNjYWxlO1xuICAgICAgICB0aGlzLnZpc2libGVfYXJlYVswXSA9IHN0YXJ0eDtcbiAgICAgICAgdGhpcy52aXNpYmxlX2FyZWFbMV0gPSBzdGFydHk7XG4gICAgICAgIHRoaXMudmlzaWJsZV9hcmVhWzJdID0gZW5keCAtIHN0YXJ0eDtcbiAgICAgICAgdGhpcy52aXNpYmxlX2FyZWFbM10gPSBlbmR5IC0gc3RhcnR5O1xuICAgIH07XG5cbiAgICBEcmFnQW5kU2NhbGUucHJvdG90eXBlLm9uTW91c2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5lbGVtZW50O1xuICAgICAgICB2YXIgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHggPSBlLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgICAgIHZhciB5ID0gZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgICAgIGUuY2FudmFzeCA9IHg7XG4gICAgICAgIGUuY2FudmFzeSA9IHk7XG4gICAgICAgIGUuZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nO1xuICAgICAgICBcblx0XHR2YXIgaXNfaW5zaWRlID0gIXRoaXMudmlld3BvcnQgfHwgKCB0aGlzLnZpZXdwb3J0ICYmIHggPj0gdGhpcy52aWV3cG9ydFswXSAmJiB4IDwgKHRoaXMudmlld3BvcnRbMF0gKyB0aGlzLnZpZXdwb3J0WzJdKSAmJiB5ID49IHRoaXMudmlld3BvcnRbMV0gJiYgeSA8ICh0aGlzLnZpZXdwb3J0WzFdICsgdGhpcy52aWV3cG9ydFszXSkgKTtcblxuXHRcdC8vY29uc29sZS5sb2coXCJwb2ludGVyZXZlbnRzOiBEcmFnQW5kU2NhbGUgb25Nb3VzZSBcIitlLnR5cGUrXCIgXCIraXNfaW5zaWRlKTtcblx0XHRcbiAgICAgICAgdmFyIGlnbm9yZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5vbm1vdXNlKSB7XG4gICAgICAgICAgICBpZ25vcmUgPSB0aGlzLm9ubW91c2UoZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS50eXBlID09IExpdGVHcmFwaC5wb2ludGVyZXZlbnRzX21ldGhvZCtcImRvd25cIiAmJiBpc19pbnNpZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuXHRcdFx0TGl0ZUdyYXBoLnBvaW50ZXJMaXN0ZW5lclJlbW92ZShjYW52YXMsXCJtb3ZlXCIsdGhpcy5fYmluZGVkX21vdXNlX2NhbGxiYWNrKTtcblx0XHRcdExpdGVHcmFwaC5wb2ludGVyTGlzdGVuZXJBZGQoZG9jdW1lbnQsXCJtb3ZlXCIsdGhpcy5fYmluZGVkX21vdXNlX2NhbGxiYWNrKTtcblx0XHRcdExpdGVHcmFwaC5wb2ludGVyTGlzdGVuZXJBZGQoZG9jdW1lbnQsXCJ1cFwiLHRoaXMuX2JpbmRlZF9tb3VzZV9jYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS50eXBlID09IExpdGVHcmFwaC5wb2ludGVyZXZlbnRzX21ldGhvZCtcIm1vdmVcIikge1xuICAgICAgICAgICAgaWYgKCFpZ25vcmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGF4ID0geCAtIHRoaXMubGFzdF9tb3VzZVswXTtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGF5ID0geSAtIHRoaXMubGFzdF9tb3VzZVsxXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdXNlRHJhZyhkZWx0YXgsIGRlbHRheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PSBMaXRlR3JhcGgucG9pbnRlcmV2ZW50c19tZXRob2QrXCJ1cFwiKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cdFx0XHRMaXRlR3JhcGgucG9pbnRlckxpc3RlbmVyUmVtb3ZlKGRvY3VtZW50LFwibW92ZVwiLHRoaXMuX2JpbmRlZF9tb3VzZV9jYWxsYmFjayk7XG5cdFx0XHRMaXRlR3JhcGgucG9pbnRlckxpc3RlbmVyUmVtb3ZlKGRvY3VtZW50LFwidXBcIix0aGlzLl9iaW5kZWRfbW91c2VfY2FsbGJhY2spO1xuXHRcdFx0TGl0ZUdyYXBoLnBvaW50ZXJMaXN0ZW5lckFkZChjYW52YXMsXCJtb3ZlXCIsdGhpcy5fYmluZGVkX21vdXNlX2NhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIGlmICggaXNfaW5zaWRlICYmXG4gICAgICAgICAgICAoZS50eXBlID09IFwibW91c2V3aGVlbFwiIHx8XG4gICAgICAgICAgICBlLnR5cGUgPT0gXCJ3aGVlbFwiIHx8XG4gICAgICAgICAgICBlLnR5cGUgPT0gXCJET01Nb3VzZVNjcm9sbFwiKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGUuZXZlbnRUeXBlID0gXCJtb3VzZXdoZWVsXCI7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09IFwid2hlZWxcIikge1xuICAgICAgICAgICAgICAgIGUud2hlZWwgPSAtZS5kZWx0YVk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGUud2hlZWwgPVxuICAgICAgICAgICAgICAgICAgICBlLndoZWVsRGVsdGFZICE9IG51bGwgPyBlLndoZWVsRGVsdGFZIDogZS5kZXRhaWwgKiAtNjA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZnJvbSBzdGFjayBvdmVyZmxvd1xuICAgICAgICAgICAgZS5kZWx0YSA9IGUud2hlZWxEZWx0YVxuICAgICAgICAgICAgICAgID8gZS53aGVlbERlbHRhIC8gNDBcbiAgICAgICAgICAgICAgICA6IGUuZGVsdGFZXG4gICAgICAgICAgICAgICAgPyAtZS5kZWx0YVkgLyAzXG4gICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZWx0YVNjYWxlKDEuMCArIGUuZGVsdGEgKiAwLjA1KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdF9tb3VzZVswXSA9IHg7XG4gICAgICAgIHRoaXMubGFzdF9tb3VzZVsxXSA9IHk7XG5cblx0XHRpZihpc19pbnNpZGUpXG5cdFx0e1xuXHQgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblx0XHQgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHQgICAgcmV0dXJuIGZhbHNlO1xuXHRcdH1cbiAgICB9O1xuXG4gICAgRHJhZ0FuZFNjYWxlLnByb3RvdHlwZS50b0NhbnZhc0NvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgY3R4LnNjYWxlKHRoaXMuc2NhbGUsIHRoaXMuc2NhbGUpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMub2Zmc2V0WzBdLCB0aGlzLm9mZnNldFsxXSk7XG4gICAgfTtcblxuICAgIERyYWdBbmRTY2FsZS5wcm90b3R5cGUuY29udmVydE9mZnNldFRvQ2FudmFzID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIC8vcmV0dXJuIFtwb3NbMF0gLyB0aGlzLnNjYWxlIC0gdGhpcy5vZmZzZXRbMF0sIHBvc1sxXSAvIHRoaXMuc2NhbGUgLSB0aGlzLm9mZnNldFsxXV07XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAocG9zWzBdICsgdGhpcy5vZmZzZXRbMF0pICogdGhpcy5zY2FsZSxcbiAgICAgICAgICAgIChwb3NbMV0gKyB0aGlzLm9mZnNldFsxXSkgKiB0aGlzLnNjYWxlXG4gICAgICAgIF07XG4gICAgfTtcblxuICAgIERyYWdBbmRTY2FsZS5wcm90b3R5cGUuY29udmVydENhbnZhc1RvT2Zmc2V0ID0gZnVuY3Rpb24ocG9zLCBvdXQpIHtcbiAgICAgICAgb3V0ID0gb3V0IHx8IFswLCAwXTtcbiAgICAgICAgb3V0WzBdID0gcG9zWzBdIC8gdGhpcy5zY2FsZSAtIHRoaXMub2Zmc2V0WzBdO1xuICAgICAgICBvdXRbMV0gPSBwb3NbMV0gLyB0aGlzLnNjYWxlIC0gdGhpcy5vZmZzZXRbMV07XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcblxuICAgIERyYWdBbmRTY2FsZS5wcm90b3R5cGUubW91c2VEcmFnID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB0aGlzLm9mZnNldFswXSArPSB4IC8gdGhpcy5zY2FsZTtcbiAgICAgICAgdGhpcy5vZmZzZXRbMV0gKz0geSAvIHRoaXMuc2NhbGU7XG5cbiAgICAgICAgaWYgKHRoaXMub25yZWRyYXcpIHtcbiAgICAgICAgICAgIHRoaXMub25yZWRyYXcodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRHJhZ0FuZFNjYWxlLnByb3RvdHlwZS5jaGFuZ2VTY2FsZSA9IGZ1bmN0aW9uKHZhbHVlLCB6b29taW5nX2NlbnRlcikge1xuICAgICAgICBpZiAodmFsdWUgPCB0aGlzLm1pbl9zY2FsZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLm1pbl9zY2FsZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA+IHRoaXMubWF4X3NjYWxlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMubWF4X3NjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09IHRoaXMuc2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKCFyZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB6b29taW5nX2NlbnRlciA9IHpvb21pbmdfY2VudGVyIHx8IFtcbiAgICAgICAgICAgIHJlY3Qud2lkdGggKiAwLjUsXG4gICAgICAgICAgICByZWN0LmhlaWdodCAqIDAuNVxuICAgICAgICBdO1xuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5jb252ZXJ0Q2FudmFzVG9PZmZzZXQoem9vbWluZ19jZW50ZXIpO1xuICAgICAgICB0aGlzLnNjYWxlID0gdmFsdWU7XG4gICAgICAgIGlmIChNYXRoLmFicyh0aGlzLnNjYWxlIC0gMSkgPCAwLjAxKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdfY2VudGVyID0gdGhpcy5jb252ZXJ0Q2FudmFzVG9PZmZzZXQoem9vbWluZ19jZW50ZXIpO1xuICAgICAgICB2YXIgZGVsdGFfb2Zmc2V0ID0gW1xuICAgICAgICAgICAgbmV3X2NlbnRlclswXSAtIGNlbnRlclswXSxcbiAgICAgICAgICAgIG5ld19jZW50ZXJbMV0gLSBjZW50ZXJbMV1cbiAgICAgICAgXTtcblxuICAgICAgICB0aGlzLm9mZnNldFswXSArPSBkZWx0YV9vZmZzZXRbMF07XG4gICAgICAgIHRoaXMub2Zmc2V0WzFdICs9IGRlbHRhX29mZnNldFsxXTtcblxuICAgICAgICBpZiAodGhpcy5vbnJlZHJhdykge1xuICAgICAgICAgICAgdGhpcy5vbnJlZHJhdyh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBEcmFnQW5kU2NhbGUucHJvdG90eXBlLmNoYW5nZURlbHRhU2NhbGUgPSBmdW5jdGlvbih2YWx1ZSwgem9vbWluZ19jZW50ZXIpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VTY2FsZSh0aGlzLnNjYWxlICogdmFsdWUsIHpvb21pbmdfY2VudGVyKTtcbiAgICB9O1xuXG4gICAgRHJhZ0FuZFNjYWxlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNjYWxlID0gMTtcbiAgICAgICAgdGhpcy5vZmZzZXRbMF0gPSAwO1xuICAgICAgICB0aGlzLm9mZnNldFsxXSA9IDA7XG4gICAgfTtcblxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gTEdyYXBoQ2FudmFzOiBMR3JhcGggcmVuZGVyZXIgQ0xBU1NcbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgLyoqXG4gICAgICogVGhpcyBjbGFzcyBpcyBpbiBjaGFyZ2Ugb2YgcmVuZGVyaW5nIG9uZSBncmFwaCBpbnNpZGUgYSBjYW52YXMuIEFuZCBwcm92aWRlcyBhbGwgdGhlIGludGVyYWN0aW9uIHJlcXVpcmVkLlxuICAgICAqIFZhbGlkIGNhbGxiYWNrcyBhcmU6IG9uTm9kZVNlbGVjdGVkLCBvbk5vZGVEZXNlbGVjdGVkLCBvblNob3dOb2RlUGFuZWwsIG9uTm9kZURibENsaWNrZWRcbiAgICAgKlxuICAgICAqIEBjbGFzcyBMR3JhcGhDYW52YXNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXN9IGNhbnZhcyB0aGUgY2FudmFzIHdoZXJlIHlvdSB3YW50IHRvIHJlbmRlciAoaXQgYWNjZXB0cyBhIHNlbGVjdG9yIGluIHN0cmluZyBmb3JtYXQgb3IgdGhlIGNhbnZhcyBlbGVtZW50IGl0c2VsZilcbiAgICAgKiBAcGFyYW0ge0xHcmFwaH0gZ3JhcGggW29wdGlvbmFsXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFtvcHRpb25hbF0geyBza2lwX3JlbmRlcmluZywgYXV0b3Jlc2l6ZSwgdmlld3BvcnQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExHcmFwaENhbnZhcyhjYW52YXMsIGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8vaWYoZ3JhcGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgLy9cdHRocm93IChcIk5vIGdyYXBoIGFzc2lnbmVkXCIpO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRfaW1hZ2UgPSBMR3JhcGhDYW52YXMuREVGQVVMVF9CQUNLR1JPVU5EX0lNQUdFO1xuXG4gICAgICAgIGlmIChjYW52YXMgJiYgY2FudmFzLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcbiAgICAgICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY2FudmFzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHMgPSBuZXcgRHJhZ0FuZFNjYWxlKCk7XG4gICAgICAgIHRoaXMuem9vbV9tb2RpZnlfYWxwaGEgPSB0cnVlOyAvL290aGVyd2lzZSBpdCBnZW5lcmF0ZXMgdWdseSBwYXR0ZXJucyB3aGVuIHNjYWxpbmcgZG93biB0b28gbXVjaFxuXG4gICAgICAgIHRoaXMudGl0bGVfdGV4dF9mb250ID0gXCJcIiArIExpdGVHcmFwaC5OT0RFX1RFWFRfU0laRSArIFwicHggQXJpYWxcIjtcbiAgICAgICAgdGhpcy5pbm5lcl90ZXh0X2ZvbnQgPVxuICAgICAgICAgICAgXCJub3JtYWwgXCIgKyBMaXRlR3JhcGguTk9ERV9TVUJURVhUX1NJWkUgKyBcInB4IEFyaWFsXCI7XG4gICAgICAgIHRoaXMubm9kZV90aXRsZV9jb2xvciA9IExpdGVHcmFwaC5OT0RFX1RJVExFX0NPTE9SO1xuICAgICAgICB0aGlzLmRlZmF1bHRfbGlua19jb2xvciA9IExpdGVHcmFwaC5MSU5LX0NPTE9SO1xuICAgICAgICB0aGlzLmRlZmF1bHRfY29ubmVjdGlvbl9jb2xvciA9IHtcbiAgICAgICAgICAgIGlucHV0X29mZjogXCIjNzc4XCIsXG4gICAgICAgICAgICBpbnB1dF9vbjogXCIjN0Y3XCIsIC8vXCIjQkJEXCJcbiAgICAgICAgICAgIG91dHB1dF9vZmY6IFwiIzc3OFwiLFxuICAgICAgICAgICAgb3V0cHV0X29uOiBcIiM3RjdcIiAvL1wiI0JCRFwiXG5cdFx0fTtcbiAgICAgICAgdGhpcy5kZWZhdWx0X2Nvbm5lY3Rpb25fY29sb3JfYnlUeXBlID0ge1xuICAgICAgICAgICAgLypudW1iZXI6IFwiIzdGN1wiLFxuICAgICAgICAgICAgc3RyaW5nOiBcIiM3N0ZcIixcbiAgICAgICAgICAgIGJvb2xlYW46IFwiI0Y3N1wiLCovXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWZhdWx0X2Nvbm5lY3Rpb25fY29sb3JfYnlUeXBlT2ZmID0ge1xuICAgICAgICAgICAgLypudW1iZXI6IFwiIzQ3NFwiLFxuICAgICAgICAgICAgc3RyaW5nOiBcIiM0NDdcIixcbiAgICAgICAgICAgIGJvb2xlYW46IFwiIzc0NFwiLCovXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5oaWdocXVhbGl0eV9yZW5kZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLnVzZV9ncmFkaWVudHMgPSBmYWxzZTsgLy9zZXQgdG8gdHJ1ZSB0byByZW5kZXIgdGl0bGViYXIgd2l0aCBncmFkaWVudHNcbiAgICAgICAgdGhpcy5lZGl0b3JfYWxwaGEgPSAxOyAvL3VzZWQgZm9yIHRyYW5zaXRpb25cbiAgICAgICAgdGhpcy5wYXVzZV9yZW5kZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jbGVhcl9iYWNrZ3JvdW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbGVhcl9iYWNrZ3JvdW5kX2NvbG9yID0gXCIjMjIyXCI7XG5cblx0XHR0aGlzLnJlYWRfb25seSA9IGZhbHNlOyAvL2lmIHNldCB0byB0cnVlIHVzZXJzIGNhbm5vdCBtb2RpZnkgdGhlIGdyYXBoXG4gICAgICAgIHRoaXMucmVuZGVyX29ubHlfc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxpdmVfbW9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3dfaW5mbyA9IHRydWU7XG4gICAgICAgIHRoaXMuYWxsb3dfZHJhZ2NhbnZhcyA9IHRydWU7XG4gICAgICAgIHRoaXMuYWxsb3dfZHJhZ25vZGVzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbGxvd19pbnRlcmFjdGlvbiA9IHRydWU7IC8vYWxsb3cgdG8gY29udHJvbCB3aWRnZXRzLCBidXR0b25zLCBjb2xsYXBzZSwgZXRjXG4gICAgICAgIHRoaXMubXVsdGlfc2VsZWN0ID0gZmFsc2U7IC8vYWxsb3cgc2VsZWN0aW5nIG11bHRpIG5vZGVzIHdpdGhvdXQgcHJlc3NpbmcgZXh0cmEga2V5c1xuICAgICAgICB0aGlzLmFsbG93X3NlYXJjaGJveCA9IHRydWU7XG4gICAgICAgIHRoaXMuYWxsb3dfcmVjb25uZWN0X2xpbmtzID0gdHJ1ZTsgLy9hbGxvd3MgdG8gY2hhbmdlIGEgY29ubmVjdGlvbiB3aXRoIGhhdmluZyB0byByZWRvIGl0IGFnYWluXG5cdFx0dGhpcy5hbGlnbl90b19ncmlkID0gZmFsc2U7IC8vc25hcCB0byBncmlkXG5cbiAgICAgICAgdGhpcy5kcmFnX21vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuZmlsdGVyID0gbnVsbDsgLy9hbGxvd3MgdG8gZmlsdGVyIHRvIG9ubHkgYWNjZXB0IHNvbWUgdHlwZSBvZiBub2RlcyBpbiBhIGdyYXBoXG5cblx0XHR0aGlzLnNldF9jYW52YXNfZGlydHlfb25fbW91c2VfZXZlbnQgPSB0cnVlOyAvL2ZvcmNlcyB0byByZWRyYXcgdGhlIGNhbnZhcyBpZiB0aGUgbW91c2UgZG9lcyBhbnl0aGluZ1xuICAgICAgICB0aGlzLmFsd2F5c19yZW5kZXJfYmFja2dyb3VuZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbmRlcl9zaGFkb3dzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZW5kZXJfY2FudmFzX2JvcmRlciA9IHRydWU7XG4gICAgICAgIHRoaXMucmVuZGVyX2Nvbm5lY3Rpb25zX3NoYWRvd3MgPSBmYWxzZTsgLy90b28gbXVjaCBjcHVcbiAgICAgICAgdGhpcy5yZW5kZXJfY29ubmVjdGlvbnNfYm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZW5kZXJfY3VydmVkX2Nvbm5lY3Rpb25zID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVuZGVyX2Nvbm5lY3Rpb25fYXJyb3dzID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVuZGVyX2NvbGxhcHNlZF9zbG90cyA9IHRydWU7XG4gICAgICAgIHRoaXMucmVuZGVyX2V4ZWN1dGlvbl9vcmRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbmRlcl90aXRsZV9jb2xvcmVkID0gdHJ1ZTtcblx0XHR0aGlzLnJlbmRlcl9saW5rX3Rvb2x0aXAgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMubGlua3NfcmVuZGVyX21vZGUgPSBMaXRlR3JhcGguU1BMSU5FX0xJTks7XG5cbiAgICAgICAgdGhpcy5tb3VzZSA9IFswLCAwXTsgLy9tb3VzZSBpbiBjYW52YXMgY29vcmRpbmF0ZXMsIHdoZXJlIDAsMCBpcyB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBibHVlIHJlY3RhbmdsZVxuICAgICAgICB0aGlzLmdyYXBoX21vdXNlID0gWzAsIDBdOyAvL21vdXNlIGluIGdyYXBoIGNvb3JkaW5hdGVzLCB3aGVyZSAwLDAgaXMgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgYmx1ZSByZWN0YW5nbGVcblx0XHR0aGlzLmNhbnZhc19tb3VzZSA9IHRoaXMuZ3JhcGhfbW91c2U7IC8vTEVHQUNZOiBSRU1PVkUgVEhJUywgVVNFIEdSQVBIX01PVVNFIElOU1RFQURcblxuICAgICAgICAvL3RvIHBlcnNvbmFsaXplIHRoZSBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMub25TZWFyY2hCb3ggPSBudWxsO1xuICAgICAgICB0aGlzLm9uU2VhcmNoQm94U2VsZWN0aW9uID0gbnVsbDtcblxuICAgICAgICAvL2NhbGxiYWNrc1xuICAgICAgICB0aGlzLm9uTW91c2UgPSBudWxsO1xuICAgICAgICB0aGlzLm9uRHJhd0JhY2tncm91bmQgPSBudWxsOyAvL3RvIHJlbmRlciBiYWNrZ3JvdW5kIG9iamVjdHMgKGJlaGluZCBub2RlcyBhbmQgY29ubmVjdGlvbnMpIGluIHRoZSBjYW52YXMgYWZmZWN0ZWQgYnkgdHJhbnNmb3JtXG4gICAgICAgIHRoaXMub25EcmF3Rm9yZWdyb3VuZCA9IG51bGw7IC8vdG8gcmVuZGVyIGZvcmVncm91bmQgb2JqZWN0cyAoYWJvdmUgbm9kZXMgYW5kIGNvbm5lY3Rpb25zKSBpbiB0aGUgY2FudmFzIGFmZmVjdGVkIGJ5IHRyYW5zZm9ybVxuICAgICAgICB0aGlzLm9uRHJhd092ZXJsYXkgPSBudWxsOyAvL3RvIHJlbmRlciBmb3JlZ3JvdW5kIG9iamVjdHMgbm90IGFmZmVjdGVkIGJ5IHRyYW5zZm9ybSAoZm9yIEdVSXMpXG5cdFx0dGhpcy5vbkRyYXdMaW5rVG9vbHRpcCA9IG51bGw7IC8vY2FsbGVkIHdoZW4gcmVuZGVyaW5nIGEgdG9vbHRpcFxuXHRcdHRoaXMub25Ob2RlTW92ZWQgPSBudWxsOyAvL2NhbGxlZCBhZnRlciBtb3ZpbmcgYSBub2RlXG5cdFx0dGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9IG51bGw7IC8vY2FsbGVkIGlmIHRoZSBzZWxlY3Rpb24gY2hhbmdlc1xuXHRcdHRoaXMub25Db25uZWN0aW5nQ2hhbmdlID0gbnVsbDsgLy9jYWxsZWQgYmVmb3JlIGFueSBsaW5rIGNoYW5nZXNcblx0XHR0aGlzLm9uQmVmb3JlQ2hhbmdlID0gbnVsbDsgLy9jYWxsZWQgYmVmb3JlIG1vZGlmeWluZyB0aGUgZ3JhcGhcblx0XHR0aGlzLm9uQWZ0ZXJDaGFuZ2UgPSBudWxsOyAvL2NhbGxlZCBhZnRlciBtb2RpZnlpbmcgdGhlIGdyYXBoXG5cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uc193aWR0aCA9IDM7XG4gICAgICAgIHRoaXMucm91bmRfcmFkaXVzID0gODtcblxuICAgICAgICB0aGlzLmN1cnJlbnRfbm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMubm9kZV93aWRnZXQgPSBudWxsOyAvL3VzZWQgZm9yIHdpZGdldHNcblx0XHR0aGlzLm92ZXJfbGlua19jZW50ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RfbW91c2VfcG9zaXRpb24gPSBbMCwgMF07XG4gICAgICAgIHRoaXMudmlzaWJsZV9hcmVhID0gdGhpcy5kcy52aXNpYmxlX2FyZWE7XG4gICAgICAgIHRoaXMudmlzaWJsZV9saW5rcyA9IFtdO1xuXG5cdFx0dGhpcy52aWV3cG9ydCA9IG9wdGlvbnMudmlld3BvcnQgfHwgbnVsbDsgLy90byBjb25zdHJhaW50IHJlbmRlciBhcmVhIHRvIGEgcG9ydGlvbiBvZiB0aGUgY2FudmFzXG5cbiAgICAgICAgLy9saW5rIGNhbnZhcyBhbmQgZ3JhcGhcbiAgICAgICAgaWYgKGdyYXBoKSB7XG4gICAgICAgICAgICBncmFwaC5hdHRhY2hDYW52YXModGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldENhbnZhcyhjYW52YXMsb3B0aW9ucy5za2lwX2V2ZW50cyk7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMuc2tpcF9yZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRSZW5kZXJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXV0b3Jlc2l6ZSA9IG9wdGlvbnMuYXV0b3Jlc2l6ZTtcbiAgICB9XG5cbiAgICBnbG9iYWwuTEdyYXBoQ2FudmFzID0gTGl0ZUdyYXBoLkxHcmFwaENhbnZhcyA9IExHcmFwaENhbnZhcztcblxuXHRMR3JhcGhDYW52YXMuREVGQVVMVF9CQUNLR1JPVU5EX0lNQUdFID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUdRQUFBQmtDQUlBQUFEL2dBSURBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQVFCSlJFRlVlTnJzMXJFS3dqQVVobEVUVWtqM3ZQOXJkbXIxWXNhbW1rMnc1d2R4dUxnY01IeXB0ZmF3dVpYNHBKU1daVG5mbnUvbG5JZS9qTk54SEhHTm4vL0hOYmJ2KzRkcjZWKzExdUY1MjdhclU3K3U2M3FmYS9ibm1oOHNXTEJnd1lKbHFSZjhNRXB0WFBCWEpYYTM3QlNsM2l4WXNHREJNbGl3Rkx5Q1YvRGVMSU1GQ3hZc1dMQk13U3Q0QmUvTmdnWExZTUdDQlV2QkszaU5ydUM5V2JCZ3dZSmxzR0FwZUFXdjRMMVpCZ3NXTEZpd1lKbUNWL0FLM3BzRkM1YkJnZ1VMbG9KWDhCcGR3WHV6WU1HQ0JjdGd3Vkx3Q2w3QmU3TU1GaXhZc0dEQnN1OEZIMUZhU21FeFZmQXhCYS9ndlZtd1lNR0NaYkJnL1c0dkFRWUE1dFJGOVFZbHYvUUFBQUFBU1VWT1JLNUNZSUk9XCI7XG5cbiAgICBMR3JhcGhDYW52YXMubGlua190eXBlX2NvbG9ycyA9IHtcbiAgICAgICAgXCItMVwiOiBMaXRlR3JhcGguRVZFTlRfTElOS19DT0xPUixcbiAgICAgICAgbnVtYmVyOiBcIiNBQUFcIixcbiAgICAgICAgbm9kZTogXCIjRENBXCJcbiAgICB9O1xuICAgIExHcmFwaENhbnZhcy5ncmFkaWVudHMgPSB7fTsgLy9jYWNoZSBvZiBncmFkaWVudHNcblxuICAgIC8qKlxuICAgICAqIGNsZWFycyBhbGwgdGhlIGRhdGEgaW5zaWRlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNsZWFyXG4gICAgICovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZyYW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0X2RyYXdfdGltZSA9IDA7XG4gICAgICAgIHRoaXMucmVuZGVyX3RpbWUgPSAwO1xuICAgICAgICB0aGlzLmZwcyA9IDA7XG5cbiAgICAgICAgLy90aGlzLnNjYWxlID0gMTtcbiAgICAgICAgLy90aGlzLm9mZnNldCA9IFswLDBdO1xuXG4gICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlID0gbnVsbDtcblxuICAgICAgICB0aGlzLnNlbGVjdGVkX25vZGVzID0ge307XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfZ3JvdXAgPSBudWxsO1xuXG4gICAgICAgIHRoaXMudmlzaWJsZV9ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLm5vZGVfZHJhZ2dlZCA9IG51bGw7XG4gICAgICAgIHRoaXMubm9kZV9vdmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5ub2RlX2NhcHR1cmluZ19pbnB1dCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29ubmVjdGluZ19ub2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRlZF9saW5rcyA9IHt9O1xuXG5cdFx0dGhpcy5kcmFnZ2luZ19jYW52YXMgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpcnR5X2FyZWEgPSBudWxsO1xuXG4gICAgICAgIHRoaXMubm9kZV9pbl9wYW5lbCA9IG51bGw7XG4gICAgICAgIHRoaXMubm9kZV93aWRnZXQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMubGFzdF9tb3VzZSA9IFswLCAwXTtcbiAgICAgICAgdGhpcy5sYXN0X21vdXNlY2xpY2sgPSAwO1xuXHQgIFx0dGhpcy5wb2ludGVyX2lzX2Rvd24gPSBmYWxzZTtcblx0ICBcdHRoaXMucG9pbnRlcl9pc19kb3VibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52aXNpYmxlX2FyZWEuc2V0KFswLCAwLCAwLCAwXSk7XG5cbiAgICAgICAgaWYgKHRoaXMub25DbGVhcikge1xuICAgICAgICAgICAgdGhpcy5vbkNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYXNzaWducyBhIGdyYXBoLCB5b3UgY2FuIHJlYXNzaWduIGdyYXBocyB0byB0aGUgc2FtZSBjYW52YXNcbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2V0R3JhcGhcbiAgICAgKiBAcGFyYW0ge0xHcmFwaH0gZ3JhcGhcbiAgICAgKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnNldEdyYXBoID0gZnVuY3Rpb24oZ3JhcGgsIHNraXBfY2xlYXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGggPT0gZ3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2tpcF9jbGVhcikge1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFncmFwaCAmJiB0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoLmRldGFjaENhbnZhcyh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyYXBoLmF0dGFjaENhbnZhcyh0aGlzKTtcblxuXHRcdC8vcmVtb3ZlIHRoZSBncmFwaCBzdGFjayBpbiBjYXNlIGEgc3ViZ3JhcGggd2FzIG9wZW5cblx0XHRpZiAodGhpcy5fZ3JhcGhfc3RhY2spXG5cdFx0XHR0aGlzLl9ncmFwaF9zdGFjayA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5zZXREaXJ0eSh0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgdG9wIGxldmVsIGdyYXBoIChpbiBjYXNlIHRoZXJlIGFyZSBzdWJncmFwaHMgb3BlbiBvbiB0aGUgY2FudmFzKVxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRUb3BHcmFwaFxuICAgICAqIEByZXR1cm4ge0xHcmFwaH0gZ3JhcGhcbiAgICAgKi9cblx0TEdyYXBoQ2FudmFzLnByb3RvdHlwZS5nZXRUb3BHcmFwaCA9IGZ1bmN0aW9uKClcblx0e1xuXHRcdGlmKHRoaXMuX2dyYXBoX3N0YWNrLmxlbmd0aClcblx0XHRcdHJldHVybiB0aGlzLl9ncmFwaF9zdGFja1swXTtcblx0XHRyZXR1cm4gdGhpcy5ncmFwaDtcblx0fVxuXG4gICAgLyoqXG4gICAgICogb3BlbnMgYSBncmFwaCBjb250YWluZWQgaW5zaWRlIGEgbm9kZSBpbiB0aGUgY3VycmVudCBncmFwaFxuICAgICAqXG4gICAgICogQG1ldGhvZCBvcGVuU3ViZ3JhcGhcbiAgICAgKiBAcGFyYW0ge0xHcmFwaH0gZ3JhcGhcbiAgICAgKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLm9wZW5TdWJncmFwaCA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gICAgICAgIGlmICghZ3JhcGgpIHtcbiAgICAgICAgICAgIHRocm93IFwiZ3JhcGggY2Fubm90IGJlIG51bGxcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoID09IGdyYXBoKSB7XG4gICAgICAgICAgICB0aHJvdyBcImdyYXBoIGNhbm5vdCBiZSB0aGUgc2FtZVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2dyYXBoX3N0YWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhfc3RhY2sgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2dyYXBoX3N0YWNrLnB1c2godGhpcy5ncmFwaCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmFwaC5hdHRhY2hDYW52YXModGhpcyk7XG5cdFx0dGhpcy5jaGVja1BhbmVscygpO1xuICAgICAgICB0aGlzLnNldERpcnR5KHRydWUsIHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjbG9zZXMgYSBzdWJncmFwaCBjb250YWluZWQgaW5zaWRlIGEgbm9kZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBjbG9zZVN1YmdyYXBoXG4gICAgICogQHBhcmFtIHtMR3JhcGh9IGFzc2lnbnMgYSBncmFwaFxuICAgICAqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuY2xvc2VTdWJncmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2dyYXBoX3N0YWNrIHx8IHRoaXMuX2dyYXBoX3N0YWNrLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YmdyYXBoX25vZGUgPSB0aGlzLmdyYXBoLl9zdWJncmFwaF9ub2RlO1xuICAgICAgICB2YXIgZ3JhcGggPSB0aGlzLl9ncmFwaF9zdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZF9ub2RlcyA9IHt9O1xuICAgICAgICB0aGlzLmhpZ2hsaWdodGVkX2xpbmtzID0ge307XG4gICAgICAgIGdyYXBoLmF0dGFjaENhbnZhcyh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXREaXJ0eSh0cnVlLCB0cnVlKTtcbiAgICAgICAgaWYgKHN1YmdyYXBoX25vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyT25Ob2RlKHN1YmdyYXBoX25vZGUpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3ROb2Rlcyhbc3ViZ3JhcGhfbm9kZV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdoZW4gY2xvc2Ugc3ViIGdyYXBoIGJhY2sgdG8gb2Zmc2V0IFswLCAwXSBzY2FsZSAxXG4gICAgICAgIHRoaXMuZHMub2Zmc2V0ID0gWzAsIDBdXG4gICAgICAgIHRoaXMuZHMuc2NhbGUgPSAxXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIHZpc3VhbGx5IGFjdGl2ZSBncmFwaCAoaW4gY2FzZSB0aGVyZSBhcmUgbW9yZSBpbiB0aGUgc3RhY2spXG4gICAgICogQG1ldGhvZCBnZXRDdXJyZW50R3JhcGhcbiAgICAgKiBAcmV0dXJuIHtMR3JhcGh9IHRoZSBhY3RpdmUgZ3JhcGhcbiAgICAgKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmdldEN1cnJlbnRHcmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmFwaDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYXNzaWducyBhIGNhbnZhc1xuICAgICAqXG4gICAgICogQG1ldGhvZCBzZXRDYW52YXNcbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gYXNzaWducyBhIGNhbnZhcyAoYWxzbyBhY2NlcHRzIHRoZSBJRCBvZiB0aGUgZWxlbWVudCAobm90IGEgc2VsZWN0b3IpXG4gICAgICovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zZXRDYW52YXMgPSBmdW5jdGlvbihjYW52YXMsIHNraXBfZXZlbnRzKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICBpZiAoY2FudmFzLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXMpO1xuICAgICAgICAgICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiRXJyb3IgY3JlYXRpbmcgTGl0ZUdyYXBoIGNhbnZhczogQ2FudmFzIG5vdCBmb3VuZFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYW52YXMgPT09IHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNhbnZhcyAmJiB0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgLy9tYXliZSBkZXRhY2ggZXZlbnRzIGZyb20gb2xkX2NhbnZhc1xuICAgICAgICAgICAgaWYgKCFza2lwX2V2ZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5kcy5lbGVtZW50ID0gY2FudmFzO1xuXG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL3RoaXMuY2FudmFzLnRhYmluZGV4ID0gXCIxMDAwXCI7XG4gICAgICAgIGNhbnZhcy5jbGFzc05hbWUgKz0gXCIgbGdyYXBoY2FudmFzXCI7XG4gICAgICAgIGNhbnZhcy5kYXRhID0gdGhpcztcbiAgICAgICAgY2FudmFzLnRhYmluZGV4ID0gXCIxXCI7IC8vdG8gYWxsb3cga2V5IGV2ZW50c1xuXG4gICAgICAgIC8vYmcgY2FudmFzOiB1c2VkIGZvciBub24gY2hhbmdpbmcgc3R1ZmZcbiAgICAgICAgdGhpcy5iZ2NhbnZhcyA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5iZ2NhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5iZ2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICB0aGlzLmJnY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmJnY2FudmFzLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYW52YXMuZ2V0Q29udGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY2FudmFzLmxvY2FsTmFtZSAhPSBcImNhbnZhc1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJFbGVtZW50IHN1cHBsaWVkIGZvciBMR3JhcGhDYW52YXMgbXVzdCBiZSBhIDxjYW52YXM+IGVsZW1lbnQsIHlvdSBwYXNzZWQgYSBcIiArXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5sb2NhbE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBcIlRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgQ2FudmFzXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3R4ID0gKHRoaXMuY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSk7XG4gICAgICAgIGlmIChjdHggPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFjYW52YXMud2ViZ2xfZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgXCJUaGlzIGNhbnZhcyBzZWVtcyB0byBiZSBXZWJHTCwgZW5hYmxpbmcgV2ViR0wgcmVuZGVyZXJcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVuYWJsZVdlYkdMKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lucHV0OiAgKG1vdmUgYW5kIHVwIGNvdWxkIGJlIHVuYmluZGVkKVxuICAgICAgICAvLyB3aHkgaGVyZT8gdGhpcy5fbW91c2Vtb3ZlX2NhbGxiYWNrID0gdGhpcy5wcm9jZXNzTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIC8vIHdoeSBoZXJlPyB0aGlzLl9tb3VzZXVwX2NhbGxiYWNrID0gdGhpcy5wcm9jZXNzTW91c2VVcC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGlmICghc2tpcF9ldmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vdXNlZCBpbiBzb21lIGV2ZW50cyB0byBjYXB0dXJlIHRoZW1cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLl9kb05vdGhpbmcgPSBmdW5jdGlvbiBkb05vdGhpbmcoZSkge1xuICAgIFx0Ly9jb25zb2xlLmxvZyhcInBvaW50ZXJldmVudHM6IF9kb05vdGhpbmcgXCIrZS50eXBlKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLl9kb1JldHVyblRydWUgPSBmdW5jdGlvbiBkb05vdGhpbmcoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBiaW5kcyBtb3VzZSwga2V5Ym9hcmQsIHRvdWNoIGFuZCBkcmFnIGV2ZW50cyB0byB0aGUgY2FudmFzXG4gICAgICogQG1ldGhvZCBiaW5kRXZlbnRzXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuYmluZEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZXZlbnRzX2JpbmRlZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTEdyYXBoQ2FudmFzOiBldmVudHMgYWxyZWFkeSBiaW5kZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbnNvbGUubG9nKFwicG9pbnRlcmV2ZW50czogYmluZEV2ZW50c1wiKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcblxuICAgICAgICB2YXIgcmVmX3dpbmRvdyA9IHRoaXMuZ2V0Q2FudmFzV2luZG93KCk7XG4gICAgICAgIHZhciBkb2N1bWVudCA9IHJlZl93aW5kb3cuZG9jdW1lbnQ7IC8vaGFjayB1c2VkIHdoZW4gbW92aW5nIGNhbnZhcyBiZXR3ZWVuIHdpbmRvd3NcblxuICAgICAgICB0aGlzLl9tb3VzZWRvd25fY2FsbGJhY2sgPSB0aGlzLnByb2Nlc3NNb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fbW91c2V3aGVlbF9jYWxsYmFjayA9IHRoaXMucHJvY2Vzc01vdXNlV2hlZWwuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gd2h5IG1vdXNlbW92ZSBhbmQgbW91c2V1cCB3ZXJlIG5vdCBiaW5kZWQgaGVyZT9cbiAgICAgICAgdGhpcy5fbW91c2Vtb3ZlX2NhbGxiYWNrID0gdGhpcy5wcm9jZXNzTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX21vdXNldXBfY2FsbGJhY2sgPSB0aGlzLnByb2Nlc3NNb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgICAgIFxuICAgICAgICAvL3RvdWNoIGV2ZW50cyAtLSBUT0RPIElNUExFTUVOVFxuICAgICAgICAvL3RoaXMuX3RvdWNoX2NhbGxiYWNrID0gdGhpcy50b3VjaEhhbmRsZXIuYmluZCh0aGlzKTtcblxuXHRcdExpdGVHcmFwaC5wb2ludGVyTGlzdGVuZXJBZGQoY2FudmFzLFwiZG93blwiLCB0aGlzLl9tb3VzZWRvd25fY2FsbGJhY2ssIHRydWUpOyAvL2Rvd24gZG8gbm90IG5lZWQgdG8gc3RvcmUgdGhlIGJpbmRlZFxuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNld2hlZWxcIiwgdGhpcy5fbW91c2V3aGVlbF9jYWxsYmFjaywgZmFsc2UpO1xuXG4gICAgICAgIExpdGVHcmFwaC5wb2ludGVyTGlzdGVuZXJBZGQoY2FudmFzLFwidXBcIiwgdGhpcy5fbW91c2V1cF9jYWxsYmFjaywgdHJ1ZSk7IC8vIENIRUNLOiA/Pz8gYmluZGVkIG9yIG5vdFxuXHRcdExpdGVHcmFwaC5wb2ludGVyTGlzdGVuZXJBZGQoY2FudmFzLFwibW92ZVwiLCB0aGlzLl9tb3VzZW1vdmVfY2FsbGJhY2spO1xuICAgICAgICBcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCB0aGlzLl9kb05vdGhpbmcpO1xuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwiRE9NTW91c2VTY3JvbGxcIixcbiAgICAgICAgICAgIHRoaXMuX21vdXNld2hlZWxfY2FsbGJhY2ssXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vdG91Y2ggZXZlbnRzIC0tIFRISVMgV0FZIERPRVMgTk9UIFdPUkssIGZpbmlzaCBpbXBsZW1lbnRpbmcgcG9pbnRlcmV2ZW50cywgdGhhbiBjbGVhbiB0aGUgdG91Y2hldmVudHNcbiAgICAgICAgLyppZiggJ3RvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl90b3VjaF9jYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl90b3VjaF9jYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3RvdWNoX2NhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgdGhpcy5fdG91Y2hfY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9Ki9cblxuICAgICAgICAvL0tleWJvYXJkICoqKioqKioqKioqKioqKioqKlxuICAgICAgICB0aGlzLl9rZXlfY2FsbGJhY2sgPSB0aGlzLnByb2Nlc3NLZXkuYmluZCh0aGlzKTtcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsMSk7IC8vb3RoZXJ3aXNlIGtleSBldmVudHMgYXJlIGlnbm9yZWRcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleV9jYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLl9rZXlfY2FsbGJhY2ssIHRydWUpOyAvL2luIGRvY3VtZW50LCBvdGhlcndpc2UgaXQgZG9lc24ndCBmaXJlIGtleXVwXG5cbiAgICAgICAgLy9Ecm9wcGluZyBTdHVmZiBvdmVyIG5vZGVzICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICB0aGlzLl9vbmRyb3BfY2FsbGJhY2sgPSB0aGlzLnByb2Nlc3NEcm9wLmJpbmQodGhpcyk7XG5cbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCB0aGlzLl9kb05vdGhpbmcsIGZhbHNlKTtcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW5kXCIsIHRoaXMuX2RvTm90aGluZywgZmFsc2UpO1xuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgdGhpcy5fb25kcm9wX2NhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2VudGVyXCIsIHRoaXMuX2RvUmV0dXJuVHJ1ZSwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuX2V2ZW50c19iaW5kZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmRzIG1vdXNlIGV2ZW50cyBmcm9tIHRoZSBjYW52YXNcbiAgICAgKiBAbWV0aG9kIHVuYmluZEV2ZW50c1xuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnVuYmluZEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50c19iaW5kZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkxHcmFwaENhbnZhczogbm8gZXZlbnRzIGJpbmRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJwb2ludGVyZXZlbnRzOiB1bmJpbmRFdmVudHNcIik7XG4gICAgICAgIFxuICAgICAgICB2YXIgcmVmX3dpbmRvdyA9IHRoaXMuZ2V0Q2FudmFzV2luZG93KCk7XG4gICAgICAgIHZhciBkb2N1bWVudCA9IHJlZl93aW5kb3cuZG9jdW1lbnQ7XG5cblx0XHRMaXRlR3JhcGgucG9pbnRlckxpc3RlbmVyUmVtb3ZlKHRoaXMuY2FudmFzLFwibW92ZVwiLCB0aGlzLl9tb3VzZWRvd25fY2FsbGJhY2spO1xuICAgICAgICBMaXRlR3JhcGgucG9pbnRlckxpc3RlbmVyUmVtb3ZlKHRoaXMuY2FudmFzLFwidXBcIiwgdGhpcy5fbW91c2Vkb3duX2NhbGxiYWNrKTtcbiAgICAgICAgTGl0ZUdyYXBoLnBvaW50ZXJMaXN0ZW5lclJlbW92ZSh0aGlzLmNhbnZhcyxcImRvd25cIiwgdGhpcy5fbW91c2Vkb3duX2NhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwibW91c2V3aGVlbFwiLFxuICAgICAgICAgICAgdGhpcy5fbW91c2V3aGVlbF9jYWxsYmFja1xuICAgICAgICApO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJET01Nb3VzZVNjcm9sbFwiLFxuICAgICAgICAgICAgdGhpcy5fbW91c2V3aGVlbF9jYWxsYmFja1xuICAgICAgICApO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlfY2FsbGJhY2spO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5fa2V5X2NhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIHRoaXMuX2RvTm90aGluZyk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIHRoaXMuX29uZHJvcF9jYWxsYmFjayk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnZW50ZXJcIiwgdGhpcy5fZG9SZXR1cm5UcnVlKTtcblxuICAgICAgICAvL3RvdWNoIGV2ZW50cyAtLSBUSElTIFdBWSBET0VTIE5PVCBXT1JLLCBmaW5pc2ggaW1wbGVtZW50aW5nIHBvaW50ZXJldmVudHMsIHRoYW4gY2xlYW4gdGhlIHRvdWNoZXZlbnRzXG4gICAgICAgIC8qdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5fdG91Y2hfY2FsbGJhY2sgKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl90b3VjaF9jYWxsYmFjayApO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fdG91Y2hfY2FsbGJhY2sgKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIHRoaXMuX3RvdWNoX2NhbGxiYWNrICk7Ki9cblxuICAgICAgICB0aGlzLl9tb3VzZWRvd25fY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLl9tb3VzZXdoZWVsX2NhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5fa2V5X2NhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb25kcm9wX2NhbGxiYWNrID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9ldmVudHNfYmluZGVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5nZXRGaWxlRXh0ZW5zaW9uID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIHZhciBxdWVzdGlvbiA9IHVybC5pbmRleE9mKFwiP1wiKTtcbiAgICAgICAgaWYgKHF1ZXN0aW9uICE9IC0xKSB7XG4gICAgICAgICAgICB1cmwgPSB1cmwuc3Vic3RyKDAsIHF1ZXN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9pbnQgPSB1cmwubGFzdEluZGV4T2YoXCIuXCIpO1xuICAgICAgICBpZiAocG9pbnQgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmwuc3Vic3RyKHBvaW50ICsgMSkudG9Mb3dlckNhc2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdGhpcyBmdW5jdGlvbiBhbGxvd3MgdG8gcmVuZGVyIHRoZSBjYW52YXMgdXNpbmcgV2ViR0wgaW5zdGVhZCBvZiBDYW52YXMyRFxuICAgICAqIHRoaXMgaXMgdXNlZnVsIGlmIHlvdSBwbGFudCB0byByZW5kZXIgM0Qgb2JqZWN0cyBpbnNpZGUgeW91ciBub2RlcywgaXQgdXNlcyBsaXRlZ2wuanMgZm9yIHdlYmdsIGFuZCBjYW52YXMyRHRvV2ViR0wgdG8gZW11bGF0ZSB0aGUgQ2FudmFzMkQgY2FsbHMgaW4gd2ViR0xcbiAgICAgKiBAbWV0aG9kIGVuYWJsZVdlYkdMXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZW5hYmxlV2ViR0wgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBHTCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhyb3cgXCJsaXRlZ2wuanMgbXVzdCBiZSBpbmNsdWRlZCB0byB1c2UgYSBXZWJHTCBjYW52YXNcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZVdlYkdMQ2FudmFzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBcIndlYmdsQ2FudmFzLmpzIG11c3QgYmUgaW5jbHVkZWQgdG8gdXNlIHRoaXMgZmVhdHVyZVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nbCA9IHRoaXMuY3R4ID0gZW5hYmxlV2ViR0xDYW52YXModGhpcy5jYW52YXMpO1xuICAgICAgICB0aGlzLmN0eC53ZWJnbCA9IHRydWU7XG4gICAgICAgIHRoaXMuYmdjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgICAgdGhpcy5iZ2N0eCA9IHRoaXMuZ2w7XG4gICAgICAgIHRoaXMuY2FudmFzLndlYmdsX2VuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIC8qXG5cdEdMLmNyZWF0ZSh7IGNhbnZhczogdGhpcy5iZ2NhbnZhcyB9KTtcblx0dGhpcy5iZ2N0eCA9IGVuYWJsZVdlYkdMQ2FudmFzKCB0aGlzLmJnY2FudmFzICk7XG5cdHdpbmRvdy5nbCA9IHRoaXMuZ2w7XG5cdCovXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIG1hcmtzIGFzIGRpcnR5IHRoZSBjYW52YXMsIHRoaXMgd2F5IGl0IHdpbGwgYmUgcmVuZGVyZWQgYWdhaW5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBMR3JhcGhDYW52YXNcbiAgICAgKiBAbWV0aG9kIHNldERpcnR5XG4gICAgICogQHBhcmFtIHtib29sfSBmZ2NhbnZhcyBpZiB0aGUgZm9yZWdyb3VuZCBjYW52YXMgaXMgZGlydHkgKHRoZSBvbmUgY29udGFpbmluZyB0aGUgbm9kZXMpXG4gICAgICogQHBhcmFtIHtib29sfSBiZ2NhbnZhcyBpZiB0aGUgYmFja2dyb3VuZCBjYW52YXMgaXMgZGlydHkgKHRoZSBvbmUgY29udGFpbmluZyB0aGUgd2lyZXMpXG4gICAgICovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zZXREaXJ0eSA9IGZ1bmN0aW9uKGZnY2FudmFzLCBiZ2NhbnZhcykge1xuICAgICAgICBpZiAoZmdjYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmdjYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gYXR0YWNoIHRoZSBjYW52YXMgaW4gYSBwb3B1cFxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRDYW52YXNXaW5kb3dcbiAgICAgKiBAcmV0dXJuIHt3aW5kb3d9IHJldHVybnMgdGhlIHdpbmRvdyB3aGVyZSB0aGUgY2FudmFzIGlzIGF0dGFjaGVkICh0aGUgRE9NIHJvb3Qgbm9kZSlcbiAgICAgKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmdldENhbnZhc1dpbmRvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmNhbnZhcy5vd25lckRvY3VtZW50O1xuICAgICAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHN0YXJ0cyByZW5kZXJpbmcgdGhlIGNvbnRlbnQgb2YgdGhlIGNhbnZhcyB3aGVuIG5lZWRlZFxuICAgICAqXG4gICAgICogQG1ldGhvZCBzdGFydFJlbmRlcmluZ1xuICAgICAqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuc3RhcnRSZW5kZXJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNfcmVuZGVyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy9hbHJlYWR5IHJlbmRlcmluZ1xuXG4gICAgICAgIHRoaXMuaXNfcmVuZGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgcmVuZGVyRnJhbWUuY2FsbCh0aGlzKTtcblxuICAgICAgICBmdW5jdGlvbiByZW5kZXJGcmFtZSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXVzZV9yZW5kZXJpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHdpbmRvdyA9IHRoaXMuZ2V0Q2FudmFzV2luZG93KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc19yZW5kZXJpbmcpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlckZyYW1lLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHN0b3BzIHJlbmRlcmluZyB0aGUgY29udGVudCBvZiB0aGUgY2FudmFzICh0byBzYXZlIHJlc291cmNlcylcbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc3RvcFJlbmRlcmluZ1xuICAgICAqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuc3RvcFJlbmRlcmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmlzX3JlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgICAvKlxuXHRpZih0aGlzLnJlbmRlcmluZ190aW1lcl9pZClcblx0e1xuXHRcdGNsZWFySW50ZXJ2YWwodGhpcy5yZW5kZXJpbmdfdGltZXJfaWQpO1xuXHRcdHRoaXMucmVuZGVyaW5nX3RpbWVyX2lkID0gbnVsbDtcblx0fVxuXHQqL1xuICAgIH07XG5cbiAgICAvKiBMaXRlR3JhcGhDYW52YXMgaW5wdXQgKi9cblxuXHQvL3VzZWQgdG8gYmxvY2sgZnV0dXJlIG1vdXNlIGV2ZW50cyAoYmVjYXVzZSBvZiBpbSBndWkpXG5cdExHcmFwaENhbnZhcy5wcm90b3R5cGUuYmxvY2tDbGljayA9IGZ1bmN0aW9uKClcblx0e1xuXHRcdHRoaXMuYmxvY2tfY2xpY2sgPSB0cnVlO1xuXHRcdHRoaXMubGFzdF9tb3VzZWNsaWNrID0gMDtcblx0fVxuXHRcbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnByb2Nlc3NNb3VzZURvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgXHRcblx0XHRpZiggdGhpcy5zZXRfY2FudmFzX2RpcnR5X29uX21vdXNlX2V2ZW50IClcblx0XHRcdHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcblx0XHRcblx0XHRpZiAoIXRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRqdXN0TW91c2VFdmVudChlKTtcblxuICAgICAgICB2YXIgcmVmX3dpbmRvdyA9IHRoaXMuZ2V0Q2FudmFzV2luZG93KCk7XG4gICAgICAgIHZhciBkb2N1bWVudCA9IHJlZl93aW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgIExHcmFwaENhbnZhcy5hY3RpdmVfY2FudmFzID0gdGhpcztcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dmFyIHggPSBlLmNsaWVudFg7XG5cdFx0dmFyIHkgPSBlLmNsaWVudFk7XG5cdFx0Ly9jb25zb2xlLmxvZyh5LHRoaXMudmlld3BvcnQpO1xuXHRcdC8vY29uc29sZS5sb2coXCJwb2ludGVyZXZlbnRzOiBwcm9jZXNzTW91c2VEb3duIHBvaW50ZXJJZDpcIitlLnBvaW50ZXJJZCtcIiB3aGljaDpcIitlLndoaWNoK1wiIGlzUHJpbWFyeTpcIitlLmlzUHJpbWFyeStcIiA6OiB4IHkgXCIreCtcIiBcIit5KTtcblxuXHRcdHRoaXMuZHMudmlld3BvcnQgPSB0aGlzLnZpZXdwb3J0O1xuXHRcdHZhciBpc19pbnNpZGUgPSAhdGhpcy52aWV3cG9ydCB8fCAoIHRoaXMudmlld3BvcnQgJiYgeCA+PSB0aGlzLnZpZXdwb3J0WzBdICYmIHggPCAodGhpcy52aWV3cG9ydFswXSArIHRoaXMudmlld3BvcnRbMl0pICYmIHkgPj0gdGhpcy52aWV3cG9ydFsxXSAmJiB5IDwgKHRoaXMudmlld3BvcnRbMV0gKyB0aGlzLnZpZXdwb3J0WzNdKSApO1xuXG4gICAgICAgIC8vbW92ZSBtb3VzZSBtb3ZlIGV2ZW50IHRvIHRoZSB3aW5kb3cgaW4gY2FzZSBpdCBkcmFncyBvdXRzaWRlIG9mIHRoZSBjYW52YXNcblx0XHRpZighdGhpcy5vcHRpb25zLnNraXBfZXZlbnRzKVxuXHRcdHtcblx0XHRcdExpdGVHcmFwaC5wb2ludGVyTGlzdGVuZXJSZW1vdmUodGhpcy5jYW52YXMsXCJtb3ZlXCIsIHRoaXMuX21vdXNlbW92ZV9jYWxsYmFjayk7XG5cdFx0XHRMaXRlR3JhcGgucG9pbnRlckxpc3RlbmVyQWRkKHJlZl93aW5kb3cuZG9jdW1lbnQsXCJtb3ZlXCIsIHRoaXMuX21vdXNlbW92ZV9jYWxsYmFjayx0cnVlKTsgLy9jYXRjaCBmb3IgdGhlIGVudGlyZSB3aW5kb3dcblx0XHRcdExpdGVHcmFwaC5wb2ludGVyTGlzdGVuZXJBZGQocmVmX3dpbmRvdy5kb2N1bWVudCxcInVwXCIsIHRoaXMuX21vdXNldXBfY2FsbGJhY2ssdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0aWYoIWlzX2luc2lkZSl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ncmFwaC5nZXROb2RlT25Qb3MoIGUuY2FudmFzWCwgZS5jYW52YXNZLCB0aGlzLnZpc2libGVfbm9kZXMsIDUgKTtcbiAgICAgICAgdmFyIHNraXBfZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNraXBfYWN0aW9uID0gZmFsc2U7XG4gICAgICAgIHZhciBub3cgPSBMaXRlR3JhcGguZ2V0VGltZSgpO1xuXHRcdHZhciBpc19wcmltYXJ5ID0gKGUuaXNQcmltYXJ5ID09PSB1bmRlZmluZWQgfHwgIWUuaXNQcmltYXJ5KTtcbiAgICAgICAgdmFyIGlzX2RvdWJsZV9jbGljayA9IChub3cgLSB0aGlzLmxhc3RfbW91c2VjbGljayA8IDMwMCkgJiYgaXNfcHJpbWFyeTtcblx0XHR0aGlzLm1vdXNlWzBdID0gZS5jbGllbnRYO1xuXHRcdHRoaXMubW91c2VbMV0gPSBlLmNsaWVudFk7XG4gICAgICAgIHRoaXMuZ3JhcGhfbW91c2VbMF0gPSBlLmNhbnZhc1g7XG4gICAgICAgIHRoaXMuZ3JhcGhfbW91c2VbMV0gPSBlLmNhbnZhc1k7XG5cdFx0dGhpcy5sYXN0X2NsaWNrX3Bvc2l0aW9uID0gW3RoaXMubW91c2VbMF0sdGhpcy5tb3VzZVsxXV07XG5cdCAgXHRcblx0ICBcdGlmICh0aGlzLnBvaW50ZXJfaXNfZG93biAmJiBpc19wcmltYXJ5ICl7XG5cdFx0ICB0aGlzLnBvaW50ZXJfaXNfZG91YmxlID0gdHJ1ZTtcblx0XHQgIC8vY29uc29sZS5sb2coXCJwb2ludGVyZXZlbnRzOiBwb2ludGVyX2lzX2RvdWJsZSBzdGFydFwiKTtcblx0XHR9ZWxzZXtcblx0XHQgIHRoaXMucG9pbnRlcl9pc19kb3VibGUgPSBmYWxzZTtcblx0XHR9XG5cdCAgXHR0aGlzLnBvaW50ZXJfaXNfZG93biA9IHRydWU7XG5cdCAgXG5cdCAgXHRcbiAgICAgICAgdGhpcy5jYW52YXMuZm9jdXMoKTtcblxuICAgICAgICBMaXRlR3JhcGguY2xvc2VBbGxDb250ZXh0TWVudXMocmVmX3dpbmRvdyk7XG5cbiAgICAgICAgaWYgKHRoaXMub25Nb3VzZSlcblx0XHR7XG4gICAgICAgICAgICBpZiAodGhpcy5vbk1vdXNlKGUpID09IHRydWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cblx0XHQvL2xlZnQgYnV0dG9uIG1vdXNlIC8gc2luZ2xlIGZpbmdlclxuICAgICAgICBpZiAoZS53aGljaCA9PSAxICYmICF0aGlzLnBvaW50ZXJfaXNfZG91YmxlKVxuXHRcdHtcbiAgICAgICAgICAgIGlmIChlLmN0cmxLZXkpXG5cdFx0XHR7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGUgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzBdID0gZS5jYW52YXNYO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzFdID0gZS5jYW52YXNZO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzJdID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVszXSA9IDE7XG4gICAgICAgICAgICAgICAgc2tpcF9hY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjbG9uZSBub2RlIEFMVCBkcmFnZ2luZ1xuICAgICAgICAgICAgaWYgKExpdGVHcmFwaC5hbHRfZHJhZ19kb19jbG9uZV9ub2RlcyAmJiBlLmFsdEtleSAmJiBub2RlICYmIHRoaXMuYWxsb3dfaW50ZXJhY3Rpb24gJiYgIXNraXBfYWN0aW9uICYmICF0aGlzLnJlYWRfb25seSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xvbmVkID0gbm9kZS5jbG9uZSgpKXtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLnBvc1swXSArPSA1O1xuICAgICAgICAgICAgICAgICAgICBjbG9uZWQucG9zWzFdICs9IDU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGguYWRkKGNsb25lZCxmYWxzZSx7ZG9DYWxjU2l6ZTogZmFsc2V9KTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGNsb25lZDtcbiAgICAgICAgICAgICAgICAgICAgc2tpcF9hY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJsb2NrX2RyYWdfbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dfZHJhZ25vZGVzKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZ3JhcGguYmVmb3JlQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlX2RyYWdnZWQgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGVkX25vZGVzW25vZGUuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTm9kZVNlbGVjdGVkKG5vZGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgY2xpY2tpbmdfY2FudmFzX2JnID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vd2hlbiBjbGlja2VkIG9uIHRvcCBvZiBhIG5vZGVcbiAgICAgICAgICAgIC8vYW5kIGl0IGlzIG5vdCBpbnRlcmFjdGl2ZVxuICAgICAgICAgICAgaWYgKG5vZGUgJiYgKHRoaXMuYWxsb3dfaW50ZXJhY3Rpb24gfHwgbm9kZS5mbGFncy5hbGxvd19pbnRlcmFjdGlvbikgJiYgIXNraXBfYWN0aW9uICYmICF0aGlzLnJlYWRfb25seSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5saXZlX21vZGUgJiYgIW5vZGUuZmxhZ3MucGlubmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnJpbmdUb0Zyb250KG5vZGUpO1xuICAgICAgICAgICAgICAgIH0gLy9pZiBpdCB3YXNuJ3Qgc2VsZWN0ZWQ/XG5cbiAgICAgICAgICAgICAgICAvL25vdCBkcmFnZ2luZyBtb3VzZSB0byBjb25uZWN0IHR3byBzbG90c1xuICAgICAgICAgICAgICAgIGlmICggdGhpcy5hbGxvd19pbnRlcmFjdGlvbiAmJiAhdGhpcy5jb25uZWN0aW5nX25vZGUgJiYgIW5vZGUuZmxhZ3MuY29sbGFwc2VkICYmICF0aGlzLmxpdmVfbW9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9TZWFyY2ggZm9yIGNvcm5lciBmb3IgcmVzaXplXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXNraXBfYWN0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlc2l6YWJsZSAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSW5zaWRlUmVjdGFuZ2xlKCBlLmNhbnZhc1gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jYW52YXNZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucG9zWzBdICsgbm9kZS5zaXplWzBdIC0gNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBvc1sxXSArIG5vZGUuc2l6ZVsxXSAtIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmdyYXBoLmJlZm9yZUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemluZ19ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmN1cnNvciA9IFwic2UtcmVzaXplXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwX2FjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NlYXJjaCBmb3Igb3V0cHV0c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUub3V0cHV0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG5vZGUub3V0cHV0cy5sZW5ndGg7IGkgPCBsOyArK2kgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBub2RlLm91dHB1dHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5rX3BvcyA9IG5vZGUuZ2V0Q29ubmVjdGlvblBvcyhmYWxzZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSW5zaWRlUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMF0gLSAxNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rX3Bvc1sxXSAtIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX25vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX291dHB1dCA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19vdXRwdXQuc2xvdF9pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdfcG9zID0gbm9kZS5nZXRDb25uZWN0aW9uUG9zKCBmYWxzZSwgaSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX3Nsb3QgPSBpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLnNoaWZ0X2NsaWNrX2RvX2JyZWFrX2xpbmtfZnJvbSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kaXNjb25uZWN0T3V0cHV0KGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2RvdWJsZV9jbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm9uT3V0cHV0RGJsQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5vbk91dHB1dERibENsaWNrKGksIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUub25PdXRwdXRDbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm9uT3V0cHV0Q2xpY2soaSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwX2FjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zZWFyY2ggZm9yIGlucHV0c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbm9kZS5pbnB1dHMubGVuZ3RoOyBpIDwgbDsgKytpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBub2RlLmlucHV0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmtfcG9zID0gbm9kZS5nZXRDb25uZWN0aW9uUG9zKHRydWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0luc2lkZVJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jYW52YXNZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfcG9zWzBdIC0gMTUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMV0gLSAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19kb3VibGVfY2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5vbklucHV0RGJsQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5vbklucHV0RGJsQ2xpY2soaSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5vbklucHV0Q2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5vbklucHV0Q2xpY2soaSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQubGluayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5rX2luZm8gPSB0aGlzLmdyYXBoLmxpbmtzW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5saW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTsgLy9iZWZvcmUgZGlzY29ubmVjdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMaXRlR3JhcGguY2xpY2tfZG9fYnJlYWtfbGlua190byl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGlzY29ubmVjdElucHV0KGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2JnY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcF9hY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBzYW1lIGFjdGlvbiBhcyBoYXMgbm90IG5vZGUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGxvd19yZWNvbm5lY3RfbGlua3MgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvL3RoaXMubW92ZV9kZXN0aW5hdGlvbl9saW5rX3dpdGhvdXRfc2hpZnQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zaGlmdEtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUxpdGVHcmFwaC5jbGlja19kb19icmVha19saW5rX3RvKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGlzY29ubmVjdElucHV0KGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19ub2RlID0gdGhpcy5ncmFwaC5fbm9kZXNfYnlfaWRbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8ub3JpZ2luX2lkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19zbG90ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaW5mby5vcmlnaW5fc2xvdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX291dHB1dCA9IHRoaXMuY29ubmVjdGluZ19ub2RlLm91dHB1dHNbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpbmdfc2xvdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdfcG9zID0gdGhpcy5jb25uZWN0aW5nX25vZGUuZ2V0Q29ubmVjdGlvblBvcyggZmFsc2UsIHRoaXMuY29ubmVjdGluZ19zbG90ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2JnY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcF9hY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFzIG5vdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2tpcF9hY3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbm5lY3QgZnJvbSBpbiB0byBvdXQsIGZyb20gdG8gdG8gZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdfaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdfaW5wdXQuc2xvdF9pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX3BvcyA9IG5vZGUuZ2V0Q29ubmVjdGlvblBvcyggdHJ1ZSwgaSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19zbG90ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2JnY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwX2FjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gLy9ub3QgcmVzaXppbmdcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2l0IHdhc24ndCBjbGlja2VkIG9uIHRoZSBsaW5rcyBib3hlc1xuICAgICAgICAgICAgICAgIGlmICghc2tpcF9hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrX2RyYWdfbm9kZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHZhciBwb3MgPSBbZS5jYW52YXNYIC0gbm9kZS5wb3NbMF0sIGUuY2FudmFzWSAtIG5vZGUucG9zWzFdXTtcblxuICAgICAgICAgICAgICAgICAgICAvL3dpZGdldHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMucHJvY2Vzc05vZGVXaWRnZXRzKCBub2RlLCB0aGlzLmdyYXBoX21vdXNlLCBlICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aWRnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrX2RyYWdfbm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVfd2lkZ2V0ID0gW25vZGUsIHdpZGdldF07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL2RvdWJsZSBjbGlja2luZ1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxvd19pbnRlcmFjdGlvbiAmJiBpc19kb3VibGVfY2xpY2sgJiYgdGhpcy5zZWxlY3RlZF9ub2Rlc1tub2RlLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9kb3VibGUgY2xpY2sgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUub25EYmxDbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUub25EYmxDbGljayggZSwgcG9zLCB0aGlzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NOb2RlRGJsQ2xpY2tlZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrX2RyYWdfbm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL2lmIGRvIG5vdCBjYXB0dXJlIG1vdXNlXG4gICAgICAgICAgICAgICAgICAgIGlmICggbm9kZS5vbk1vdXNlRG93biAmJiBub2RlLm9uTW91c2VEb3duKCBlLCBwb3MsIHRoaXMgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrX2RyYWdfbm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvL29wZW4gc3ViZ3JhcGggYnV0dG9uXG5cdFx0XHRcdFx0XHRpZihub2RlLnN1YmdyYXBoICYmICFub2RlLnNraXBfc3ViZ3JhcGhfYnV0dG9uKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRpZiAoICFub2RlLmZsYWdzLmNvbGxhcHNlZCAmJiBwb3NbMF0gPiBub2RlLnNpemVbMF0gLSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgJiYgcG9zWzFdIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRcdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoYXQub3BlblN1YmdyYXBoKG5vZGUuc3ViZ3JhcGgpO1xuXHRcdFx0XHRcdFx0XHRcdH0sIDEwKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5saXZlX21vZGUpIHtcblx0XHRcdFx0XHRcdFx0Y2xpY2tpbmdfY2FudmFzX2JnID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tfZHJhZ19ub2RlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghYmxvY2tfZHJhZ19ub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxvd19kcmFnbm9kZXMpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVfZHJhZ2dlZCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NOb2RlU2VsZWN0ZWQobm9kZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGRvdWJsZS1jbGlja1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBEb24ndCBjYWxsIHRoZSBmdW5jdGlvbiBpZiB0aGUgYmxvY2sgaXMgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIE90aGVyd2lzZSwgaXQgY291bGQgY2F1c2UgdGhlIGJsb2NrIHRvIGJlIHVuc2VsZWN0ZWQgd2hpbGUgaXRzIHBhbmVsIGlzIG9wZW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5pc19zZWxlY3RlZCkgdGhpcy5wcm9jZXNzTm9kZVNlbGVjdGVkKG5vZGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy9jbGlja2VkIG91dHNpZGUgb2Ygbm9kZXNcbiAgICAgICAgICAgIGVsc2Uge1xuXHRcdFx0XHRpZiAoIXNraXBfYWN0aW9uKXtcblx0XHRcdFx0XHQvL3NlYXJjaCBmb3IgbGluayBjb25uZWN0b3Jcblx0XHRcdFx0XHRpZighdGhpcy5yZWFkX29ubHkpIHtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52aXNpYmxlX2xpbmtzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBsaW5rID0gdGhpcy52aXNpYmxlX2xpbmtzW2ldO1xuXHRcdFx0XHRcdFx0XHR2YXIgY2VudGVyID0gbGluay5fcG9zO1xuXHRcdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdFx0IWNlbnRlciB8fFxuXHRcdFx0XHRcdFx0XHRcdGUuY2FudmFzWCA8IGNlbnRlclswXSAtIDQgfHxcblx0XHRcdFx0XHRcdFx0XHRlLmNhbnZhc1ggPiBjZW50ZXJbMF0gKyA0IHx8XG5cdFx0XHRcdFx0XHRcdFx0ZS5jYW52YXNZIDwgY2VudGVyWzFdIC0gNCB8fFxuXHRcdFx0XHRcdFx0XHRcdGUuY2FudmFzWSA+IGNlbnRlclsxXSArIDRcblx0XHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Ly9saW5rIGNsaWNrZWRcblx0XHRcdFx0XHRcdFx0dGhpcy5zaG93TGlua01lbnUobGluaywgZSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMub3Zlcl9saW5rX2NlbnRlciA9IG51bGw7IC8vY2xlYXIgdG9vbHRpcFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkX2dyb3VwID0gdGhpcy5ncmFwaC5nZXRHcm91cE9uUG9zKCBlLmNhbnZhc1gsIGUuY2FudmFzWSApO1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWRfZ3JvdXBfcmVzaXppbmcgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAodGhpcy5zZWxlY3RlZF9ncm91cCAmJiAhdGhpcy5yZWFkX29ubHkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoZS5jdHJsS2V5KSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFyIGRpc3QgPSBkaXN0YW5jZSggW2UuY2FudmFzWCwgZS5jYW52YXNZXSwgWyB0aGlzLnNlbGVjdGVkX2dyb3VwLnBvc1swXSArIHRoaXMuc2VsZWN0ZWRfZ3JvdXAuc2l6ZVswXSwgdGhpcy5zZWxlY3RlZF9ncm91cC5wb3NbMV0gKyB0aGlzLnNlbGVjdGVkX2dyb3VwLnNpemVbMV0gXSApO1xuXHRcdFx0XHRcdFx0aWYgKGRpc3QgKiB0aGlzLmRzLnNjYWxlIDwgMTApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZWxlY3RlZF9ncm91cF9yZXNpemluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkX2dyb3VwLnJlY29tcHV0ZUluc2lkZU5vZGVzKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGlzX2RvdWJsZV9jbGljayAmJiAhdGhpcy5yZWFkX29ubHkgJiYgdGhpcy5hbGxvd19zZWFyY2hib3gpIHtcblx0XHRcdFx0XHRcdHRoaXMuc2hvd1NlYXJjaEJveChlKTtcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2xpY2tpbmdfY2FudmFzX2JnID0gdHJ1ZTtcblx0XHRcdFx0fVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNraXBfYWN0aW9uICYmIGNsaWNraW5nX2NhbnZhc19iZyAmJiB0aGlzLmFsbG93X2RyYWdjYW52YXMpIHtcbiAgICAgICAgICAgIFx0Ly9jb25zb2xlLmxvZyhcInBvaW50ZXJldmVudHM6IGRyYWdnaW5nX2NhbnZhcyBzdGFydFwiKTtcbiAgICAgICAgICAgIFx0dGhpcy5kcmFnZ2luZ19jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PSAyKSB7XG4gICAgICAgICAgICAvL21pZGRsZSBidXR0b25cbiAgICAgICAgXHRcblx0XHRcdGlmIChMaXRlR3JhcGgubWlkZGxlX2NsaWNrX3Nsb3RfYWRkX2RlZmF1bHRfbm9kZSl7XG5cdFx0XHRcdGlmIChub2RlICYmIHRoaXMuYWxsb3dfaW50ZXJhY3Rpb24gJiYgIXNraXBfYWN0aW9uICYmICF0aGlzLnJlYWRfb25seSl7XG5cdFx0XHRcdFx0Ly9ub3QgZHJhZ2dpbmcgbW91c2UgdG8gY29ubmVjdCB0d28gc2xvdHNcblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHQhdGhpcy5jb25uZWN0aW5nX25vZGUgJiZcblx0XHRcdFx0XHRcdCFub2RlLmZsYWdzLmNvbGxhcHNlZCAmJlxuXHRcdFx0XHRcdFx0IXRoaXMubGl2ZV9tb2RlXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHR2YXIgbUNsaWtTbG90ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR2YXIgbUNsaWtTbG90X2luZGV4ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR2YXIgbUNsaWtTbG90X2lzT3V0ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHQvL3NlYXJjaCBmb3Igb3V0cHV0c1xuXHRcdFx0XHRcdFx0aWYgKG5vZGUub3V0cHV0cykge1xuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBub2RlLm91dHB1dHMubGVuZ3RoOyBpIDwgbDsgKytpICkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBvdXRwdXQgPSBub2RlLm91dHB1dHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGxpbmtfcG9zID0gbm9kZS5nZXRDb25uZWN0aW9uUG9zKGZhbHNlLCBpKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoaXNJbnNpZGVSZWN0YW5nbGUoZS5jYW52YXNYLGUuY2FudmFzWSxsaW5rX3Bvc1swXSAtIDE1LGxpbmtfcG9zWzFdIC0gMTAsMzAsMjApKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtQ2xpa1Nsb3QgPSBvdXRwdXQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRtQ2xpa1Nsb3RfaW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0XHRcdFx0bUNsaWtTbG90X2lzT3V0ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvL3NlYXJjaCBmb3IgaW5wdXRzXG5cdFx0XHRcdFx0XHRpZiAobm9kZS5pbnB1dHMpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbm9kZS5pbnB1dHMubGVuZ3RoOyBpIDwgbDsgKytpICkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBpbnB1dCA9IG5vZGUuaW5wdXRzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBsaW5rX3BvcyA9IG5vZGUuZ2V0Q29ubmVjdGlvblBvcyh0cnVlLCBpKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoaXNJbnNpZGVSZWN0YW5nbGUoZS5jYW52YXNYLGUuY2FudmFzWSxsaW5rX3Bvc1swXSAtIDE1LGxpbmtfcG9zWzFdIC0gMTAsMzAsMjApKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtQ2xpa1Nsb3QgPSBpbnB1dDtcblx0XHRcdFx0XHRcdFx0XHRcdG1DbGlrU2xvdF9pbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0XHRtQ2xpa1Nsb3RfaXNPdXQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIm1pZGRsZUNsaWNrU2xvdHM/IFwiK21DbGlrU2xvdCtcIiAmIFwiKyhtQ2xpa1Nsb3RfaW5kZXghPT1mYWxzZSkpO1xuXHRcdFx0XHRcdFx0aWYgKG1DbGlrU2xvdCAmJiBtQ2xpa1Nsb3RfaW5kZXghPT1mYWxzZSl7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHR2YXIgYWxwaGFQb3NZID0gMC41LSgobUNsaWtTbG90X2luZGV4KzEpLygobUNsaWtTbG90X2lzT3V0P25vZGUub3V0cHV0cy5sZW5ndGg6bm9kZS5pbnB1dHMubGVuZ3RoKSkpO1xuXHRcdFx0XHRcdFx0XHR2YXIgbm9kZV9ib3VuZGluZyA9IG5vZGUuZ2V0Qm91bmRpbmcoKTtcblx0XHRcdFx0XHRcdFx0Ly8gZXN0aW1hdGUgYSBwb3NpdGlvbjogdGhpcyBpcyBhIGJhZCBzZW1pLWJhZC13b3JraW5nIG1lc3MgLi4gUkVGQUNUT1Igd2l0aCBhIGNvcnJlY3QgYXV0b3BsYWNlbWVudCB0aGF0IGtub3dzIGFib3V0IHRoZSBvdGhlcnMgc2xvdHMgYW5kIG5vZGVzXG5cdFx0XHRcdFx0XHRcdHZhciBwb3NSZWYgPSBbXHQoIW1DbGlrU2xvdF9pc091dD9ub2RlX2JvdW5kaW5nWzBdOm5vZGVfYm91bmRpbmdbMF0rbm9kZV9ib3VuZGluZ1syXSkvLyArIG5vZGVfYm91bmRpbmdbMF0vdGhpcy5jYW52YXMud2lkdGgqMTUwXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LGUuY2FudmFzWS04MC8vICsgbm9kZV9ib3VuZGluZ1swXS90aGlzLmNhbnZhcy53aWR0aCo2NiAvLyB2ZXJ0aWNhbCBcImRlcml2ZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAgXTtcblx0XHRcdFx0XHRcdFx0dmFyIG5vZGVDcmVhdGVkID0gdGhpcy5jcmVhdGVEZWZhdWx0Tm9kZUZvclNsb3QoeyAgIFx0bm9kZUZyb206ICFtQ2xpa1Nsb3RfaXNPdXQ/bnVsbDpub2RlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQsc2xvdEZyb206ICFtQ2xpa1Nsb3RfaXNPdXQ/bnVsbDptQ2xpa1Nsb3RfaW5kZXhcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCxub2RlVG86ICFtQ2xpa1Nsb3RfaXNPdXQ/bm9kZTpudWxsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQsc2xvdFRvOiAhbUNsaWtTbG90X2lzT3V0P21DbGlrU2xvdF9pbmRleDpudWxsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQscG9zaXRpb246IHBvc1JlZiAvLyxlOiBlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQsbm9kZVR5cGU6IFwiQVVUT1wiIC8vbm9kZU5ld1R5cGVcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCxwb3NBZGQ6WyFtQ2xpa1Nsb3RfaXNPdXQ/LTMwOjMwLCAtYWxwaGFQb3NZKjEzMF0gLy8tYWxwaGFQb3NZKjMwXVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LHBvc1NpemVGaXg6WyFtQ2xpa1Nsb3RfaXNPdXQ/LTE6MCwgMF0gLy8tYWxwaGFQb3NZKjIqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICghc2tpcF9hY3Rpb24gJiYgdGhpcy5hbGxvd19kcmFnY2FudmFzKSB7XG4gICAgICAgICAgICBcdC8vY29uc29sZS5sb2coXCJwb2ludGVyZXZlbnRzOiBkcmFnZ2luZ19jYW52YXMgc3RhcnQgZnJvbSBtaWRkbGUgYnV0dG9uXCIpO1xuICAgICAgICAgICAgXHR0aGlzLmRyYWdnaW5nX2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgXHRcbiAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IDMgfHwgdGhpcy5wb2ludGVyX2lzX2RvdWJsZSkge1xuXHRcdFx0XG4gICAgICAgICAgICAvL3JpZ2h0IGJ1dHRvblxuXHRcdFx0aWYgKHRoaXMuYWxsb3dfaW50ZXJhY3Rpb24gJiYgIXNraXBfYWN0aW9uICYmICF0aGlzLnJlYWRfb25seSl7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBpcyBpdCBob3ZlciBhIG5vZGUgP1xuXHRcdFx0XHRpZiAobm9kZSl7XG5cdFx0XHRcdFx0aWYoT2JqZWN0LmtleXModGhpcy5zZWxlY3RlZF9ub2RlcykubGVuZ3RoXG5cdFx0XHRcdFx0ICAgJiYgKHRoaXMuc2VsZWN0ZWRfbm9kZXNbbm9kZS5pZF0gfHwgZS5zaGlmdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KVxuXHRcdFx0XHRcdCl7XG5cdFx0XHRcdFx0XHQvLyBpcyBtdWx0aXNlbGVjdGVkIG9yIHVzaW5nIHNoaWZ0IHRvIGluY2x1ZGUgdGhlIG5vdyBub2RlXG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuc2VsZWN0ZWRfbm9kZXNbbm9kZS5pZF0pIHRoaXMuc2VsZWN0Tm9kZXMoW25vZGVdLHRydWUpOyAvLyBhZGQgdGhpcyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0Ly8gdXBkYXRlIHNlbGVjdGlvblxuXHRcdFx0XHRcdFx0dGhpcy5zZWxlY3ROb2Rlcyhbbm9kZV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gc2hvdyBtZW51IG9uIHRoaXMgbm9kZVxuXHRcdFx0XHR0aGlzLnByb2Nlc3NDb250ZXh0TWVudShub2RlLCBlKTtcblx0XHRcdH1cblx0XHRcdFxuICAgICAgICB9XG5cbiAgICAgICAgLy9UT0RPXG4gICAgICAgIC8vaWYodGhpcy5ub2RlX3NlbGVjdGVkICE9IHByZXZfc2VsZWN0ZWQpXG4gICAgICAgIC8vXHR0aGlzLm9uTm9kZVNlbGVjdGlvbkNoYW5nZSh0aGlzLm5vZGVfc2VsZWN0ZWQpO1xuXG4gICAgICAgIHRoaXMubGFzdF9tb3VzZVswXSA9IGUuY2xpZW50WDtcbiAgICAgICAgdGhpcy5sYXN0X21vdXNlWzFdID0gZS5jbGllbnRZO1xuICAgICAgICB0aGlzLmxhc3RfbW91c2VjbGljayA9IExpdGVHcmFwaC5nZXRUaW1lKCk7XG4gICAgICAgIHRoaXMubGFzdF9tb3VzZV9kcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgLypcblx0aWYoICh0aGlzLmRpcnR5X2NhbnZhcyB8fCB0aGlzLmRpcnR5X2JnY2FudmFzKSAmJiB0aGlzLnJlbmRlcmluZ190aW1lcl9pZCA9PSBudWxsKVxuXHRcdHRoaXMuZHJhdygpO1xuXHQqL1xuXG4gICAgICAgIHRoaXMuZ3JhcGguY2hhbmdlKCk7XG5cbiAgICAgICAgLy90aGlzIGlzIHRvIGVuc3VyZSB0byBkZWZvY3VzKGJsdXIpIGlmIGEgdGV4dCBpbnB1dCBlbGVtZW50IGlzIG9uIGZvY3VzXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICFyZWZfd2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHxcbiAgICAgICAgICAgIChyZWZfd2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPVxuICAgICAgICAgICAgICAgIFwiaW5wdXRcIiAmJlxuICAgICAgICAgICAgICAgIHJlZl93aW5kb3cuZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9XG4gICAgICAgICAgICAgICAgICAgIFwidGV4dGFyZWFcIilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBpZiAodGhpcy5vbk1vdXNlRG93bikge1xuICAgICAgICAgICAgdGhpcy5vbk1vdXNlRG93bihlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBtb3VzZSBtb3ZlIGV2ZW50IGhhcyB0byBiZSBwcm9jZXNzZWRcbiAgICAgKiBAbWV0aG9kIHByb2Nlc3NNb3VzZU1vdmVcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wcm9jZXNzTW91c2VNb3ZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGhpcy5hdXRvcmVzaXplKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB9XG5cblx0XHRpZiggdGhpcy5zZXRfY2FudmFzX2RpcnR5X29uX21vdXNlX2V2ZW50IClcblx0XHRcdHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIExHcmFwaENhbnZhcy5hY3RpdmVfY2FudmFzID0gdGhpcztcbiAgICAgICAgdGhpcy5hZGp1c3RNb3VzZUV2ZW50KGUpO1xuICAgICAgICB2YXIgbW91c2UgPSBbZS5jbGllbnRYLCBlLmNsaWVudFldO1xuXHRcdHRoaXMubW91c2VbMF0gPSBtb3VzZVswXTtcblx0XHR0aGlzLm1vdXNlWzFdID0gbW91c2VbMV07XG4gICAgICAgIHZhciBkZWx0YSA9IFtcbiAgICAgICAgICAgIG1vdXNlWzBdIC0gdGhpcy5sYXN0X21vdXNlWzBdLFxuICAgICAgICAgICAgbW91c2VbMV0gLSB0aGlzLmxhc3RfbW91c2VbMV1cbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5sYXN0X21vdXNlID0gbW91c2U7XG4gICAgICAgIHRoaXMuZ3JhcGhfbW91c2VbMF0gPSBlLmNhbnZhc1g7XG4gICAgICAgIHRoaXMuZ3JhcGhfbW91c2VbMV0gPSBlLmNhbnZhc1k7XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyhcInBvaW50ZXJldmVudHM6IHByb2Nlc3NNb3VzZU1vdmUgXCIrZS5wb2ludGVySWQrXCIgXCIrZS5pc1ByaW1hcnkpO1xuICAgICAgICBcblx0XHRpZih0aGlzLmJsb2NrX2NsaWNrKVxuXHRcdHtcblx0XHRcdC8vY29uc29sZS5sb2coXCJwb2ludGVyZXZlbnRzOiBwcm9jZXNzTW91c2VNb3ZlIGJsb2NrX2NsaWNrXCIpO1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuICAgICAgICBlLmRyYWdnaW5nID0gdGhpcy5sYXN0X21vdXNlX2RyYWdnaW5nO1xuXG4gICAgICAgIGlmICh0aGlzLm5vZGVfd2lkZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NOb2RlV2lkZ2V0cyhcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVfd2lkZ2V0WzBdLFxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhfbW91c2UsXG4gICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVfd2lkZ2V0WzFdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9nZXQgbm9kZSBvdmVyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ncmFwaC5nZXROb2RlT25Qb3MoZS5jYW52YXNYLGUuY2FudmFzWSx0aGlzLnZpc2libGVfbm9kZXMpO1xuXG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZSlcblx0XHR7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVsyXSA9IGUuY2FudmFzWCAtIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzBdO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbM10gPSBlLmNhbnZhc1kgLSB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVsxXTtcbiAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgfSBcblx0XHRlbHNlIGlmICh0aGlzLnNlbGVjdGVkX2dyb3VwICYmICF0aGlzLnJlYWRfb25seSlcblx0XHR7XG4gICAgICAgICAgICAvL21vdmluZy9yZXNpemluZyBhIGdyb3VwXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZF9ncm91cF9yZXNpemluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfZ3JvdXAuc2l6ZSA9IFtcbiAgICAgICAgICAgICAgICAgICAgZS5jYW52YXNYIC0gdGhpcy5zZWxlY3RlZF9ncm91cC5wb3NbMF0sXG4gICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWSAtIHRoaXMuc2VsZWN0ZWRfZ3JvdXAucG9zWzFdXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRheCA9IGRlbHRhWzBdIC8gdGhpcy5kcy5zY2FsZTtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGF5ID0gZGVsdGFbMV0gLyB0aGlzLmRzLnNjYWxlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfZ3JvdXAubW92ZShkZWx0YXgsIGRlbHRheSwgZS5jdHJsS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZF9ncm91cC5fbm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpcnR5X2JnY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRyYWdnaW5nX2NhbnZhcykge1xuICAgICAgICBcdC8vLy9jb25zb2xlLmxvZyhcInBvaW50ZXJldmVudHM6IHByb2Nlc3NNb3VzZU1vdmUgaXMgZHJhZ2dpbmdfY2FudmFzXCIpO1xuICAgICAgICAgICAgdGhpcy5kcy5vZmZzZXRbMF0gKz0gZGVsdGFbMF0gLyB0aGlzLmRzLnNjYWxlO1xuICAgICAgICAgICAgdGhpcy5kcy5vZmZzZXRbMV0gKz0gZGVsdGFbMV0gLyB0aGlzLmRzLnNjYWxlO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eV9iZ2NhbnZhcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoKHRoaXMuYWxsb3dfaW50ZXJhY3Rpb24gfHwgKG5vZGUgJiYgbm9kZS5mbGFncy5hbGxvd19pbnRlcmFjdGlvbikpICYmICF0aGlzLnJlYWRfb25seSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGluZ19ub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3JlbW92ZSBtb3VzZW92ZXIgZmxhZ1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmdyYXBoLl9ub2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmFwaC5fbm9kZXNbaV0ubW91c2VPdmVyICYmIG5vZGUgIT0gdGhpcy5ncmFwaC5fbm9kZXNbaV0gKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vbW91c2UgbGVhdmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5fbm9kZXNbaV0ubW91c2VPdmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVfb3ZlciAmJiB0aGlzLm5vZGVfb3Zlci5vbk1vdXNlTGVhdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZV9vdmVyLm9uTW91c2VMZWF2ZShlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVfb3ZlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vbW91c2Ugb3ZlciBhIG5vZGVcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG5cblx0XHRcdFx0aWYobm9kZS5yZWRyYXdfb25fbW91c2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vdGhpcy5jYW52YXMuc3R5bGUuY3Vyc29yID0gXCJtb3ZlXCI7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLm1vdXNlT3Zlcikge1xuICAgICAgICAgICAgICAgICAgICAvL21vdXNlIGVudGVyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUubW91c2VPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlX292ZXIgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUub25Nb3VzZUVudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLm9uTW91c2VFbnRlcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vaW4gY2FzZSB0aGUgbm9kZSB3YW50cyB0byBkbyBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5vbk1vdXNlTW92ZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm9uTW91c2VNb3ZlKCBlLCBbZS5jYW52YXNYIC0gbm9kZS5wb3NbMF0sIGUuY2FudmFzWSAtIG5vZGUucG9zWzFdXSwgdGhpcyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vaWYgZHJhZ2dpbmcgYSBsaW5rXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGluZ19ub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW5nX291dHB1dCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLl9oaWdobGlnaHRfaW5wdXQgfHwgWzAsIDBdOyAvL3RvIHN0b3JlIHRoZSBvdXRwdXQgb2YgaXNPdmVyTm9kZUlucHV0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vb24gdG9wIG9mIGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc092ZXJOb2RlQm94KG5vZGUsIGUuY2FudmFzWCwgZS5jYW52YXNZKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbW91c2Ugb24gdG9wIG9mIHRoZSBjb3JuZXIgYm94LCBkb24ndCBrbm93IHdoYXQgdG8gZG9cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiBJIGhhdmUgYSBzbG90IGJlbG93IGRlIG1vdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmlzT3Zlck5vZGVJbnB1dCggbm9kZSwgZS5jYW52YXNYLCBlLmNhbnZhc1ksIHBvcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbG90ICE9IC0xICYmIG5vZGUuaW5wdXRzW3Nsb3RdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90X3R5cGUgPSBub2RlLmlucHV0c1tzbG90XS50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIExpdGVHcmFwaC5pc1ZhbGlkQ29ubmVjdGlvbiggdGhpcy5jb25uZWN0aW5nX291dHB1dC50eXBlLCBzbG90X3R5cGUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodF9pbnB1dCA9IHBvcztcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2hpZ2hsaWdodF9pbnB1dF9zbG90ID0gbm9kZS5pbnB1dHNbc2xvdF07IC8vIFhYWCBDSEVDSyBUSElTXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRfaW5wdXQgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2hpZ2hsaWdodF9pbnB1dF9zbG90ID0gbnVsbDsgIC8vIFhYWCBDSEVDSyBUSElTXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1lbHNlIGlmKHRoaXMuY29ubmVjdGluZ19pbnB1dCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLl9oaWdobGlnaHRfb3V0cHV0IHx8IFswLCAwXTsgLy90byBzdG9yZSB0aGUgb3V0cHV0IG9mIGlzT3Zlck5vZGVPdXRwdXRcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9vbiB0b3Agb2Ygb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc092ZXJOb2RlQm94KG5vZGUsIGUuY2FudmFzWCwgZS5jYW52YXNZKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbW91c2Ugb24gdG9wIG9mIHRoZSBjb3JuZXIgYm94LCBkb24ndCBrbm93IHdoYXQgdG8gZG9cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiBJIGhhdmUgYSBzbG90IGJlbG93IGRlIG1vdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmlzT3Zlck5vZGVPdXRwdXQoIG5vZGUsIGUuY2FudmFzWCwgZS5jYW52YXNZLCBwb3MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdCAhPSAtMSAmJiBub2RlLm91dHB1dHNbc2xvdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RfdHlwZSA9IG5vZGUub3V0cHV0c1tzbG90XS50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIExpdGVHcmFwaC5pc1ZhbGlkQ29ubmVjdGlvbiggdGhpcy5jb25uZWN0aW5nX2lucHV0LnR5cGUsIHNsb3RfdHlwZSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0X291dHB1dCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodF9vdXRwdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vU2VhcmNoIGZvciBjb3JuZXJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnNpZGVSZWN0YW5nbGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jYW52YXNYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBvc1swXSArIG5vZGUuc2l6ZVswXSAtIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wb3NbMV0gKyBub2RlLnNpemVbMV0gLSA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmN1cnNvciA9IFwic2UtcmVzaXplXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSBcImNyb3NzaGFpclwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHsgLy9ub3Qgb3ZlciBhIG5vZGVcblxuICAgICAgICAgICAgICAgIC8vc2VhcmNoIGZvciBsaW5rIGNvbm5lY3RvclxuXHRcdFx0XHR2YXIgb3Zlcl9saW5rID0gbnVsbDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZpc2libGVfbGlua3MubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHR2YXIgbGluayA9IHRoaXMudmlzaWJsZV9saW5rc1tpXTtcblx0XHRcdFx0XHR2YXIgY2VudGVyID0gbGluay5fcG9zO1xuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdCFjZW50ZXIgfHxcblx0XHRcdFx0XHRcdGUuY2FudmFzWCA8IGNlbnRlclswXSAtIDQgfHxcblx0XHRcdFx0XHRcdGUuY2FudmFzWCA+IGNlbnRlclswXSArIDQgfHxcblx0XHRcdFx0XHRcdGUuY2FudmFzWSA8IGNlbnRlclsxXSAtIDQgfHxcblx0XHRcdFx0XHRcdGUuY2FudmFzWSA+IGNlbnRlclsxXSArIDRcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvdmVyX2xpbmsgPSBsaW5rO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCBvdmVyX2xpbmsgIT0gdGhpcy5vdmVyX2xpbmtfY2VudGVyIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMub3Zlcl9saW5rX2NlbnRlciA9IG92ZXJfbGluaztcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLmNhbnZhcykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuY3Vyc29yID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fSAvL2VuZFxuXG5cdFx0XHQvL3NlbmQgZXZlbnQgdG8gbm9kZSBpZiBjYXB0dXJpbmcgaW5wdXQgKHVzZWQgd2l0aCB3aWRnZXRzIHRoYXQgYWxsb3cgZHJhZyBvdXRzaWRlIG9mIHRoZSBhcmVhIG9mIHRoZSBub2RlKVxuICAgICAgICAgICAgaWYgKCB0aGlzLm5vZGVfY2FwdHVyaW5nX2lucHV0ICYmIHRoaXMubm9kZV9jYXB0dXJpbmdfaW5wdXQgIT0gbm9kZSAmJiB0aGlzLm5vZGVfY2FwdHVyaW5nX2lucHV0Lm9uTW91c2VNb3ZlICkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZV9jYXB0dXJpbmdfaW5wdXQub25Nb3VzZU1vdmUoZSxbZS5jYW52YXNYIC0gdGhpcy5ub2RlX2NhcHR1cmluZ19pbnB1dC5wb3NbMF0sZS5jYW52YXNZIC0gdGhpcy5ub2RlX2NhcHR1cmluZ19pbnB1dC5wb3NbMV1dLCB0aGlzKTtcbiAgICAgICAgICAgIH1cblxuXHRcdFx0Ly9ub2RlIGJlaW5nIGRyYWdnZWRcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVfZHJhZ2dlZCAmJiAhdGhpcy5saXZlX21vZGUpIHtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcImRyYWdnaW4hXCIsdGhpcy5zZWxlY3RlZF9ub2Rlcyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNlbGVjdGVkX25vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy5zZWxlY3RlZF9ub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgbi5wb3NbMF0gKz0gZGVsdGFbMF0gLyB0aGlzLmRzLnNjYWxlO1xuICAgICAgICAgICAgICAgICAgICBuLnBvc1sxXSArPSBkZWx0YVsxXSAvIHRoaXMuZHMuc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbi5pc19zZWxlY3RlZCkgdGhpcy5wcm9jZXNzTm9kZVNlbGVjdGVkKG4sIGUpOyAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBEb24ndCBjYWxsIHRoZSBmdW5jdGlvbiBpZiB0aGUgYmxvY2sgaXMgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgICAgICAgICAgICAgICAgICogT3RoZXJ3aXNlLCBpdCBjb3VsZCBjYXVzZSB0aGUgYmxvY2sgdG8gYmUgdW5zZWxlY3RlZCB3aGlsZSBkcmFnZ2luZy5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5yZXNpemluZ19ub2RlICYmICF0aGlzLmxpdmVfbW9kZSkge1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBtb3VzZSB0byBub2RlIHNwYWNlXG5cdFx0XHRcdHZhciBkZXNpcmVkX3NpemUgPSBbIGUuY2FudmFzWCAtIHRoaXMucmVzaXppbmdfbm9kZS5wb3NbMF0sIGUuY2FudmFzWSAtIHRoaXMucmVzaXppbmdfbm9kZS5wb3NbMV0gXTtcblx0XHRcdFx0dmFyIG1pbl9zaXplID0gdGhpcy5yZXNpemluZ19ub2RlLmNvbXB1dGVTaXplKCk7XG5cdFx0XHRcdGRlc2lyZWRfc2l6ZVswXSA9IE1hdGgubWF4KCBtaW5fc2l6ZVswXSwgZGVzaXJlZF9zaXplWzBdICk7XG5cdFx0XHRcdGRlc2lyZWRfc2l6ZVsxXSA9IE1hdGgubWF4KCBtaW5fc2l6ZVsxXSwgZGVzaXJlZF9zaXplWzFdICk7XG5cdFx0XHRcdHRoaXMucmVzaXppbmdfbm9kZS5zZXRTaXplKCBkZXNpcmVkX3NpemUgKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmN1cnNvciA9IFwic2UtcmVzaXplXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgbW91c2UgdXAgZXZlbnQgaGFzIHRvIGJlIHByb2Nlc3NlZFxuICAgICAqIEBtZXRob2QgcHJvY2Vzc01vdXNlVXBcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wcm9jZXNzTW91c2VVcCA9IGZ1bmN0aW9uKGUpIHtcblxuXHRcdHZhciBpc19wcmltYXJ5ID0gKCBlLmlzUHJpbWFyeSA9PT0gdW5kZWZpbmVkIHx8IGUuaXNQcmltYXJ5ICk7XG5cbiAgICBcdC8vZWFybHkgZXhpdCBmb3IgZXh0cmEgcG9pbnRlclxuICAgIFx0aWYoIWlzX3ByaW1hcnkpe1xuICAgIFx0XHQvKmUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIFx0ZS5wcmV2ZW50RGVmYXVsdCgpOyovXG4gICAgXHRcdC8vY29uc29sZS5sb2coXCJwb2ludGVyZXZlbnRzOiBwcm9jZXNzTW91c2VVcCBwb2ludGVyTl9zdG9wIFwiK2UucG9pbnRlcklkK1wiIFwiK2UuaXNQcmltYXJ5KTtcbiAgICBcdFx0cmV0dXJuIGZhbHNlO1xuICAgIFx0fVxuICAgIFx0XG4gICAgXHQvL2NvbnNvbGUubG9nKFwicG9pbnRlcmV2ZW50czogcHJvY2Vzc01vdXNlVXAgXCIrZS5wb2ludGVySWQrXCIgXCIrZS5pc1ByaW1hcnkrXCIgOjogXCIrZS5jbGllbnRYK1wiIFwiK2UuY2xpZW50WSk7XG4gICAgXHRcblx0XHRpZiggdGhpcy5zZXRfY2FudmFzX2RpcnR5X29uX21vdXNlX2V2ZW50IClcblx0XHRcdHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZ3JhcGgpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIHdpbmRvdyA9IHRoaXMuZ2V0Q2FudmFzV2luZG93KCk7XG4gICAgICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgTEdyYXBoQ2FudmFzLmFjdGl2ZV9jYW52YXMgPSB0aGlzO1xuXG4gICAgICAgIC8vcmVzdG9yZSB0aGUgbW91c2Vtb3ZlIGV2ZW50IGJhY2sgdG8gdGhlIGNhbnZhc1xuXHRcdGlmKCF0aGlzLm9wdGlvbnMuc2tpcF9ldmVudHMpXG5cdFx0e1xuXHRcdFx0Ly9jb25zb2xlLmxvZyhcInBvaW50ZXJldmVudHM6IHByb2Nlc3NNb3VzZVVwIGFkanVzdEV2ZW50TGlzdGVuZXJcIik7XG5cdFx0XHRMaXRlR3JhcGgucG9pbnRlckxpc3RlbmVyUmVtb3ZlKGRvY3VtZW50LFwibW92ZVwiLCB0aGlzLl9tb3VzZW1vdmVfY2FsbGJhY2ssdHJ1ZSk7XG5cdFx0XHRMaXRlR3JhcGgucG9pbnRlckxpc3RlbmVyQWRkKHRoaXMuY2FudmFzLFwibW92ZVwiLCB0aGlzLl9tb3VzZW1vdmVfY2FsbGJhY2ssdHJ1ZSk7XG5cdFx0XHRMaXRlR3JhcGgucG9pbnRlckxpc3RlbmVyUmVtb3ZlKGRvY3VtZW50LFwidXBcIiwgdGhpcy5fbW91c2V1cF9jYWxsYmFjayx0cnVlKTtcblx0XHR9XG5cbiAgICAgICAgdGhpcy5hZGp1c3RNb3VzZUV2ZW50KGUpO1xuICAgICAgICB2YXIgbm93ID0gTGl0ZUdyYXBoLmdldFRpbWUoKTtcbiAgICAgICAgZS5jbGlja190aW1lID0gbm93IC0gdGhpcy5sYXN0X21vdXNlY2xpY2s7XG4gICAgICAgIHRoaXMubGFzdF9tb3VzZV9kcmFnZ2luZyA9IGZhbHNlO1xuXHRcdHRoaXMubGFzdF9jbGlja19wb3NpdGlvbiA9IG51bGw7XG5cblx0XHRpZih0aGlzLmJsb2NrX2NsaWNrKVxuXHRcdHtcblx0XHRcdC8vY29uc29sZS5sb2coXCJwb2ludGVyZXZlbnRzOiBwcm9jZXNzTW91c2VVcCBibG9ja19jbGlja3NcIik7XG5cdFx0XHR0aGlzLmJsb2NrX2NsaWNrID0gZmFsc2U7IC8vdXNlZCB0byBhdm9pZCBzZW5kaW5nIHR3aWNlIGEgY2xpY2sgaW4gYSBpbW1lZGlhdGUgYnV0dG9uXG5cdFx0fVxuXG5cdFx0Ly9jb25zb2xlLmxvZyhcInBvaW50ZXJldmVudHM6IHByb2Nlc3NNb3VzZVVwIHdoaWNoOiBcIitlLndoaWNoKTtcblx0XHRcbiAgICAgICAgaWYgKGUud2hpY2ggPT0gMSkge1xuXG5cdFx0XHRpZiggdGhpcy5ub2RlX3dpZGdldCApXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMucHJvY2Vzc05vZGVXaWRnZXRzKCB0aGlzLm5vZGVfd2lkZ2V0WzBdLCB0aGlzLmdyYXBoX21vdXNlLCBlICk7XG5cdFx0XHR9XG5cbiAgICAgICAgICAgIC8vbGVmdCBidXR0b25cbiAgICAgICAgICAgIHRoaXMubm9kZV93aWRnZXQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZF9ncm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBkaWZmeCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfZ3JvdXAucG9zWzBdIC1cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZCh0aGlzLnNlbGVjdGVkX2dyb3VwLnBvc1swXSk7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmZ5ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9ncm91cC5wb3NbMV0gLVxuICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHRoaXMuc2VsZWN0ZWRfZ3JvdXAucG9zWzFdKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2dyb3VwLm1vdmUoZGlmZngsIGRpZmZ5LCBlLmN0cmxLZXkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfZ3JvdXAucG9zWzBdID0gTWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9ncm91cC5wb3NbMF1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfZ3JvdXAucG9zWzFdID0gTWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF9ncm91cC5wb3NbMV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkX2dyb3VwLl9ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2dyb3VwID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfZ3JvdXBfcmVzaXppbmcgPSBmYWxzZTtcblxuXHRcdFx0dmFyIG5vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVPblBvcyhcblx0XHRcdFx0XHRcdFx0ZS5jYW52YXNYLFxuXHRcdFx0XHRcdFx0XHRlLmNhbnZhc1ksXG5cdFx0XHRcdFx0XHRcdHRoaXMudmlzaWJsZV9ub2Rlc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFxuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ncmFwaC5fbm9kZXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlX2JvdW5kaW5nID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vY29tcHV0ZSBib3VuZGluZyBhbmQgZmxpcCBpZiBsZWZ0IHRvIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHZhciB3ID0gTWF0aC5hYnModGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbMl0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IE1hdGguYWJzKHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0eCA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVsyXSA8IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzBdIC0gd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydHkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbM10gPCAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVsxXSAtIGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzFdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVswXSA9IHN0YXJ0eDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbMV0gPSBzdGFydHk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzJdID0gdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbM10gPSBoO1xuXG5cdFx0XHRcdFx0Ly8gdGVzdCBkcmFnZ2luZyByZWN0IHNpemUsIGlmIG1pbmltdW4gc2ltdWxhdGUgYSBjbGlja1xuXHRcdFx0XHRcdGlmICghbm9kZSB8fCAodyA+IDEwICYmIGggPiAxMCApKXtcblx0XHRcdFx0XHRcdC8vdGVzdCBhZ2FpbnN0IGFsbCBub2RlcyAobm90IHZpc2libGUgYmVjYXVzZSB0aGUgcmVjdGFuZ2xlIG1heWJlIHN0YXJ0IG91dHNpZGVcblx0XHRcdFx0XHRcdHZhciB0b19zZWxlY3QgPSBbXTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG5vZGVYID0gbm9kZXNbaV07XG5cdFx0XHRcdFx0XHRcdG5vZGVYLmdldEJvdW5kaW5nKG5vZGVfYm91bmRpbmcpO1xuXHRcdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdFx0IW92ZXJsYXBCb3VuZGluZyhcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlLFxuXHRcdFx0XHRcdFx0XHRcdFx0bm9kZV9ib3VuZGluZ1xuXHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdH0gLy9vdXQgb2YgdGhlIHZpc2libGUgYXJlYVxuXHRcdFx0XHRcdFx0XHR0b19zZWxlY3QucHVzaChub2RlWCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodG9fc2VsZWN0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNlbGVjdE5vZGVzKHRvX3NlbGVjdCxlLnNoaWZ0S2V5KTsgLy8gYWRkIHRvIHNlbGVjdGlvbiB3aXRoIHNoaWZ0XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHQvLyB3aWxsIHNlbGVjdCBvZiB1cGRhdGUgc2VsZWN0aW9uXG5cdFx0XHRcdFx0XHR0aGlzLnNlbGVjdE5vZGVzKFtub2RlXSxlLnNoaWZ0S2V5fHxlLmN0cmxLZXkpOyAvLyBhZGQgdG8gc2VsZWN0aW9uIGFkZCB0byBzZWxlY3Rpb24gd2l0aCBjdHJsS2V5IG9yIHNoaWZ0S2V5XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY29ubmVjdGluZ19ub2RlKSB7XG4gICAgICAgICAgICAgICAgLy9kcmFnZ2luZyBhIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9iZ2NhbnZhcyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29ubkluT3JPdXQgPSB0aGlzLmNvbm5lY3Rpbmdfb3V0cHV0IHx8IHRoaXMuY29ubmVjdGluZ19pbnB1dDtcbiAgICAgICAgICAgICAgICB2YXIgY29ublR5cGUgPSBjb25uSW5Pck91dC50eXBlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vbm9kZSBiZWxvdyBtb3VzZVxuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvKiBubyBuZWVkIHRvIGNvbmRpdGlvbiBvbiBldmVudCB0eXBlLi4ganVzdCBhbm90aGVyIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ublR5cGUgPT0gTGl0ZUdyYXBoLkVWRU5UICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzT3Zlck5vZGVCb3gobm9kZSwgZS5jYW52YXNYLCBlLmNhbnZhc1kpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpbmdfbm9kZS5jb25uZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19zbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLkVWRU5UXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7Ki9cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zbG90IGJlbG93IG1vdXNlPyBjb25uZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpbmdfb3V0cHV0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IHRoaXMuaXNPdmVyTm9kZUlucHV0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3QgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX25vZGUuY29ubmVjdCh0aGlzLmNvbm5lY3Rpbmdfc2xvdCwgbm9kZSwgc2xvdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ub3Qgb24gdG9wIG9mIGFuIGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvb2sgZm9yIGEgZ29vZCBzbG90XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19ub2RlLmNvbm5lY3RCeVR5cGUodGhpcy5jb25uZWN0aW5nX3Nsb3Qsbm9kZSxjb25uVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2UgaWYgKHRoaXMuY29ubmVjdGluZ19pbnB1dCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmlzT3Zlck5vZGVPdXRwdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FudmFzWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jYW52YXNZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbG90ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29ubmVjdChzbG90LCB0aGlzLmNvbm5lY3Rpbmdfbm9kZSwgdGhpcy5jb25uZWN0aW5nX3Nsb3QpOyAvLyB0aGlzIGlzIGludmVydGVkIGhhcyBvdXRwdXQtaW5wdXQgbmF0dXJlIGxpa2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25vdCBvbiB0b3Agb2YgYW4gaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9vayBmb3IgYSBnb29kIHNsb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX25vZGUuY29ubmVjdEJ5VHlwZU91dHB1dCh0aGlzLmNvbm5lY3Rpbmdfc2xvdCxub2RlLGNvbm5UeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgbWVudSB3aGVuIHJlbGVhc2luZyBsaW5rIGluIGVtcHR5IHNwYWNlXG4gICAgICAgICAgICAgICAgXHRpZiAoTGl0ZUdyYXBoLnJlbGVhc2VfbGlua19vbl9lbXB0eV9zaG93c19tZW51KXtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZS5zaGlmdEtleSAmJiB0aGlzLmFsbG93X3NlYXJjaGJveCl7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29ubmVjdGluZ19vdXRwdXQpe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93U2VhcmNoQm94KGUse25vZGVfZnJvbTogdGhpcy5jb25uZWN0aW5nX25vZGUsIHNsb3RfZnJvbTogdGhpcy5jb25uZWN0aW5nX291dHB1dCwgdHlwZV9maWx0ZXJfaW46IHRoaXMuY29ubmVjdGluZ19vdXRwdXQudHlwZX0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSBpZih0aGlzLmNvbm5lY3RpbmdfaW5wdXQpe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93U2VhcmNoQm94KGUse25vZGVfdG86IHRoaXMuY29ubmVjdGluZ19ub2RlLCBzbG90X2Zyb206IHRoaXMuY29ubmVjdGluZ19pbnB1dCwgdHlwZV9maWx0ZXJfb3V0OiB0aGlzLmNvbm5lY3RpbmdfaW5wdXQudHlwZX0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29ubmVjdGluZ19vdXRwdXQpe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93Q29ubmVjdGlvbk1lbnUoe25vZGVGcm9tOiB0aGlzLmNvbm5lY3Rpbmdfbm9kZSwgc2xvdEZyb206IHRoaXMuY29ubmVjdGluZ19vdXRwdXQsIGU6IGV9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2UgaWYodGhpcy5jb25uZWN0aW5nX2lucHV0KXtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Nvbm5lY3Rpb25NZW51KHtub2RlVG86IHRoaXMuY29ubmVjdGluZ19ub2RlLCBzbG90VG86IHRoaXMuY29ubmVjdGluZ19pbnB1dCwgZTogZX0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFx0fVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19vdXRwdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19pbnB1dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX3BvcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX25vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19zbG90ID0gLTE7XG4gICAgICAgICAgICB9IC8vbm90IGRyYWdnaW5nIGNvbm5lY3Rpb25cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXppbmdfbm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2JnY2FudmFzID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5ncmFwaC5hZnRlckNoYW5nZSh0aGlzLnJlc2l6aW5nX25vZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXppbmdfbm9kZSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubm9kZV9kcmFnZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy9ub2RlIGJlaW5nIGRyYWdnZWQ/XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVfZHJhZ2dlZDtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgZS5jbGlja190aW1lIDwgMzAwICYmXG4gICAgICAgICAgICAgICAgICAgIGlzSW5zaWRlUmVjdGFuZ2xlKCBlLmNhbnZhc1gsIGUuY2FudmFzWSwgbm9kZS5wb3NbMF0sIG5vZGUucG9zWzFdIC0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hULCBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQsIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY29sbGFwc2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9iZ2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlX2RyYWdnZWQucG9zWzBdID0gTWF0aC5yb3VuZCh0aGlzLm5vZGVfZHJhZ2dlZC5wb3NbMF0pO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZV9kcmFnZ2VkLnBvc1sxXSA9IE1hdGgucm91bmQodGhpcy5ub2RlX2RyYWdnZWQucG9zWzFdKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmFwaC5jb25maWcuYWxpZ25fdG9fZ3JpZCB8fCB0aGlzLmFsaWduX3RvX2dyaWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZV9kcmFnZ2VkLmFsaWduVG9HcmlkKCk7XG4gICAgICAgICAgICAgICAgfVxuXHRcdFx0XHRpZiggdGhpcy5vbk5vZGVNb3ZlZCApXG5cdFx0XHRcdFx0dGhpcy5vbk5vZGVNb3ZlZCggdGhpcy5ub2RlX2RyYWdnZWQgKTtcblx0XHRcdFx0dGhpcy5ncmFwaC5hZnRlckNoYW5nZSh0aGlzLm5vZGVfZHJhZ2dlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlX2RyYWdnZWQgPSBudWxsO1xuICAgICAgICAgICAgfSAvL25vIG5vZGUgYmVpbmcgZHJhZ2dlZFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9nZXQgbm9kZSBvdmVyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVPblBvcyhcbiAgICAgICAgICAgICAgICAgICAgZS5jYW52YXNYLFxuICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1ksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZV9ub2Rlc1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUgJiYgZS5jbGlja190aW1lIDwgMzAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzZWxlY3RBbGxOb2RlcygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX2NhbnZhcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZV9vdmVyICYmIHRoaXMubm9kZV9vdmVyLm9uTW91c2VVcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVfb3Zlci5vbk1vdXNlVXAoIGUsIFsgZS5jYW52YXNYIC0gdGhpcy5ub2RlX292ZXIucG9zWzBdLCBlLmNhbnZhc1kgLSB0aGlzLm5vZGVfb3Zlci5wb3NbMV0gXSwgdGhpcyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZV9jYXB0dXJpbmdfaW5wdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlX2NhcHR1cmluZ19pbnB1dC5vbk1vdXNlVXBcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlX2NhcHR1cmluZ19pbnB1dC5vbk1vdXNlVXAoZSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5jYW52YXNYIC0gdGhpcy5ub2RlX2NhcHR1cmluZ19pbnB1dC5wb3NbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmNhbnZhc1kgLSB0aGlzLm5vZGVfY2FwdHVyaW5nX2lucHV0LnBvc1sxXVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PSAyKSB7XG4gICAgICAgICAgICAvL21pZGRsZSBidXR0b25cbiAgICAgICAgICAgIC8vdHJhY2UoXCJtaWRkbGVcIik7XG4gICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nX2NhbnZhcyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT0gMykge1xuICAgICAgICAgICAgLy9yaWdodCBidXR0b25cbiAgICAgICAgICAgIC8vdHJhY2UoXCJyaWdodFwiKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfY2FudmFzID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuXHRcdGlmKCh0aGlzLmRpcnR5X2NhbnZhcyB8fCB0aGlzLmRpcnR5X2JnY2FudmFzKSAmJiB0aGlzLnJlbmRlcmluZ190aW1lcl9pZCA9PSBudWxsKVxuXHRcdFx0dGhpcy5kcmF3KCk7XG5cdFx0Ki9cblxuXHQgIFx0aWYgKGlzX3ByaW1hcnkpXG5cdFx0e1xuXHRcdFx0dGhpcy5wb2ludGVyX2lzX2Rvd24gPSBmYWxzZTtcblx0XHRcdHRoaXMucG9pbnRlcl9pc19kb3VibGUgPSBmYWxzZTtcblx0XHR9XG5cdCAgXG4gICAgICAgIHRoaXMuZ3JhcGguY2hhbmdlKCk7XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyhcInBvaW50ZXJldmVudHM6IHByb2Nlc3NNb3VzZVVwIHN0b3BQcm9wYWdhdGlvblwiKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgbW91c2Ugd2hlZWwgZXZlbnQgaGFzIHRvIGJlIHByb2Nlc3NlZFxuICAgICAqIEBtZXRob2QgcHJvY2Vzc01vdXNlV2hlZWxcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wcm9jZXNzTW91c2VXaGVlbCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoIHx8ICF0aGlzLmFsbG93X2RyYWdjYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWx0YSA9IGUud2hlZWxEZWx0YVkgIT0gbnVsbCA/IGUud2hlZWxEZWx0YVkgOiBlLmRldGFpbCAqIC02MDtcblxuICAgICAgICB0aGlzLmFkanVzdE1vdXNlRXZlbnQoZSk7XG5cblx0XHR2YXIgeCA9IGUuY2xpZW50WDtcblx0XHR2YXIgeSA9IGUuY2xpZW50WTtcblx0XHR2YXIgaXNfaW5zaWRlID0gIXRoaXMudmlld3BvcnQgfHwgKCB0aGlzLnZpZXdwb3J0ICYmIHggPj0gdGhpcy52aWV3cG9ydFswXSAmJiB4IDwgKHRoaXMudmlld3BvcnRbMF0gKyB0aGlzLnZpZXdwb3J0WzJdKSAmJiB5ID49IHRoaXMudmlld3BvcnRbMV0gJiYgeSA8ICh0aGlzLnZpZXdwb3J0WzFdICsgdGhpcy52aWV3cG9ydFszXSkgKTtcblx0XHRpZighaXNfaW5zaWRlKVxuXHRcdFx0cmV0dXJuO1xuXG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZHMuc2NhbGU7XG5cbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgc2NhbGUgKj0gMS4xO1xuICAgICAgICB9IGVsc2UgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgc2NhbGUgKj0gMSAvIDEuMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGhpcy5zZXRab29tKCBzY2FsZSwgWyBlLmNsaWVudFgsIGUuY2xpZW50WSBdICk7XG4gICAgICAgIHRoaXMuZHMuY2hhbmdlU2NhbGUoc2NhbGUsIFtlLmNsaWVudFgsIGUuY2xpZW50WV0pO1xuXG4gICAgICAgIHRoaXMuZ3JhcGguY2hhbmdlKCk7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHByZXZlbnQgZGVmYXVsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRydWUgaWYgYSBwb3NpdGlvbiAoaW4gZ3JhcGggc3BhY2UpIGlzIG9uIHRvcCBvZiBhIG5vZGUgbGl0dGxlIGNvcm5lciBib3hcbiAgICAgKiBAbWV0aG9kIGlzT3Zlck5vZGVCb3hcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5pc092ZXJOb2RlQm94ID0gZnVuY3Rpb24obm9kZSwgY2FudmFzeCwgY2FudmFzeSkge1xuICAgICAgICB2YXIgdGl0bGVfaGVpZ2h0ID0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBpc0luc2lkZVJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICBjYW52YXN4LFxuICAgICAgICAgICAgICAgIGNhbnZhc3ksXG4gICAgICAgICAgICAgICAgbm9kZS5wb3NbMF0gKyAyLFxuICAgICAgICAgICAgICAgIG5vZGUucG9zWzFdICsgMiAtIHRpdGxlX2hlaWdodCxcbiAgICAgICAgICAgICAgICB0aXRsZV9oZWlnaHQgLSA0LFxuICAgICAgICAgICAgICAgIHRpdGxlX2hlaWdodCAtIDRcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIElOREVYIGlmIGEgcG9zaXRpb24gKGluIGdyYXBoIHNwYWNlKSBpcyBvbiB0b3Agb2YgYSBub2RlIGlucHV0IHNsb3RcbiAgICAgKiBAbWV0aG9kIGlzT3Zlck5vZGVJbnB1dFxuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmlzT3Zlck5vZGVJbnB1dCA9IGZ1bmN0aW9uKFxuICAgICAgICBub2RlLFxuICAgICAgICBjYW52YXN4LFxuICAgICAgICBjYW52YXN5LFxuICAgICAgICBzbG90X3Bvc1xuICAgICkge1xuICAgICAgICBpZiAobm9kZS5pbnB1dHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5pbnB1dHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gbm9kZS5pbnB1dHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtfcG9zID0gbm9kZS5nZXRDb25uZWN0aW9uUG9zKHRydWUsIGkpO1xuICAgICAgICAgICAgICAgIHZhciBpc19pbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzX2luc2lkZSA9IGlzSW5zaWRlUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc3ksXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX3Bvc1swXSAtIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX3Bvc1sxXSAtIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAyMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlzX2luc2lkZSA9IGlzSW5zaWRlUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc3ksXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX3Bvc1swXSAtIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMV0gLSA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgNDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNfaW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbG90X3Bvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdF9wb3NbMF0gPSBsaW5rX3Bvc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RfcG9zWzFdID0gbGlua19wb3NbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIElOREVYIGlmIGEgcG9zaXRpb24gKGluIGdyYXBoIHNwYWNlKSBpcyBvbiB0b3Agb2YgYSBub2RlIG91dHB1dCBzbG90XG4gICAgICogQG1ldGhvZCBpc092ZXJOb2RlT3VwdXRcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5pc092ZXJOb2RlT3V0cHV0ID0gZnVuY3Rpb24oXG4gICAgICAgIG5vZGUsXG4gICAgICAgIGNhbnZhc3gsXG4gICAgICAgIGNhbnZhc3ksXG4gICAgICAgIHNsb3RfcG9zXG4gICAgKSB7XG4gICAgICAgIGlmIChub2RlLm91dHB1dHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5vdXRwdXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBub2RlLm91dHB1dHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtfcG9zID0gbm9kZS5nZXRDb25uZWN0aW9uUG9zKGZhbHNlLCBpKTtcbiAgICAgICAgICAgICAgICB2YXIgaXNfaW5zaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICBpc19pbnNpZGUgPSBpc0luc2lkZVJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc3gsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMF0gLSA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMV0gLSAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMjBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpc19pbnNpZGUgPSBpc0luc2lkZVJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc3gsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19wb3NbMF0gLSAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfcG9zWzFdIC0gNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzX2luc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdF9wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RfcG9zWzBdID0gbGlua19wb3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90X3Bvc1sxXSA9IGxpbmtfcG9zWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHByb2Nlc3MgYSBrZXkgZXZlbnRcbiAgICAgKiBAbWV0aG9kIHByb2Nlc3NLZXlcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wcm9jZXNzS2V5ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBibG9ja19kZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIC8vY29uc29sZS5sb2coZSk7IC8vZGVidWdcblxuICAgICAgICBpZiAoZS50YXJnZXQubG9jYWxOYW1lID09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PSBcImtleWRvd25cIikge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAzMikge1xuICAgICAgICAgICAgICAgIC8vc3BhY2VcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYmxvY2tfZGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gMjcpIHtcbiAgICAgICAgICAgICAgICAvL2VzY1xuICAgICAgICAgICAgICAgIGlmKHRoaXMubm9kZV9wYW5lbCkgdGhpcy5ub2RlX3BhbmVsLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zX3BhbmVsKSB0aGlzLm9wdGlvbnNfcGFuZWwuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBibG9ja19kZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9zZWxlY3QgYWxsIENvbnRyb2wgQVxuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSA2NSAmJiBlLmN0cmxLZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdE5vZGVzKCk7XG4gICAgICAgICAgICAgICAgYmxvY2tfZGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgoZS5rZXlDb2RlID09PSA2NykgJiYgKGUubWV0YUtleSB8fCBlLmN0cmxLZXkpICYmICFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgLy9jb3B5XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRfbm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3B5VG9DbGlwYm9hcmQoKTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tfZGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGUua2V5Q29kZSA9PT0gODYpICYmIChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5KSkge1xuICAgICAgICAgICAgICAgIC8vcGFzdGVcbiAgICAgICAgICAgICAgICB0aGlzLnBhc3RlRnJvbUNsaXBib2FyZChlLnNoaWZ0S2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9kZWxldGUgb3IgYmFja3NwYWNlXG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDQ2IHx8IGUua2V5Q29kZSA9PSA4KSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5sb2NhbE5hbWUgIT0gXCJpbnB1dFwiICYmXG4gICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0LmxvY2FsTmFtZSAhPSBcInRleHRhcmVhXCJcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGVTZWxlY3RlZE5vZGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrX2RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9jb2xsYXBzZVxuICAgICAgICAgICAgLy8uLi5cblxuICAgICAgICAgICAgLy9UT0RPXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZF9ub2Rlcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zZWxlY3RlZF9ub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZF9ub2Rlc1tpXS5vbktleURvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfbm9kZXNbaV0ub25LZXlEb3duKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PSBcImtleXVwXCIpIHtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gMzIpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGFjZVxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfY2FudmFzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkX25vZGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNlbGVjdGVkX25vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkX25vZGVzW2ldLm9uS2V5VXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfbm9kZXNbaV0ub25LZXlVcChlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JhcGguY2hhbmdlKCk7XG5cbiAgICAgICAgaWYgKGJsb2NrX2RlZmF1bHQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5jb3B5VG9DbGlwYm9hcmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNsaXBib2FyZF9pbmZvID0ge1xuICAgICAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICAgICAgbGlua3M6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBzZWxlY3RlZF9ub2Rlc19hcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc2VsZWN0ZWRfbm9kZXMpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zZWxlY3RlZF9ub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChub2RlLmNsb25hYmxlID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIG5vZGUuX3JlbGF0aXZlX2lkID0gaW5kZXg7XG4gICAgICAgICAgICBzZWxlY3RlZF9ub2Rlc19hcnJheS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRfbm9kZXNfYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gc2VsZWN0ZWRfbm9kZXNfYXJyYXlbaV07XG4gICAgICAgICAgICBpZihub2RlLmNsb25hYmxlID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBjbG9uZWQgPSBub2RlLmNsb25lKCk7XG4gICAgICAgICAgICBpZighY2xvbmVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIm5vZGUgdHlwZSBub3QgZm91bmQ6IFwiICsgbm9kZS50eXBlICk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGlwYm9hcmRfaW5mby5ub2Rlcy5wdXNoKGNsb25lZC5zZXJpYWxpemUoKSk7XG4gICAgICAgICAgICBpZiAobm9kZS5pbnB1dHMgJiYgbm9kZS5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLmlucHV0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBub2RlLmlucHV0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnB1dCB8fCBpbnB1dC5saW5rID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5rX2luZm8gPSB0aGlzLmdyYXBoLmxpbmtzW2lucHV0LmxpbmtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxpbmtfaW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldF9ub2RlID0gdGhpcy5ncmFwaC5nZXROb2RlQnlJZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaW5mby5vcmlnaW5faWRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRfbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xpcGJvYXJkX2luZm8ubGlua3MucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRfbm9kZS5fcmVsYXRpdmVfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8ub3JpZ2luX3Nsb3QsIC8vaixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuX3JlbGF0aXZlX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLnRhcmdldF9zbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X25vZGUuaWRcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgICAgXCJsaXRlZ3JhcGhlZGl0b3JfY2xpcGJvYXJkXCIsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShjbGlwYm9hcmRfaW5mbylcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wYXN0ZUZyb21DbGlwYm9hcmQgPSBmdW5jdGlvbihpc0Nvbm5lY3RVbnNlbGVjdGVkID0gZmFsc2UpIHtcbiAgICAgICAgLy8gaWYgY3RybCArIHNoaWZ0ICsgdiBpcyBvZmYsIHJldHVybiB3aGVuIGlzQ29ubmVjdFVuc2VsZWN0ZWQgaXMgdHJ1ZSAoc2hpZnQgaXMgcHJlc3NlZCkgdG8gbWFpbnRhaW4gb2xkIGJlaGF2aW9yXG4gICAgICAgIGlmICghTGl0ZUdyYXBoLmN0cmxfc2hpZnRfdl9wYXN0ZV9jb25uZWN0X3Vuc2VsZWN0ZWRfb3V0cHV0cyAmJiBpc0Nvbm5lY3RVbnNlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImxpdGVncmFwaGVkaXRvcl9jbGlwYm9hcmRcIik7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cblx0XHR0aGlzLmdyYXBoLmJlZm9yZUNoYW5nZSgpO1xuXG4gICAgICAgIC8vY3JlYXRlIG5vZGVzXG4gICAgICAgIHZhciBjbGlwYm9hcmRfaW5mbyA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0b3AtbGVmdCBub2RlLCBjb3VsZCB3b3JrIHdpdGhvdXQgdGhpcyBwcm9jZXNzaW5nIGJ1dCB1c2luZyBkaWZmIHdpdGggbGFzdCBub2RlIHBvcyA6OiBjbGlwYm9hcmRfaW5mby5ub2Rlc1tjbGlwYm9hcmRfaW5mby5ub2Rlcy5sZW5ndGgtMV0ucG9zXG4gICAgICAgIHZhciBwb3NNaW4gPSBmYWxzZTtcbiAgICAgICAgdmFyIHBvc01pbkluZGV4ZXMgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwYm9hcmRfaW5mby5ub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHBvc01pbil7XG4gICAgICAgICAgICAgICAgaWYocG9zTWluWzBdPmNsaXBib2FyZF9pbmZvLm5vZGVzW2ldLnBvc1swXSl7XG4gICAgICAgICAgICAgICAgICAgIHBvc01pblswXSA9IGNsaXBib2FyZF9pbmZvLm5vZGVzW2ldLnBvc1swXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zTWluSW5kZXhlc1swXSA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKHBvc01pblsxXT5jbGlwYm9hcmRfaW5mby5ub2Rlc1tpXS5wb3NbMV0pe1xuICAgICAgICAgICAgICAgICAgICBwb3NNaW5bMV0gPSBjbGlwYm9hcmRfaW5mby5ub2Rlc1tpXS5wb3NbMV07XG4gICAgICAgICAgICAgICAgICAgIHBvc01pbkluZGV4ZXNbMV0gPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgcG9zTWluID0gW2NsaXBib2FyZF9pbmZvLm5vZGVzW2ldLnBvc1swXSwgY2xpcGJvYXJkX2luZm8ubm9kZXNbaV0ucG9zWzFdXTtcbiAgICAgICAgICAgICAgICBwb3NNaW5JbmRleGVzID0gW2ksIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBib2FyZF9pbmZvLm5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZV9kYXRhID0gY2xpcGJvYXJkX2luZm8ubm9kZXNbaV07XG4gICAgICAgICAgICB2YXIgbm9kZSA9IExpdGVHcmFwaC5jcmVhdGVOb2RlKG5vZGVfZGF0YS50eXBlKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jb25maWd1cmUobm9kZV9kYXRhKTtcbiAgICAgICAgXG5cdFx0XHRcdC8vcGFzdGUgaW4gbGFzdCBrbm93biBtb3VzZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgIG5vZGUucG9zWzBdICs9IHRoaXMuZ3JhcGhfbW91c2VbMF0gLSBwb3NNaW5bMF07IC8vKz0gNTtcbiAgICAgICAgICAgICAgICBub2RlLnBvc1sxXSArPSB0aGlzLmdyYXBoX21vdXNlWzFdIC0gcG9zTWluWzFdOyAvLys9IDU7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLmFkZChub2RlLHtkb1Byb2Nlc3NDaGFuZ2U6ZmFsc2V9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9jcmVhdGUgbGlua3NcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwYm9hcmRfaW5mby5saW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGxpbmtfaW5mbyA9IGNsaXBib2FyZF9pbmZvLmxpbmtzW2ldO1xuICAgICAgICAgICAgdmFyIG9yaWdpbl9ub2RlO1xuICAgICAgICAgICAgdmFyIG9yaWdpbl9ub2RlX3JlbGF0aXZlX2lkID0gbGlua19pbmZvWzBdO1xuICAgICAgICAgICAgaWYgKG9yaWdpbl9ub2RlX3JlbGF0aXZlX2lkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5fbm9kZSA9IG5vZGVzW29yaWdpbl9ub2RlX3JlbGF0aXZlX2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTGl0ZUdyYXBoLmN0cmxfc2hpZnRfdl9wYXN0ZV9jb25uZWN0X3Vuc2VsZWN0ZWRfb3V0cHV0cyAmJiBpc0Nvbm5lY3RVbnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbl9ub2RlX2lkID0gbGlua19pbmZvWzRdO1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5fbm9kZV9pZCkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5fbm9kZSA9IHRoaXMuZ3JhcGguZ2V0Tm9kZUJ5SWQob3JpZ2luX25vZGVfaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0YXJnZXRfbm9kZSA9IG5vZGVzW2xpbmtfaW5mb1syXV07XG5cdFx0XHRpZiggb3JpZ2luX25vZGUgJiYgdGFyZ2V0X25vZGUgKVxuXHQgICAgICAgICAgICBvcmlnaW5fbm9kZS5jb25uZWN0KGxpbmtfaW5mb1sxXSwgdGFyZ2V0X25vZGUsIGxpbmtfaW5mb1szXSk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGNvbnNvbGUud2FybihcIldhcm5pbmcsIG5vZGVzIG1pc3Npbmcgb24gcGFzdGluZ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VsZWN0Tm9kZXMobm9kZXMpO1xuXG5cdFx0dGhpcy5ncmFwaC5hZnRlckNoYW5nZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBwcm9jZXNzIGEgaXRlbSBkcm9wIGV2ZW50IG9uIHRvcCB0aGUgY2FudmFzXG4gICAgICogQG1ldGhvZCBwcm9jZXNzRHJvcFxuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnByb2Nlc3NEcm9wID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuYWRqdXN0TW91c2VFdmVudChlKTtcblx0XHR2YXIgeCA9IGUuY2xpZW50WDtcblx0XHR2YXIgeSA9IGUuY2xpZW50WTtcblx0XHR2YXIgaXNfaW5zaWRlID0gIXRoaXMudmlld3BvcnQgfHwgKCB0aGlzLnZpZXdwb3J0ICYmIHggPj0gdGhpcy52aWV3cG9ydFswXSAmJiB4IDwgKHRoaXMudmlld3BvcnRbMF0gKyB0aGlzLnZpZXdwb3J0WzJdKSAmJiB5ID49IHRoaXMudmlld3BvcnRbMV0gJiYgeSA8ICh0aGlzLnZpZXdwb3J0WzFdICsgdGhpcy52aWV3cG9ydFszXSkgKTtcblx0XHRpZighaXNfaW5zaWRlKXtcblx0XHRcdHJldHVybjtcblx0XHRcdC8vIC0tLSBCUkVBSyAtLS1cblx0XHR9XG5cbiAgICAgICAgdmFyIHBvcyA9IFtlLmNhbnZhc1gsIGUuY2FudmFzWV07XG5cblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ3JhcGggPyB0aGlzLmdyYXBoLmdldE5vZGVPblBvcyhwb3NbMF0sIHBvc1sxXSkgOiBudWxsO1xuXG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgdmFyIHIgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMub25Ecm9wSXRlbSkge1xuICAgICAgICAgICAgICAgIHIgPSB0aGlzLm9uRHJvcEl0ZW0oZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0Ryb3BJdGVtKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUub25Ecm9wRmlsZSB8fCBub2RlLm9uRHJvcERhdGEpIHtcbiAgICAgICAgICAgIHZhciBmaWxlcyA9IGUuZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgICAgICAgICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGUgPSBlLmRhdGFUcmFuc2Zlci5maWxlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gZmlsZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ID0gTEdyYXBoQ2FudmFzLmdldEZpbGVFeHRlbnNpb24oZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGZpbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm9uRHJvcEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUub25Ecm9wRmlsZShmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm9uRHJvcERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcHJlcGFyZSByZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm9uRHJvcERhdGEoZGF0YSwgZmlsZW5hbWUsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWFkIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZmlsZS50eXBlLnNwbGl0KFwiL1wiKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IFwidGV4dFwiIHx8IHR5cGUgPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwiaW1hZ2VcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5vbkRyb3BJdGVtKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5vbkRyb3BJdGVtKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub25Ecm9wSXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25Ecm9wSXRlbShldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8vY2FsbGVkIGlmIHRoZSBncmFwaCBkb2Vzbid0IGhhdmUgYSBkZWZhdWx0IGRyb3AgaXRlbSBiZWhhdmlvdXJcbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmNoZWNrRHJvcEl0ZW0gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlci5maWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmaWxlID0gZS5kYXRhVHJhbnNmZXIuZmlsZXNbMF07XG4gICAgICAgICAgICB2YXIgZXh0ID0gTEdyYXBoQ2FudmFzLmdldEZpbGVFeHRlbnNpb24oZmlsZS5uYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIG5vZGV0eXBlID0gTGl0ZUdyYXBoLm5vZGVfdHlwZXNfYnlfZmlsZV9leHRlbnNpb25bZXh0XTtcbiAgICAgICAgICAgIGlmIChub2RldHlwZSkge1xuXHRcdFx0XHR0aGlzLmdyYXBoLmJlZm9yZUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUobm9kZXR5cGUudHlwZSk7XG4gICAgICAgICAgICAgICAgbm9kZS5wb3MgPSBbZS5jYW52YXNYLCBlLmNhbnZhc1ldO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGguYWRkKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm9uRHJvcEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5vbkRyb3BGaWxlKGZpbGUpO1xuICAgICAgICAgICAgICAgIH1cblx0XHRcdFx0dGhpcy5ncmFwaC5hZnRlckNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUucHJvY2Vzc05vZGVEYmxDbGlja2VkID0gZnVuY3Rpb24obikge1xuICAgICAgICBpZiAodGhpcy5vblNob3dOb2RlUGFuZWwpIHtcbiAgICAgICAgICAgIHRoaXMub25TaG93Tm9kZVBhbmVsKG4pO1xuICAgICAgICB9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRoaXMuc2hvd1Nob3dOb2RlUGFuZWwobik7XG5cdFx0fVxuXG4gICAgICAgIGlmICh0aGlzLm9uTm9kZURibENsaWNrZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25Ob2RlRGJsQ2xpY2tlZChuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0RGlydHkodHJ1ZSk7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUucHJvY2Vzc05vZGVTZWxlY3RlZCA9IGZ1bmN0aW9uKG5vZGUsIGUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3ROb2RlKG5vZGUsIGUgJiYgKGUuc2hpZnRLZXkgfHwgZS5jdHJsS2V5IHx8IHRoaXMubXVsdGlfc2VsZWN0KSk7XG4gICAgICAgIGlmICh0aGlzLm9uTm9kZVNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uTm9kZVNlbGVjdGVkKG5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNlbGVjdHMgYSBnaXZlbiBub2RlIChvciBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbilcbiAgICAgKiBAbWV0aG9kIHNlbGVjdE5vZGVcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zZWxlY3ROb2RlID0gZnVuY3Rpb24oXG4gICAgICAgIG5vZGUsXG4gICAgICAgIGFkZF90b19jdXJyZW50X3NlbGVjdGlvblxuICAgICkge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0QWxsTm9kZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Tm9kZXMoW25vZGVdLCBhZGRfdG9fY3VycmVudF9zZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNlbGVjdHMgc2V2ZXJhbCBub2RlcyAob3IgYWRkcyB0aGVtIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbilcbiAgICAgKiBAbWV0aG9kIHNlbGVjdE5vZGVzXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuc2VsZWN0Tm9kZXMgPSBmdW5jdGlvbiggbm9kZXMsIGFkZF90b19jdXJyZW50X3NlbGVjdGlvbiApXG5cdHtcblx0XHRpZiAoIWFkZF90b19jdXJyZW50X3NlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdEFsbE5vZGVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlcyA9IG5vZGVzIHx8IHRoaXMuZ3JhcGguX25vZGVzO1xuXHRcdGlmICh0eXBlb2Ygbm9kZXMgPT0gXCJzdHJpbmdcIikgbm9kZXMgPSBbbm9kZXNdO1xuICAgICAgICBmb3IgKHZhciBpIGluIG5vZGVzKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNfc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc2VsZWN0Tm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFub2RlLmlzX3NlbGVjdGVkICYmIG5vZGUub25TZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIG5vZGUub25TZWxlY3RlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5pc19zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkX25vZGVzW25vZGUuaWRdID0gbm9kZTtcblxuICAgICAgICAgICAgaWYgKG5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLmlucHV0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkX2xpbmtzW25vZGUuaW5wdXRzW2pdLmxpbmtdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLm91dHB1dHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IG5vZGUub3V0cHV0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dC5saW5rcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGlua3MubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkX2xpbmtzW291dC5saW5rc1trXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblx0XHRpZihcdHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgKVxuXHRcdFx0dGhpcy5vblNlbGVjdGlvbkNoYW5nZSggdGhpcy5zZWxlY3RlZF9ub2RlcyApO1xuXG4gICAgICAgIHRoaXMuc2V0RGlydHkodHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZXMgYSBub2RlIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICogQG1ldGhvZCBkZXNlbGVjdE5vZGVcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kZXNlbGVjdE5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGlmICghbm9kZS5pc19zZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLm9uRGVzZWxlY3RlZCkge1xuICAgICAgICAgICAgbm9kZS5vbkRlc2VsZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmlzX3NlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMub25Ob2RlRGVzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5vbk5vZGVEZXNlbGVjdGVkKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9yZW1vdmUgaGlnaGxpZ2h0ZWRcbiAgICAgICAgaWYgKG5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaGlnaGxpZ2h0ZWRfbGlua3Nbbm9kZS5pbnB1dHNbaV0ubGlua107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUub3V0cHV0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0ID0gbm9kZS5vdXRwdXRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvdXQubGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdXQubGlua3MubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhpZ2hsaWdodGVkX2xpbmtzW291dC5saW5rc1tqXV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlcyBhbGwgbm9kZXMgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgKiBAbWV0aG9kIGRlc2VsZWN0QWxsTm9kZXNcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kZXNlbGVjdEFsbE5vZGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuZ3JhcGguX25vZGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmICghbm9kZS5pc19zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUub25EZXNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5vbkRlc2VsZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuaXNfc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdGlmICh0aGlzLm9uTm9kZURlc2VsZWN0ZWQpIHtcblx0XHRcdFx0dGhpcy5vbk5vZGVEZXNlbGVjdGVkKG5vZGUpO1xuXHRcdFx0fVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfbm9kZXMgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50X25vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmhpZ2hsaWdodGVkX2xpbmtzID0ge307XG5cdFx0aWYoXHR0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlIClcblx0XHRcdHRoaXMub25TZWxlY3Rpb25DaGFuZ2UoIHRoaXMuc2VsZWN0ZWRfbm9kZXMgKTtcbiAgICAgICAgdGhpcy5zZXREaXJ0eSh0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZGVsZXRlcyBhbGwgbm9kZXMgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGZyb20gdGhlIGdyYXBoXG4gICAgICogQG1ldGhvZCBkZWxldGVTZWxlY3RlZE5vZGVzXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZGVsZXRlU2VsZWN0ZWROb2RlcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dGhpcy5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc2VsZWN0ZWRfbm9kZXMpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zZWxlY3RlZF9ub2Rlc1tpXTtcblxuXHRcdFx0aWYobm9kZS5ibG9ja19kZWxldGUpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHQvL2F1dG9jb25uZWN0IHdoZW4gcG9zc2libGUgKHZlcnkgYmFzaWMsIG9ubHkgdGFrZXMgaW50byBhY2NvdW50IGZpcnN0IGlucHV0LW91dHB1dClcblx0XHRcdGlmKG5vZGUuaW5wdXRzICYmIG5vZGUuaW5wdXRzLmxlbmd0aCAmJiBub2RlLm91dHB1dHMgJiYgbm9kZS5vdXRwdXRzLmxlbmd0aCAmJiBMaXRlR3JhcGguaXNWYWxpZENvbm5lY3Rpb24oIG5vZGUuaW5wdXRzWzBdLnR5cGUsIG5vZGUub3V0cHV0c1swXS50eXBlICkgJiYgbm9kZS5pbnB1dHNbMF0ubGluayAmJiBub2RlLm91dHB1dHNbMF0ubGlua3MgJiYgbm9kZS5vdXRwdXRzWzBdLmxpbmtzLmxlbmd0aCApIFxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgaW5wdXRfbGluayA9IG5vZGUuZ3JhcGgubGlua3NbIG5vZGUuaW5wdXRzWzBdLmxpbmsgXTtcblx0XHRcdFx0dmFyIG91dHB1dF9saW5rID0gbm9kZS5ncmFwaC5saW5rc1sgbm9kZS5vdXRwdXRzWzBdLmxpbmtzWzBdIF07XG5cdFx0XHRcdHZhciBpbnB1dF9ub2RlID0gbm9kZS5nZXRJbnB1dE5vZGUoMCk7XG5cdFx0XHRcdHZhciBvdXRwdXRfbm9kZSA9IG5vZGUuZ2V0T3V0cHV0Tm9kZXMoMClbMF07XG5cdFx0XHRcdGlmKGlucHV0X25vZGUgJiYgb3V0cHV0X25vZGUpXG5cdFx0XHRcdFx0aW5wdXRfbm9kZS5jb25uZWN0KCBpbnB1dF9saW5rLm9yaWdpbl9zbG90LCBvdXRwdXRfbm9kZSwgb3V0cHV0X2xpbmsudGFyZ2V0X3Nsb3QgKTtcblx0XHRcdH1cbiAgICAgICAgICAgIHRoaXMuZ3JhcGgucmVtb3ZlKG5vZGUpO1xuXHRcdFx0aWYgKHRoaXMub25Ob2RlRGVzZWxlY3RlZCkge1xuXHRcdFx0XHR0aGlzLm9uTm9kZURlc2VsZWN0ZWQobm9kZSk7XG5cdFx0XHR9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3RlZF9ub2RlcyA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRfbm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRfbGlua3MgPSB7fTtcbiAgICAgICAgdGhpcy5zZXREaXJ0eSh0cnVlKTtcblx0XHR0aGlzLmdyYXBoLmFmdGVyQ2hhbmdlKCk7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBjZW50ZXJzIHRoZSBjYW1lcmEgb24gYSBnaXZlbiBub2RlXG4gICAgICogQG1ldGhvZCBjZW50ZXJPbk5vZGVcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5jZW50ZXJPbk5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMuZHMub2Zmc2V0WzBdID1cbiAgICAgICAgICAgIC1ub2RlLnBvc1swXSAtXG4gICAgICAgICAgICBub2RlLnNpemVbMF0gKiAwLjUgK1xuICAgICAgICAgICAgKHRoaXMuY2FudmFzLndpZHRoICogMC41KSAvIHRoaXMuZHMuc2NhbGU7XG4gICAgICAgIHRoaXMuZHMub2Zmc2V0WzFdID1cbiAgICAgICAgICAgIC1ub2RlLnBvc1sxXSAtXG4gICAgICAgICAgICBub2RlLnNpemVbMV0gKiAwLjUgK1xuICAgICAgICAgICAgKHRoaXMuY2FudmFzLmhlaWdodCAqIDAuNSkgLyB0aGlzLmRzLnNjYWxlO1xuICAgICAgICB0aGlzLnNldERpcnR5KHRydWUsIHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhZGRzIHNvbWUgdXNlZnVsIHByb3BlcnRpZXMgdG8gYSBtb3VzZSBldmVudCwgbGlrZSB0aGUgcG9zaXRpb24gaW4gZ3JhcGggY29vcmRpbmF0ZXNcbiAgICAgKiBAbWV0aG9kIGFkanVzdE1vdXNlRXZlbnRcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5hZGp1c3RNb3VzZUV2ZW50ID0gZnVuY3Rpb24oZSkge1xuXHR2YXIgY2xpZW50WF9yZWwgPSAwO1xuICAgICAgICB2YXIgY2xpZW50WV9yZWwgPSAwO1xuXHQgICAgXG4gICAgXHRpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjbGllbnRYX3JlbCA9IGUuY2xpZW50WCAtIGIubGVmdDtcbiAgICAgICAgICAgIGNsaWVudFlfcmVsID0gZS5jbGllbnRZIC0gYi50b3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIFx0Y2xpZW50WF9yZWwgPSBlLmNsaWVudFg7XG4gICAgICAgIFx0Y2xpZW50WV9yZWwgPSBlLmNsaWVudFk7XG4gICAgICAgIH1cbiAgICBcdFxuICAgICAgICAvLyBlLmRlbHRhWCA9IGNsaWVudFhfcmVsIC0gdGhpcy5sYXN0X21vdXNlX3Bvc2l0aW9uWzBdO1xuICAgICAgICAvLyBlLmRlbHRhWSA9IGNsaWVudFlfcmVsLSB0aGlzLmxhc3RfbW91c2VfcG9zaXRpb25bMV07XG5cbiAgICAgICAgdGhpcy5sYXN0X21vdXNlX3Bvc2l0aW9uWzBdID0gY2xpZW50WF9yZWw7XG4gICAgICAgIHRoaXMubGFzdF9tb3VzZV9wb3NpdGlvblsxXSA9IGNsaWVudFlfcmVsO1xuXG4gICAgICAgIGUuY2FudmFzWCA9IGNsaWVudFhfcmVsIC8gdGhpcy5kcy5zY2FsZSAtIHRoaXMuZHMub2Zmc2V0WzBdO1xuICAgICAgICBlLmNhbnZhc1kgPSBjbGllbnRZX3JlbCAvIHRoaXMuZHMuc2NhbGUgLSB0aGlzLmRzLm9mZnNldFsxXTtcbiAgICAgICAgXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJwb2ludGVyZXZlbnRzOiBhZGp1c3RNb3VzZUV2ZW50IFwiK2UuY2xpZW50WCtcIjpcIitlLmNsaWVudFkrXCIgXCIrY2xpZW50WF9yZWwrXCI6XCIrY2xpZW50WV9yZWwrXCIgXCIrZS5jYW52YXNYK1wiOlwiK2UuY2FudmFzWSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNoYW5nZXMgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIGdyYXBoIChkZWZhdWx0IGlzIDEpLCB5b3UgY2FuIHBhc3MgYWxzbyBhIHBsYWNlIHVzZWQgdG8gcGl2b3QgdGhlIHpvb21cbiAgICAgKiBAbWV0aG9kIHNldFpvb21cbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zZXRab29tID0gZnVuY3Rpb24odmFsdWUsIHpvb21pbmdfY2VudGVyKSB7XG4gICAgICAgIHRoaXMuZHMuY2hhbmdlU2NhbGUodmFsdWUsIHpvb21pbmdfY2VudGVyKTtcbiAgICAgICAgLypcblx0aWYoIXpvb21pbmdfY2VudGVyICYmIHRoaXMuY2FudmFzKVxuXHRcdHpvb21pbmdfY2VudGVyID0gW3RoaXMuY2FudmFzLndpZHRoICogMC41LHRoaXMuY2FudmFzLmhlaWdodCAqIDAuNV07XG5cblx0dmFyIGNlbnRlciA9IHRoaXMuY29udmVydE9mZnNldFRvQ2FudmFzKCB6b29taW5nX2NlbnRlciApO1xuXG5cdHRoaXMuZHMuc2NhbGUgPSB2YWx1ZTtcblxuXHRpZih0aGlzLnNjYWxlID4gdGhpcy5tYXhfem9vbSlcblx0XHR0aGlzLnNjYWxlID0gdGhpcy5tYXhfem9vbTtcblx0ZWxzZSBpZih0aGlzLnNjYWxlIDwgdGhpcy5taW5fem9vbSlcblx0XHR0aGlzLnNjYWxlID0gdGhpcy5taW5fem9vbTtcblxuXHR2YXIgbmV3X2NlbnRlciA9IHRoaXMuY29udmVydE9mZnNldFRvQ2FudmFzKCB6b29taW5nX2NlbnRlciApO1xuXHR2YXIgZGVsdGFfb2Zmc2V0ID0gW25ld19jZW50ZXJbMF0gLSBjZW50ZXJbMF0sIG5ld19jZW50ZXJbMV0gLSBjZW50ZXJbMV1dO1xuXG5cdHRoaXMub2Zmc2V0WzBdICs9IGRlbHRhX29mZnNldFswXTtcblx0dGhpcy5vZmZzZXRbMV0gKz0gZGVsdGFfb2Zmc2V0WzFdO1xuXHQqL1xuXG4gICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXJ0eV9iZ2NhbnZhcyA9IHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIGEgY29vcmRpbmF0ZSBmcm9tIGdyYXBoIGNvb3JkaW5hdGVzIHRvIGNhbnZhczJEIGNvb3JkaW5hdGVzXG4gICAgICogQG1ldGhvZCBjb252ZXJ0T2Zmc2V0VG9DYW52YXNcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5jb252ZXJ0T2Zmc2V0VG9DYW52YXMgPSBmdW5jdGlvbihwb3MsIG91dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcy5jb252ZXJ0T2Zmc2V0VG9DYW52YXMocG9zLCBvdXQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBhIGNvb3JkaW5hdGUgZnJvbSBDYW52YXMyRCBjb29yZGluYXRlcyB0byBncmFwaCBzcGFjZVxuICAgICAqIEBtZXRob2QgY29udmVydENhbnZhc1RvT2Zmc2V0XG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuY29udmVydENhbnZhc1RvT2Zmc2V0ID0gZnVuY3Rpb24ocG9zLCBvdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHMuY29udmVydENhbnZhc1RvT2Zmc2V0KHBvcywgb3V0KTtcbiAgICB9O1xuXG4gICAgLy9jb252ZXJ0cyBldmVudCBjb29yZGluYXRlcyBmcm9tIGNhbnZhczJEIHRvIGdyYXBoIGNvb3JkaW5hdGVzXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5jb252ZXJ0RXZlbnRUb0NhbnZhc09mZnNldCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydENhbnZhc1RvT2Zmc2V0KFtcbiAgICAgICAgICAgIGUuY2xpZW50WCAtIHJlY3QubGVmdCxcbiAgICAgICAgICAgIGUuY2xpZW50WSAtIHJlY3QudG9wXG4gICAgICAgIF0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBicmluZ3MgYSBub2RlIHRvIGZyb250IChhYm92ZSBhbGwgb3RoZXIgbm9kZXMpXG4gICAgICogQG1ldGhvZCBicmluZ1RvRnJvbnRcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5icmluZ1RvRnJvbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5ncmFwaC5fbm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICAgICAgaWYgKGkgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JhcGguX25vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5ncmFwaC5fbm9kZXMucHVzaChub2RlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2VuZHMgYSBub2RlIHRvIHRoZSBiYWNrIChiZWxvdyBhbGwgb3RoZXIgbm9kZXMpXG4gICAgICogQG1ldGhvZCBzZW5kVG9CYWNrXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuc2VuZFRvQmFjayA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmdyYXBoLl9ub2Rlcy5pbmRleE9mKG5vZGUpO1xuICAgICAgICBpZiAoaSA9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmFwaC5fbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB0aGlzLmdyYXBoLl9ub2Rlcy51bnNoaWZ0KG5vZGUpO1xuICAgIH07XG5cbiAgICAvKiBJbnRlcmFjdGlvbiAqL1xuXG4gICAgLyogTEdyYXBoQ2FudmFzIHJlbmRlciAqL1xuICAgIHZhciB0ZW1wID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcblxuICAgIC8qKlxuICAgICAqIGNoZWNrcyB3aGljaCBub2RlcyBhcmUgdmlzaWJsZSAoaW5zaWRlIHRoZSBjYW1lcmEgYXJlYSlcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVWaXNpYmxlTm9kZXNcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5jb21wdXRlVmlzaWJsZU5vZGVzID0gZnVuY3Rpb24obm9kZXMsIG91dCkge1xuICAgICAgICB2YXIgdmlzaWJsZV9ub2RlcyA9IG91dCB8fCBbXTtcbiAgICAgICAgdmlzaWJsZV9ub2Rlcy5sZW5ndGggPSAwO1xuICAgICAgICBub2RlcyA9IG5vZGVzIHx8IHRoaXMuZ3JhcGguX25vZGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdmFyIG4gPSBub2Rlc1tpXTtcblxuICAgICAgICAgICAgLy9za2lwIHJlbmRlcmluZyBub2RlcyBpbiBsaXZlIG1vZGVcbiAgICAgICAgICAgIGlmICh0aGlzLmxpdmVfbW9kZSAmJiAhbi5vbkRyYXdCYWNrZ3JvdW5kICYmICFuLm9uRHJhd0ZvcmVncm91bmQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvdmVybGFwQm91bmRpbmcodGhpcy52aXNpYmxlX2FyZWEsIG4uZ2V0Qm91bmRpbmcodGVtcCwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vb3V0IG9mIHRoZSB2aXNpYmxlIGFyZWFcblxuICAgICAgICAgICAgdmlzaWJsZV9ub2Rlcy5wdXNoKG4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aXNpYmxlX25vZGVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZW5kZXJzIHRoZSB3aG9sZSBjYW52YXMgY29udGVudCwgYnkgcmVuZGVyaW5nIGluIHR3byBzZXBhcmF0ZWQgY2FudmFzLCBvbmUgY29udGFpbmluZyB0aGUgYmFja2dyb3VuZCBncmlkIGFuZCB0aGUgY29ubmVjdGlvbnMsIGFuZCBvbmUgY29udGFpbmluZyB0aGUgbm9kZXMpXG4gICAgICogQG1ldGhvZCBkcmF3XG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGZvcmNlX2NhbnZhcywgZm9yY2VfYmdjYW52YXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbnZhcyB8fCB0aGlzLmNhbnZhcy53aWR0aCA9PSAwIHx8IHRoaXMuY2FudmFzLmhlaWdodCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL2ZwcyBjb3VudGluZ1xuICAgICAgICB2YXIgbm93ID0gTGl0ZUdyYXBoLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJfdGltZSA9IChub3cgLSB0aGlzLmxhc3RfZHJhd190aW1lKSAqIDAuMDAxO1xuICAgICAgICB0aGlzLmxhc3RfZHJhd190aW1lID0gbm93O1xuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICB0aGlzLmRzLmNvbXB1dGVWaXNpYmxlQXJlYSh0aGlzLnZpZXdwb3J0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgfHxcbiAgICAgICAgICAgIGZvcmNlX2JnY2FudmFzIHx8XG4gICAgICAgICAgICB0aGlzLmFsd2F5c19yZW5kZXJfYmFja2dyb3VuZCB8fFxuICAgICAgICAgICAgKHRoaXMuZ3JhcGggJiZcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLl9sYXN0X3RyaWdnZXJfdGltZSAmJlxuICAgICAgICAgICAgICAgIG5vdyAtIHRoaXMuZ3JhcGguX2xhc3RfdHJpZ2dlcl90aW1lIDwgMTAwMClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdCYWNrQ2FudmFzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kaXJ0eV9jYW52YXMgfHwgZm9yY2VfY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdGcm9udENhbnZhcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mcHMgPSB0aGlzLnJlbmRlcl90aW1lID8gMS4wIC8gdGhpcy5yZW5kZXJfdGltZSA6IDA7XG4gICAgICAgIHRoaXMuZnJhbWUgKz0gMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZHJhd3MgdGhlIGZyb250IGNhbnZhcyAodGhlIG9uZSBjb250YWluaW5nIGFsbCB0aGUgbm9kZXMpXG4gICAgICogQG1ldGhvZCBkcmF3RnJvbnRDYW52YXNcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kcmF3RnJvbnRDYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXRoaXMuY3R4KSB7XG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuYmdjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgIC8vbWF5YmUgaXMgdXNpbmcgd2ViZ2wuLi5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgICAgaWYgKCBjdHguc3RhcnQyRCAmJiAhdGhpcy52aWV3cG9ydCApIHtcbiAgICAgICAgICAgIGN0eC5zdGFydDJEKCk7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2xpcCBkaXJ0eSBhcmVhIGlmIHRoZXJlIGlzIG9uZSwgb3RoZXJ3aXNlIHdvcmsgaW4gZnVsbCBjYW52YXNcblx0XHR2YXIgYXJlYSA9IHRoaXMudmlld3BvcnQgfHwgdGhpcy5kaXJ0eV9hcmVhO1xuICAgICAgICBpZiAoYXJlYSkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5yZWN0KCBhcmVhWzBdLGFyZWFbMV0sYXJlYVsyXSxhcmVhWzNdICk7XG4gICAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jbGVhclxuICAgICAgICAvL2NhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgaWYgKHRoaXMuY2xlYXJfYmFja2dyb3VuZCkge1xuXHRcdFx0aWYoYXJlYSlcblx0ICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCggYXJlYVswXSxhcmVhWzFdLGFyZWFbMl0sYXJlYVszXSApO1xuXHRcdFx0ZWxzZVxuXHQgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2RyYXcgYmcgY2FudmFzXG4gICAgICAgIGlmICh0aGlzLmJnY2FudmFzID09IHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdCYWNrQ2FudmFzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKCB0aGlzLmJnY2FudmFzLCAwLCAwICk7XG4gICAgICAgIH1cblxuICAgICAgICAvL3JlbmRlcmluZ1xuICAgICAgICBpZiAodGhpcy5vblJlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5vblJlbmRlcihjYW52YXMsIGN0eCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2luZm8gd2lkZ2V0XG4gICAgICAgIGlmICh0aGlzLnNob3dfaW5mbykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJJbmZvKGN0eCwgYXJlYSA/IGFyZWFbMF0gOiAwLCBhcmVhID8gYXJlYVsxXSA6IDAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICAvL2FwcGx5IHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIHRoaXMuZHMudG9DYW52YXNDb250ZXh0KGN0eCk7XG5cbiAgICAgICAgICAgIC8vZHJhdyBub2Rlc1xuICAgICAgICAgICAgdmFyIGRyYXduX25vZGVzID0gMDtcbiAgICAgICAgICAgIHZhciB2aXNpYmxlX25vZGVzID0gdGhpcy5jb21wdXRlVmlzaWJsZU5vZGVzKFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlX25vZGVzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpc2libGVfbm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHZpc2libGVfbm9kZXNbaV07XG5cbiAgICAgICAgICAgICAgICAvL3RyYW5zZm9ybSBjb29yZHMgc3lzdGVtXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKG5vZGUucG9zWzBdLCBub2RlLnBvc1sxXSk7XG5cbiAgICAgICAgICAgICAgICAvL0RyYXdcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdOb2RlKG5vZGUsIGN0eCk7XG4gICAgICAgICAgICAgICAgZHJhd25fbm9kZXMgKz0gMTtcblxuICAgICAgICAgICAgICAgIC8vUmVzdG9yZVxuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vb24gdG9wIChkZWJ1ZylcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcl9leGVjdXRpb25fb3JkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdFeGVjdXRpb25PcmRlcihjdHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2Nvbm5lY3Rpb25zIG9udG9wP1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JhcGguY29uZmlnLmxpbmtzX29udG9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxpdmVfbW9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdDb25uZWN0aW9ucyhjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9jdXJyZW50IGNvbm5lY3Rpb24gKHRoZSBvbmUgYmVpbmcgZHJhZ2dlZCBieSB0aGUgbW91c2UpXG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW5nX3BvcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuY29ubmVjdGlvbnNfd2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtfY29sb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBjb25uSW5Pck91dCA9IHRoaXMuY29ubmVjdGluZ19vdXRwdXQgfHwgdGhpcy5jb25uZWN0aW5nX2lucHV0O1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvbm5UeXBlID0gY29ubkluT3JPdXQudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgY29ubkRpciA9IGNvbm5Jbk9yT3V0LmRpcjtcblx0XHRcdFx0aWYoY29ubkRpciA9PSBudWxsKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHRoaXMuY29ubmVjdGluZ19vdXRwdXQpXG5cdFx0XHRcdFx0XHRjb25uRGlyID0gdGhpcy5jb25uZWN0aW5nX25vZGUuaG9yaXpvbnRhbCA/IExpdGVHcmFwaC5ET1dOIDogTGl0ZUdyYXBoLlJJR0hUO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdGNvbm5EaXIgPSB0aGlzLmNvbm5lY3Rpbmdfbm9kZS5ob3Jpem9udGFsID8gTGl0ZUdyYXBoLlVQIDogTGl0ZUdyYXBoLkxFRlQ7XG5cdFx0XHRcdH1cbiAgICAgICAgICAgICAgICB2YXIgY29ublNoYXBlID0gY29ubkluT3JPdXQuc2hhcGU7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb25uVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5FVkVOVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfY29sb3IgPSBMaXRlR3JhcGguRVZFTlRfTElOS19DT0xPUjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19jb2xvciA9IExpdGVHcmFwaC5DT05ORUNUSU5HX0xJTktfQ09MT1I7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy90aGUgY29ubmVjdGlvbiBiZWluZyBkcmFnZ2VkIGJ5IHRoZSBtb3VzZVxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGluayhcbiAgICAgICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdfcG9zLFxuICAgICAgICAgICAgICAgICAgICBbdGhpcy5ncmFwaF9tb3VzZVswXSwgdGhpcy5ncmFwaF9tb3VzZVsxXV0sXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBsaW5rX2NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBjb25uRGlyLFxuICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGguQ0VOVEVSXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGNvbm5UeXBlID09PSBMaXRlR3JhcGguRVZFTlQgfHxcbiAgICAgICAgICAgICAgICAgICAgY29ublNoYXBlID09PSBMaXRlR3JhcGguQk9YX1NIQVBFXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX3Bvc1swXSAtIDYgKyAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdfcG9zWzFdIC0gNSArIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDE0LFxuICAgICAgICAgICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhfbW91c2VbMF0gLSA2ICsgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaF9tb3VzZVsxXSAtIDUgKyAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAxNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb25uU2hhcGUgPT09IExpdGVHcmFwaC5BUlJPV19TSEFQRSkge1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHRoaXMuY29ubmVjdGluZ19wb3NbMF0gKyA4LCB0aGlzLmNvbm5lY3RpbmdfcG9zWzFdICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLmNvbm5lY3RpbmdfcG9zWzBdIC0gNCwgdGhpcy5jb25uZWN0aW5nX3Bvc1sxXSArIDYgKyAwLjUpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRoaXMuY29ubmVjdGluZ19wb3NbMF0gLSA0LCB0aGlzLmNvbm5lY3RpbmdfcG9zWzFdIC0gNiArIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguYXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nX3Bvc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ19wb3NbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguUEkgKiAyXG4gICAgICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuXHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhfbW91c2VbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoX21vdXNlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLlBJICogMlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmY2MwMFwiO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oaWdobGlnaHRfaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLl9oaWdobGlnaHRfaW5wdXRfc2xvdC5zaGFwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlID09PSBMaXRlR3JhcGguQVJST1dfU0hBUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy5faGlnaGxpZ2h0X2lucHV0WzBdICsgOCwgdGhpcy5faGlnaGxpZ2h0X2lucHV0WzFdICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy5faGlnaGxpZ2h0X2lucHV0WzBdIC0gNCwgdGhpcy5faGlnaGxpZ2h0X2lucHV0WzFdICsgNiArIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRoaXMuX2hpZ2hsaWdodF9pbnB1dFswXSAtIDQsIHRoaXMuX2hpZ2hsaWdodF9pbnB1dFsxXSAtIDYgKyAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRfaW5wdXRbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0X2lucHV0WzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLlBJICogMlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGlnaGxpZ2h0X291dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGFwZSA9PT0gTGl0ZUdyYXBoLkFSUk9XX1NIQVBFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHRoaXMuX2hpZ2hsaWdodF9vdXRwdXRbMF0gKyA4LCB0aGlzLl9oaWdobGlnaHRfb3V0cHV0WzFdICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy5faGlnaGxpZ2h0X291dHB1dFswXSAtIDQsIHRoaXMuX2hpZ2hsaWdodF9vdXRwdXRbMV0gKyA2ICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy5faGlnaGxpZ2h0X291dHB1dFswXSAtIDQsIHRoaXMuX2hpZ2hsaWdodF9vdXRwdXRbMV0gLSA2ICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0X291dHB1dFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRfb3V0cHV0WzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLlBJICogMlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXHRcdFx0Ly90aGUgc2VsZWN0aW9uIHJlY3RhbmdsZVxuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCIjRkZGXCI7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzBdLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX3JlY3RhbmdsZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ19yZWN0YW5nbGVbMl0sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdfcmVjdGFuZ2xlWzNdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuXHRcdFx0Ly9vbiB0b3Agb2YgbGluayBjZW50ZXJcblx0XHRcdGlmKHRoaXMub3Zlcl9saW5rX2NlbnRlciAmJiB0aGlzLnJlbmRlcl9saW5rX3Rvb2x0aXApXG5cdFx0XHRcdHRoaXMuZHJhd0xpbmtUb29sdGlwKCBjdHgsIHRoaXMub3Zlcl9saW5rX2NlbnRlciApO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRpZih0aGlzLm9uRHJhd0xpbmtUb29sdGlwKSAvL3RvIHJlbW92ZVxuXHRcdFx0XHRcdHRoaXMub25EcmF3TGlua1Rvb2x0aXAoY3R4LG51bGwpO1xuXG5cdFx0XHQvL2N1c3RvbSBpbmZvXG4gICAgICAgICAgICBpZiAodGhpcy5vbkRyYXdGb3JlZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRyYXdGb3JlZ3JvdW5kKGN0eCwgdGhpcy52aXNpYmxlX3JlY3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG5cblx0XHQvL2RyYXdzIHBhbmVsIGluIHRoZSBjb3JuZXIgXG5cdFx0aWYgKHRoaXMuX2dyYXBoX3N0YWNrICYmIHRoaXMuX2dyYXBoX3N0YWNrLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5kcmF3U3ViZ3JhcGhQYW5lbCggY3R4ICk7XG5cdFx0fVxuXG5cbiAgICAgICAgaWYgKHRoaXMub25EcmF3T3ZlcmxheSkge1xuICAgICAgICAgICAgdGhpcy5vbkRyYXdPdmVybGF5KGN0eCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJlYSl7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN0eC5maW5pc2gyRCkge1xuICAgICAgICAgICAgLy90aGlzIGlzIGEgZnVuY3Rpb24gSSB1c2UgaW4gd2ViZ2wgcmVuZGVyZXJcbiAgICAgICAgICAgIGN0eC5maW5pc2gyRCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGRyYXdzIHRoZSBwYW5lbCBpbiB0aGUgY29ybmVyIHRoYXQgc2hvd3Mgc3ViZ3JhcGggcHJvcGVydGllc1xuICAgICAqIEBtZXRob2QgZHJhd1N1YmdyYXBoUGFuZWxcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kcmF3U3ViZ3JhcGhQYW5lbCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIHN1YmdyYXBoID0gdGhpcy5ncmFwaDtcbiAgICAgICAgdmFyIHN1Ym5vZGUgPSBzdWJncmFwaC5fc3ViZ3JhcGhfbm9kZTtcbiAgICAgICAgaWYgKCFzdWJub2RlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJzdWJncmFwaCB3aXRob3V0IHN1Ym5vZGVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmF3U3ViZ3JhcGhQYW5lbExlZnQoc3ViZ3JhcGgsIHN1Ym5vZGUsIGN0eClcbiAgICAgICAgdGhpcy5kcmF3U3ViZ3JhcGhQYW5lbFJpZ2h0KHN1YmdyYXBoLCBzdWJub2RlLCBjdHgpXG4gICAgfVxuXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kcmF3U3ViZ3JhcGhQYW5lbExlZnQgPSBmdW5jdGlvbiAoc3ViZ3JhcGgsIHN1Ym5vZGUsIGN0eCkge1xuICAgICAgICB2YXIgbnVtID0gc3Vibm9kZS5pbnB1dHMgPyBzdWJub2RlLmlucHV0cy5sZW5ndGggOiAwO1xuICAgICAgICB2YXIgdyA9IDIwMDtcbiAgICAgICAgdmFyIGggPSBNYXRoLmZsb29yKExpdGVHcmFwaC5OT0RFX1NMT1RfSEVJR0hUICogMS42KTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjMTExXCI7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuODtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgucm91bmRSZWN0KDEwLCAxMCwgdywgKG51bSArIDEpICogaCArIDUwLCBbOF0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiM4ODhcIjtcbiAgICAgICAgY3R4LmZvbnQgPSBcIjE0cHggQXJpYWxcIjtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICBjdHguZmlsbFRleHQoXCJHcmFwaCBJbnB1dHNcIiwgMjAsIDM0KTtcbiAgICAgICAgLy8gdmFyIHBvcyA9IHRoaXMubW91c2U7XG5cbiAgICAgICAgaWYgKHRoaXMuZHJhd0J1dHRvbih3IC0gMjAsIDIwLCAyMCwgMjAsIFwiWFwiLCBcIiMxNTE1MTVcIikpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VTdWJncmFwaCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHkgPSA1MDtcbiAgICAgICAgY3R4LmZvbnQgPSBcIjE0cHggQXJpYWxcIjtcbiAgICAgICAgaWYgKHN1Ym5vZGUuaW5wdXRzKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJub2RlLmlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHN1Ym5vZGUuaW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5ub3Rfc3ViZ3JhcGhfaW5wdXQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgLy9pbnB1dCBidXR0b24gY2xpY2tlZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRyYXdCdXR0b24oMjAsIHkgKyAyLCB3IC0gMjAsIGggLSAyKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHN1Ym5vZGUuY29uc3RydWN0b3IuaW5wdXRfbm9kZV90eXBlIHx8IFwiZ3JhcGgvaW5wdXRcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld25vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZSh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld25vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmdyYXBoLmFkZChuZXdub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tfY2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdF9jbGlja19wb3NpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdE5vZGVzKFtuZXdub2RlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVfZHJhZ2dlZCA9IG5ld25vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX2NhbnZhcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3bm9kZS5zZXRQcm9wZXJ0eShcIm5hbWVcIiwgaW5wdXQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdub2RlLnNldFByb3BlcnR5KFwidHlwZVwiLCBpbnB1dC50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZV9kcmFnZ2VkLnBvc1swXSA9IHRoaXMuZ3JhcGhfbW91c2VbMF0gLSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlX2RyYWdnZWQucG9zWzFdID0gdGhpcy5ncmFwaF9tb3VzZVsxXSAtIDU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLmFmdGVyQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImdyYXBoIGlucHV0IG5vZGUgbm90IGZvdW5kOlwiLCB0eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzlDOVwiO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHcgLSAxNiwgeSArIGggKiAwLjUsIDUsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNBQUFcIjtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoaW5wdXQubmFtZSwgMzAsIHkgKyBoICogMC43NSk7XG4gICAgICAgICAgICAgICAgLy8gdmFyIHR3ID0gY3R4Lm1lYXN1cmVUZXh0KGlucHV0Lm5hbWUpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiM3NzdcIjtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoaW5wdXQudHlwZSwgMTMwLCB5ICsgaCAqIDAuNzUpO1xuICAgICAgICAgICAgICAgIHkgKz0gaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy9hZGQgKyBidXR0b25cbiAgICAgICAgaWYgKHRoaXMuZHJhd0J1dHRvbigyMCwgeSArIDIsIHcgLSAyMCwgaCAtIDIsIFwiK1wiLCBcIiMxNTE1MTVcIiwgXCIjMjIyXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dTdWJncmFwaFByb3BlcnRpZXNEaWFsb2coc3Vibm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kcmF3U3ViZ3JhcGhQYW5lbFJpZ2h0ID0gZnVuY3Rpb24gKHN1YmdyYXBoLCBzdWJub2RlLCBjdHgpIHtcbiAgICAgICAgdmFyIG51bSA9IHN1Ym5vZGUub3V0cHV0cyA/IHN1Ym5vZGUub3V0cHV0cy5sZW5ndGggOiAwO1xuICAgICAgICB2YXIgY2FudmFzX3cgPSB0aGlzLmJnY2FudmFzLndpZHRoXG4gICAgICAgIHZhciB3ID0gMjAwO1xuICAgICAgICB2YXIgaCA9IE1hdGguZmxvb3IoTGl0ZUdyYXBoLk5PREVfU0xPVF9IRUlHSFQgKiAxLjYpO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiMxMTFcIjtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC44O1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5yb3VuZFJlY3QoY2FudmFzX3cgLSB3IC0gMTAsIDEwLCB3LCAobnVtICsgMSkgKiBoICsgNTAsIFs4XSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzg4OFwiO1xuICAgICAgICBjdHguZm9udCA9IFwiMTRweCBBcmlhbFwiO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgIHZhciB0aXRsZV90ZXh0ID0gXCJHcmFwaCBPdXRwdXRzXCJcbiAgICAgICAgdmFyIHR3ID0gY3R4Lm1lYXN1cmVUZXh0KHRpdGxlX3RleHQpLndpZHRoXG4gICAgICAgIGN0eC5maWxsVGV4dCh0aXRsZV90ZXh0LCAoY2FudmFzX3cgLSB0dykgLSAyMCwgMzQpO1xuICAgICAgICAvLyB2YXIgcG9zID0gdGhpcy5tb3VzZTtcbiAgICAgICAgaWYgKHRoaXMuZHJhd0J1dHRvbihjYW52YXNfdyAtIHcsIDIwLCAyMCwgMjAsIFwiWFwiLCBcIiMxNTE1MTVcIikpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VTdWJncmFwaCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHkgPSA1MDtcbiAgICAgICAgY3R4LmZvbnQgPSBcIjE0cHggQXJpYWxcIjtcbiAgICAgICAgaWYgKHN1Ym5vZGUub3V0cHV0cylcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vibm9kZS5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IHN1Ym5vZGUub3V0cHV0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lm5vdF9zdWJncmFwaF9pbnB1dClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAvL291dHB1dCBidXR0b24gY2xpY2tlZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRyYXdCdXR0b24oY2FudmFzX3cgLSB3LCB5ICsgMiwgdyAtIDIwLCBoIC0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBzdWJub2RlLmNvbnN0cnVjdG9yLm91dHB1dF9ub2RlX3R5cGUgfHwgXCJncmFwaC9vdXRwdXRcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld25vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZSh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld25vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmdyYXBoLmFkZChuZXdub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tfY2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdF9jbGlja19wb3NpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdE5vZGVzKFtuZXdub2RlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVfZHJhZ2dlZCA9IG5ld25vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nX2NhbnZhcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3bm9kZS5zZXRQcm9wZXJ0eShcIm5hbWVcIiwgb3V0cHV0Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3bm9kZS5zZXRQcm9wZXJ0eShcInR5cGVcIiwgb3V0cHV0LnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlX2RyYWdnZWQucG9zWzBdID0gdGhpcy5ncmFwaF9tb3VzZVswXSAtIDU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVfZHJhZ2dlZC5wb3NbMV0gPSB0aGlzLmdyYXBoX21vdXNlWzFdIC0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGguYWZ0ZXJDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZ3JhcGggaW5wdXQgbm9kZSBub3QgZm91bmQ6XCIsIHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjOUM5XCI7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoY2FudmFzX3cgLSB3ICsgMTYsIHkgKyBoICogMC41LCA1LCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjQUFBXCI7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KG91dHB1dC5uYW1lLCBjYW52YXNfdyAtIHcgKyAzMCwgeSArIGggKiAwLjc1KTtcbiAgICAgICAgICAgICAgICAvLyB2YXIgdHcgPSBjdHgubWVhc3VyZVRleHQoaW5wdXQubmFtZSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzc3N1wiO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChvdXRwdXQudHlwZSwgY2FudmFzX3cgLSB3ICsgMTMwLCB5ICsgaCAqIDAuNzUpO1xuICAgICAgICAgICAgICAgIHkgKz0gaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy9hZGQgKyBidXR0b25cbiAgICAgICAgaWYgKHRoaXMuZHJhd0J1dHRvbihjYW52YXNfdyAtIHcsIHkgKyAyLCB3IC0gMjAsIGggLSAyLCBcIitcIiwgXCIjMTUxNTE1XCIsIFwiIzIyMlwiKSkge1xuICAgICAgICAgICAgdGhpcy5zaG93U3ViZ3JhcGhQcm9wZXJ0aWVzRGlhbG9nUmlnaHQoc3Vibm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cdC8vRHJhd3MgYSBidXR0b24gaW50byB0aGUgY2FudmFzIG92ZXJsYXkgYW5kIGNvbXB1dGVzIGlmIGl0IHdhcyBjbGlja2VkIHVzaW5nIHRoZSBpbW1lZGlhdGUgZ3VpIHBhcmFkaWdtXG5cdExHcmFwaENhbnZhcy5wcm90b3R5cGUuZHJhd0J1dHRvbiA9IGZ1bmN0aW9uKCB4LHksdyxoLCB0ZXh0LCBiZ2NvbG9yLCBob3ZlcmNvbG9yLCB0ZXh0Y29sb3IgKVxuXHR7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY3R4O1xuXHRcdGJnY29sb3IgPSBiZ2NvbG9yIHx8IExpdGVHcmFwaC5OT0RFX0RFRkFVTFRfQ09MT1I7XG5cdFx0aG92ZXJjb2xvciA9IGhvdmVyY29sb3IgfHwgXCIjNTU1XCI7XG5cdFx0dGV4dGNvbG9yID0gdGV4dGNvbG9yIHx8IExpdGVHcmFwaC5OT0RFX1RFWFRfQ09MT1I7XG5cdFx0dmFyIHBvcyA9IHRoaXMuZHMuY29udmVydE9mZnNldFRvQ2FudmFzKHRoaXMuZ3JhcGhfbW91c2UpO1xuXHRcdHZhciBob3ZlciA9IExpdGVHcmFwaC5pc0luc2lkZVJlY3RhbmdsZSggcG9zWzBdLCBwb3NbMV0sIHgseSx3LGggKTtcblx0XHRwb3MgPSB0aGlzLmxhc3RfY2xpY2tfcG9zaXRpb24gPyBbdGhpcy5sYXN0X2NsaWNrX3Bvc2l0aW9uWzBdLCB0aGlzLmxhc3RfY2xpY2tfcG9zaXRpb25bMV1dIDogbnVsbDtcbiAgICAgICAgaWYocG9zKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgcG9zWzBdIC09IHJlY3QubGVmdDtcbiAgICAgICAgICAgIHBvc1sxXSAtPSByZWN0LnRvcDtcbiAgICAgICAgfVxuXHRcdHZhciBjbGlja2VkID0gcG9zICYmIExpdGVHcmFwaC5pc0luc2lkZVJlY3RhbmdsZSggcG9zWzBdLCBwb3NbMV0sIHgseSx3LGggKTtcblxuXHRcdGN0eC5maWxsU3R5bGUgPSBob3ZlciA/IGhvdmVyY29sb3IgOiBiZ2NvbG9yO1xuXHRcdGlmKGNsaWNrZWQpXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gXCIjQUFBXCI7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5yb3VuZFJlY3QoeCx5LHcsaCxbNF0gKTtcblx0XHRjdHguZmlsbCgpO1xuXG5cdFx0aWYodGV4dCAhPSBudWxsKVxuXHRcdHtcblx0XHRcdGlmKHRleHQuY29uc3RydWN0b3IgPT0gU3RyaW5nKVxuXHRcdFx0e1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdGV4dGNvbG9yO1xuXHRcdFx0XHRjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0Y3R4LmZvbnQgPSAoKGggKiAwLjY1KXwwKSArIFwicHggQXJpYWxcIjtcblx0XHRcdFx0Y3R4LmZpbGxUZXh0KCB0ZXh0LCB4ICsgdyAqIDAuNSx5ICsgaCAqIDAuNzUgKTtcblx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciB3YXNfY2xpY2tlZCA9IGNsaWNrZWQgJiYgIXRoaXMuYmxvY2tfY2xpY2s7XG5cdFx0aWYoY2xpY2tlZClcblx0XHRcdHRoaXMuYmxvY2tDbGljaygpO1xuXHRcdHJldHVybiB3YXNfY2xpY2tlZDtcblx0fVxuXG5cdExHcmFwaENhbnZhcy5wcm90b3R5cGUuaXNBcmVhQ2xpY2tlZCA9IGZ1bmN0aW9uKCB4LHksdyxoLCBob2xkX2NsaWNrIClcblx0e1xuXHRcdHZhciBwb3MgPSB0aGlzLm1vdXNlO1xuXHRcdHZhciBob3ZlciA9IExpdGVHcmFwaC5pc0luc2lkZVJlY3RhbmdsZSggcG9zWzBdLCBwb3NbMV0sIHgseSx3LGggKTtcblx0XHRwb3MgPSB0aGlzLmxhc3RfY2xpY2tfcG9zaXRpb247XG5cdFx0dmFyIGNsaWNrZWQgPSBwb3MgJiYgTGl0ZUdyYXBoLmlzSW5zaWRlUmVjdGFuZ2xlKCBwb3NbMF0sIHBvc1sxXSwgeCx5LHcsaCApO1xuXHRcdHZhciB3YXNfY2xpY2tlZCA9IGNsaWNrZWQgJiYgIXRoaXMuYmxvY2tfY2xpY2s7XG5cdFx0aWYoY2xpY2tlZCAmJiBob2xkX2NsaWNrKVxuXHRcdFx0dGhpcy5ibG9ja0NsaWNrKCk7XG5cdFx0cmV0dXJuIHdhc19jbGlja2VkO1xuXHR9XG5cbiAgICAvKipcbiAgICAgKiBkcmF3cyBzb21lIHVzZWZ1bCBzdGF0cyBpbiB0aGUgY29ybmVyIG9mIHRoZSBjYW52YXNcbiAgICAgKiBAbWV0aG9kIHJlbmRlckluZm9cbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5yZW5kZXJJbmZvID0gZnVuY3Rpb24oY3R4LCB4LCB5KSB7XG4gICAgICAgIHggPSB4IHx8IDEwO1xuICAgICAgICB5ID0geSB8fCB0aGlzLmNhbnZhcy5oZWlnaHQgLSA4MDtcblxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuXG4gICAgICAgIGN0eC5mb250ID0gXCIxMHB4IEFyaWFsXCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiM4ODhcIjtcblx0XHRjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgIGlmICh0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoIFwiVDogXCIgKyB0aGlzLmdyYXBoLmdsb2JhbHRpbWUudG9GaXhlZCgyKSArIFwic1wiLCA1LCAxMyAqIDEgKTtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChcIkk6IFwiICsgdGhpcy5ncmFwaC5pdGVyYXRpb24sIDUsIDEzICogMiApO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFwiTjogXCIgKyB0aGlzLmdyYXBoLl9ub2Rlcy5sZW5ndGggKyBcIiBbXCIgKyB0aGlzLnZpc2libGVfbm9kZXMubGVuZ3RoICsgXCJdXCIsIDUsIDEzICogMyApO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFwiVjogXCIgKyB0aGlzLmdyYXBoLl92ZXJzaW9uLCA1LCAxMyAqIDQpO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFwiRlBTOlwiICsgdGhpcy5mcHMudG9GaXhlZCgyKSwgNSwgMTMgKiA1KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChcIk5vIGdyYXBoIHNlbGVjdGVkXCIsIDUsIDEzICogMSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZHJhd3MgdGhlIGJhY2sgY2FudmFzICh0aGUgb25lIGNvbnRhaW5pbmcgdGhlIGJhY2tncm91bmQgYW5kIHRoZSBjb25uZWN0aW9ucylcbiAgICAgKiBAbWV0aG9kIGRyYXdCYWNrQ2FudmFzXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZHJhd0JhY2tDYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuYmdjYW52YXM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCAhPSB0aGlzLmNhbnZhcy53aWR0aCB8fFxuICAgICAgICAgICAgY2FudmFzLmhlaWdodCAhPSB0aGlzLmNhbnZhcy5oZWlnaHRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuYmdjdHgpIHtcbiAgICAgICAgICAgIHRoaXMuYmdjdHggPSB0aGlzLmJnY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5iZ2N0eDtcbiAgICAgICAgaWYgKGN0eC5zdGFydCkge1xuICAgICAgICAgICAgY3R4LnN0YXJ0KCk7XG4gICAgICAgIH1cblxuXHRcdHZhciB2aWV3cG9ydCA9IHRoaXMudmlld3BvcnQgfHwgWzAsMCxjdHguY2FudmFzLndpZHRoLGN0eC5jYW52YXMuaGVpZ2h0XTtcblxuICAgICAgICAvL2NsZWFyXG4gICAgICAgIGlmICh0aGlzLmNsZWFyX2JhY2tncm91bmQpIHtcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoIHZpZXdwb3J0WzBdLCB2aWV3cG9ydFsxXSwgdmlld3BvcnRbMl0sIHZpZXdwb3J0WzNdICk7XG4gICAgICAgIH1cblxuXHRcdC8vc2hvdyBzdWJncmFwaCBzdGFjayBoZWFkZXJcbiAgICAgICAgaWYgKHRoaXMuX2dyYXBoX3N0YWNrICYmIHRoaXMuX2dyYXBoX3N0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRfZ3JhcGggPSB0aGlzLl9ncmFwaF9zdGFja1t0aGlzLl9ncmFwaF9zdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBzdWJncmFwaF9ub2RlID0gdGhpcy5ncmFwaC5fc3ViZ3JhcGhfbm9kZTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN1YmdyYXBoX25vZGUuYmdjb2xvcjtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxMDtcbiAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KDEsIDEsIGNhbnZhcy53aWR0aCAtIDIsIGNhbnZhcy5oZWlnaHQgLSAyKTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBcIjQwcHggQXJpYWxcIjtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN1YmdyYXBoX25vZGUuYmdjb2xvciB8fCBcIiNBQUFcIjtcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuX2dyYXBoX3N0YWNrLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGl0bGUgKz1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhfc3RhY2tbaV0uX3N1YmdyYXBoX25vZGUuZ2V0VGl0bGUoKSArIFwiID4+IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFxuICAgICAgICAgICAgICAgIHRpdGxlICsgc3ViZ3JhcGhfbm9kZS5nZXRUaXRsZSgpLFxuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCAqIDAuNSxcbiAgICAgICAgICAgICAgICA0MFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmdfYWxyZWFkeV9wYWludGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9uUmVuZGVyQmFja2dyb3VuZCkge1xuICAgICAgICAgICAgYmdfYWxyZWFkeV9wYWludGVkID0gdGhpcy5vblJlbmRlckJhY2tncm91bmQoY2FudmFzLCBjdHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9yZXNldCBpbiBjYXNlIG9mIGVycm9yXG4gICAgICAgIGlmICggIXRoaXMudmlld3BvcnQgKVxuXHRcdHtcblx0ICAgICAgICBjdHgucmVzdG9yZSgpO1xuXHRcdCAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdH1cbiAgICAgICAgdGhpcy52aXNpYmxlX2xpbmtzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgIC8vYXBwbHkgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgdGhpcy5kcy50b0NhbnZhc0NvbnRleHQoY3R4KTtcblxuICAgICAgICAgICAgLy9yZW5kZXIgQkdcbiAgICAgICAgICAgIGlmICggdGhpcy5kcy5zY2FsZSA8IDEuNSAmJiAhYmdfYWxyZWFkeV9wYWludGVkICYmIHRoaXMuY2xlYXJfYmFja2dyb3VuZF9jb2xvciApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY2xlYXJfYmFja2dyb3VuZF9jb2xvcjtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZV9hcmVhWzBdLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVfYXJlYVsxXSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlX2FyZWFbMl0sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZV9hcmVhWzNdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZF9pbWFnZSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZHMuc2NhbGUgPiAwLjUgJiZcbiAgICAgICAgICAgICAgICAhYmdfYWxyZWFkeV9wYWludGVkXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy56b29tX21vZGlmeV9hbHBoYSkge1xuICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgKDEuMCAtIDAuNSAvIHRoaXMuZHMuc2NhbGUpICogdGhpcy5lZGl0b3JfYWxwaGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5lZGl0b3JfYWxwaGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7IC8vIGN0eC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLl9iZ19pbWcgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmdfaW1nLm5hbWUgIT0gdGhpcy5iYWNrZ3JvdW5kX2ltYWdlXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JnX2ltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iZ19pbWcubmFtZSA9IHRoaXMuYmFja2dyb3VuZF9pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmdfaW1nLnNyYyA9IHRoaXMuYmFja2dyb3VuZF9pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iZ19pbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmRyYXcodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wYXR0ZXJuID09IG51bGwgJiYgdGhpcy5fYmdfaW1nLndpZHRoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odGhpcy5fYmdfaW1nLCBcInJlcGVhdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGF0dGVybl9pbWcgPSB0aGlzLl9iZ19pbWc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl9wYXR0ZXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlX2FyZWFbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVfYXJlYVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZV9hcmVhWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlX2FyZWFbM11cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxLjA7XG4gICAgICAgICAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSB0cnVlOyAvLz0gY3R4Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2dyb3Vwc1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JhcGguX2dyb3Vwcy5sZW5ndGggJiYgIXRoaXMubGl2ZV9tb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3R3JvdXBzKGNhbnZhcywgY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub25EcmF3QmFja2dyb3VuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25EcmF3QmFja2dyb3VuZChjdHgsIHRoaXMudmlzaWJsZV9hcmVhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9uQmFja2dyb3VuZFJlbmRlcikge1xuICAgICAgICAgICAgICAgIC8vTEVHQUNZXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJXQVJOSU5HISBvbkJhY2tncm91bmRSZW5kZXIgZGVwcmVjYXRlZCwgbm93IGlzIG5hbWVkIG9uRHJhd0JhY2tncm91bmQgXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMub25CYWNrZ3JvdW5kUmVuZGVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9ERUJVRzogc2hvdyBjbGlwcGluZyBhcmVhXG4gICAgICAgICAgICAvL2N0eC5maWxsU3R5bGUgPSBcInJlZFwiO1xuICAgICAgICAgICAgLy9jdHguZmlsbFJlY3QoIHRoaXMudmlzaWJsZV9hcmVhWzBdICsgMTAsIHRoaXMudmlzaWJsZV9hcmVhWzFdICsgMTAsIHRoaXMudmlzaWJsZV9hcmVhWzJdIC0gMjAsIHRoaXMudmlzaWJsZV9hcmVhWzNdIC0gMjApO1xuXG4gICAgICAgICAgICAvL2JnXG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJfY2FudmFzX2JvcmRlcikge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiIzIzNVwiO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcl9jb25uZWN0aW9uc19zaGFkb3dzKSB7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCIjMDAwXCI7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwicmdiYSgwLDAsMCwwKVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2RyYXcgY29ubmVjdGlvbnNcbiAgICAgICAgICAgIGlmICghdGhpcy5saXZlX21vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdDb25uZWN0aW9ucyhjdHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBcInJnYmEoMCwwLDAsMClcIjtcblxuICAgICAgICAgICAgLy9yZXN0b3JlIHN0YXRlXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN0eC5maW5pc2gpIHtcbiAgICAgICAgICAgIGN0eC5maW5pc2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlOyAvL3RvIGZvcmNlIHRvIHJlcGFpbnQgdGhlIGZyb250IGNhbnZhcyB3aXRoIHRoZSBiZ2NhbnZhc1xuICAgIH07XG5cbiAgICB2YXIgdGVtcF92ZWMyID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcblxuICAgIC8qKlxuICAgICAqIGRyYXdzIHRoZSBnaXZlbiBub2RlIGluc2lkZSB0aGUgY2FudmFzXG4gICAgICogQG1ldGhvZCBkcmF3Tm9kZVxuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmRyYXdOb2RlID0gZnVuY3Rpb24obm9kZSwgY3R4KSB7XG4gICAgICAgIHZhciBnbG93ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3VycmVudF9ub2RlID0gbm9kZTtcblxuICAgICAgICB2YXIgY29sb3IgPSBub2RlLmNvbG9yIHx8IG5vZGUuY29uc3RydWN0b3IuY29sb3IgfHwgTGl0ZUdyYXBoLk5PREVfREVGQVVMVF9DT0xPUjtcbiAgICAgICAgdmFyIGJnY29sb3IgPSBub2RlLmJnY29sb3IgfHwgbm9kZS5jb25zdHJ1Y3Rvci5iZ2NvbG9yIHx8IExpdGVHcmFwaC5OT0RFX0RFRkFVTFRfQkdDT0xPUjtcblxuICAgICAgICAvL3NoYWRvdyBhbmQgZ2xvd1xuICAgICAgICBpZiAobm9kZS5tb3VzZU92ZXIpIHtcbiAgICAgICAgICAgIGdsb3cgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvd19xdWFsaXR5ID0gdGhpcy5kcy5zY2FsZSA8IDAuNjsgLy96b29tZWQgb3V0XG5cbiAgICAgICAgLy9vbmx5IHJlbmRlciBpZiBpdCBmb3JjZXMgaXQgdG8gZG8gaXRcbiAgICAgICAgaWYgKHRoaXMubGl2ZV9tb2RlKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm9uRHJhd0ZvcmVncm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5vbkRyYXdGb3JlZ3JvdW5kKGN0eCwgdGhpcywgdGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlZGl0b3JfYWxwaGEgPSB0aGlzLmVkaXRvcl9hbHBoYTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZWRpdG9yX2FscGhhO1xuXG4gICAgICAgIGlmICh0aGlzLnJlbmRlcl9zaGFkb3dzICYmICFsb3dfcXVhbGl0eSkge1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gTGl0ZUdyYXBoLkRFRkFVTFRfU0hBRE9XX0NPTE9SO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSAyICogdGhpcy5kcy5zY2FsZTtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gMiAqIHRoaXMuZHMuc2NhbGU7XG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDMgKiB0aGlzLmRzLnNjYWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jdXN0b20gZHJhdyBjb2xsYXBzZWQgbWV0aG9kIChkcmF3IGFmdGVyIHNoYWRvd3MgYmVjYXVzZSB0aGV5IGFyZSBhZmZlY3RlZClcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbm9kZS5mbGFncy5jb2xsYXBzZWQgJiZcbiAgICAgICAgICAgIG5vZGUub25EcmF3Q29sbGFwc2VkICYmXG4gICAgICAgICAgICBub2RlLm9uRHJhd0NvbGxhcHNlZChjdHgsIHRoaXMpID09IHRydWVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL2NsaXAgaWYgcmVxdWlyZWQgKG1hc2spXG4gICAgICAgIHZhciBzaGFwZSA9IG5vZGUuX3NoYXBlIHx8IExpdGVHcmFwaC5CT1hfU0hBUEU7XG4gICAgICAgIHZhciBzaXplID0gdGVtcF92ZWMyO1xuICAgICAgICB0ZW1wX3ZlYzIuc2V0KG5vZGUuc2l6ZSk7XG4gICAgICAgIHZhciBob3Jpem9udGFsID0gbm9kZS5ob3Jpem9udGFsOyAvLyB8fCBub2RlLmZsYWdzLmhvcml6b250YWw7XG5cbiAgICAgICAgaWYgKG5vZGUuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICBjdHguZm9udCA9IHRoaXMuaW5uZXJfdGV4dF9mb250O1xuICAgICAgICAgICAgdmFyIHRpdGxlID0gbm9kZS5nZXRUaXRsZSA/IG5vZGUuZ2V0VGl0bGUoKSA6IG5vZGUudGl0bGU7XG4gICAgICAgICAgICBpZiAodGl0bGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5vZGUuX2NvbGxhcHNlZF93aWR0aCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICBub2RlLnNpemVbMF0sXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tZWFzdXJlVGV4dCh0aXRsZSkud2lkdGggK1xuICAgICAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICogMlxuICAgICAgICAgICAgICAgICk7IC8vTGl0ZUdyYXBoLk5PREVfQ09MTEFQU0VEX1dJRFRIO1xuICAgICAgICAgICAgICAgIHNpemVbMF0gPSBub2RlLl9jb2xsYXBzZWRfd2lkdGg7XG4gICAgICAgICAgICAgICAgc2l6ZVsxXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5jbGlwX2FyZWEpIHtcbiAgICAgICAgICAgIC8vU3RhcnQgY2xpcHBpbmdcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBpZiAoc2hhcGUgPT0gTGl0ZUdyYXBoLkJPWF9TSEFQRSkge1xuICAgICAgICAgICAgICAgIGN0eC5yZWN0KDAsIDAsIHNpemVbMF0sIHNpemVbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PSBMaXRlR3JhcGguUk9VTkRfU0hBUEUpIHtcbiAgICAgICAgICAgICAgICBjdHgucm91bmRSZWN0KDAsIDAsIHNpemVbMF0sIHNpemVbMV0sIFsxMF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PSBMaXRlR3JhcGguQ0lSQ0xFX1NIQVBFKSB7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyhcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVswXSAqIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVsxXSAqIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVswXSAqIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSAqIDJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZHJhdyBzaGFwZVxuICAgICAgICBpZiAobm9kZS5oYXNfZXJyb3JzKSB7XG4gICAgICAgICAgICBiZ2NvbG9yID0gXCJyZWRcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYXdOb2RlU2hhcGUoXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgYmdjb2xvcixcbiAgICAgICAgICAgIG5vZGUuaXNfc2VsZWN0ZWQsXG4gICAgICAgICAgICBub2RlLm1vdXNlT3ZlclxuICAgICAgICApO1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG5cbiAgICAgICAgLy9kcmF3IGZvcmVncm91bmRcbiAgICAgICAgaWYgKG5vZGUub25EcmF3Rm9yZWdyb3VuZCkge1xuICAgICAgICAgICAgbm9kZS5vbkRyYXdGb3JlZ3JvdW5kKGN0eCwgdGhpcywgdGhpcy5jYW52YXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jb25uZWN0aW9uIHNsb3RzXG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBob3Jpem9udGFsID8gXCJjZW50ZXJcIiA6IFwibGVmdFwiO1xuICAgICAgICBjdHguZm9udCA9IHRoaXMuaW5uZXJfdGV4dF9mb250O1xuXG4gICAgICAgIHZhciByZW5kZXJfdGV4dCA9ICFsb3dfcXVhbGl0eTtcblxuICAgICAgICB2YXIgb3V0X3Nsb3QgPSB0aGlzLmNvbm5lY3Rpbmdfb3V0cHV0O1xuICAgICAgICB2YXIgaW5fc2xvdCA9IHRoaXMuY29ubmVjdGluZ19pbnB1dDtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG5cbiAgICAgICAgdmFyIG1heF95ID0gMDtcbiAgICAgICAgdmFyIHNsb3RfcG9zID0gbmV3IEZsb2F0MzJBcnJheSgyKTsgLy90byByZXVzZVxuXG4gICAgICAgIC8vcmVuZGVyIGlucHV0cyBhbmQgb3V0cHV0c1xuICAgICAgICBpZiAoIW5vZGUuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAvL2lucHV0IGNvbm5lY3Rpb24gc2xvdHNcbiAgICAgICAgICAgIGlmIChub2RlLmlucHV0cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5pbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBub2RlLmlucHV0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90X3R5cGUgPSBzbG90LnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90X3NoYXBlID0gc2xvdC5zaGFwZTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGVkaXRvcl9hbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgLy9jaGFuZ2Ugb3BhY2l0eSBvZiBpbmNvbXBhdGlibGUgc2xvdHMgd2hlbiBkcmFnZ2luZyBhIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLmNvbm5lY3Rpbmdfb3V0cHV0ICYmICFMaXRlR3JhcGguaXNWYWxpZENvbm5lY3Rpb24oIHNsb3QudHlwZSAsIG91dF9zbG90LnR5cGUpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC40ICogZWRpdG9yX2FscGhhO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90LmxpbmsgIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2xvdC5jb2xvcl9vbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0X2Nvbm5lY3Rpb25fY29sb3JfYnlUeXBlW3Nsb3RfdHlwZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdF9jb25uZWN0aW9uX2NvbG9yLmlucHV0X29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzbG90LmNvbG9yX29mZiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0X2Nvbm5lY3Rpb25fY29sb3JfYnlUeXBlT2ZmW3Nsb3RfdHlwZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdF9jb25uZWN0aW9uX2NvbG9yX2J5VHlwZVtzbG90X3R5cGVdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRfY29ubmVjdGlvbl9jb2xvci5pbnB1dF9vZmY7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IG5vZGUuZ2V0Q29ubmVjdGlvblBvcyh0cnVlLCBpLCBzbG90X3Bvcyk7XG4gICAgICAgICAgICAgICAgICAgIHBvc1swXSAtPSBub2RlLnBvc1swXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zWzFdIC09IG5vZGUucG9zWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF4X3kgPCBwb3NbMV0gKyBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCAqIDAuNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4X3kgPSBwb3NbMV0gKyBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdFx0XHRcdGlmIChzbG90X3R5cGUgPT0gXCJhcnJheVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3Rfc2hhcGUgPSBMaXRlR3JhcGguR1JJRF9TSEFQRTsgLy8gcGxhY2UgaW4gYWRkSW5wdXQ/IGFkZE91dHB1dCBpbnN0ZWFkP1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgZG9TdHJva2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdC50eXBlID09PSBMaXRlR3JhcGguRVZFTlQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3Quc2hhcGUgPT09IExpdGVHcmFwaC5CT1hfU0hBUEVcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NbMF0gLSA1ICsgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NbMV0gLSA4ICsgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zWzBdIC0gNiArIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zWzFdIC0gNSArIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzbG90X3NoYXBlID09PSBMaXRlR3JhcGguQVJST1dfU0hBUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9zWzBdICsgOCwgcG9zWzFdICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9zWzBdIC0gNCwgcG9zWzFdICsgNiArIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBvc1swXSAtIDQsIHBvc1sxXSAtIDYgKyAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNsb3Rfc2hhcGUgPT09IExpdGVHcmFwaC5HUklEX1NIQVBFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChwb3NbMF0gLSA0LCBwb3NbMV0gLSA0LCAyLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHBvc1swXSAtIDEsIHBvc1sxXSAtIDQsIDIsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QocG9zWzBdICsgMiwgcG9zWzFdIC0gNCwgMiwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChwb3NbMF0gLSA0LCBwb3NbMV0gLSAxLCAyLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHBvc1swXSAtIDEsIHBvc1sxXSAtIDEsIDIsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QocG9zWzBdICsgMiwgcG9zWzFdIC0gMSwgMiwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChwb3NbMF0gLSA0LCBwb3NbMV0gKyAyLCAyLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHBvc1swXSAtIDEsIHBvc1sxXSArIDIsIDIsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QocG9zWzBdICsgMiwgcG9zWzFdICsgMiwgMiwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb1N0cm9rZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYobG93X3F1YWxpdHkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHBvc1swXSAtIDQsIHBvc1sxXSAtIDQsIDgsIDggKTsgLy9mYXN0ZXJcblx0XHRcdFx0XHRcdGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhwb3NbMF0sIHBvc1sxXSwgNCwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9yZW5kZXIgbmFtZVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVuZGVyX3RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gc2xvdC5sYWJlbCAhPSBudWxsID8gc2xvdC5sYWJlbCA6IHNsb3QubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IExpdGVHcmFwaC5OT0RFX1RFWFRfQ09MT1I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvcml6b250YWwgfHwgc2xvdC5kaXIgPT0gTGl0ZUdyYXBoLlVQKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCBwb3NbMF0sIHBvc1sxXSAtIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgcG9zWzBdICsgMTAsIHBvc1sxXSArIDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9vdXRwdXQgY29ubmVjdGlvbiBzbG90c1xuXG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gaG9yaXpvbnRhbCA/IFwiY2VudGVyXCIgOiBcInJpZ2h0XCI7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgICAgICBpZiAobm9kZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLm91dHB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBub2RlLm91dHB1dHNbaV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdF90eXBlID0gc2xvdC50eXBlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdF9zaGFwZSA9IHNsb3Quc2hhcGU7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL2NoYW5nZSBvcGFjaXR5IG9mIGluY29tcGF0aWJsZSBzbG90cyB3aGVuIGRyYWdnaW5nIGEgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW5nX2lucHV0ICYmICFMaXRlR3JhcGguaXNWYWxpZENvbm5lY3Rpb24oIHNsb3RfdHlwZSAsIGluX3Nsb3QudHlwZSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjQgKiBlZGl0b3JfYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBub2RlLmdldENvbm5lY3Rpb25Qb3MoZmFsc2UsIGksIHNsb3RfcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zWzBdIC09IG5vZGUucG9zWzBdO1xuICAgICAgICAgICAgICAgICAgICBwb3NbMV0gLT0gbm9kZS5wb3NbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhfeSA8IHBvc1sxXSArIExpdGVHcmFwaC5OT0RFX1NMT1RfSEVJR0hUICogMC41KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhfeSA9IHBvc1sxXSArIExpdGVHcmFwaC5OT0RFX1NMT1RfSEVJR0hUICogMC41O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90LmxpbmtzICYmIHNsb3QubGlua3MubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzbG90LmNvbG9yX29uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRfY29ubmVjdGlvbl9jb2xvcl9ieVR5cGVbc2xvdF90eXBlXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0X2Nvbm5lY3Rpb25fY29sb3Iub3V0cHV0X29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzbG90LmNvbG9yX29mZiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0X2Nvbm5lY3Rpb25fY29sb3JfYnlUeXBlT2ZmW3Nsb3RfdHlwZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdF9jb25uZWN0aW9uX2NvbG9yX2J5VHlwZVtzbG90X3R5cGVdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRfY29ubmVjdGlvbl9jb2xvci5vdXRwdXRfb2ZmO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vY3R4LnJlY3QoIG5vZGUuc2l6ZVswXSAtIDE0LGkqMTQsMTAsMTApO1xuXG5cdFx0XHRcdFx0aWYgKHNsb3RfdHlwZSA9PSBcImFycmF5XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdF9zaGFwZSA9IExpdGVHcmFwaC5HUklEX1NIQVBFO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgZG9TdHJva2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdF90eXBlID09PSBMaXRlR3JhcGguRVZFTlQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3Rfc2hhcGUgPT09IExpdGVHcmFwaC5CT1hfU0hBUEVcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NbMF0gLSA1ICsgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NbMV0gLSA4ICsgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zWzBdIC0gNiArIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zWzFdIC0gNSArIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzbG90X3NoYXBlID09PSBMaXRlR3JhcGguQVJST1dfU0hBUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9zWzBdICsgOCwgcG9zWzFdICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9zWzBdIC0gNCwgcG9zWzFdICsgNiArIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBvc1swXSAtIDQsIHBvc1sxXSAtIDYgKyAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB9ICBlbHNlIGlmIChzbG90X3NoYXBlID09PSBMaXRlR3JhcGguR1JJRF9TSEFQRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QocG9zWzBdIC0gNCwgcG9zWzFdIC0gNCwgMiwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChwb3NbMF0gLSAxLCBwb3NbMV0gLSA0LCAyLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHBvc1swXSArIDIsIHBvc1sxXSAtIDQsIDIsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QocG9zWzBdIC0gNCwgcG9zWzFdIC0gMSwgMiwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChwb3NbMF0gLSAxLCBwb3NbMV0gLSAxLCAyLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHBvc1swXSArIDIsIHBvc1sxXSAtIDEsIDIsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QocG9zWzBdIC0gNCwgcG9zWzFdICsgMiwgMiwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChwb3NbMF0gLSAxLCBwb3NbMV0gKyAyLCAyLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHBvc1swXSArIDIsIHBvc1sxXSArIDIsIDIsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9TdHJva2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmKGxvd19xdWFsaXR5KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChwb3NbMF0gLSA0LCBwb3NbMV0gLSA0LCA4LCA4ICk7XG5cdFx0XHRcdFx0XHRlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMocG9zWzBdLCBwb3NbMV0sIDQsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vdHJpZ2dlclxuICAgICAgICAgICAgICAgICAgICAvL2lmKHNsb3Qubm9kZV9pZCAhPSBudWxsICYmIHNsb3Quc2xvdCA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgLy9cdGN0eC5maWxsU3R5bGUgPSBcIiNGODVcIjtcblxuICAgICAgICAgICAgICAgICAgICAvL2lmKHNsb3QubGlua3MgIT0gbnVsbCAmJiBzbG90LmxpbmtzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcblx0XHRcdFx0XHRpZighbG93X3F1YWxpdHkgJiYgZG9TdHJva2UpXG5cdCAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vcmVuZGVyIG91dHB1dCBuYW1lXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW5kZXJfdGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBzbG90LmxhYmVsICE9IG51bGwgPyBzbG90LmxhYmVsIDogc2xvdC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gTGl0ZUdyYXBoLk5PREVfVEVYVF9DT0xPUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9yaXpvbnRhbCB8fCBzbG90LmRpciA9PSBMaXRlR3JhcGguRE9XTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgcG9zWzBdLCBwb3NbMV0gLSA4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgcG9zWzBdIC0gMTAsIHBvc1sxXSArIDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcblxuICAgICAgICAgICAgaWYgKG5vZGUud2lkZ2V0cykge1xuXHRcdFx0XHR2YXIgd2lkZ2V0c195ID0gbWF4X3k7XG4gICAgICAgICAgICAgICAgaWYgKGhvcml6b250YWwgfHwgbm9kZS53aWRnZXRzX3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZGdldHNfeSA9IDI7XG4gICAgICAgICAgICAgICAgfVxuXHRcdFx0XHRpZiggbm9kZS53aWRnZXRzX3N0YXJ0X3kgIT0gbnVsbCApXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldHNfeSA9IG5vZGUud2lkZ2V0c19zdGFydF95O1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd05vZGVXaWRnZXRzKFxuICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICB3aWRnZXRzX3ksXG4gICAgICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlX3dpZGdldCAmJiB0aGlzLm5vZGVfd2lkZ2V0WzBdID09IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5ub2RlX3dpZGdldFsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlbmRlcl9jb2xsYXBzZWRfc2xvdHMpIHtcbiAgICAgICAgICAgIC8vaWYgY29sbGFwc2VkXG4gICAgICAgICAgICB2YXIgaW5wdXRfc2xvdCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgb3V0cHV0X3Nsb3QgPSBudWxsO1xuXG4gICAgICAgICAgICAvL2dldCBmaXJzdCBjb25uZWN0ZWQgc2xvdCB0byByZW5kZXJcbiAgICAgICAgICAgIGlmIChub2RlLmlucHV0cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5pbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBub2RlLmlucHV0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3QubGluayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnB1dF9zbG90ID0gc2xvdDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUub3V0cHV0cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5vdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90ID0gbm9kZS5vdXRwdXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNsb3QubGlua3MgfHwgIXNsb3QubGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRfc2xvdCA9IHNsb3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5wdXRfc2xvdCkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCAqIC0wLjU7IC8vY2VudGVyXG4gICAgICAgICAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IG5vZGUuX2NvbGxhcHNlZF93aWR0aCAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IC1MaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiM2ODZcIjtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBzbG90LnR5cGUgPT09IExpdGVHcmFwaC5FVkVOVCB8fFxuICAgICAgICAgICAgICAgICAgICBzbG90LnNoYXBlID09PSBMaXRlR3JhcGguQk9YX1NIQVBFXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHggLSA3ICsgMC41LCB5IC0gNCwgMTQsIDgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2xvdC5zaGFwZSA9PT0gTGl0ZUdyYXBoLkFSUk9XX1NIQVBFKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIDgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyAtNCwgeSAtIDQpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyAtNCwgeSArIDQpO1xuICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCA0LCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvdXRwdXRfc2xvdCkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gbm9kZS5fY29sbGFwc2VkX3dpZHRoO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICogLTAuNTsgLy9jZW50ZXJcbiAgICAgICAgICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gbm9kZS5fY29sbGFwc2VkX3dpZHRoICogMC41O1xuICAgICAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzY4NlwiO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBzbG90LnR5cGUgPT09IExpdGVHcmFwaC5FVkVOVCB8fFxuICAgICAgICAgICAgICAgICAgICBzbG90LnNoYXBlID09PSBMaXRlR3JhcGguQk9YX1NIQVBFXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHggLSA3ICsgMC41LCB5IC0gNCwgMTQsIDgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2xvdC5zaGFwZSA9PT0gTGl0ZUdyYXBoLkFSUk9XX1NIQVBFKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIDYsIHkpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggLSA2LCB5IC0gNCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCAtIDYsIHkgKyA0KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgNCwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIC8vY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUuY2xpcF9hcmVhKSB7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMS4wO1xuICAgIH07XG5cblx0Ly91c2VkIGJ5IHRoaXMub3Zlcl9saW5rX2NlbnRlclxuXHRMR3JhcGhDYW52YXMucHJvdG90eXBlLmRyYXdMaW5rVG9vbHRpcCA9IGZ1bmN0aW9uKCBjdHgsIGxpbmsgKVxuXHR7XG5cdFx0dmFyIHBvcyA9IGxpbmsuX3Bvcztcblx0XHRjdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHguYXJjKCBwb3NbMF0sIHBvc1sxXSwgMywgMCwgTWF0aC5QSSAqIDIgKTtcblx0XHRjdHguZmlsbCgpO1xuXG5cdFx0aWYobGluay5kYXRhID09IG51bGwpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRpZih0aGlzLm9uRHJhd0xpbmtUb29sdGlwKVxuXHRcdFx0aWYoIHRoaXMub25EcmF3TGlua1Rvb2x0aXAoY3R4LGxpbmssdGhpcykgPT0gdHJ1ZSApXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdHZhciBkYXRhID0gbGluay5kYXRhO1xuXHRcdHZhciB0ZXh0ID0gbnVsbDtcblxuXHRcdGlmKCBkYXRhLmNvbnN0cnVjdG9yID09PSBOdW1iZXIgKVxuXHRcdFx0dGV4dCA9IGRhdGEudG9GaXhlZCgyKTtcblx0XHRlbHNlIGlmKCBkYXRhLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgKVxuXHRcdFx0dGV4dCA9IFwiXFxcIlwiICsgZGF0YSArIFwiXFxcIlwiO1xuXHRcdGVsc2UgaWYoIGRhdGEuY29uc3RydWN0b3IgPT09IEJvb2xlYW4gKVxuXHRcdFx0dGV4dCA9IFN0cmluZyhkYXRhKTtcblx0XHRlbHNlIGlmIChkYXRhLnRvVG9vbFRpcClcblx0XHRcdHRleHQgPSBkYXRhLnRvVG9vbFRpcCgpO1xuXHRcdGVsc2Vcblx0XHRcdHRleHQgPSBcIltcIiArIGRhdGEuY29uc3RydWN0b3IubmFtZSArIFwiXVwiO1xuXG5cdFx0aWYodGV4dCA9PSBudWxsKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRleHQgPSB0ZXh0LnN1YnN0cigwLDMwKTsgLy9hdm9pZCB3ZWlyZFxuXG5cdFx0Y3R4LmZvbnQgPSBcIjE0cHggQ291cmllciBOZXdcIjtcblx0XHR2YXIgaW5mbyA9IGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcblx0XHR2YXIgdyA9IGluZm8ud2lkdGggKyAyMDtcblx0XHR2YXIgaCA9IDI0O1xuXHRcdGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcblx0XHRjdHguc2hhZG93T2Zmc2V0WCA9IDI7XG5cdFx0Y3R4LnNoYWRvd09mZnNldFkgPSAyO1xuXHRcdGN0eC5zaGFkb3dCbHVyID0gMztcblx0XHRjdHguZmlsbFN0eWxlID0gXCIjNDU0XCI7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5yb3VuZFJlY3QoIHBvc1swXSAtIHcqMC41LCBwb3NbMV0gLSAxNSAtIGgsIHcsIGgsIFszXSk7XG5cdFx0Y3R4Lm1vdmVUbyggcG9zWzBdIC0gMTAsIHBvc1sxXSAtIDE1ICk7XG5cdFx0Y3R4LmxpbmVUbyggcG9zWzBdICsgMTAsIHBvc1sxXSAtIDE1ICk7XG5cdFx0Y3R4LmxpbmVUbyggcG9zWzBdLCBwb3NbMV0gLSA1ICk7XG5cdFx0Y3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuXHRcdGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuXHRcdGN0eC5maWxsU3R5bGUgPSBcIiNDRUNcIjtcblx0XHRjdHguZmlsbFRleHQodGV4dCwgcG9zWzBdLCBwb3NbMV0gLSAxNSAtIGggKiAwLjMpO1xuXHR9XG5cbiAgICAvKipcbiAgICAgKiBkcmF3cyB0aGUgc2hhcGUgb2YgdGhlIGdpdmVuIG5vZGUgaW4gdGhlIGNhbnZhc1xuICAgICAqIEBtZXRob2QgZHJhd05vZGVTaGFwZVxuICAgICAqKi9cbiAgICB2YXIgdG1wX2FyZWEgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kcmF3Tm9kZVNoYXBlID0gZnVuY3Rpb24oXG4gICAgICAgIG5vZGUsXG4gICAgICAgIGN0eCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgZmdjb2xvcixcbiAgICAgICAgYmdjb2xvcixcbiAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgIG1vdXNlX292ZXJcbiAgICApIHtcbiAgICAgICAgLy9iZyByZWN0XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGZnY29sb3I7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBiZ2NvbG9yO1xuXG4gICAgICAgIHZhciB0aXRsZV9oZWlnaHQgPSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQ7XG4gICAgICAgIHZhciBsb3dfcXVhbGl0eSA9IHRoaXMuZHMuc2NhbGUgPCAwLjU7XG5cbiAgICAgICAgLy9yZW5kZXIgbm9kZSBhcmVhIGRlcGVuZGluZyBvbiBzaGFwZVxuICAgICAgICB2YXIgc2hhcGUgPVxuICAgICAgICAgICAgbm9kZS5fc2hhcGUgfHwgbm9kZS5jb25zdHJ1Y3Rvci5zaGFwZSB8fCBMaXRlR3JhcGguUk9VTkRfU0hBUEU7XG5cbiAgICAgICAgdmFyIHRpdGxlX21vZGUgPSBub2RlLmNvbnN0cnVjdG9yLnRpdGxlX21vZGU7XG5cbiAgICAgICAgdmFyIHJlbmRlcl90aXRsZSA9IHRydWU7XG4gICAgICAgIGlmICh0aXRsZV9tb2RlID09IExpdGVHcmFwaC5UUkFOU1BBUkVOVF9USVRMRSB8fCB0aXRsZV9tb2RlID09IExpdGVHcmFwaC5OT19USVRMRSkge1xuICAgICAgICAgICAgcmVuZGVyX3RpdGxlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodGl0bGVfbW9kZSA9PSBMaXRlR3JhcGguQVVUT0hJREVfVElUTEUgJiYgbW91c2Vfb3Zlcikge1xuICAgICAgICAgICAgcmVuZGVyX3RpdGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcmVhID0gdG1wX2FyZWE7XG4gICAgICAgIGFyZWFbMF0gPSAwOyAvL3hcbiAgICAgICAgYXJlYVsxXSA9IHJlbmRlcl90aXRsZSA/IC10aXRsZV9oZWlnaHQgOiAwOyAvL3lcbiAgICAgICAgYXJlYVsyXSA9IHNpemVbMF0gKyAxOyAvL3dcbiAgICAgICAgYXJlYVszXSA9IHJlbmRlcl90aXRsZSA/IHNpemVbMV0gKyB0aXRsZV9oZWlnaHQgOiBzaXplWzFdOyAvL2hcblxuICAgICAgICB2YXIgb2xkX2FscGhhID0gY3R4Lmdsb2JhbEFscGhhO1xuXG4gICAgICAgIC8vZnVsbCBub2RlIHNoYXBlXG4gICAgICAgIC8vaWYobm9kZS5mbGFncy5jb2xsYXBzZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGlmIChzaGFwZSA9PSBMaXRlR3JhcGguQk9YX1NIQVBFIHx8IGxvd19xdWFsaXR5KSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGFyZWFbMF0sIGFyZWFbMV0sIGFyZWFbMl0sIGFyZWFbM10pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzaGFwZSA9PSBMaXRlR3JhcGguUk9VTkRfU0hBUEUgfHxcbiAgICAgICAgICAgICAgICBzaGFwZSA9PSBMaXRlR3JhcGguQ0FSRF9TSEFQRVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY3R4LnJvdW5kUmVjdChcbiAgICAgICAgICAgICAgICAgICAgYXJlYVswXSxcbiAgICAgICAgICAgICAgICAgICAgYXJlYVsxXSxcbiAgICAgICAgICAgICAgICAgICAgYXJlYVsyXSxcbiAgICAgICAgICAgICAgICAgICAgYXJlYVszXSxcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUgPT0gTGl0ZUdyYXBoLkNBUkRfU0hBUEUgPyBbdGhpcy5yb3VuZF9yYWRpdXMsdGhpcy5yb3VuZF9yYWRpdXMsMCwwXSA6IFt0aGlzLnJvdW5kX3JhZGl1c10gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT0gTGl0ZUdyYXBoLkNJUkNMRV9TSEFQRSkge1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoXG4gICAgICAgICAgICAgICAgICAgIHNpemVbMF0gKiAwLjUsXG4gICAgICAgICAgICAgICAgICAgIHNpemVbMV0gKiAwLjUsXG4gICAgICAgICAgICAgICAgICAgIHNpemVbMF0gKiAwLjUsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIE1hdGguUEkgKiAyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG5cblx0XHRcdC8vc2VwYXJhdG9yXG5cdFx0XHRpZighbm9kZS5mbGFncy5jb2xsYXBzZWQgJiYgcmVuZGVyX3RpdGxlKVxuXHRcdFx0e1xuXHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMCwwLDAsMC4yKVwiO1xuXHRcdFx0XHRjdHguZmlsbFJlY3QoMCwgLTEsIGFyZWFbMl0sIDIpO1xuXHRcdFx0fVxuICAgICAgICB9XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcblxuICAgICAgICBpZiAobm9kZS5vbkRyYXdCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICBub2RlLm9uRHJhd0JhY2tncm91bmQoY3R4LCB0aGlzLCB0aGlzLmNhbnZhcywgdGhpcy5ncmFwaF9tb3VzZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy90aXRsZSBiZyAocmVtZW1iZXIsIGl0IGlzIHJlbmRlcmVkIEFCT1ZFIHRoZSBub2RlKVxuICAgICAgICBpZiAocmVuZGVyX3RpdGxlIHx8IHRpdGxlX21vZGUgPT0gTGl0ZUdyYXBoLlRSQU5TUEFSRU5UX1RJVExFKSB7XG4gICAgICAgICAgICAvL3RpdGxlIGJhclxuICAgICAgICAgICAgaWYgKG5vZGUub25EcmF3VGl0bGVCYXIpIHtcbiAgICAgICAgICAgICAgICBub2RlLm9uRHJhd1RpdGxlQmFyKCBjdHgsIHRpdGxlX2hlaWdodCwgc2l6ZSwgdGhpcy5kcy5zY2FsZSwgZmdjb2xvciApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICB0aXRsZV9tb2RlICE9IExpdGVHcmFwaC5UUkFOU1BBUkVOVF9USVRMRSAmJlxuICAgICAgICAgICAgICAgIChub2RlLmNvbnN0cnVjdG9yLnRpdGxlX2NvbG9yIHx8IHRoaXMucmVuZGVyX3RpdGxlX2NvbG9yZWQpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgdGl0bGVfY29sb3IgPSBub2RlLmNvbnN0cnVjdG9yLnRpdGxlX2NvbG9yIHx8IGZnY29sb3I7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gTGl0ZUdyYXBoLkRFRkFVTFRfU0hBRE9XX0NPTE9SO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vKiBncmFkaWVudCB0ZXN0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlX2dyYWRpZW50cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JhZCA9IExHcmFwaENhbnZhcy5ncmFkaWVudHNbdGl0bGVfY29sb3JdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdyYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWQgPSBMR3JhcGhDYW52YXMuZ3JhZGllbnRzWyB0aXRsZV9jb2xvciBdID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIDQwMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkLmFkZENvbG9yU3RvcCgwLCB0aXRsZV9jb2xvcik7IC8vIFRPRE8gcmVmYWN0b3I6IHZhbGlkYXRlIGNvbG9yICEhIHByZXZlbnQgRE9NRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkLmFkZENvbG9yU3RvcCgxLCBcIiMwMDBcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyYWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRpdGxlX2NvbG9yO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vY3R4Lmdsb2JhbEFscGhhID0gMC41ICogb2xkX2FscGhhO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUgPT0gTGl0ZUdyYXBoLkJPWF9TSEFQRSB8fCBsb3dfcXVhbGl0eSkge1xuICAgICAgICAgICAgICAgICAgICBjdHgucmVjdCgwLCAtdGl0bGVfaGVpZ2h0LCBzaXplWzBdICsgMSwgdGl0bGVfaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCAgc2hhcGUgPT0gTGl0ZUdyYXBoLlJPVU5EX1NIQVBFIHx8IHNoYXBlID09IExpdGVHcmFwaC5DQVJEX1NIQVBFICkge1xuICAgICAgICAgICAgICAgICAgICBjdHgucm91bmRSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC10aXRsZV9oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplWzBdICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlX2hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZmxhZ3MuY29sbGFwc2VkID8gW3RoaXMucm91bmRfcmFkaXVzXSA6IFt0aGlzLnJvdW5kX3JhZGl1cyx0aGlzLnJvdW5kX3JhZGl1cywwLDBdXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29sU3RhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChMaXRlR3JhcGgubm9kZV9ib3hfY29sb3VyZWRfYnlfbW9kZSl7XG4gICAgICAgICAgICAgICAgaWYoTGl0ZUdyYXBoLk5PREVfTU9ERVNfQ09MT1JTW25vZGUubW9kZV0pe1xuICAgICAgICAgICAgICAgICAgICBjb2xTdGF0ZSA9IExpdGVHcmFwaC5OT0RFX01PREVTX0NPTE9SU1tub2RlLm1vZGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChMaXRlR3JhcGgubm9kZV9ib3hfY29sb3VyZWRfd2hlbl9vbil7XG4gICAgICAgICAgICAgICAgY29sU3RhdGUgPSBub2RlLmFjdGlvbl90cmlnZ2VyZWQgPyBcIiNGRkZcIiA6IChub2RlLmV4ZWN1dGVfdHJpZ2dlcmVkID8gXCIjQUFBXCIgOiBjb2xTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vdGl0bGUgYm94XG4gICAgICAgICAgICB2YXIgYm94X3NpemUgPSAxMDtcbiAgICAgICAgICAgIGlmIChub2RlLm9uRHJhd1RpdGxlQm94KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5vbkRyYXdUaXRsZUJveChjdHgsIHRpdGxlX2hlaWdodCwgc2l6ZSwgdGhpcy5kcy5zY2FsZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHNoYXBlID09IExpdGVHcmFwaC5ST1VORF9TSEFQRSB8fFxuICAgICAgICAgICAgICAgIHNoYXBlID09IExpdGVHcmFwaC5DSVJDTEVfU0hBUEUgfHxcbiAgICAgICAgICAgICAgICBzaGFwZSA9PSBMaXRlR3JhcGguQ0FSRF9TSEFQRVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvd19xdWFsaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlX2hlaWdodCAqIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlX2hlaWdodCAqIC0wLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3hfc2l6ZSAqIDAuNSArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSAqIDJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG5vZGUuYm94Y29sb3IgfHwgY29sU3RhdGUgfHwgTGl0ZUdyYXBoLk5PREVfREVGQVVMVF9CT1hDT0xPUjtcblx0XHRcdFx0aWYobG93X3F1YWxpdHkpXG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KCB0aXRsZV9oZWlnaHQgKiAwLjUgLSBib3hfc2l6ZSAqMC41LCB0aXRsZV9oZWlnaHQgKiAtMC41IC0gYm94X3NpemUgKjAuNSwgYm94X3NpemUgLCBib3hfc2l6ZSAgKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdGN0eC5hcmMoXG5cdFx0XHRcdFx0XHR0aXRsZV9oZWlnaHQgKiAwLjUsXG5cdFx0XHRcdFx0XHR0aXRsZV9oZWlnaHQgKiAtMC41LFxuXHRcdFx0XHRcdFx0Ym94X3NpemUgKiAwLjUsXG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0TWF0aC5QSSAqIDJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRcdH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvd19xdWFsaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aXRsZV9oZWlnaHQgLSBib3hfc2l6ZSkgKiAwLjUgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRpdGxlX2hlaWdodCArIGJveF9zaXplKSAqIC0wLjUgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm94X3NpemUgKyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm94X3NpemUgKyAyXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBub2RlLmJveGNvbG9yIHx8IGNvbFN0YXRlIHx8IExpdGVHcmFwaC5OT0RFX0RFRkFVTFRfQk9YQ09MT1I7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAgICAgICAodGl0bGVfaGVpZ2h0IC0gYm94X3NpemUpICogMC41LFxuICAgICAgICAgICAgICAgICAgICAodGl0bGVfaGVpZ2h0ICsgYm94X3NpemUpICogLTAuNSxcbiAgICAgICAgICAgICAgICAgICAgYm94X3NpemUsXG4gICAgICAgICAgICAgICAgICAgIGJveF9zaXplXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9sZF9hbHBoYTtcblxuICAgICAgICAgICAgLy90aXRsZSB0ZXh0XG4gICAgICAgICAgICBpZiAobm9kZS5vbkRyYXdUaXRsZVRleHQpIHtcbiAgICAgICAgICAgICAgICBub2RlLm9uRHJhd1RpdGxlVGV4dChcbiAgICAgICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgICAgICB0aXRsZV9oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHMuc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGl0bGVfdGV4dF9mb250LFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxvd19xdWFsaXR5KSB7XG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGlzLnRpdGxlX3RleHRfZm9udDtcbiAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSBTdHJpbmcobm9kZS5nZXRUaXRsZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gTGl0ZUdyYXBoLk5PREVfU0VMRUNURURfVElUTEVfQ09MT1I7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnN0cnVjdG9yLnRpdGxlX3RleHRfY29sb3IgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVfdGl0bGVfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVhc3VyZSA9IGN0eC5tZWFzdXJlVGV4dCh0aXRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUuc3Vic3RyKDAsMjApLCAvL2F2b2lkIHVybHMgdG9vIGxvbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZV9oZWlnaHQsLy8gKyBtZWFzdXJlLndpZHRoICogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5OT0RFX1RJVExFX1RFWFRfWSAtIHRpdGxlX2hlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZV9oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLk5PREVfVElUTEVfVEVYVF9ZIC0gdGl0bGVfaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cdFx0XHQvL3N1YmdyYXBoIGJveFxuXHRcdFx0aWYgKCFub2RlLmZsYWdzLmNvbGxhcHNlZCAmJiBub2RlLnN1YmdyYXBoICYmICFub2RlLnNraXBfc3ViZ3JhcGhfYnV0dG9uKSB7XG5cdFx0XHRcdHZhciB3ID0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUO1xuXHRcdFx0XHR2YXIgeCA9IG5vZGUuc2l6ZVswXSAtIHc7XG5cdFx0XHRcdHZhciBvdmVyID0gTGl0ZUdyYXBoLmlzSW5zaWRlUmVjdGFuZ2xlKCB0aGlzLmdyYXBoX21vdXNlWzBdIC0gbm9kZS5wb3NbMF0sIHRoaXMuZ3JhcGhfbW91c2VbMV0gLSBub2RlLnBvc1sxXSwgeCsyLCAtdysyLCB3LTQsIHctNCApO1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gb3ZlciA/IFwiIzg4OFwiIDogXCIjNTU1XCI7XG5cdFx0XHRcdGlmKCBzaGFwZSA9PSBMaXRlR3JhcGguQk9YX1NIQVBFIHx8IGxvd19xdWFsaXR5KVxuXHRcdFx0XHRcdGN0eC5maWxsUmVjdCh4KzIsIC13KzIsIHctNCwgdy00KTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdGN0eC5yb3VuZFJlY3QoeCsyLCAtdysyLCB3LTQsIHctNCxbNF0pO1xuXHRcdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IFwiIzMzM1wiO1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5tb3ZlVG8oeCArIHcgKiAwLjIsIC13ICogMC42KTtcblx0XHRcdFx0Y3R4LmxpbmVUbyh4ICsgdyAqIDAuOCwgLXcgKiAwLjYpO1xuXHRcdFx0XHRjdHgubGluZVRvKHggKyB3ICogMC41LCAtdyAqIDAuMyk7XG5cdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vY3VzdG9tIHRpdGxlIHJlbmRlclxuICAgICAgICAgICAgaWYgKG5vZGUub25EcmF3VGl0bGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLm9uRHJhd1RpdGxlKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3JlbmRlciBzZWxlY3Rpb24gbWFya2VyXG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgaWYgKG5vZGUub25Cb3VuZGluZykge1xuICAgICAgICAgICAgICAgIG5vZGUub25Cb3VuZGluZyhhcmVhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRpdGxlX21vZGUgPT0gTGl0ZUdyYXBoLlRSQU5TUEFSRU5UX1RJVExFKSB7XG4gICAgICAgICAgICAgICAgYXJlYVsxXSAtPSB0aXRsZV9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgYXJlYVszXSArPSB0aXRsZV9oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuODtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGlmIChzaGFwZSA9PSBMaXRlR3JhcGguQk9YX1NIQVBFKSB7XG4gICAgICAgICAgICAgICAgY3R4LnJlY3QoXG4gICAgICAgICAgICAgICAgICAgIC02ICsgYXJlYVswXSxcbiAgICAgICAgICAgICAgICAgICAgLTYgKyBhcmVhWzFdLFxuICAgICAgICAgICAgICAgICAgICAxMiArIGFyZWFbMl0sXG4gICAgICAgICAgICAgICAgICAgIDEyICsgYXJlYVszXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHNoYXBlID09IExpdGVHcmFwaC5ST1VORF9TSEFQRSB8fFxuICAgICAgICAgICAgICAgIChzaGFwZSA9PSBMaXRlR3JhcGguQ0FSRF9TSEFQRSAmJiBub2RlLmZsYWdzLmNvbGxhcHNlZClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGN0eC5yb3VuZFJlY3QoXG4gICAgICAgICAgICAgICAgICAgIC02ICsgYXJlYVswXSxcbiAgICAgICAgICAgICAgICAgICAgLTYgKyBhcmVhWzFdLFxuICAgICAgICAgICAgICAgICAgICAxMiArIGFyZWFbMl0sXG4gICAgICAgICAgICAgICAgICAgIDEyICsgYXJlYVszXSxcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMucm91bmRfcmFkaXVzICogMl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PSBMaXRlR3JhcGguQ0FSRF9TSEFQRSkge1xuICAgICAgICAgICAgICAgIGN0eC5yb3VuZFJlY3QoXG4gICAgICAgICAgICAgICAgICAgIC02ICsgYXJlYVswXSxcbiAgICAgICAgICAgICAgICAgICAgLTYgKyBhcmVhWzFdLFxuICAgICAgICAgICAgICAgICAgICAxMiArIGFyZWFbMl0sXG4gICAgICAgICAgICAgICAgICAgIDEyICsgYXJlYVszXSxcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMucm91bmRfcmFkaXVzICogMiwyLHRoaXMucm91bmRfcmFkaXVzICogMiwyXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09IExpdGVHcmFwaC5DSVJDTEVfU0hBUEUpIHtcbiAgICAgICAgICAgICAgICBjdHguYXJjKFxuICAgICAgICAgICAgICAgICAgICBzaXplWzBdICogMC41LFxuICAgICAgICAgICAgICAgICAgICBzaXplWzFdICogMC41LFxuICAgICAgICAgICAgICAgICAgICBzaXplWzBdICogMC41ICsgNixcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSAqIDJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gTGl0ZUdyYXBoLk5PREVfQk9YX09VVExJTkVfQ09MT1I7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBmZ2NvbG9yO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gdGhlc2UgY291bnRlciBoZWxwcyBpbiBjb25kaXRpb25pbmcgZHJhd2luZyBiYXNlZCBvbiBpZiB0aGUgbm9kZSBoYXMgYmVlbiBleGVjdXRlZCBvciBhbiBhY3Rpb24gb2NjdXJyZWRcbiAgICAgICAgaWYgKG5vZGUuZXhlY3V0ZV90cmlnZ2VyZWQ+MCkgbm9kZS5leGVjdXRlX3RyaWdnZXJlZC0tO1xuICAgICAgICBpZiAobm9kZS5hY3Rpb25fdHJpZ2dlcmVkPjApIG5vZGUuYWN0aW9uX3RyaWdnZXJlZC0tO1xuICAgIH07XG5cbiAgICB2YXIgbWFyZ2luX2FyZWEgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgIHZhciBsaW5rX2JvdW5kaW5nID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICB2YXIgdGVtcEEgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgIHZhciB0ZW1wQiA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG5cbiAgICAvKipcbiAgICAgKiBkcmF3cyBldmVyeSBjb25uZWN0aW9uIHZpc2libGUgaW4gdGhlIGNhbnZhc1xuICAgICAqIE9QVElNSVpFIFRISVM6IHByZS1jYXRjaCBjb25uZWN0aW9ucyBwb3NpdGlvbiBpbnN0ZWFkIG9mIHJlY29tcHV0aW5nIHRoZW0gZXZlcnkgdGltZVxuICAgICAqIEBtZXRob2QgZHJhd0Nvbm5lY3Rpb25zXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuZHJhd0Nvbm5lY3Rpb25zID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIHZhciBub3cgPSBMaXRlR3JhcGguZ2V0VGltZSgpO1xuICAgICAgICB2YXIgdmlzaWJsZV9hcmVhID0gdGhpcy52aXNpYmxlX2FyZWE7XG4gICAgICAgIG1hcmdpbl9hcmVhWzBdID0gdmlzaWJsZV9hcmVhWzBdIC0gMjA7XG4gICAgICAgIG1hcmdpbl9hcmVhWzFdID0gdmlzaWJsZV9hcmVhWzFdIC0gMjA7XG4gICAgICAgIG1hcmdpbl9hcmVhWzJdID0gdmlzaWJsZV9hcmVhWzJdICsgNDA7XG4gICAgICAgIG1hcmdpbl9hcmVhWzNdID0gdmlzaWJsZV9hcmVhWzNdICsgNDA7XG5cbiAgICAgICAgLy9kcmF3IGNvbm5lY3Rpb25zXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmNvbm5lY3Rpb25zX3dpZHRoO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNBQUFcIjtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCIjQUFBXCI7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuZWRpdG9yX2FscGhhO1xuICAgICAgICAvL2ZvciBldmVyeSBub2RlXG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuZ3JhcGguX25vZGVzO1xuICAgICAgICBmb3IgKHZhciBuID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgbiA8IGw7ICsrbikge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tuXTtcbiAgICAgICAgICAgIC8vZm9yIGV2ZXJ5IGlucHV0ICh3ZSByZW5kZXIganVzdCBpbnB1dHMgYmVjYXVzZSBpdCBpcyBlYXNpZXIgYXMgZXZlcnkgc2xvdCBjYW4gb25seSBoYXZlIG9uZSBpbnB1dClcbiAgICAgICAgICAgIGlmICghbm9kZS5pbnB1dHMgfHwgIW5vZGUuaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gbm9kZS5pbnB1dHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dCB8fCBpbnB1dC5saW5rID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsaW5rX2lkID0gaW5wdXQubGluaztcbiAgICAgICAgICAgICAgICB2YXIgbGluayA9IHRoaXMuZ3JhcGgubGlua3NbbGlua19pZF07XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vZmluZCBsaW5rIGluZm9cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRfbm9kZSA9IHRoaXMuZ3JhcGguZ2V0Tm9kZUJ5SWQobGluay5vcmlnaW5faWQpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydF9ub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdGFydF9ub2RlX3Nsb3QgPSBsaW5rLm9yaWdpbl9zbG90O1xuICAgICAgICAgICAgICAgIHZhciBzdGFydF9ub2RlX3Nsb3Rwb3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydF9ub2RlX3Nsb3QgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfbm9kZV9zbG90cG9zID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRfbm9kZS5wb3NbMF0gKyAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X25vZGUucG9zWzFdICsgMTBcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFydF9ub2RlX3Nsb3Rwb3MgPSBzdGFydF9ub2RlLmdldENvbm5lY3Rpb25Qb3MoXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X25vZGVfc2xvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBBXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlbmRfbm9kZV9zbG90cG9zID0gbm9kZS5nZXRDb25uZWN0aW9uUG9zKHRydWUsIGksIHRlbXBCKTtcblxuICAgICAgICAgICAgICAgIC8vY29tcHV0ZSBsaW5rIGJvdW5kaW5nXG4gICAgICAgICAgICAgICAgbGlua19ib3VuZGluZ1swXSA9IHN0YXJ0X25vZGVfc2xvdHBvc1swXTtcbiAgICAgICAgICAgICAgICBsaW5rX2JvdW5kaW5nWzFdID0gc3RhcnRfbm9kZV9zbG90cG9zWzFdO1xuICAgICAgICAgICAgICAgIGxpbmtfYm91bmRpbmdbMl0gPSBlbmRfbm9kZV9zbG90cG9zWzBdIC0gc3RhcnRfbm9kZV9zbG90cG9zWzBdO1xuICAgICAgICAgICAgICAgIGxpbmtfYm91bmRpbmdbM10gPSBlbmRfbm9kZV9zbG90cG9zWzFdIC0gc3RhcnRfbm9kZV9zbG90cG9zWzFdO1xuICAgICAgICAgICAgICAgIGlmIChsaW5rX2JvdW5kaW5nWzJdIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5rX2JvdW5kaW5nWzBdICs9IGxpbmtfYm91bmRpbmdbMl07XG4gICAgICAgICAgICAgICAgICAgIGxpbmtfYm91bmRpbmdbMl0gPSBNYXRoLmFicyhsaW5rX2JvdW5kaW5nWzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxpbmtfYm91bmRpbmdbM10gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmtfYm91bmRpbmdbMV0gKz0gbGlua19ib3VuZGluZ1szXTtcbiAgICAgICAgICAgICAgICAgICAgbGlua19ib3VuZGluZ1szXSA9IE1hdGguYWJzKGxpbmtfYm91bmRpbmdbM10pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vc2tpcCBsaW5rcyBvdXRzaWRlIG9mIHRoZSB2aXNpYmxlIGFyZWEgb2YgdGhlIGNhbnZhc1xuICAgICAgICAgICAgICAgIGlmICghb3ZlcmxhcEJvdW5kaW5nKGxpbmtfYm91bmRpbmcsIG1hcmdpbl9hcmVhKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRfc2xvdCA9IHN0YXJ0X25vZGUub3V0cHV0c1tzdGFydF9ub2RlX3Nsb3RdO1xuICAgICAgICAgICAgICAgIHZhciBlbmRfc2xvdCA9IG5vZGUuaW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghc3RhcnRfc2xvdCB8fCAhZW5kX3Nsb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdGFydF9kaXIgPVxuICAgICAgICAgICAgICAgICAgICBzdGFydF9zbG90LmRpciB8fFxuICAgICAgICAgICAgICAgICAgICAoc3RhcnRfbm9kZS5ob3Jpem9udGFsID8gTGl0ZUdyYXBoLkRPV04gOiBMaXRlR3JhcGguUklHSFQpO1xuICAgICAgICAgICAgICAgIHZhciBlbmRfZGlyID1cbiAgICAgICAgICAgICAgICAgICAgZW5kX3Nsb3QuZGlyIHx8XG4gICAgICAgICAgICAgICAgICAgIChub2RlLmhvcml6b250YWwgPyBMaXRlR3JhcGguVVAgOiBMaXRlR3JhcGguTEVGVCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxpbmsoXG4gICAgICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfbm9kZV9zbG90cG9zLFxuICAgICAgICAgICAgICAgICAgICBlbmRfbm9kZV9zbG90cG9zLFxuICAgICAgICAgICAgICAgICAgICBsaW5rLFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfZGlyLFxuICAgICAgICAgICAgICAgICAgICBlbmRfZGlyXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vZXZlbnQgdHJpZ2dlcmVkIHJlbmRlcmVkIG9uIHRvcFxuICAgICAgICAgICAgICAgIGlmIChsaW5rICYmIGxpbmsuX2xhc3RfdGltZSAmJiBub3cgLSBsaW5rLl9sYXN0X3RpbWUgPCAxMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gMi4wIC0gKG5vdyAtIGxpbmsuX2xhc3RfdGltZSkgKiAwLjAwMjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IGN0eC5nbG9iYWxBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdG1wICogZjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMaW5rKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRfbm9kZV9zbG90cG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kX25vZGVfc2xvdHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmssXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X2RpcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZF9kaXJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdG1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBkcmF3cyBhIGxpbmsgYmV0d2VlbiB0d28gcG9pbnRzXG4gICAgICogQG1ldGhvZCByZW5kZXJMaW5rXG4gICAgICogQHBhcmFtIHt2ZWMyfSBhIHN0YXJ0IHBvc1xuICAgICAqIEBwYXJhbSB7dmVjMn0gYiBlbmQgcG9zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxpbmsgdGhlIGxpbmsgb2JqZWN0IHdpdGggYWxsIHRoZSBsaW5rIGluZm9cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNraXBfYm9yZGVyIGlnbm9yZSB0aGUgc2hhZG93IG9mIHRoZSBsaW5rXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmbG93IHNob3cgZmxvdyBhbmltYXRpb24gKGZvciBldmVudHMpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIHRoZSBjb2xvciBmb3IgdGhlIGxpbmtcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRfZGlyIHRoZSBkaXJlY3Rpb24gZW51bVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRfZGlyIHRoZSBkaXJlY3Rpb24gZW51bVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1fc3VibGluZXMgbnVtYmVyIG9mIHN1YmxpbmVzICh1c2VmdWwgdG8gcmVwcmVzZW50IHZlYzMgb3IgcmdiKVxuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnJlbmRlckxpbmsgPSBmdW5jdGlvbihcbiAgICAgICAgY3R4LFxuICAgICAgICBhLFxuICAgICAgICBiLFxuICAgICAgICBsaW5rLFxuICAgICAgICBza2lwX2JvcmRlcixcbiAgICAgICAgZmxvdyxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHN0YXJ0X2RpcixcbiAgICAgICAgZW5kX2RpcixcbiAgICAgICAgbnVtX3N1YmxpbmVzXG4gICAgKSB7XG4gICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVfbGlua3MucHVzaChsaW5rKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hvb3NlIGNvbG9yXG4gICAgICAgIGlmICghY29sb3IgJiYgbGluaykge1xuICAgICAgICAgICAgY29sb3IgPSBsaW5rLmNvbG9yIHx8IExHcmFwaENhbnZhcy5saW5rX3R5cGVfY29sb3JzW2xpbmsudHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb2xvcikge1xuICAgICAgICAgICAgY29sb3IgPSB0aGlzLmRlZmF1bHRfbGlua19jb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluayAhPSBudWxsICYmIHRoaXMuaGlnaGxpZ2h0ZWRfbGlua3NbbGluay5pZF0pIHtcbiAgICAgICAgICAgIGNvbG9yID0gXCIjRkZGXCI7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydF9kaXIgPSBzdGFydF9kaXIgfHwgTGl0ZUdyYXBoLlJJR0hUO1xuICAgICAgICBlbmRfZGlyID0gZW5kX2RpciB8fCBMaXRlR3JhcGguTEVGVDtcblxuICAgICAgICB2YXIgZGlzdCA9IGRpc3RhbmNlKGEsIGIpO1xuXG4gICAgICAgIGlmICh0aGlzLnJlbmRlcl9jb25uZWN0aW9uc19ib3JkZXIgJiYgdGhpcy5kcy5zY2FsZSA+IDAuNikge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuY29ubmVjdGlvbnNfd2lkdGggKyA0O1xuICAgICAgICB9XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IFwicm91bmRcIjtcbiAgICAgICAgbnVtX3N1YmxpbmVzID0gbnVtX3N1YmxpbmVzIHx8IDE7XG4gICAgICAgIGlmIChudW1fc3VibGluZXMgPiAxKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMC41O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9iZWdpbiBsaW5lIHNoYXBlXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fc3VibGluZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldHkgPSAoaSAtIChudW1fc3VibGluZXMgLSAxKSAqIDAuNSkgKiA1O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5saW5rc19yZW5kZXJfbW9kZSA9PSBMaXRlR3JhcGguU1BMSU5FX0xJTkspIHtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGFbMF0sIGFbMV0gKyBvZmZzZXR5KTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRfb2Zmc2V0X3ggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydF9vZmZzZXRfeSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGVuZF9vZmZzZXRfeCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGVuZF9vZmZzZXRfeSA9IDA7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzdGFydF9kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X29mZnNldF94ID0gZGlzdCAqIC0wLjI1O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLlJJR0hUOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRfb2Zmc2V0X3ggPSBkaXN0ICogMC4yNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5VUDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X29mZnNldF95ID0gZGlzdCAqIC0wLjI1O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLkRPV046XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydF9vZmZzZXRfeSA9IGRpc3QgKiAwLjI1O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZW5kX2Rpcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5MRUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kX29mZnNldF94ID0gZGlzdCAqIC0wLjI1O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLlJJR0hUOlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kX29mZnNldF94ID0gZGlzdCAqIDAuMjU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguVVA6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRfb2Zmc2V0X3kgPSBkaXN0ICogLTAuMjU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguRE9XTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZF9vZmZzZXRfeSA9IGRpc3QgKiAwLjI1O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICBhWzBdICsgc3RhcnRfb2Zmc2V0X3gsXG4gICAgICAgICAgICAgICAgICAgIGFbMV0gKyBzdGFydF9vZmZzZXRfeSArIG9mZnNldHksXG4gICAgICAgICAgICAgICAgICAgIGJbMF0gKyBlbmRfb2Zmc2V0X3gsXG4gICAgICAgICAgICAgICAgICAgIGJbMV0gKyBlbmRfb2Zmc2V0X3kgKyBvZmZzZXR5LFxuICAgICAgICAgICAgICAgICAgICBiWzBdLFxuICAgICAgICAgICAgICAgICAgICBiWzFdICsgb2Zmc2V0eVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGlua3NfcmVuZGVyX21vZGUgPT0gTGl0ZUdyYXBoLkxJTkVBUl9MSU5LKSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhhWzBdLCBhWzFdICsgb2Zmc2V0eSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0X29mZnNldF94ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRfb2Zmc2V0X3kgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBlbmRfb2Zmc2V0X3ggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBlbmRfb2Zmc2V0X3kgPSAwO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhcnRfZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLkxFRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydF9vZmZzZXRfeCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLlJJR0hUOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRfb2Zmc2V0X3ggPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLlVQOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRfb2Zmc2V0X3kgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5ET1dOOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRfb2Zmc2V0X3kgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZW5kX2Rpcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5MRUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kX29mZnNldF94ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguUklHSFQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRfb2Zmc2V0X3ggPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLlVQOlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kX29mZnNldF95ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguRE9XTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZF9vZmZzZXRfeSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGwgPSAxNTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKFxuICAgICAgICAgICAgICAgICAgICBhWzBdICsgc3RhcnRfb2Zmc2V0X3ggKiBsLFxuICAgICAgICAgICAgICAgICAgICBhWzFdICsgc3RhcnRfb2Zmc2V0X3kgKiBsICsgb2Zmc2V0eVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhcbiAgICAgICAgICAgICAgICAgICAgYlswXSArIGVuZF9vZmZzZXRfeCAqIGwsXG4gICAgICAgICAgICAgICAgICAgIGJbMV0gKyBlbmRfb2Zmc2V0X3kgKiBsICsgb2Zmc2V0eVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhiWzBdLCBiWzFdICsgb2Zmc2V0eSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGlua3NfcmVuZGVyX21vZGUgPT0gTGl0ZUdyYXBoLlNUUkFJR0hUX0xJTkspIHtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGFbMF0sIGFbMV0pO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydF94ID0gYVswXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRfeSA9IGFbMV07XG4gICAgICAgICAgICAgICAgdmFyIGVuZF94ID0gYlswXTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kX3kgPSBiWzFdO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydF9kaXIgPT0gTGl0ZUdyYXBoLlJJR0hUKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X3ggKz0gMTA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfeSArPSAxMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVuZF9kaXIgPT0gTGl0ZUdyYXBoLkxFRlQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kX3ggLT0gMTA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kX3kgLT0gMTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oc3RhcnRfeCwgc3RhcnRfeSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbygoc3RhcnRfeCArIGVuZF94KSAqIDAuNSwgc3RhcnRfeSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbygoc3RhcnRfeCArIGVuZF94KSAqIDAuNSwgZW5kX3kpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oZW5kX3gsIGVuZF95KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGJbMF0sIGJbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IC8vdW5rbm93blxuICAgICAgICB9XG5cbiAgICAgICAgLy9yZW5kZXJpbmcgdGhlIG91dGxpbmUgb2YgdGhlIGNvbm5lY3Rpb24gY2FuIGJlIGEgbGl0dGxlIGJpdCBzbG93XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMucmVuZGVyX2Nvbm5lY3Rpb25zX2JvcmRlciAmJlxuICAgICAgICAgICAgdGhpcy5kcy5zY2FsZSA+IDAuNiAmJlxuICAgICAgICAgICAgIXNraXBfYm9yZGVyXG4gICAgICAgICkge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDAsMCwwLDAuNSlcIjtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmNvbm5lY3Rpb25zX3dpZHRoO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgLy9lbmQgbGluZSBzaGFwZVxuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmNvbXB1dGVDb25uZWN0aW9uUG9pbnQoYSwgYiwgMC41LCBzdGFydF9kaXIsIGVuZF9kaXIpO1xuICAgICAgICBpZiAobGluayAmJiBsaW5rLl9wb3MpIHtcbiAgICAgICAgICAgIGxpbmsuX3Bvc1swXSA9IHBvc1swXTtcbiAgICAgICAgICAgIGxpbmsuX3Bvc1sxXSA9IHBvc1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vcmVuZGVyIGFycm93IGluIHRoZSBtaWRkbGVcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5kcy5zY2FsZSA+PSAwLjYgJiZcbiAgICAgICAgICAgIHRoaXMuaGlnaHF1YWxpdHlfcmVuZGVyICYmXG4gICAgICAgICAgICBlbmRfZGlyICE9IExpdGVHcmFwaC5DRU5URVJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvL3JlbmRlciBhcnJvd1xuICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyX2Nvbm5lY3Rpb25fYXJyb3dzKSB7XG4gICAgICAgICAgICAgICAgLy9jb21wdXRlIHR3byBwb2ludHMgaW4gdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICB2YXIgcG9zQSA9IHRoaXMuY29tcHV0ZUNvbm5lY3Rpb25Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgYSxcbiAgICAgICAgICAgICAgICAgICAgYixcbiAgICAgICAgICAgICAgICAgICAgMC4yNSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfZGlyLFxuICAgICAgICAgICAgICAgICAgICBlbmRfZGlyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zQiA9IHRoaXMuY29tcHV0ZUNvbm5lY3Rpb25Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgYSxcbiAgICAgICAgICAgICAgICAgICAgYixcbiAgICAgICAgICAgICAgICAgICAgMC4yNixcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfZGlyLFxuICAgICAgICAgICAgICAgICAgICBlbmRfZGlyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zQyA9IHRoaXMuY29tcHV0ZUNvbm5lY3Rpb25Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgYSxcbiAgICAgICAgICAgICAgICAgICAgYixcbiAgICAgICAgICAgICAgICAgICAgMC43NSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfZGlyLFxuICAgICAgICAgICAgICAgICAgICBlbmRfZGlyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zRCA9IHRoaXMuY29tcHV0ZUNvbm5lY3Rpb25Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgYSxcbiAgICAgICAgICAgICAgICAgICAgYixcbiAgICAgICAgICAgICAgICAgICAgMC43NixcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfZGlyLFxuICAgICAgICAgICAgICAgICAgICBlbmRfZGlyXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vY29tcHV0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0aGVtIHNvIHRoZSBhcnJvdyBwb2ludHMgaW4gdGhlIHJpZ2h0IGRpcmVjdGlvblxuICAgICAgICAgICAgICAgIHZhciBhbmdsZUEgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBhbmdsZUIgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcl9jdXJ2ZWRfY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGVBID0gLU1hdGguYXRhbjIocG9zQlswXSAtIHBvc0FbMF0sIHBvc0JbMV0gLSBwb3NBWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGVCID0gLU1hdGguYXRhbjIocG9zRFswXSAtIHBvc0NbMF0sIHBvc0RbMV0gLSBwb3NDWzFdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbmdsZUIgPSBhbmdsZUEgPSBiWzFdID4gYVsxXSA/IDAgOiBNYXRoLlBJO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vcmVuZGVyIGFycm93XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHBvc0FbMF0sIHBvc0FbMV0pO1xuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoYW5nbGVBKTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbygtNSwgLTMpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oMCwgKzcpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oKzUsIC0zKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHBvc0NbMF0sIHBvc0NbMV0pO1xuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoYW5nbGVCKTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbygtNSwgLTMpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oMCwgKzcpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oKzUsIC0zKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vY2lyY2xlXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguYXJjKHBvc1swXSwgcG9zWzFdLCA1LCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9yZW5kZXIgZmxvd2luZyBwb2ludHNcbiAgICAgICAgaWYgKGZsb3cpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSAoTGl0ZUdyYXBoLmdldFRpbWUoKSAqIDAuMDAxICsgaSAqIDAuMikgJSAxO1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmNvbXB1dGVDb25uZWN0aW9uUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgIGEsXG4gICAgICAgICAgICAgICAgICAgIGIsXG4gICAgICAgICAgICAgICAgICAgIGYsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X2RpcixcbiAgICAgICAgICAgICAgICAgICAgZW5kX2RpclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMocG9zWzBdLCBwb3NbMV0sIDUsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vcmV0dXJucyB0aGUgbGluayBjZW50ZXIgcG9pbnQgYmFzZWQgb24gY3VydmF0dXJlXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5jb21wdXRlQ29ubmVjdGlvblBvaW50ID0gZnVuY3Rpb24oXG4gICAgICAgIGEsXG4gICAgICAgIGIsXG4gICAgICAgIHQsXG4gICAgICAgIHN0YXJ0X2RpcixcbiAgICAgICAgZW5kX2RpclxuICAgICkge1xuICAgICAgICBzdGFydF9kaXIgPSBzdGFydF9kaXIgfHwgTGl0ZUdyYXBoLlJJR0hUO1xuICAgICAgICBlbmRfZGlyID0gZW5kX2RpciB8fCBMaXRlR3JhcGguTEVGVDtcblxuICAgICAgICB2YXIgZGlzdCA9IGRpc3RhbmNlKGEsIGIpO1xuICAgICAgICB2YXIgcDAgPSBhO1xuICAgICAgICB2YXIgcDEgPSBbYVswXSwgYVsxXV07XG4gICAgICAgIHZhciBwMiA9IFtiWzBdLCBiWzFdXTtcbiAgICAgICAgdmFyIHAzID0gYjtcblxuICAgICAgICBzd2l0Y2ggKHN0YXJ0X2Rpcikge1xuICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguTEVGVDpcbiAgICAgICAgICAgICAgICBwMVswXSArPSBkaXN0ICogLTAuMjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5SSUdIVDpcbiAgICAgICAgICAgICAgICBwMVswXSArPSBkaXN0ICogMC4yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLlVQOlxuICAgICAgICAgICAgICAgIHAxWzFdICs9IGRpc3QgKiAtMC4yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLkRPV046XG4gICAgICAgICAgICAgICAgcDFbMV0gKz0gZGlzdCAqIDAuMjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChlbmRfZGlyKSB7XG4gICAgICAgICAgICBjYXNlIExpdGVHcmFwaC5MRUZUOlxuICAgICAgICAgICAgICAgIHAyWzBdICs9IGRpc3QgKiAtMC4yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTGl0ZUdyYXBoLlJJR0hUOlxuICAgICAgICAgICAgICAgIHAyWzBdICs9IGRpc3QgKiAwLjI1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguVVA6XG4gICAgICAgICAgICAgICAgcDJbMV0gKz0gZGlzdCAqIC0wLjI1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMaXRlR3JhcGguRE9XTjpcbiAgICAgICAgICAgICAgICBwMlsxXSArPSBkaXN0ICogMC4yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjMSA9ICgxIC0gdCkgKiAoMSAtIHQpICogKDEgLSB0KTtcbiAgICAgICAgdmFyIGMyID0gMyAqICgoMSAtIHQpICogKDEgLSB0KSkgKiB0O1xuICAgICAgICB2YXIgYzMgPSAzICogKDEgLSB0KSAqICh0ICogdCk7XG4gICAgICAgIHZhciBjNCA9IHQgKiB0ICogdDtcblxuICAgICAgICB2YXIgeCA9IGMxICogcDBbMF0gKyBjMiAqIHAxWzBdICsgYzMgKiBwMlswXSArIGM0ICogcDNbMF07XG4gICAgICAgIHZhciB5ID0gYzEgKiBwMFsxXSArIGMyICogcDFbMV0gKyBjMyAqIHAyWzFdICsgYzQgKiBwM1sxXTtcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kcmF3RXhlY3V0aW9uT3JkZXIgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjI1O1xuXG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNzU7XG5cbiAgICAgICAgdmFyIHZpc2libGVfbm9kZXMgPSB0aGlzLnZpc2libGVfbm9kZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlzaWJsZV9ub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB2aXNpYmxlX25vZGVzW2ldO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgICBub2RlLnBvc1swXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCxcbiAgICAgICAgICAgICAgICBub2RlLnBvc1sxXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCxcbiAgICAgICAgICAgICAgICBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQsXG4gICAgICAgICAgICAgICAgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKG5vZGUub3JkZXIgPT0gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KFxuICAgICAgICAgICAgICAgICAgICBub2RlLnBvc1swXSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCArIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wb3NbMV0gLSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgKyAwLjUsXG4gICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCxcbiAgICAgICAgICAgICAgICAgICAgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNGRkZcIjtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChcbiAgICAgICAgICAgICAgICBub2RlLm9yZGVyLFxuICAgICAgICAgICAgICAgIG5vZGUucG9zWzBdICsgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICogLTAuNSxcbiAgICAgICAgICAgICAgICBub2RlLnBvc1sxXSAtIDZcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZHJhd3MgdGhlIHdpZGdldHMgc3RvcmVkIGluc2lkZSBhIG5vZGVcbiAgICAgKiBAbWV0aG9kIGRyYXdOb2RlV2lkZ2V0c1xuICAgICAqKi9cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmRyYXdOb2RlV2lkZ2V0cyA9IGZ1bmN0aW9uKFxuICAgICAgICBub2RlLFxuICAgICAgICBwb3NZLFxuICAgICAgICBjdHgsXG4gICAgICAgIGFjdGl2ZV93aWRnZXRcbiAgICApIHtcbiAgICAgICAgaWYgKCFub2RlLndpZGdldHMgfHwgIW5vZGUud2lkZ2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IG5vZGUuc2l6ZVswXTtcbiAgICAgICAgdmFyIHdpZGdldHMgPSBub2RlLndpZGdldHM7XG4gICAgICAgIHBvc1kgKz0gMjtcbiAgICAgICAgdmFyIEggPSBMaXRlR3JhcGguTk9ERV9XSURHRVRfSEVJR0hUO1xuICAgICAgICB2YXIgc2hvd190ZXh0ID0gdGhpcy5kcy5zY2FsZSA+IDAuNTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5lZGl0b3JfYWxwaGE7XG4gICAgICAgIHZhciBvdXRsaW5lX2NvbG9yID0gTGl0ZUdyYXBoLldJREdFVF9PVVRMSU5FX0NPTE9SO1xuICAgICAgICB2YXIgYmFja2dyb3VuZF9jb2xvciA9IExpdGVHcmFwaC5XSURHRVRfQkdDT0xPUjtcbiAgICAgICAgdmFyIHRleHRfY29sb3IgPSBMaXRlR3JhcGguV0lER0VUX1RFWFRfQ09MT1I7XG5cdFx0dmFyIHNlY29uZGFyeV90ZXh0X2NvbG9yID0gTGl0ZUdyYXBoLldJREdFVF9TRUNPTkRBUllfVEVYVF9DT0xPUjtcbiAgICAgICAgdmFyIG1hcmdpbiA9IDE1O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2lkZ2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHcgPSB3aWRnZXRzW2ldO1xuICAgICAgICAgICAgdmFyIHkgPSBwb3NZO1xuICAgICAgICAgICAgaWYgKHcueSkge1xuICAgICAgICAgICAgICAgIHkgPSB3Lnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3Lmxhc3RfeSA9IHk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvdXRsaW5lX2NvbG9yO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzIyMlwiO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuXHRcdFx0Ly9jdHgubGluZVdpZHRoID0gMjtcblx0XHRcdGlmKHcuZGlzYWJsZWQpXG5cdFx0XHRcdGN0eC5nbG9iYWxBbHBoYSAqPSAwLjU7XG5cdFx0XHR2YXIgd2lkZ2V0X3dpZHRoID0gdy53aWR0aCB8fCB3aWR0aDtcblxuICAgICAgICAgICAgc3dpdGNoICh3LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYnV0dG9uXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh3LmNsaWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNBQUFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcuY2xpY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChtYXJnaW4sIHksIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIsIEgpO1xuXHRcdFx0XHRcdGlmKHNob3dfdGV4dCAmJiAhdy5kaXNhYmxlZClcblx0ICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlUmVjdCggbWFyZ2luLCB5LCB3aWRnZXRfd2lkdGggLSBtYXJnaW4gKiAyLCBIICk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG93X3RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQody5sYWJlbCB8fCB3Lm5hbWUsIHdpZGdldF93aWR0aCAqIDAuNSwgeSArIEggKiAwLjcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b2dnbGVcIjpcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvdXRsaW5lX2NvbG9yO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZF9jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd190ZXh0KVxuXHQgICAgICAgICAgICAgICAgICAgIGN0eC5yb3VuZFJlY3QobWFyZ2luLCB5LCB3aWRnZXRfd2lkdGggLSBtYXJnaW4gKiAyLCBILCBbSCAqIDAuNV0pO1xuXHRcdFx0XHRcdGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChtYXJnaW4sIHksIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIsIEggKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcblx0XHRcdFx0XHRpZihzaG93X3RleHQgJiYgIXcuZGlzYWJsZWQpXG5cdCAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdy52YWx1ZSA/IFwiIzg5QVwiIDogXCIjMzMzXCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyggd2lkZ2V0X3dpZHRoIC0gbWFyZ2luICogMiwgeSArIEggKiAwLjUsIEggKiAwLjM2LCAwLCBNYXRoLlBJICogMiApO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd190ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc2Vjb25kYXJ5X3RleHRfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IHcubGFiZWwgfHwgdy5uYW1lOyAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGxhYmVsLCBtYXJnaW4gKiAyLCB5ICsgSCAqIDAuNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdy52YWx1ZSA/IHRleHRfY29sb3IgOiBzZWNvbmRhcnlfdGV4dF9jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdy52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHcub3B0aW9ucy5vbiB8fCBcInRydWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHcub3B0aW9ucy5vZmYgfHwgXCJmYWxzZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldF93aWR0aCAtIDQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKyBIICogMC43XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzbGlkZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChtYXJnaW4sIHksIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIsIEgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB3Lm9wdGlvbnMubWF4IC0gdy5vcHRpb25zLm1pbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG52YWx1ZSA9ICh3LnZhbHVlIC0gdy5vcHRpb25zLm1pbikgLyByYW5nZTtcblx0XHRcdFx0XHRpZihudmFsdWUgPCAwLjApIG52YWx1ZSA9IDAuMDtcblx0XHRcdFx0XHRpZihudmFsdWUgPiAxLjApIG52YWx1ZSA9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHcub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcInNsaWRlcl9jb2xvclwiKSA/IHcub3B0aW9ucy5zbGlkZXJfY29sb3IgOiAoYWN0aXZlX3dpZGdldCA9PSB3ID8gXCIjODlBXCIgOiBcIiM2NzhcIik7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChtYXJnaW4sIHksIG52YWx1ZSAqICh3aWRnZXRfd2lkdGggLSBtYXJnaW4gKiAyKSwgSCk7XG5cdFx0XHRcdFx0aWYoc2hvd190ZXh0ICYmICF3LmRpc2FibGVkKVxuXHQgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KG1hcmdpbiwgeSwgd2lkZ2V0X3dpZHRoIC0gbWFyZ2luICogMiwgSCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3Lm1hcmtlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmtlcl9udmFsdWUgPSAody5tYXJrZXIgLSB3Lm9wdGlvbnMubWluKSAvIHJhbmdlO1xuXHRcdFx0XHRcdFx0aWYobWFya2VyX252YWx1ZSA8IDAuMCkgbWFya2VyX252YWx1ZSA9IDAuMDtcblx0XHRcdFx0XHRcdGlmKG1hcmtlcl9udmFsdWUgPiAxLjApIG1hcmtlcl9udmFsdWUgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdy5vcHRpb25zLmhhc093blByb3BlcnR5KFwibWFya2VyX2NvbG9yXCIpID8gdy5vcHRpb25zLm1hcmtlcl9jb2xvciA6IFwiI0FBOVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KCBtYXJnaW4gKyBtYXJrZXJfbnZhbHVlICogKHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIpLCB5LCAyLCBIICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dfdGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGV4dF9jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3LmxhYmVsIHx8IHcubmFtZSArIFwiICBcIiArIE51bWJlcih3LnZhbHVlKS50b0ZpeGVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdy5vcHRpb25zLnByZWNpc2lvbiAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB3Lm9wdGlvbnMucHJlY2lzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkZ2V0X3dpZHRoICogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKyBIICogMC43XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29tYm9cIjpcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvdXRsaW5lX2NvbG9yO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZF9jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdGlmKHNob3dfdGV4dClcblx0ICAgICAgICAgICAgICAgICAgICBjdHgucm91bmRSZWN0KG1hcmdpbiwgeSwgd2lkZ2V0X3dpZHRoIC0gbWFyZ2luICogMiwgSCwgW0ggKiAwLjVdICk7XG5cdFx0XHRcdFx0ZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KG1hcmdpbiwgeSwgd2lkZ2V0X3dpZHRoIC0gbWFyZ2luICogMiwgSCApO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd190ZXh0KSB7XG5cdFx0XHRcdFx0XHRpZighdy5kaXNhYmxlZClcblx0XHQgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0X2NvbG9yO1xuXHRcdFx0XHRcdFx0aWYoIXcuZGlzYWJsZWQpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdFx0Y3R4Lm1vdmVUbyhtYXJnaW4gKyAxNiwgeSArIDUpO1xuXHRcdFx0XHRcdFx0XHRjdHgubGluZVRvKG1hcmdpbiArIDYsIHkgKyBIICogMC41KTtcblx0XHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhtYXJnaW4gKyAxNiwgeSArIEggLSA1KTtcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0XHRjdHgubW92ZVRvKHdpZGdldF93aWR0aCAtIG1hcmdpbiAtIDE2LCB5ICsgNSk7XG5cdFx0XHRcdFx0XHRcdGN0eC5saW5lVG8od2lkZ2V0X3dpZHRoIC0gbWFyZ2luIC0gNiwgeSArIEggKiAwLjUpO1xuXHRcdFx0XHRcdFx0XHRjdHgubGluZVRvKHdpZGdldF93aWR0aCAtIG1hcmdpbiAtIDE2LCB5ICsgSCAtIDUpO1xuXHRcdFx0XHRcdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0XHRcdFx0fVxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNlY29uZGFyeV90ZXh0X2NvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHcubGFiZWwgfHwgdy5uYW1lLCBtYXJnaW4gKiAyICsgNSwgeSArIEggKiAwLjcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJyaWdodFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcudHlwZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIody52YWx1ZSkudG9GaXhlZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcub3B0aW9ucy5wcmVjaXNpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdy5vcHRpb25zLnByZWNpc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXRfd2lkdGggLSBtYXJnaW4gKiAyIC0gMjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKyBIICogMC43XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciB2ID0gdy52YWx1ZTtcblx0XHRcdFx0XHRcdFx0aWYoIHcub3B0aW9ucy52YWx1ZXMgKVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IHcub3B0aW9ucy52YWx1ZXM7XG5cdFx0XHRcdFx0XHRcdFx0aWYoIHZhbHVlcy5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24gKVxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzID0gdmFsdWVzKCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYodmFsdWVzICYmIHZhbHVlcy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpXG5cdFx0XHRcdFx0XHRcdFx0XHR2ID0gdmFsdWVzWyB3LnZhbHVlIF07XG5cdFx0XHRcdFx0XHRcdH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIgLSAyMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArIEggKiAwLjdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG91dGxpbmVfY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kX2NvbG9yO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG93X3RleHQpXG5cdCAgICAgICAgICAgICAgICAgICAgY3R4LnJvdW5kUmVjdChtYXJnaW4sIHksIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIsIEgsIFtIICogMC41XSk7XG5cdFx0XHRcdFx0ZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KCBtYXJnaW4sIHksIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIsIEggKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcblx0ICAgICAgICAgICAgICAgIGlmIChzaG93X3RleHQpIHtcblx0XHRcdFx0XHRcdGlmKCF3LmRpc2FibGVkKVxuXHRcdFx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG4gICAgXHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0XHRjdHgucmVjdChtYXJnaW4sIHksIHdpZGdldF93aWR0aCAtIG1hcmdpbiAqIDIsIEgpO1xuXHRcdFx0XHRcdFx0Y3R4LmNsaXAoKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNlY29uZGFyeV90ZXh0X2NvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSB3LmxhYmVsIHx8IHcubmFtZTtcdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQobGFiZWwsIG1hcmdpbiAqIDIsIHkgKyBIICogMC43KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0X2NvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwicmlnaHRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChTdHJpbmcody52YWx1ZSkuc3Vic3RyKDAsMzApLCB3aWRnZXRfd2lkdGggLSBtYXJnaW4gKiAyLCB5ICsgSCAqIDAuNyk7IC8vMzAgY2hhcnMgbWF4XG5cdFx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh3LmRyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcuZHJhdyhjdHgsIG5vZGUsIHdpZGdldF93aWR0aCwgeSwgSCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NZICs9ICh3LmNvbXB1dGVTaXplID8gdy5jb21wdXRlU2l6ZSh3aWRnZXRfd2lkdGgpWzFdIDogSCkgKyA0O1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gdGhpcy5lZGl0b3JfYWxwaGE7XG5cbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXHRcdGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcHJvY2VzcyBhbiBldmVudCBvbiB3aWRnZXRzXG4gICAgICogQG1ldGhvZCBwcm9jZXNzTm9kZVdpZGdldHNcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wcm9jZXNzTm9kZVdpZGdldHMgPSBmdW5jdGlvbihcbiAgICAgICAgbm9kZSxcbiAgICAgICAgcG9zLFxuICAgICAgICBldmVudCxcbiAgICAgICAgYWN0aXZlX3dpZGdldFxuICAgICkge1xuICAgICAgICBpZiAoIW5vZGUud2lkZ2V0cyB8fCAhbm9kZS53aWRnZXRzLmxlbmd0aCB8fCAoIXRoaXMuYWxsb3dfaW50ZXJhY3Rpb24gJiYgIW5vZGUuZmxhZ3MuYWxsb3dfaW50ZXJhY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4ID0gcG9zWzBdIC0gbm9kZS5wb3NbMF07XG4gICAgICAgIHZhciB5ID0gcG9zWzFdIC0gbm9kZS5wb3NbMV07XG4gICAgICAgIHZhciB3aWR0aCA9IG5vZGUuc2l6ZVswXTtcbiAgICAgICAgdmFyIGRlbHRhWCA9IGV2ZW50LmRlbHRhWCB8fCBldmVudC5kZWx0YXggfHwgMDtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgcmVmX3dpbmRvdyA9IHRoaXMuZ2V0Q2FudmFzV2luZG93KCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLndpZGdldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB3ID0gbm9kZS53aWRnZXRzW2ldO1xuXHRcdFx0aWYoIXcgfHwgdy5kaXNhYmxlZClcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR2YXIgd2lkZ2V0X2hlaWdodCA9IHcuY29tcHV0ZVNpemUgPyB3LmNvbXB1dGVTaXplKHdpZHRoKVsxXSA6IExpdGVHcmFwaC5OT0RFX1dJREdFVF9IRUlHSFQ7XG5cdFx0XHR2YXIgd2lkZ2V0X3dpZHRoID0gdy53aWR0aCB8fCB3aWR0aDtcblx0XHRcdC8vb3V0c2lkZVxuXHRcdFx0aWYgKCB3ICE9IGFjdGl2ZV93aWRnZXQgJiYgXG5cdFx0XHRcdCh4IDwgNiB8fCB4ID4gd2lkZ2V0X3dpZHRoIC0gMTIgfHwgeSA8IHcubGFzdF95IHx8IHkgPiB3Lmxhc3RfeSArIHdpZGdldF9oZWlnaHQgfHwgdy5sYXN0X3kgPT09IHVuZGVmaW5lZCkgKSBcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdHZhciBvbGRfdmFsdWUgPSB3LnZhbHVlO1xuXG4gICAgICAgICAgICAvL2lmICggdyA9PSBhY3RpdmVfd2lkZ2V0IHx8ICh4ID4gNiAmJiB4IDwgd2lkZ2V0X3dpZHRoIC0gMTIgJiYgeSA+IHcubGFzdF95ICYmIHkgPCB3Lmxhc3RfeSArIHdpZGdldF9oZWlnaHQpICkge1xuXHRcdFx0Ly9pbnNpZGUgd2lkZ2V0XG5cdFx0XHRzd2l0Y2ggKHcudHlwZSkge1xuXHRcdFx0XHRjYXNlIFwiYnV0dG9uXCI6XG5cdFx0XHRcdFx0aWYgKGV2ZW50LnR5cGUgPT09IExpdGVHcmFwaC5wb2ludGVyZXZlbnRzX21ldGhvZCtcImRvd25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3LmNhbGxiYWNrKHcsIHRoYXQsIG5vZGUsIHBvcywgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHcuY2xpY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInNsaWRlclwiOlxuXHRcdFx0XHRcdHZhciBvbGRfdmFsdWUgPSB3LnZhbHVlO1xuXHRcdFx0XHRcdHZhciBudmFsdWUgPSBjbGFtcCgoeCAtIDE1KSAvICh3aWRnZXRfd2lkdGggLSAzMCksIDAsIDEpO1xuXHRcdFx0XHRcdGlmKHcub3B0aW9ucy5yZWFkX29ubHkpIGJyZWFrO1xuXHRcdFx0XHRcdHcudmFsdWUgPSB3Lm9wdGlvbnMubWluICsgKHcub3B0aW9ucy5tYXggLSB3Lm9wdGlvbnMubWluKSAqIG52YWx1ZTtcblx0XHRcdFx0XHRpZiAob2xkX3ZhbHVlICE9IHcudmFsdWUpIHtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdGlubmVyX3ZhbHVlX2NoYW5nZSh3LCB3LnZhbHVlKTtcblx0XHRcdFx0XHRcdH0sIDIwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwibnVtYmVyXCI6XG5cdFx0XHRcdGNhc2UgXCJjb21ib1wiOlxuXHRcdFx0XHRcdHZhciBvbGRfdmFsdWUgPSB3LnZhbHVlO1xuXHRcdFx0XHRcdGlmIChldmVudC50eXBlID09IExpdGVHcmFwaC5wb2ludGVyZXZlbnRzX21ldGhvZCtcIm1vdmVcIiAmJiB3LnR5cGUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVsdGFYKVxuXHRcdFx0XHRcdFx0ICAgIHcudmFsdWUgKz0gZGVsdGFYICogMC4xICogKHcub3B0aW9ucy5zdGVwIHx8IDEpO1xuXHRcdFx0XHRcdFx0aWYgKCB3Lm9wdGlvbnMubWluICE9IG51bGwgJiYgdy52YWx1ZSA8IHcub3B0aW9ucy5taW4gKSB7XG5cdFx0XHRcdFx0XHRcdHcudmFsdWUgPSB3Lm9wdGlvbnMubWluO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCB3Lm9wdGlvbnMubWF4ICE9IG51bGwgJiYgdy52YWx1ZSA+IHcub3B0aW9ucy5tYXggKSB7XG5cdFx0XHRcdFx0XHRcdHcudmFsdWUgPSB3Lm9wdGlvbnMubWF4O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PSBMaXRlR3JhcGgucG9pbnRlcmV2ZW50c19tZXRob2QrXCJkb3duXCIpIHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSB3Lm9wdGlvbnMudmFsdWVzO1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlcyAmJiB2YWx1ZXMuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlcyA9IHcub3B0aW9ucy52YWx1ZXModywgbm9kZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzX2xpc3QgPSBudWxsO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiggdy50eXBlICE9IFwibnVtYmVyXCIpXG5cdFx0XHRcdFx0XHRcdHZhbHVlc19saXN0ID0gdmFsdWVzLmNvbnN0cnVjdG9yID09PSBBcnJheSA/IHZhbHVlcyA6IE9iamVjdC5rZXlzKHZhbHVlcyk7XG5cblx0XHRcdFx0XHRcdHZhciBkZWx0YSA9IHggPCA0MCA/IC0xIDogeCA+IHdpZGdldF93aWR0aCAtIDQwID8gMSA6IDA7XG5cdFx0XHRcdFx0XHRpZiAody50eXBlID09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRcdFx0dy52YWx1ZSArPSBkZWx0YSAqIDAuMSAqICh3Lm9wdGlvbnMuc3RlcCB8fCAxKTtcblx0XHRcdFx0XHRcdFx0aWYgKCB3Lm9wdGlvbnMubWluICE9IG51bGwgJiYgdy52YWx1ZSA8IHcub3B0aW9ucy5taW4gKSB7XG5cdFx0XHRcdFx0XHRcdFx0dy52YWx1ZSA9IHcub3B0aW9ucy5taW47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCB3Lm9wdGlvbnMubWF4ICE9IG51bGwgJiYgdy52YWx1ZSA+IHcub3B0aW9ucy5tYXggKSB7XG5cdFx0XHRcdFx0XHRcdFx0dy52YWx1ZSA9IHcub3B0aW9ucy5tYXg7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoZGVsdGEpIHsgLy9jbGlja2VkIGluIGFycm93LCB1c2VkIGZvciBjb21ib3MgXG5cdFx0XHRcdFx0XHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmxhc3RfbW91c2VjbGljayA9IDA7IC8vYXZvaWRzIGRvYmwgY2xpY2sgZXZlbnRcblx0XHRcdFx0XHRcdFx0aWYodmFsdWVzLmNvbnN0cnVjdG9yID09PSBPYmplY3QpXG5cdFx0XHRcdFx0XHRcdFx0aW5kZXggPSB2YWx1ZXNfbGlzdC5pbmRleE9mKCBTdHJpbmcoIHcudmFsdWUgKSApICsgZGVsdGE7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRpbmRleCA9IHZhbHVlc19saXN0LmluZGV4T2YoIHcudmFsdWUgKSArIGRlbHRhO1xuXHRcdFx0XHRcdFx0XHRpZiAoaW5kZXggPj0gdmFsdWVzX2xpc3QubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5kZXggPSB2YWx1ZXNfbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChpbmRleCA8IDApIHtcblx0XHRcdFx0XHRcdFx0XHRpbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoIHZhbHVlcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgKVxuXHRcdFx0XHRcdFx0XHRcdHcudmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0dy52YWx1ZSA9IGluZGV4O1xuXHRcdFx0XHRcdFx0fSBlbHNlIHsgLy9jb21ibyBjbGlja2VkIFxuXHRcdFx0XHRcdFx0XHR2YXIgdGV4dF92YWx1ZXMgPSB2YWx1ZXMgIT0gdmFsdWVzX2xpc3QgPyBPYmplY3QudmFsdWVzKHZhbHVlcykgOiB2YWx1ZXM7XG5cdFx0XHRcdFx0XHRcdHZhciBtZW51ID0gbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudSh0ZXh0X3ZhbHVlcywge1xuXHRcdFx0XHRcdFx0XHRcdFx0c2NhbGU6IE1hdGgubWF4KDEsIHRoaXMuZHMuc2NhbGUpLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZXZlbnQ6IGV2ZW50LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lOiBcImRhcmtcIixcblx0XHRcdFx0XHRcdFx0XHRcdGNhbGxiYWNrOiBpbm5lcl9jbGlja2VkLmJpbmQodylcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdHJlZl93aW5kb3cpO1xuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbiBpbm5lcl9jbGlja2VkKHYsIG9wdGlvbiwgZXZlbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZih2YWx1ZXMgIT0gdmFsdWVzX2xpc3QpXG5cdFx0XHRcdFx0XHRcdFx0XHR2ID0gdGV4dF92YWx1ZXMuaW5kZXhPZih2KTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdjtcblx0XHRcdFx0XHRcdFx0XHRpbm5lcl92YWx1ZV9jaGFuZ2UodGhpcywgdik7XG5cdFx0XHRcdFx0XHRcdFx0dGhhdC5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gLy9lbmQgbW91c2Vkb3duXG5cdFx0XHRcdFx0ZWxzZSBpZihldmVudC50eXBlID09IExpdGVHcmFwaC5wb2ludGVyZXZlbnRzX21ldGhvZCtcInVwXCIgJiYgdy50eXBlID09IFwibnVtYmVyXCIpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dmFyIGRlbHRhID0geCA8IDQwID8gLTEgOiB4ID4gd2lkZ2V0X3dpZHRoIC0gNDAgPyAxIDogMDtcblx0XHRcdFx0XHRcdGlmIChldmVudC5jbGlja190aW1lIDwgMjAwICYmIGRlbHRhID09IDApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5wcm9tcHQoXCJWYWx1ZVwiLHcudmFsdWUsZnVuY3Rpb24odikge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gY2hlY2sgaWYgdiBpcyBhIHZhbGlkIGVxdWF0aW9uIG9yIGEgbnVtYmVyXG5cdFx0XHRcdFx0XHRcdFx0XHQgIGlmICgvXlswLTkrXFwtKi8oKVxcc10rfFxcZCtcXC5cXGQrJC8udGVzdCh2KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkgey8vc29sdmUgdGhlIGVxdWF0aW9uIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHQgICAgXHRcdHYgPSBldmFsKHYpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlKSB7IH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cdFxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy52YWx1ZSA9IE51bWJlcih2KTtcblx0XHRcdFx0XHRcdFx0XHRcdGlubmVyX3ZhbHVlX2NoYW5nZSh0aGlzLCB0aGlzLnZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHR9LmJpbmQodyksXG5cdFx0XHRcdFx0XHRcdFx0ZXZlbnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmKCBvbGRfdmFsdWUgIT0gdy52YWx1ZSApXG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KFxuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpbm5lcl92YWx1ZV9jaGFuZ2UodGhpcywgdGhpcy52YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdH0uYmluZCh3KSxcblx0XHRcdFx0XHRcdFx0MjBcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0dGhpcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwidG9nZ2xlXCI6XG5cdFx0XHRcdFx0aWYgKGV2ZW50LnR5cGUgPT0gTGl0ZUdyYXBoLnBvaW50ZXJldmVudHNfbWV0aG9kK1wiZG93blwiKSB7XG5cdFx0XHRcdFx0XHR3LnZhbHVlID0gIXcudmFsdWU7XG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRpbm5lcl92YWx1ZV9jaGFuZ2Uodywgdy52YWx1ZSk7XG5cdFx0XHRcdFx0XHR9LCAyMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwic3RyaW5nXCI6XG5cdFx0XHRcdGNhc2UgXCJ0ZXh0XCI6XG5cdFx0XHRcdFx0aWYgKGV2ZW50LnR5cGUgPT0gTGl0ZUdyYXBoLnBvaW50ZXJldmVudHNfbWV0aG9kK1wiZG93blwiKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnByb21wdChcIlZhbHVlXCIsdy52YWx1ZSxmdW5jdGlvbih2KSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5uZXJfdmFsdWVfY2hhbmdlKHRoaXMsIHYpO1xuXHRcdFx0XHRcdFx0XHR9LmJpbmQodyksXG5cdFx0XHRcdFx0XHRcdGV2ZW50LHcub3B0aW9ucyA/IHcub3B0aW9ucy5tdWx0aWxpbmUgOiBmYWxzZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRpZiAody5tb3VzZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5kaXJ0eV9jYW52YXMgPSB3Lm1vdXNlKGV2ZW50LCBbeCwgeV0sIG5vZGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH0gLy9lbmQgc3dpdGNoXG5cblx0XHRcdC8vdmFsdWUgY2hhbmdlZFxuXHRcdFx0aWYoIG9sZF92YWx1ZSAhPSB3LnZhbHVlIClcblx0XHRcdHtcblx0XHRcdFx0aWYobm9kZS5vbldpZGdldENoYW5nZWQpXG5cdFx0XHRcdFx0bm9kZS5vbldpZGdldENoYW5nZWQoIHcubmFtZSx3LnZhbHVlLG9sZF92YWx1ZSx3ICk7XG4gICAgICAgICAgICAgICAgbm9kZS5ncmFwaC5fdmVyc2lvbisrO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdztcbiAgICAgICAgfS8vZW5kIGZvclxuXG4gICAgICAgIGZ1bmN0aW9uIGlubmVyX3ZhbHVlX2NoYW5nZSh3aWRnZXQsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZih3aWRnZXQudHlwZSA9PSBcIm51bWJlclwiKXtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aWRnZXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICggd2lkZ2V0Lm9wdGlvbnMgJiYgd2lkZ2V0Lm9wdGlvbnMucHJvcGVydHkgJiYgbm9kZS5wcm9wZXJ0aWVzW3dpZGdldC5vcHRpb25zLnByb3BlcnR5XSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0UHJvcGVydHkoIHdpZGdldC5vcHRpb25zLnByb3BlcnR5LCB2YWx1ZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdpZGdldC5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHdpZGdldC5jYWxsYmFjayh3aWRnZXQudmFsdWUsIHRoYXQsIG5vZGUsIHBvcywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGRyYXdzIGV2ZXJ5IGdyb3VwIGFyZWEgaW4gdGhlIGJhY2tncm91bmRcbiAgICAgKiBAbWV0aG9kIGRyYXdHcm91cHNcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5kcmF3R3JvdXBzID0gZnVuY3Rpb24oY2FudmFzLCBjdHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncmFwaC5fZ3JvdXBzO1xuXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNSAqIHRoaXMuZWRpdG9yX2FscGhhO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbaV07XG5cbiAgICAgICAgICAgIGlmICghb3ZlcmxhcEJvdW5kaW5nKHRoaXMudmlzaWJsZV9hcmVhLCBncm91cC5fYm91bmRpbmcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vb3V0IG9mIHRoZSB2aXNpYmxlIGFyZWFcblxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyb3VwLmNvbG9yIHx8IFwiIzMzNVwiO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZ3JvdXAuY29sb3IgfHwgXCIjMzM1XCI7XG4gICAgICAgICAgICB2YXIgcG9zID0gZ3JvdXAuX3BvcztcbiAgICAgICAgICAgIHZhciBzaXplID0gZ3JvdXAuX3NpemU7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjI1ICogdGhpcy5lZGl0b3JfYWxwaGE7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgucmVjdChwb3NbMF0gKyAwLjUsIHBvc1sxXSArIDAuNSwgc2l6ZVswXSwgc2l6ZVsxXSk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5lZGl0b3JfYWxwaGE7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9zWzBdICsgc2l6ZVswXSwgcG9zWzFdICsgc2l6ZVsxXSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBvc1swXSArIHNpemVbMF0gLSAxMCwgcG9zWzFdICsgc2l6ZVsxXSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBvc1swXSArIHNpemVbMF0sIHBvc1sxXSArIHNpemVbMV0gLSAxMCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgICAgICB2YXIgZm9udF9zaXplID1cbiAgICAgICAgICAgICAgICBncm91cC5mb250X3NpemUgfHwgTGl0ZUdyYXBoLkRFRkFVTFRfR1JPVVBfRk9OVF9TSVpFO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250X3NpemUgKyBcInB4IEFyaWFsXCI7XG5cdFx0XHRjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoZ3JvdXAudGl0bGUsIHBvc1swXSArIDQsIHBvc1sxXSArIGZvbnRfc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmFkanVzdE5vZGVzU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmdyYXBoLl9ub2RlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbm9kZXNbaV0uc2l6ZSA9IG5vZGVzW2ldLmNvbXB1dGVTaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXREaXJ0eSh0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVzaXplcyB0aGUgY2FudmFzIHRvIGEgZ2l2ZW4gc2l6ZSwgaWYgbm8gc2l6ZSBpcyBwYXNzZWQsIHRoZW4gaXQgdHJpZXMgdG8gZmlsbCB0aGUgcGFyZW50Tm9kZVxuICAgICAqIEBtZXRob2QgcmVzaXplXG4gICAgICoqL1xuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICBpZiAoIXdpZHRoICYmICFoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmNhbnZhcy5wYXJlbnROb2RlO1xuICAgICAgICAgICAgd2lkdGggPSBwYXJlbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSBwYXJlbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY2FudmFzLndpZHRoID09IHdpZHRoICYmIHRoaXMuY2FudmFzLmhlaWdodCA9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5iZ2NhbnZhcy53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoO1xuICAgICAgICB0aGlzLmJnY2FudmFzLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodDtcbiAgICAgICAgdGhpcy5zZXREaXJ0eSh0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc3dpdGNoZXMgdG8gbGl2ZSBtb2RlIChub2RlIHNoYXBlcyBhcmUgbm90IHJlbmRlcmVkLCBvbmx5IHRoZSBjb250ZW50KVxuICAgICAqIHRoaXMgZmVhdHVyZSB3YXMgZGVzaWduZWQgd2hlbiBncmFwaHMgd2hlcmUgbWVhbnQgdG8gY3JlYXRlIHVzZXIgaW50ZXJmYWNlc1xuICAgICAqIEBtZXRob2Qgc3dpdGNoTGl2ZU1vZGVcbiAgICAgKiovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zd2l0Y2hMaXZlTW9kZSA9IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcbiAgICAgICAgaWYgKCF0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxpdmVfbW9kZSA9ICF0aGlzLmxpdmVfbW9kZTtcbiAgICAgICAgICAgIHRoaXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlydHlfYmdjYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZGVsdGEgPSB0aGlzLmxpdmVfbW9kZSA/IDEuMSA6IDAuOTtcbiAgICAgICAgaWYgKHRoaXMubGl2ZV9tb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmxpdmVfbW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JfYWxwaGEgPSAwLjE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5lZGl0b3JfYWxwaGEgKj0gZGVsdGE7XG4gICAgICAgICAgICBzZWxmLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLmRpcnR5X2JnY2FudmFzID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGRlbHRhIDwgMSAmJiBzZWxmLmVkaXRvcl9hbHBoYSA8IDAuMDEpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHQpO1xuICAgICAgICAgICAgICAgIGlmIChkZWx0YSA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5saXZlX21vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDEgJiYgc2VsZi5lZGl0b3JfYWxwaGEgPiAwLjk5KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0KTtcbiAgICAgICAgICAgICAgICBzZWxmLmVkaXRvcl9hbHBoYSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEpO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLm9uTm9kZVNlbGVjdGlvbkNoYW5nZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuOyAvL2Rpc2FibGVkXG4gICAgfTtcblxuICAgIC8qIHRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gZm9yIHRvdWNoIG5vdCBpbiBwcm9kdWN0aW9uIGFuZCBub3QgcmVhZHlcbiAgICAgKi9cbiAgICAvKkxHcmFwaENhbnZhcy5wcm90b3R5cGUudG91Y2hIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgLy9hbGVydChcImZvb1wiKTtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgICAgIGZpcnN0ID0gdG91Y2hlc1swXSxcbiAgICAgICAgICAgIHR5cGUgPSBcIlwiO1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRvdWNoc3RhcnRcIjpcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJtb3VzZWRvd25cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0b3VjaG1vdmVcIjpcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJtb3VzZW1vdmVcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0b3VjaGVuZFwiOlxuICAgICAgICAgICAgICAgIHR5cGUgPSBcIm1vdXNldXBcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pbml0TW91c2VFdmVudCh0eXBlLCBjYW5CdWJibGUsIGNhbmNlbGFibGUsIHZpZXcsIGNsaWNrQ291bnQsXG4gICAgICAgIC8vICAgICAgICAgICBzY3JlZW5YLCBzY3JlZW5ZLCBjbGllbnRYLCBjbGllbnRZLCBjdHJsS2V5LFxuICAgICAgICAvLyAgICAgICAgICAgYWx0S2V5LCBzaGlmdEtleSwgbWV0YUtleSwgYnV0dG9uLCByZWxhdGVkVGFyZ2V0KTtcblxuICAgICAgICAvLyB0aGlzIGlzIGV2ZW50dWFsbHkgYSBEb20gb2JqZWN0LCBnZXQgdGhlIExHcmFwaENhbnZhcyBiYWNrXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLmdldENhbnZhc1dpbmRvdyA9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgIHZhciB3aW5kb3cgPSB0aGlzLmxncmFwaGNhbnZhcy5nZXRDYW52YXNXaW5kb3coKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB2YXIgd2luZG93ID0gdGhpcy5nZXRDYW52YXNXaW5kb3coKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG4gICAgICAgIHZhciBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKTtcbiAgICAgICAgc2ltdWxhdGVkRXZlbnQuaW5pdE1vdXNlRXZlbnQoXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICB3aW5kb3csXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgZmlyc3Quc2NyZWVuWCxcbiAgICAgICAgICAgIGZpcnN0LnNjcmVlblksXG4gICAgICAgICAgICBmaXJzdC5jbGllbnRYLFxuICAgICAgICAgICAgZmlyc3QuY2xpZW50WSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgMCwgLy9sZWZ0XG4gICAgICAgICAgICBudWxsXG4gICAgICAgICk7XG4gICAgICAgIGZpcnN0LnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9OyovXG5cbiAgICAvKiBDT05URVhUIE1FTlUgKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBMR3JhcGhDYW52YXMub25Hcm91cEFkZCA9IGZ1bmN0aW9uKGluZm8sIGVudHJ5LCBtb3VzZV9ldmVudCkge1xuICAgICAgICB2YXIgY2FudmFzID0gTEdyYXBoQ2FudmFzLmFjdGl2ZV9jYW52YXM7XG4gICAgICAgIHZhciByZWZfd2luZG93ID0gY2FudmFzLmdldENhbnZhc1dpbmRvdygpO1xuXG4gICAgICAgIHZhciBncm91cCA9IG5ldyBMaXRlR3JhcGguTEdyYXBoR3JvdXAoKTtcbiAgICAgICAgZ3JvdXAucG9zID0gY2FudmFzLmNvbnZlcnRFdmVudFRvQ2FudmFzT2Zmc2V0KG1vdXNlX2V2ZW50KTtcbiAgICAgICAgY2FudmFzLmdyYXBoLmFkZChncm91cCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIGZ1cnRoZXN0IG5vZGVzIGluIGVhY2ggZGlyZWN0aW9uXG4gICAgICogQHBhcmFtIG5vZGVzIHtMR3JhcGhOb2RlW119IHRoZSBub2RlcyB0byBmcm9tIHdoaWNoIGJvdW5kYXJ5IG5vZGVzIHdpbGwgYmUgZXh0cmFjdGVkXG4gICAgICogQHJldHVybiB7e2xlZnQ6IExHcmFwaE5vZGUsIHRvcDogTEdyYXBoTm9kZSwgcmlnaHQ6IExHcmFwaE5vZGUsIGJvdHRvbTogTEdyYXBoTm9kZX19XG4gICAgICovXG4gICAgTEdyYXBoQ2FudmFzLmdldEJvdW5kYXJ5Tm9kZXMgPSBmdW5jdGlvbihub2Rlcykge1xuICAgICAgICBsZXQgdG9wID0gbnVsbDtcbiAgICAgICAgbGV0IHJpZ2h0ID0gbnVsbDtcbiAgICAgICAgbGV0IGJvdHRvbSA9IG51bGw7XG4gICAgICAgIGxldCBsZWZ0ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBuSUQgaW4gbm9kZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tuSURdO1xuICAgICAgICAgICAgY29uc3QgW3gsIHldID0gbm9kZS5wb3M7XG4gICAgICAgICAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSBub2RlLnNpemU7XG5cbiAgICAgICAgICAgIGlmICh0b3AgPT09IG51bGwgfHwgeSA8IHRvcC5wb3NbMV0pIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0ID09PSBudWxsIHx8IHggKyB3aWR0aCA+IHJpZ2h0LnBvc1swXSArIHJpZ2h0LnNpemVbMF0pIHtcbiAgICAgICAgICAgICAgICByaWdodCA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm90dG9tID09PSBudWxsIHx8IHkgKyBoZWlnaHQgPiBib3R0b20ucG9zWzFdICsgYm90dG9tLnNpemVbMV0pIHtcbiAgICAgICAgICAgICAgICBib3R0b20gPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnQgPT09IG51bGwgfHwgeCA8IGxlZnQucG9zWzBdKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJ0b3BcIjogdG9wLFxuICAgICAgICAgICAgXCJyaWdodFwiOiByaWdodCxcbiAgICAgICAgICAgIFwiYm90dG9tXCI6IGJvdHRvbSxcbiAgICAgICAgICAgIFwibGVmdFwiOiBsZWZ0XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIGZ1cnRoZXN0IG5vZGVzIGluIGVhY2ggZGlyZWN0aW9uIGZvciB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGVzXG4gICAgICogQHJldHVybiB7e2xlZnQ6IExHcmFwaE5vZGUsIHRvcDogTEdyYXBoTm9kZSwgcmlnaHQ6IExHcmFwaE5vZGUsIGJvdHRvbTogTEdyYXBoTm9kZX19XG4gICAgICovXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5ib3VuZGFyeU5vZGVzRm9yU2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBMR3JhcGhDYW52YXMuZ2V0Qm91bmRhcnlOb2RlcyhPYmplY3QudmFsdWVzKHRoaXMuc2VsZWN0ZWRfbm9kZXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TEdyYXBoTm9kZVtdfSBub2RlcyBhIGxpc3Qgb2Ygbm9kZXNcbiAgICAgKiBAcGFyYW0ge1widG9wXCJ8XCJib3R0b21cInxcImxlZnRcInxcInJpZ2h0XCJ9IGRpcmVjdGlvbiBEaXJlY3Rpb24gdG8gYWxpZ24gdGhlIG5vZGVzXG4gICAgICogQHBhcmFtIHtMR3JhcGhOb2RlP30gYWxpZ25fdG8gTm9kZSB0byBhbGlnbiB0byAoaWYgbnVsbCwgYWxpZ24gdG8gdGhlIGZ1cnRoZXN0IG5vZGUgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbilcbiAgICAgKi9cbiAgICBMR3JhcGhDYW52YXMuYWxpZ25Ob2RlcyA9IGZ1bmN0aW9uIChub2RlcywgZGlyZWN0aW9uLCBhbGlnbl90bykge1xuICAgICAgICBpZiAoIW5vZGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYW52YXMgPSBMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcztcbiAgICAgICAgbGV0IGJvdW5kYXJ5Tm9kZXMgPSBbXVxuICAgICAgICBpZiAoYWxpZ25fdG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYm91bmRhcnlOb2RlcyA9IExHcmFwaENhbnZhcy5nZXRCb3VuZGFyeU5vZGVzKG5vZGVzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm91bmRhcnlOb2RlcyA9IHtcbiAgICAgICAgICAgICAgICBcInRvcFwiOiBhbGlnbl90byxcbiAgICAgICAgICAgICAgICBcInJpZ2h0XCI6IGFsaWduX3RvLFxuICAgICAgICAgICAgICAgIFwiYm90dG9tXCI6IGFsaWduX3RvLFxuICAgICAgICAgICAgICAgIFwibGVmdFwiOiBhbGlnbl90b1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBbXywgbm9kZV0gb2YgT2JqZWN0LmVudHJpZXMoY2FudmFzLnNlbGVjdGVkX25vZGVzKSkge1xuICAgICAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wb3NbMF0gPSBib3VuZGFyeU5vZGVzW1wicmlnaHRcIl0ucG9zWzBdICsgYm91bmRhcnlOb2Rlc1tcInJpZ2h0XCJdLnNpemVbMF0gLSBub2RlLnNpemVbMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucG9zWzBdID0gYm91bmRhcnlOb2Rlc1tcImxlZnRcIl0ucG9zWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucG9zWzFdID0gYm91bmRhcnlOb2Rlc1tcInRvcFwiXS5wb3NbMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wb3NbMV0gPSBib3VuZGFyeU5vZGVzW1wiYm90dG9tXCJdLnBvc1sxXSArIGJvdW5kYXJ5Tm9kZXNbXCJib3R0b21cIl0uc2l6ZVsxXSAtIG5vZGUuc2l6ZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYW52YXMuZGlydHlfY2FudmFzID0gdHJ1ZTtcbiAgICAgICAgY2FudmFzLmRpcnR5X2JnY2FudmFzID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLm9uTm9kZUFsaWduID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMsIGV2ZW50LCBwcmV2X21lbnUsIG5vZGUpIHtcbiAgICAgICAgbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudShbXCJUb3BcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIsIFwiUmlnaHRcIl0sIHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBpbm5lcl9jbGlja2VkLFxuICAgICAgICAgICAgcGFyZW50TWVudTogcHJldl9tZW51LFxuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBpbm5lcl9jbGlja2VkKHZhbHVlKSB7XG4gICAgICAgICAgICBMR3JhcGhDYW52YXMuYWxpZ25Ob2RlcyhMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcy5zZWxlY3RlZF9ub2RlcywgdmFsdWUudG9Mb3dlckNhc2UoKSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBMR3JhcGhDYW52YXMub25Hcm91cEFsaWduID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMsIGV2ZW50LCBwcmV2X21lbnUpIHtcbiAgICAgICAgbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudShbXCJUb3BcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIsIFwiUmlnaHRcIl0sIHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBpbm5lcl9jbGlja2VkLFxuICAgICAgICAgICAgcGFyZW50TWVudTogcHJldl9tZW51LFxuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBpbm5lcl9jbGlja2VkKHZhbHVlKSB7XG4gICAgICAgICAgICBMR3JhcGhDYW52YXMuYWxpZ25Ob2RlcyhMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcy5zZWxlY3RlZF9ub2RlcywgdmFsdWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBMR3JhcGhDYW52YXMub25NZW51QWRkID0gZnVuY3Rpb24gKG5vZGUsIG9wdGlvbnMsIGUsIHByZXZfbWVudSwgY2FsbGJhY2spIHtcblxuICAgICAgICB2YXIgY2FudmFzID0gTEdyYXBoQ2FudmFzLmFjdGl2ZV9jYW52YXM7XG4gICAgICAgIHZhciByZWZfd2luZG93ID0gY2FudmFzLmdldENhbnZhc1dpbmRvdygpO1xuICAgICAgICB2YXIgZ3JhcGggPSBjYW52YXMuZ3JhcGg7XG4gICAgICAgIGlmICghZ3JhcGgpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgZnVuY3Rpb24gaW5uZXJfb25NZW51QWRkZWQoYmFzZV9jYXRlZ29yeSAscHJldl9tZW51KXtcbiAgICBcbiAgICAgICAgICAgIHZhciBjYXRlZ29yaWVzICA9IExpdGVHcmFwaC5nZXROb2RlVHlwZXNDYXRlZ29yaWVzKGNhbnZhcy5maWx0ZXIgfHwgZ3JhcGguZmlsdGVyKS5maWx0ZXIoZnVuY3Rpb24oY2F0ZWdvcnkpe3JldHVybiBjYXRlZ29yeS5zdGFydHNXaXRoKGJhc2VfY2F0ZWdvcnkpfSk7XG4gICAgICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIFxuICAgICAgICAgICAgY2F0ZWdvcmllcy5tYXAoZnVuY3Rpb24oY2F0ZWdvcnkpe1xuICAgIFxuICAgICAgICAgICAgICAgIGlmICghY2F0ZWdvcnkpIFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgXG4gICAgICAgICAgICAgICAgdmFyIGJhc2VfY2F0ZWdvcnlfcmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBiYXNlX2NhdGVnb3J5ICsgJyknKTtcbiAgICAgICAgICAgICAgICB2YXIgY2F0ZWdvcnlfbmFtZSA9IGNhdGVnb3J5LnJlcGxhY2UoYmFzZV9jYXRlZ29yeV9yZWdleCxcIlwiKS5zcGxpdCgnLycpWzBdO1xuICAgICAgICAgICAgICAgIHZhciBjYXRlZ29yeV9wYXRoID0gYmFzZV9jYXRlZ29yeSAgPT09ICcnID8gY2F0ZWdvcnlfbmFtZSArICcvJyA6IGJhc2VfY2F0ZWdvcnkgKyBjYXRlZ29yeV9uYW1lICsgJy8nO1xuICAgIFxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gY2F0ZWdvcnlfbmFtZTtcbiAgICAgICAgICAgICAgICBpZihuYW1lLmluZGV4T2YoXCI6OlwiKSAhPSAtMSkgLy9pbiBjYXNlIGl0IGhhcyBhIG5hbWVzcGFjZSBsaWtlIFwic2hhZGVyOjptYXRoL3JhbmRcIiBpdCBoaWRlcyB0aGUgbmFtZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNwbGl0KFwiOjpcIilbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBlbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbihlbnRyeSl7cmV0dXJuIGVudHJ5LnZhbHVlID09PSBjYXRlZ29yeV9wYXRofSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2goeyB2YWx1ZTogY2F0ZWdvcnlfcGF0aCwgY29udGVudDogbmFtZSwgaGFzX3N1Ym1lbnU6IHRydWUsIGNhbGxiYWNrIDogZnVuY3Rpb24odmFsdWUsIGV2ZW50LCBtb3VzZUV2ZW50LCBjb250ZXh0TWVudSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lcl9vbk1lbnVBZGRlZCh2YWx1ZS52YWx1ZSwgY29udGV4dE1lbnUpXG4gICAgICAgICAgICAgICAgICAgIH19KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgIHZhciBub2RlcyA9IExpdGVHcmFwaC5nZXROb2RlVHlwZXNJbkNhdGVnb3J5KGJhc2VfY2F0ZWdvcnkuc2xpY2UoMCwgLTEpLCBjYW52YXMuZmlsdGVyIHx8IGdyYXBoLmZpbHRlciApO1xuICAgICAgICAgICAgbm9kZXMubWFwKGZ1bmN0aW9uKG5vZGUpe1xuICAgIFxuICAgICAgICAgICAgICAgIGlmIChub2RlLnNraXBfbGlzdClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgIFxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHsgdmFsdWU6IG5vZGUudHlwZSwgY29udGVudDogbm9kZS50aXRsZSwgaGFzX3N1Ym1lbnU6IGZhbHNlICwgY2FsbGJhY2sgOiBmdW5jdGlvbih2YWx1ZSwgZXZlbnQsIG1vdXNlRXZlbnQsIGNvbnRleHRNZW51KXtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RfZXZlbnQgPSBjb250ZXh0TWVudS5nZXRGaXJzdEV2ZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMuZ3JhcGguYmVmb3JlQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IExpdGVHcmFwaC5jcmVhdGVOb2RlKHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wb3MgPSBjYW52YXMuY29udmVydEV2ZW50VG9DYW52YXNPZmZzZXQoZmlyc3RfZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5ncmFwaC5hZGQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5ncmFwaC5hZnRlckNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICAgIFxuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICBuZXcgTGl0ZUdyYXBoLkNvbnRleHRNZW51KCBlbnRyaWVzLCB7IGV2ZW50OiBlLCBwYXJlbnRNZW51OiBwcmV2X21lbnUgfSwgcmVmX3dpbmRvdyApO1xuICAgIFxuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlubmVyX29uTWVudUFkZGVkKCcnLHByZXZfbWVudSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLm9uTWVudUNvbGxhcHNlQWxsID0gZnVuY3Rpb24oKSB7fTtcblxuICAgIExHcmFwaENhbnZhcy5vbk1lbnVOb2RlRWRpdCA9IGZ1bmN0aW9uKCkge307XG5cbiAgICBMR3JhcGhDYW52YXMuc2hvd01lbnVOb2RlT3B0aW9uYWxJbnB1dHMgPSBmdW5jdGlvbihcbiAgICAgICAgdixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZSxcbiAgICAgICAgcHJldl9tZW51LFxuICAgICAgICBub2RlXG4gICAgKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgY2FudmFzID0gTEdyYXBoQ2FudmFzLmFjdGl2ZV9jYW52YXM7XG4gICAgICAgIHZhciByZWZfd2luZG93ID0gY2FudmFzLmdldENhbnZhc1dpbmRvdygpO1xuXG4gICAgICAgIHZhciBvcHRpb25zID0gbm9kZS5vcHRpb25hbF9pbnB1dHM7XG4gICAgICAgIGlmIChub2RlLm9uR2V0SW5wdXRzKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gbm9kZS5vbkdldElucHV0cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBvcHRpb25zW2ldO1xuICAgICAgICAgICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gZW50cnlbMF07XG5cdFx0XHRcdGlmKCFlbnRyeVsyXSlcblx0XHRcdFx0XHRlbnRyeVsyXSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5WzJdLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsID0gZW50cnlbMl0ubGFiZWw7XG4gICAgICAgICAgICAgICAgfVxuXG5cdFx0XHRcdGVudHJ5WzJdLnJlbW92YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7IGNvbnRlbnQ6IGxhYmVsLCB2YWx1ZTogZW50cnkgfTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnlbMV0gPT0gTGl0ZUdyYXBoLkFDVElPTikge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmNsYXNzTmFtZSA9IFwiZXZlbnRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUub25NZW51Tm9kZUlucHV0cykge1xuICAgICAgICAgICAgdmFyIHJldEVudHJpZXMgPSBub2RlLm9uTWVudU5vZGVJbnB1dHMoZW50cmllcyk7XG4gICAgICAgICAgICBpZihyZXRFbnRyaWVzKSBlbnRyaWVzID0gcmV0RW50cmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZW50cmllcy5sZW5ndGgpIHtcblx0XHRcdGNvbnNvbGUubG9nKFwibm8gaW5wdXQgZW50cmllc1wiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZW51ID0gbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudShcbiAgICAgICAgICAgIGVudHJpZXMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGlubmVyX2NsaWNrZWQsXG4gICAgICAgICAgICAgICAgcGFyZW50TWVudTogcHJldl9tZW51LFxuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWZfd2luZG93XG4gICAgICAgICk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5uZXJfY2xpY2tlZCh2LCBlLCBwcmV2KSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2LmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdi5jYWxsYmFjay5jYWxsKHRoYXQsIG5vZGUsIHYsIGUsIHByZXYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodi52YWx1ZSkge1xuXHRcdFx0XHRub2RlLmdyYXBoLmJlZm9yZUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkSW5wdXQodi52YWx1ZVswXSwgdi52YWx1ZVsxXSwgdi52YWx1ZVsyXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5vbk5vZGVJbnB1dEFkZCkgeyAvLyBjYWxsYmFjayB0byB0aGUgbm9kZSB3aGVuIGFkZGluZyBhIHNsb3RcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5vbk5vZGVJbnB1dEFkZCh2LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcblx0XHRcdFx0bm9kZS5ncmFwaC5hZnRlckNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMuc2hvd01lbnVOb2RlT3B0aW9uYWxPdXRwdXRzID0gZnVuY3Rpb24oXG4gICAgICAgIHYsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGUsXG4gICAgICAgIHByZXZfbWVudSxcbiAgICAgICAgbm9kZVxuICAgICkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIGNhbnZhcyA9IExHcmFwaENhbnZhcy5hY3RpdmVfY2FudmFzO1xuICAgICAgICB2YXIgcmVmX3dpbmRvdyA9IGNhbnZhcy5nZXRDYW52YXNXaW5kb3coKTtcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9uYWxfb3V0cHV0cztcbiAgICAgICAgaWYgKG5vZGUub25HZXRPdXRwdXRzKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gbm9kZS5vbkdldE91dHB1dHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vc2VwYXJhdG9yP1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5mbGFncyAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlLmZsYWdzLnNraXBfcmVwZWF0ZWRfb3V0cHV0cyAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlLmZpbmRPdXRwdXRTbG90KGVudHJ5WzBdKSAhPSAtMVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IC8vc2tpcCB0aGUgb25lcyBhbHJlYWR5IG9uXG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gZW50cnlbMF07XG5cdFx0XHRcdGlmKCFlbnRyeVsyXSlcblx0XHRcdFx0XHRlbnRyeVsyXSA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeVsyXS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGVudHJ5WzJdLmxhYmVsO1xuICAgICAgICAgICAgICAgIH1cblx0XHRcdFx0ZW50cnlbMl0ucmVtb3ZhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHsgY29udGVudDogbGFiZWwsIHZhbHVlOiBlbnRyeSB9O1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeVsxXSA9PSBMaXRlR3JhcGguRVZFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5jbGFzc05hbWUgPSBcImV2ZW50XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9uTWVudU5vZGVPdXRwdXRzKSB7XG4gICAgICAgICAgICBlbnRyaWVzID0gdGhpcy5vbk1lbnVOb2RlT3V0cHV0cyhlbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTGl0ZUdyYXBoLmRvX2FkZF90cmlnZ2Vyc19zbG90cyl7IC8vY2FudmFzLmFsbG93X2FkZE91dFNsb3Rfb25FeGVjdXRlZFxuICAgICAgICAgICAgaWYgKG5vZGUuZmluZE91dHB1dFNsb3QoXCJvbkV4ZWN1dGVkXCIpID09IC0xKXtcbiAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2goe2NvbnRlbnQ6IFwiT24gRXhlY3V0ZWRcIiwgdmFsdWU6IFtcIm9uRXhlY3V0ZWRcIiwgTGl0ZUdyYXBoLkVWRU5ULCB7bmFtZUxvY2tlZDogdHJ1ZX1dLCBjbGFzc05hbWU6IFwiZXZlbnRcIn0pOyAvLywgb3B0czoge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgY2FsbGJhY2sgZm9yIG1vZGlmaW5nIHRoZSBtZW51IGVsZW1lbnRzIG9uTWVudU5vZGVPdXRwdXRzXG4gICAgICAgIGlmIChub2RlLm9uTWVudU5vZGVPdXRwdXRzKSB7XG4gICAgICAgICAgICB2YXIgcmV0RW50cmllcyA9IG5vZGUub25NZW51Tm9kZU91dHB1dHMoZW50cmllcyk7XG4gICAgICAgICAgICBpZihyZXRFbnRyaWVzKSBlbnRyaWVzID0gcmV0RW50cmllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZW51ID0gbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudShcbiAgICAgICAgICAgIGVudHJpZXMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGlubmVyX2NsaWNrZWQsXG4gICAgICAgICAgICAgICAgcGFyZW50TWVudTogcHJldl9tZW51LFxuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWZfd2luZG93XG4gICAgICAgICk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5uZXJfY2xpY2tlZCh2LCBlLCBwcmV2KSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2LmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdi5jYWxsYmFjay5jYWxsKHRoYXQsIG5vZGUsIHYsIGUsIHByZXYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHYudmFsdWVbMV07XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB2YWx1ZSAmJlxuICAgICAgICAgICAgICAgICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0IHx8IHZhbHVlLmNvbnN0cnVjdG9yID09PSBBcnJheSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vc3VibWVudSB3aHk/XG4gICAgICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaCh7IGNvbnRlbnQ6IGksIHZhbHVlOiB2YWx1ZVtpXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudShlbnRyaWVzLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBlLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogaW5uZXJfY2xpY2tlZCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50TWVudTogcHJldl9tZW51LFxuICAgICAgICAgICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcblx0XHRcdFx0bm9kZS5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICBub2RlLmFkZE91dHB1dCh2LnZhbHVlWzBdLCB2LnZhbHVlWzFdLCB2LnZhbHVlWzJdKTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlLm9uTm9kZU91dHB1dEFkZCkgeyAvLyBhIGNhbGxiYWNrIHRvIHRoZSBub2RlIHdoZW4gYWRkaW5nIGEgc2xvdFxuICAgICAgICAgICAgICAgICAgICBub2RlLm9uTm9kZU91dHB1dEFkZCh2LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcblx0XHRcdFx0bm9kZS5ncmFwaC5hZnRlckNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMub25TaG93TWVudU5vZGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBlLFxuICAgICAgICBwcmV2X21lbnUsXG4gICAgICAgIG5vZGVcbiAgICApIHtcbiAgICAgICAgaWYgKCFub2RlIHx8ICFub2RlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIGNhbnZhcyA9IExHcmFwaENhbnZhcy5hY3RpdmVfY2FudmFzO1xuICAgICAgICB2YXIgcmVmX3dpbmRvdyA9IGNhbnZhcy5nZXRDYW52YXNXaW5kb3coKTtcblxuICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpIGluIG5vZGUucHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5wcm9wZXJ0aWVzW2ldICE9PSB1bmRlZmluZWQgPyBub2RlLnByb3BlcnRpZXNbaV0gOiBcIiBcIjtcblx0XHRcdGlmKCB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiApXG5cdFx0XHRcdHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXHRcdFx0dmFyIGluZm8gPSBub2RlLmdldFByb3BlcnR5SW5mbyhpKTtcblx0XHRcdGlmKGluZm8udHlwZSA9PSBcImVudW1cIiB8fCBpbmZvLnR5cGUgPT0gXCJjb21ib1wiKVxuXHRcdFx0XHR2YWx1ZSA9IExHcmFwaENhbnZhcy5nZXRQcm9wZXJ0eVByaW50YWJsZVZhbHVlKCB2YWx1ZSwgaW5mby52YWx1ZXMgKTtcblxuICAgICAgICAgICAgLy92YWx1ZSBjb3VsZCBjb250YWluIGludmFsaWQgaHRtbCBjaGFyYWN0ZXJzLCBjbGVhbiB0aGF0XG4gICAgICAgICAgICB2YWx1ZSA9IExHcmFwaENhbnZhcy5kZWNvZGVIVE1MKHZhbHVlKTtcbiAgICAgICAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29udGVudDpcbiAgICAgICAgICAgICAgICAgICAgXCI8c3BhbiBjbGFzcz0ncHJvcGVydHlfbmFtZSc+XCIgK1xuICAgICAgICAgICAgICAgICAgICAoaW5mby5sYWJlbCA/IGluZm8ubGFiZWwgOiBpKSArXG4gICAgICAgICAgICAgICAgICAgIFwiPC9zcGFuPlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCI8c3BhbiBjbGFzcz0ncHJvcGVydHlfdmFsdWUnPlwiICtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgK1xuICAgICAgICAgICAgICAgICAgICBcIjwvc3Bhbj5cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogaVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1lbnUgPSBuZXcgTGl0ZUdyYXBoLkNvbnRleHRNZW51KFxuICAgICAgICAgICAgZW50cmllcyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogaW5uZXJfY2xpY2tlZCxcbiAgICAgICAgICAgICAgICBwYXJlbnRNZW51OiBwcmV2X21lbnUsXG4gICAgICAgICAgICAgICAgYWxsb3dfaHRtbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVmX3dpbmRvd1xuICAgICAgICApO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlubmVyX2NsaWNrZWQodiwgb3B0aW9ucywgZSwgcHJldikge1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgY2FudmFzLnNob3dFZGl0UHJvcGVydHlWYWx1ZShub2RlLCB2LnZhbHVlLCB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFtyZWN0LmxlZnQsIHJlY3QudG9wXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5kZWNvZGVIVE1MID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZS5pbm5lclRleHQgPSBzdHI7XG4gICAgICAgIHJldHVybiBlLmlubmVySFRNTDtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLm9uTWVudVJlc2l6ZU5vZGUgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucywgZSwgbWVudSwgbm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcblx0XHR2YXIgZkFwcGx5TXVsdGlOb2RlID0gZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRub2RlLnNpemUgPSBub2RlLmNvbXB1dGVTaXplKCk7XG5cdFx0XHRpZiAobm9kZS5vblJlc2l6ZSlcblx0XHRcdFx0bm9kZS5vblJlc2l6ZShub2RlLnNpemUpO1xuXHRcdH1cblx0XHRcblx0XHR2YXIgZ3JhcGhjYW52YXMgPSBMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcztcblx0XHRpZiAoIWdyYXBoY2FudmFzLnNlbGVjdGVkX25vZGVzIHx8IE9iamVjdC5rZXlzKGdyYXBoY2FudmFzLnNlbGVjdGVkX25vZGVzKS5sZW5ndGggPD0gMSl7XG5cdFx0XHRmQXBwbHlNdWx0aU5vZGUobm9kZSk7XG5cdFx0fWVsc2V7XG5cdFx0XHRmb3IgKHZhciBpIGluIGdyYXBoY2FudmFzLnNlbGVjdGVkX25vZGVzKSB7XG5cdFx0XHRcdGZBcHBseU11bHRpTm9kZShncmFwaGNhbnZhcy5zZWxlY3RlZF9ub2Rlc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuICAgICAgICBub2RlLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnNob3dMaW5rTWVudSA9IGZ1bmN0aW9uKGxpbmssIGUpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXHRcdC8vIGNvbnNvbGUubG9nKGxpbmspO1xuXHRcdHZhciBub2RlX2xlZnQgPSB0aGF0LmdyYXBoLmdldE5vZGVCeUlkKCBsaW5rLm9yaWdpbl9pZCApO1xuXHRcdHZhciBub2RlX3JpZ2h0ID0gdGhhdC5ncmFwaC5nZXROb2RlQnlJZCggbGluay50YXJnZXRfaWQgKTtcblx0XHR2YXIgZnJvbVR5cGUgPSBmYWxzZTtcblx0XHRpZiAobm9kZV9sZWZ0ICYmIG5vZGVfbGVmdC5vdXRwdXRzICYmIG5vZGVfbGVmdC5vdXRwdXRzW2xpbmsub3JpZ2luX3Nsb3RdKSBmcm9tVHlwZSA9IG5vZGVfbGVmdC5vdXRwdXRzW2xpbmsub3JpZ2luX3Nsb3RdLnR5cGU7XG4gICAgICAgIHZhciBkZXN0VHlwZSA9IGZhbHNlO1xuXHRcdGlmIChub2RlX3JpZ2h0ICYmIG5vZGVfcmlnaHQub3V0cHV0cyAmJiBub2RlX3JpZ2h0Lm91dHB1dHNbbGluay50YXJnZXRfc2xvdF0pIGRlc3RUeXBlID0gbm9kZV9yaWdodC5pbnB1dHNbbGluay50YXJnZXRfc2xvdF0udHlwZTtcblx0XHRcblx0XHR2YXIgb3B0aW9ucyA9IFtcIkFkZCBOb2RlXCIsbnVsbCxcIkRlbGV0ZVwiLG51bGxdO1xuXHRcdFxuXHRcdFxuICAgICAgICB2YXIgbWVudSA9IG5ldyBMaXRlR3JhcGguQ29udGV4dE1lbnUob3B0aW9ucywge1xuICAgICAgICAgICAgZXZlbnQ6IGUsXG5cdFx0XHR0aXRsZTogbGluay5kYXRhICE9IG51bGwgPyBsaW5rLmRhdGEuY29uc3RydWN0b3IubmFtZSA6IG51bGwsXG4gICAgICAgICAgICBjYWxsYmFjazogaW5uZXJfY2xpY2tlZFxuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBpbm5lcl9jbGlja2VkKHYsb3B0aW9ucyxlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHYpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiQWRkIE5vZGVcIjpcblx0XHRcdFx0XHRMR3JhcGhDYW52YXMub25NZW51QWRkKG51bGwsIG51bGwsIGUsIG1lbnUsIGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5kZWJ1ZyhcIm5vZGUgYXV0b2Nvbm5lY3RcIik7XG5cdFx0XHRcdFx0XHRpZighbm9kZS5pbnB1dHMgfHwgIW5vZGUuaW5wdXRzLmxlbmd0aCB8fCAhbm9kZS5vdXRwdXRzIHx8ICFub2RlLm91dHB1dHMubGVuZ3RoKXtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gbGVhdmUgdGhlIGNvbm5lY3Rpb24gdHlwZSBjaGVja2luZyBpbnNpZGUgY29ubmVjdEJ5VHlwZVxuXHRcdFx0XHRcdFx0aWYgKG5vZGVfbGVmdC5jb25uZWN0QnlUeXBlKCBsaW5rLm9yaWdpbl9zbG90LCBub2RlLCBmcm9tVHlwZSApKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0bm9kZS5jb25uZWN0QnlUeXBlKCBsaW5rLnRhcmdldF9zbG90LCBub2RlX3JpZ2h0LCBkZXN0VHlwZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucG9zWzBdIC09IG5vZGUuc2l6ZVswXSAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiRGVsZXRlXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZ3JhcGgucmVtb3ZlTGluayhsaW5rLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0XHRcdFx0XHQvKnZhciBub2RlQ3JlYXRlZCA9IGNyZWF0ZURlZmF1bHROb2RlRm9yU2xvdCh7ICAgbm9kZUZyb206IG5vZGVfbGVmdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCxzbG90RnJvbTogbGluay5vcmlnaW5fc2xvdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCxub2RlVG86IG5vZGVcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQsc2xvdFRvOiBsaW5rLnRhcmdldF9zbG90XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LGU6IGVcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQsbm9kZVR5cGU6IFwiQVVUT1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGlmKG5vZGVDcmVhdGVkKSBjb25zb2xlLmxvZyhcIm5ldyBub2RlIGluIGJlZXR3ZWVuIFwiK3YrXCIgY3JlYXRlZFwiKTsqL1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgXG4gXHRMR3JhcGhDYW52YXMucHJvdG90eXBlLmNyZWF0ZURlZmF1bHROb2RlRm9yU2xvdCA9IGZ1bmN0aW9uKG9wdFBhc3MpIHsgLy8gYWRkTm9kZU1lbnUgZm9yIGNvbm5lY3Rpb25cbiAgICAgICAgdmFyIG9wdFBhc3MgPSBvcHRQYXNzIHx8IHt9O1xuICAgICAgICB2YXIgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyAgIG5vZGVGcm9tOiBudWxsIC8vIGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsc2xvdEZyb206IG51bGwgLy8gaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICxub2RlVG86IG51bGwgICAvLyBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICxzbG90VG86IG51bGwgICAvLyBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICxwb3NpdGlvbjogW11cdC8vIHBhc3MgdGhlIGV2ZW50IGNvb3Jkc1xuXHRcdFx0XHRcdFx0XHRcdCAgXHQsbm9kZVR5cGU6IG51bGxcdC8vIGNob29zZSBhIG5vZGV0eXBlIHRvIGFkZCwgQVVUTyB0byBzZXQgYXQgZmlyc3QgZ29vZFxuXHRcdFx0XHRcdFx0XHRcdCAgXHQscG9zQWRkOlswLDBdXHQvLyBhZGp1c3QgeCx5XG5cdFx0XHRcdFx0XHRcdFx0ICBcdCxwb3NTaXplRml4OlswLDBdIC8vIGFscGhhLCBhZGp1c3QgdGhlIHBvc2l0aW9uIHgseSBiYXNlZCBvbiB0aGUgbmV3IG5vZGUgc2l6ZSB3LGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsb3B0UGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgXG4gICAgICAgIHZhciBpc0Zyb20gPSBvcHRzLm5vZGVGcm9tICYmIG9wdHMuc2xvdEZyb20hPT1udWxsO1xuICAgICAgICB2YXIgaXNUbyA9ICFpc0Zyb20gJiYgb3B0cy5ub2RlVG8gJiYgb3B0cy5zbG90VG8hPT1udWxsO1xuXHRcbiAgICAgICAgaWYgKCFpc0Zyb20gJiYgIWlzVG8pe1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gZGF0YSBwYXNzZWQgdG8gY3JlYXRlRGVmYXVsdE5vZGVGb3JTbG90IFwiK29wdHMubm9kZUZyb20rXCIgXCIrb3B0cy5zbG90RnJvbStcIiBcIitvcHRzLm5vZGVUbytcIiBcIitvcHRzLnNsb3RUbyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblx0XHRpZiAoIW9wdHMubm9kZVR5cGUpe1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gdHlwZSB0byBjcmVhdGVEZWZhdWx0Tm9kZUZvclNsb3RcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBub2RlWCA9IGlzRnJvbSA/IG9wdHMubm9kZUZyb20gOiBvcHRzLm5vZGVUbztcbiAgICAgICAgdmFyIHNsb3RYID0gaXNGcm9tID8gb3B0cy5zbG90RnJvbSA6IG9wdHMuc2xvdFRvO1xuICAgICAgICBcbiAgICAgICAgdmFyIGlTbG90Q29ubiA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBzbG90WCl7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgaVNsb3RDb25uID0gaXNGcm9tID8gbm9kZVguZmluZE91dHB1dFNsb3Qoc2xvdFgsZmFsc2UpIDogbm9kZVguZmluZElucHV0U2xvdChzbG90WCxmYWxzZSk7XG4gICAgICAgICAgICAgICAgc2xvdFggPSBpc0Zyb20gPyBub2RlWC5vdXRwdXRzW3Nsb3RYXSA6IG5vZGVYLmlucHV0c1tzbG90WF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgICAvLyBvayBzbG90WFxuICAgICAgICAgICAgICAgIGlTbG90Q29ubiA9IGlzRnJvbSA/IG5vZGVYLmZpbmRPdXRwdXRTbG90KHNsb3RYLm5hbWUpIDogbm9kZVguZmluZElucHV0U2xvdChzbG90WC5uYW1lKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGlTbG90Q29ubiA9IHNsb3RYO1xuICAgICAgICAgICAgICAgIHNsb3RYID0gaXNGcm9tID8gbm9kZVgub3V0cHV0c1tzbG90WF0gOiBub2RlWC5pbnB1dHNbc2xvdFhdO1xuICAgICAgICAgICAgYnJlYWs7XG5cdFx0XHRjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGJhZCA/XG4gICAgICAgICAgICAgICAgLy9pU2xvdENvbm4gPSAwO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNhbnQgZ2V0IHNsb3QgaW5mb3JtYXRpb24gXCIrc2xvdFgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXHRcblx0XHRpZiAoc2xvdFg9PT1mYWxzZSB8fCBpU2xvdENvbm49PT1mYWxzZSl7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJjcmVhdGVEZWZhdWx0Tm9kZUZvclNsb3QgYmFkIHNsb3RYIFwiK3Nsb3RYK1wiIFwiK2lTbG90Q29ubik7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIGNoZWNrIGZvciBkZWZhdWx0cyBub2RlcyBmb3IgdGhpcyBzbG90dHlwZVxuXHRcdHZhciBmcm9tU2xvdFR5cGUgPSBzbG90WC50eXBlPT1MaXRlR3JhcGguRVZFTlQ/XCJfZXZlbnRfXCI6c2xvdFgudHlwZTtcblx0XHR2YXIgc2xvdFR5cGVzRGVmYXVsdCA9IGlzRnJvbSA/IExpdGVHcmFwaC5zbG90X3R5cGVzX2RlZmF1bHRfb3V0IDogTGl0ZUdyYXBoLnNsb3RfdHlwZXNfZGVmYXVsdF9pbjtcblx0XHRpZihzbG90VHlwZXNEZWZhdWx0ICYmIHNsb3RUeXBlc0RlZmF1bHRbZnJvbVNsb3RUeXBlXSl7XG5cdFx0XHRpZiAoc2xvdFgubGluayAhPT0gbnVsbCkge1xuXHRcdFx0XHQvLyBpcyBjb25uZWN0ZWRcblx0XHRcdH1lbHNle1xuXHRcdFx0XHQvLyBpcyBub3Qgbm90IGNvbm5lY3RlZFxuXHRcdFx0fVxuXHRcdFx0bm9kZU5ld1R5cGUgPSBmYWxzZTtcblx0XHRcdGlmKHR5cGVvZiBzbG90VHlwZXNEZWZhdWx0W2Zyb21TbG90VHlwZV0gPT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygc2xvdFR5cGVzRGVmYXVsdFtmcm9tU2xvdFR5cGVdID09IFwiYXJyYXlcIil7XG5cdFx0XHRcdGZvcih2YXIgdHlwZVggaW4gc2xvdFR5cGVzRGVmYXVsdFtmcm9tU2xvdFR5cGVdKXtcblx0XHRcdFx0XHRpZiAob3B0cy5ub2RlVHlwZSA9PSBzbG90VHlwZXNEZWZhdWx0W2Zyb21TbG90VHlwZV1bdHlwZVhdIHx8IG9wdHMubm9kZVR5cGUgPT0gXCJBVVRPXCIpe1xuXHRcdFx0XHRcdFx0bm9kZU5ld1R5cGUgPSBzbG90VHlwZXNEZWZhdWx0W2Zyb21TbG90VHlwZV1bdHlwZVhdO1xuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJvcHRzLm5vZGVUeXBlID09IHNsb3RUeXBlc0RlZmF1bHRbZnJvbVNsb3RUeXBlXVt0eXBlWF0gOjogXCIrb3B0cy5ub2RlVHlwZSk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gLS0tLS0tLS1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1lbHNle1xuXHRcdFx0XHRpZiAob3B0cy5ub2RlVHlwZSA9PSBzbG90VHlwZXNEZWZhdWx0W2Zyb21TbG90VHlwZV0gfHwgb3B0cy5ub2RlVHlwZSA9PSBcIkFVVE9cIikgbm9kZU5ld1R5cGUgPSBzbG90VHlwZXNEZWZhdWx0W2Zyb21TbG90VHlwZV07XG5cdFx0XHR9XG5cdFx0XHRpZiAobm9kZU5ld1R5cGUpIHtcblx0XHRcdFx0dmFyIG5vZGVOZXdPcHRzID0gZmFsc2U7XG5cdFx0XHRcdGlmICh0eXBlb2Ygbm9kZU5ld1R5cGUgPT0gXCJvYmplY3RcIiAmJiBub2RlTmV3VHlwZS5ub2RlKXtcblx0XHRcdFx0XHRub2RlTmV3T3B0cyA9IG5vZGVOZXdUeXBlO1xuXHRcdFx0XHRcdG5vZGVOZXdUeXBlID0gbm9kZU5ld1R5cGUubm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly90aGF0LmdyYXBoLmJlZm9yZUNoYW5nZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIG5ld05vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZShub2RlTmV3VHlwZSk7XG5cdFx0XHRcdGlmKG5ld05vZGUpe1xuXHRcdFx0XHRcdC8vIGlmIGlzIG9iamVjdCBwYXNzIG9wdGlvbnNcblx0XHRcdFx0XHRpZiAobm9kZU5ld09wdHMpe1xuXHRcdFx0XHRcdFx0aWYgKG5vZGVOZXdPcHRzLnByb3BlcnRpZXMpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSBpbiBub2RlTmV3T3B0cy5wcm9wZXJ0aWVzKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZS5hZGRQcm9wZXJ0eSggaSwgbm9kZU5ld09wdHMucHJvcGVydGllc1tpXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAobm9kZU5ld09wdHMuaW5wdXRzKSB7XG5cdFx0XHRcdFx0XHRcdG5ld05vZGUuaW5wdXRzID0gW107XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgaW4gbm9kZU5ld09wdHMuaW5wdXRzKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZS5hZGRPdXRwdXQoXG5cdFx0XHRcdFx0XHRcdFx0XHRub2RlTmV3T3B0cy5pbnB1dHNbaV1bMF0sXG5cdFx0XHRcdFx0XHRcdFx0XHRub2RlTmV3T3B0cy5pbnB1dHNbaV1bMV1cblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAobm9kZU5ld09wdHMub3V0cHV0cykge1xuXHRcdFx0XHRcdFx0XHRuZXdOb2RlLm91dHB1dHMgPSBbXTtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSBpbiBub2RlTmV3T3B0cy5vdXRwdXRzKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV3Tm9kZS5hZGRPdXRwdXQoXG5cdFx0XHRcdFx0XHRcdFx0XHRub2RlTmV3T3B0cy5vdXRwdXRzW2ldWzBdLFxuXHRcdFx0XHRcdFx0XHRcdFx0bm9kZU5ld09wdHMub3V0cHV0c1tpXVsxXVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChub2RlTmV3T3B0cy50aXRsZSkge1xuXHRcdFx0XHRcdFx0XHRuZXdOb2RlLnRpdGxlID0gbm9kZU5ld09wdHMudGl0bGU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAobm9kZU5ld09wdHMuanNvbikge1xuXHRcdFx0XHRcdFx0XHRuZXdOb2RlLmNvbmZpZ3VyZShub2RlTmV3T3B0cy5qc29uKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBhZGQgdGhlIG5vZGVcblx0XHRcdFx0XHR0aGF0LmdyYXBoLmFkZChuZXdOb2RlKTtcblx0XHRcdFx0XHRuZXdOb2RlLnBvcyA9IFtcdG9wdHMucG9zaXRpb25bMF0rb3B0cy5wb3NBZGRbMF0rKG9wdHMucG9zU2l6ZUZpeFswXT9vcHRzLnBvc1NpemVGaXhbMF0qbmV3Tm9kZS5zaXplWzBdOjApXG5cdFx0XHRcdFx0XHRcdFx0ICAgXHQsb3B0cy5wb3NpdGlvblsxXStvcHRzLnBvc0FkZFsxXSsob3B0cy5wb3NTaXplRml4WzFdP29wdHMucG9zU2l6ZUZpeFsxXSpuZXdOb2RlLnNpemVbMV06MCldOyAvL3RoYXQubGFzdF9jbGlja19wb3NpdGlvbjsgLy9bZS5jYW52YXNYKzMwLCBlLmNhbnZhc1grNV07Ki9cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvL3RoYXQuZ3JhcGguYWZ0ZXJDaGFuZ2UoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBjb25uZWN0IHRoZSB0d28hXG5cdFx0XHRcdFx0aWYgKGlzRnJvbSl7XG5cdFx0XHRcdFx0XHRvcHRzLm5vZGVGcm9tLmNvbm5lY3RCeVR5cGUoIGlTbG90Q29ubiwgbmV3Tm9kZSwgZnJvbVNsb3RUeXBlICk7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRvcHRzLm5vZGVUby5jb25uZWN0QnlUeXBlT3V0cHV0KCBpU2xvdENvbm4sIG5ld05vZGUsIGZyb21TbG90VHlwZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBpZiBjb25uZWN0aW5nIGluIGJldHdlZW5cblx0XHRcdFx0XHRpZiAoaXNGcm9tICYmIGlzVG8pe1xuXHRcdFx0XHRcdFx0Ly8gVE9ET1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJmYWlsZWQgY3JlYXRpbmcgXCIrbm9kZU5ld1R5cGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuIFxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuc2hvd0Nvbm5lY3Rpb25NZW51ID0gZnVuY3Rpb24ob3B0UGFzcykgeyAvLyBhZGROb2RlTWVudSBmb3IgY29ubmVjdGlvblxuICAgICAgICB2YXIgb3B0UGFzcyA9IG9wdFBhc3MgfHwge307XG4gICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmFzc2lnbih7ICAgbm9kZUZyb206IG51bGwgIC8vIGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsc2xvdEZyb206IG51bGwgLy8gaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICxub2RlVG86IG51bGwgICAvLyBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICxzbG90VG86IG51bGwgICAvLyBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICxlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLG9wdFBhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIFxuICAgICAgICB2YXIgaXNGcm9tID0gb3B0cy5ub2RlRnJvbSAmJiBvcHRzLnNsb3RGcm9tO1xuICAgICAgICB2YXIgaXNUbyA9ICFpc0Zyb20gJiYgb3B0cy5ub2RlVG8gJiYgb3B0cy5zbG90VG87XG4gICAgICAgIFxuICAgICAgICBpZiAoIWlzRnJvbSAmJiAhaXNUbyl7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyBkYXRhIHBhc3NlZCB0byBzaG93Q29ubmVjdGlvbk1lbnVcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBub2RlWCA9IGlzRnJvbSA/IG9wdHMubm9kZUZyb20gOiBvcHRzLm5vZGVUbztcbiAgICAgICAgdmFyIHNsb3RYID0gaXNGcm9tID8gb3B0cy5zbG90RnJvbSA6IG9wdHMuc2xvdFRvO1xuICAgICAgICBcbiAgICAgICAgdmFyIGlTbG90Q29ubiA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBzbG90WCl7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgaVNsb3RDb25uID0gaXNGcm9tID8gbm9kZVguZmluZE91dHB1dFNsb3Qoc2xvdFgsZmFsc2UpIDogbm9kZVguZmluZElucHV0U2xvdChzbG90WCxmYWxzZSk7XG4gICAgICAgICAgICAgICAgc2xvdFggPSBpc0Zyb20gPyBub2RlWC5vdXRwdXRzW3Nsb3RYXSA6IG5vZGVYLmlucHV0c1tzbG90WF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgICAvLyBvayBzbG90WFxuICAgICAgICAgICAgICAgIGlTbG90Q29ubiA9IGlzRnJvbSA/IG5vZGVYLmZpbmRPdXRwdXRTbG90KHNsb3RYLm5hbWUpIDogbm9kZVguZmluZElucHV0U2xvdChzbG90WC5uYW1lKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGlTbG90Q29ubiA9IHNsb3RYO1xuICAgICAgICAgICAgICAgIHNsb3RYID0gaXNGcm9tID8gbm9kZVgub3V0cHV0c1tzbG90WF0gOiBub2RlWC5pbnB1dHNbc2xvdFhdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGJhZCA/XG4gICAgICAgICAgICAgICAgLy9pU2xvdENvbm4gPSAwO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNhbnQgZ2V0IHNsb3QgaW5mb3JtYXRpb24gXCIrc2xvdFgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAgICAgXG5cdFx0dmFyIG9wdGlvbnMgPSBbXCJBZGQgTm9kZVwiLG51bGxdO1xuXHRcdFxuXHRcdGlmICh0aGF0LmFsbG93X3NlYXJjaGJveCl7XG5cdFx0XHRvcHRpb25zLnB1c2goXCJTZWFyY2hcIik7XG5cdFx0XHRvcHRpb25zLnB1c2gobnVsbCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIGdldCBkZWZhdWx0cyBub2RlcyBmb3IgdGhpcyBzbG90dHlwZVxuXHRcdHZhciBmcm9tU2xvdFR5cGUgPSBzbG90WC50eXBlPT1MaXRlR3JhcGguRVZFTlQ/XCJfZXZlbnRfXCI6c2xvdFgudHlwZTtcblx0XHR2YXIgc2xvdFR5cGVzRGVmYXVsdCA9IGlzRnJvbSA/IExpdGVHcmFwaC5zbG90X3R5cGVzX2RlZmF1bHRfb3V0IDogTGl0ZUdyYXBoLnNsb3RfdHlwZXNfZGVmYXVsdF9pbjtcblx0XHRpZihzbG90VHlwZXNEZWZhdWx0ICYmIHNsb3RUeXBlc0RlZmF1bHRbZnJvbVNsb3RUeXBlXSl7XG5cdFx0XHRpZih0eXBlb2Ygc2xvdFR5cGVzRGVmYXVsdFtmcm9tU2xvdFR5cGVdID09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHNsb3RUeXBlc0RlZmF1bHRbZnJvbVNsb3RUeXBlXSA9PSBcImFycmF5XCIpe1xuXHRcdFx0XHRmb3IodmFyIHR5cGVYIGluIHNsb3RUeXBlc0RlZmF1bHRbZnJvbVNsb3RUeXBlXSl7XG5cdFx0XHRcdFx0b3B0aW9ucy5wdXNoKHNsb3RUeXBlc0RlZmF1bHRbZnJvbVNsb3RUeXBlXVt0eXBlWF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0b3B0aW9ucy5wdXNoKHNsb3RUeXBlc0RlZmF1bHRbZnJvbVNsb3RUeXBlXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIGJ1aWxkIG1lbnVcbiAgICAgICAgdmFyIG1lbnUgPSBuZXcgTGl0ZUdyYXBoLkNvbnRleHRNZW51KG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGV2ZW50OiBvcHRzLmUsXG5cdFx0XHR0aXRsZTogKHNsb3RYICYmIHNsb3RYLm5hbWUhPVwiXCIgPyAoc2xvdFgubmFtZSArIChmcm9tU2xvdFR5cGU/XCIgfCBcIjpcIlwiKSkgOiBcIlwiKSsoc2xvdFggJiYgZnJvbVNsb3RUeXBlID8gZnJvbVNsb3RUeXBlIDogXCJcIiksXG4gICAgICAgICAgICBjYWxsYmFjazogaW5uZXJfY2xpY2tlZFxuICAgICAgICB9KTtcbiAgICAgICAgXG5cdFx0Ly8gY2FsbGJhY2tcbiAgICAgICAgZnVuY3Rpb24gaW5uZXJfY2xpY2tlZCh2LG9wdGlvbnMsZSkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlByb2Nlc3Mgc2hvd0Nvbm5lY3Rpb25NZW51IHNlbGVjdGlvblwiKTtcbiAgICAgICAgICAgIHN3aXRjaCAodikge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBZGQgTm9kZVwiOlxuICAgICAgICAgICAgICAgICAgICBMR3JhcGhDYW52YXMub25NZW51QWRkKG51bGwsIG51bGwsIGUsIG1lbnUsIGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnJvbSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5ub2RlRnJvbS5jb25uZWN0QnlUeXBlKCBpU2xvdENvbm4sIG5vZGUsIGZyb21TbG90VHlwZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5ub2RlVG8uY29ubmVjdEJ5VHlwZU91dHB1dCggaVNsb3RDb25uLCBub2RlLCBmcm9tU2xvdFR5cGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiU2VhcmNoXCI6XG5cdFx0XHRcdFx0aWYoaXNGcm9tKXtcblx0XHRcdFx0XHRcdHRoYXQuc2hvd1NlYXJjaEJveChlLHtub2RlX2Zyb206IG9wdHMubm9kZUZyb20sIHNsb3RfZnJvbTogc2xvdFgsIHR5cGVfZmlsdGVyX2luOiBmcm9tU2xvdFR5cGV9KTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdHRoYXQuc2hvd1NlYXJjaEJveChlLHtub2RlX3RvOiBvcHRzLm5vZGVUbywgc2xvdF9mcm9tOiBzbG90WCwgdHlwZV9maWx0ZXJfb3V0OiBmcm9tU2xvdFR5cGV9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0XHRcdFx0XHQvLyBjaGVjayBmb3IgZGVmYXVsdHMgbm9kZXMgZm9yIHRoaXMgc2xvdHR5cGVcblx0XHRcdFx0XHR2YXIgbm9kZUNyZWF0ZWQgPSB0aGF0LmNyZWF0ZURlZmF1bHROb2RlRm9yU2xvdChPYmplY3QuYXNzaWduKG9wdHMseyBwb3NpdGlvbjogW29wdHMuZS5jYW52YXNYLCBvcHRzLmUuY2FudmFzWV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LG5vZGVUeXBlOiB2XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdFx0aWYgKG5vZGVDcmVhdGVkKXtcblx0XHRcdFx0XHRcdC8vIG5ldyBub2RlIGNyZWF0ZWRcblx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coXCJub2RlIFwiK3YrXCIgY3JlYXRlZFwiKVxuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0Ly8gZmFpbGVkIG9yIHYgaXMgbm90IGluIGRlZmF1bHRzXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ICAgXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8vIFRPRE8gcmVmYWN0b3IgOjogdGhpcyBpcyB1c2VkIGZvdCB0aXRsZSBidXQgbm90IGZvciBwcm9wZXJ0aWVzIVxuICAgIExHcmFwaENhbnZhcy5vblNob3dQcm9wZXJ0eUVkaXRvciA9IGZ1bmN0aW9uKGl0ZW0sIG9wdGlvbnMsIGUsIG1lbnUsIG5vZGUpIHtcbiAgICAgICAgdmFyIGlucHV0X2h0bWwgPSBcIlwiO1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBpdGVtLnByb3BlcnR5IHx8IFwidGl0bGVcIjtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZVtwcm9wZXJ0eV07XG5cbiAgICAgICAgLy8gVE9ETyByZWZhY3RvciA6OiB1c2UgY3JlYXRlRGlhbG9nID9cbiAgICAgICAgXG4gICAgICAgIHZhciBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaWFsb2cuaXNfbW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgZGlhbG9nLmNsYXNzTmFtZSA9IFwiZ3JhcGhkaWFsb2dcIjtcbiAgICAgICAgZGlhbG9nLmlubmVySFRNTCA9XG4gICAgICAgICAgICBcIjxzcGFuIGNsYXNzPSduYW1lJz48L3NwYW4+PGlucHV0IGF1dG9mb2N1cyB0eXBlPSd0ZXh0JyBjbGFzcz0ndmFsdWUnLz48YnV0dG9uPk9LPC9idXR0b24+XCI7XG4gICAgICAgIGRpYWxvZy5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGRpYWxvZy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgZGlhbG9nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGlhbG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRpdGxlID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoXCIubmFtZVwiKTtcbiAgICAgICAgdGl0bGUuaW5uZXJUZXh0ID0gcHJvcGVydHk7XG4gICAgICAgIHZhciBpbnB1dCA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKFwiLnZhbHVlXCIpO1xuICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZGlhbG9nLmlzX21vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDI3KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vRVNDXG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyKCk7IC8vIHNhdmVcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSAhPSAxMyAmJiBlLnRhcmdldC5sb2NhbE5hbWUgIT0gXCJ0ZXh0YXJlYVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncmFwaGNhbnZhcyA9IExHcmFwaENhbnZhcy5hY3RpdmVfY2FudmFzO1xuICAgICAgICB2YXIgY2FudmFzID0gZ3JhcGhjYW52YXMuY2FudmFzO1xuXG4gICAgICAgIHZhciByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgb2Zmc2V0eCA9IC0yMDtcbiAgICAgICAgdmFyIG9mZnNldHkgPSAtMjA7XG4gICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgICBvZmZzZXR4IC09IHJlY3QubGVmdDtcbiAgICAgICAgICAgIG9mZnNldHkgLT0gcmVjdC50b3A7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGRpYWxvZy5zdHlsZS5sZWZ0ID0gZXZlbnQuY2xpZW50WCArIG9mZnNldHggKyBcInB4XCI7XG4gICAgICAgICAgICBkaWFsb2cuc3R5bGUudG9wID0gZXZlbnQuY2xpZW50WSArIG9mZnNldHkgKyBcInB4XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaWFsb2cuc3R5bGUubGVmdCA9IGNhbnZhcy53aWR0aCAqIDAuNSArIG9mZnNldHggKyBcInB4XCI7XG4gICAgICAgICAgICBkaWFsb2cuc3R5bGUudG9wID0gY2FudmFzLmhlaWdodCAqIDAuNSArIG9mZnNldHkgKyBcInB4XCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnV0dG9uID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoXCJidXR0b25cIik7XG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaW5uZXIpO1xuICAgICAgICBjYW52YXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkaWFsb2cpO1xuXG4gICAgICAgIGlmKGlucHV0KSBpbnB1dC5mb2N1cygpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGRpYWxvZ0Nsb3NlVGltZXIgPSBudWxsO1xuICAgICAgICBkaWFsb2cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYoTGl0ZUdyYXBoLmRpYWxvZ19jbG9zZV9vbl9tb3VzZV9sZWF2ZSlcbiAgICAgICAgICAgICAgICBpZiAoIWRpYWxvZy5pc19tb2RpZmllZCAmJiBMaXRlR3JhcGguZGlhbG9nX2Nsb3NlX29uX21vdXNlX2xlYXZlKVxuICAgICAgICAgICAgICAgICAgICBkaWFsb2dDbG9zZVRpbWVyID0gc2V0VGltZW91dChkaWFsb2cuY2xvc2UsIExpdGVHcmFwaC5kaWFsb2dfY2xvc2Vfb25fbW91c2VfbGVhdmVfZGVsYXkpOyAvL2RpYWxvZy5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGlhbG9nLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmKExpdGVHcmFwaC5kaWFsb2dfY2xvc2Vfb25fbW91c2VfbGVhdmUpXG4gICAgICAgICAgICAgICAgaWYoZGlhbG9nQ2xvc2VUaW1lcikgY2xlYXJUaW1lb3V0KGRpYWxvZ0Nsb3NlVGltZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIGlubmVyKCkge1xuICAgICAgICAgICAgaWYoaW5wdXQpIHNldFZhbHVlKGlucHV0LnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS50eXBlID09IFwiTnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PSBcIkJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKGRpYWxvZy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgZGlhbG9nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGlhbG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcmVmYWN0b3I6IHRoZXJlIGFyZSBkaWZmZXJlbnQgZGlhbG9ncywgc29tZSB1c2VzIGNyZWF0ZURpYWxvZyBzb21lIGRvbnRcbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnByb21wdCA9IGZ1bmN0aW9uKHRpdGxlLCB2YWx1ZSwgY2FsbGJhY2ssIGV2ZW50LCBtdWx0aWxpbmUpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgaW5wdXRfaHRtbCA9IFwiXCI7XG4gICAgICAgIHRpdGxlID0gdGl0bGUgfHwgXCJcIjtcblxuICAgICAgICB2YXIgZGlhbG9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGlhbG9nLmlzX21vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIGRpYWxvZy5jbGFzc05hbWUgPSBcImdyYXBoZGlhbG9nIHJvdW5kZWRcIjtcbiAgICAgICAgaWYobXVsdGlsaW5lKVxuXHQgICAgICAgIGRpYWxvZy5pbm5lckhUTUwgPSBcIjxzcGFuIGNsYXNzPSduYW1lJz48L3NwYW4+IDx0ZXh0YXJlYSBhdXRvZm9jdXMgY2xhc3M9J3ZhbHVlJz48L3RleHRhcmVhPjxidXR0b24gY2xhc3M9J3JvdW5kZWQnPk9LPC9idXR0b24+XCI7XG5cdFx0ZWxzZVxuICAgICAgICBcdGRpYWxvZy5pbm5lckhUTUwgPSBcIjxzcGFuIGNsYXNzPSduYW1lJz48L3NwYW4+IDxpbnB1dCBhdXRvZm9jdXMgdHlwZT0ndGV4dCcgY2xhc3M9J3ZhbHVlJy8+PGJ1dHRvbiBjbGFzcz0ncm91bmRlZCc+T0s8L2J1dHRvbj5cIjtcbiAgICAgICAgZGlhbG9nLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGF0LnByb21wdF9ib3ggPSBudWxsO1xuICAgICAgICAgICAgaWYgKGRpYWxvZy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgZGlhbG9nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGlhbG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ3JhcGhjYW52YXMgPSBMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcztcbiAgICAgICAgdmFyIGNhbnZhcyA9IGdyYXBoY2FudmFzLmNhbnZhcztcbiAgICAgICAgY2FudmFzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZGlhbG9nKTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLmRzLnNjYWxlID4gMSkge1xuICAgICAgICAgICAgZGlhbG9nLnN0eWxlLnRyYW5zZm9ybSA9IFwic2NhbGUoXCIgKyB0aGlzLmRzLnNjYWxlICsgXCIpXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlhbG9nQ2xvc2VUaW1lciA9IG51bGw7XG4gICAgICAgIHZhciBwcmV2ZW50X3RpbWVvdXQgPSBmYWxzZTtcbiAgICAgICAgTGl0ZUdyYXBoLnBvaW50ZXJMaXN0ZW5lckFkZChkaWFsb2csXCJsZWF2ZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAocHJldmVudF90aW1lb3V0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmKExpdGVHcmFwaC5kaWFsb2dfY2xvc2Vfb25fbW91c2VfbGVhdmUpXG4gICAgICAgICAgICAgICAgaWYgKCFkaWFsb2cuaXNfbW9kaWZpZWQgJiYgTGl0ZUdyYXBoLmRpYWxvZ19jbG9zZV9vbl9tb3VzZV9sZWF2ZSlcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nQ2xvc2VUaW1lciA9IHNldFRpbWVvdXQoZGlhbG9nLmNsb3NlLCBMaXRlR3JhcGguZGlhbG9nX2Nsb3NlX29uX21vdXNlX2xlYXZlX2RlbGF5KTsgLy9kaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIExpdGVHcmFwaC5wb2ludGVyTGlzdGVuZXJBZGQoZGlhbG9nLFwiZW50ZXJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYoTGl0ZUdyYXBoLmRpYWxvZ19jbG9zZV9vbl9tb3VzZV9sZWF2ZSlcbiAgICAgICAgICAgICAgICBpZihkaWFsb2dDbG9zZVRpbWVyKSBjbGVhclRpbWVvdXQoZGlhbG9nQ2xvc2VUaW1lcik7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2VsSW5EaWEgPSBkaWFsb2cucXVlcnlTZWxlY3RvckFsbChcInNlbGVjdFwiKTtcbiAgICAgICAgaWYgKHNlbEluRGlhKXtcbiAgICAgICAgICAgIC8vIGlmIGZpbHRlcmluZywgY2hlY2sgZm9jdXMgY2hhbmdlZCB0byBjb21ib2JveGVzIGFuZCBwcmV2ZW50IGNsb3NpbmdcbiAgICAgICAgICAgIHNlbEluRGlhLmZvckVhY2goZnVuY3Rpb24oc2VsSW4pIHtcbiAgICAgICAgICAgICAgICBzZWxJbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50X3RpbWVvdXQrKztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxJbi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgcHJldmVudF90aW1lb3V0ID0gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxJbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudF90aW1lb3V0ID0gLTE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGF0LnByb21wdF9ib3gpIHtcbiAgICAgICAgICAgIHRoYXQucHJvbXB0X2JveC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQucHJvbXB0X2JveCA9IGRpYWxvZztcblxuICAgICAgICB2YXIgZmlyc3QgPSBudWxsO1xuICAgICAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IG51bGw7XG5cbiAgICAgICAgdmFyIG5hbWVfZWxlbWVudCA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKFwiLm5hbWVcIik7XG4gICAgICAgIG5hbWVfZWxlbWVudC5pbm5lclRleHQgPSB0aXRsZTtcbiAgICAgICAgdmFyIHZhbHVlX2VsZW1lbnQgPSBkaWFsb2cucXVlcnlTZWxlY3RvcihcIi52YWx1ZVwiKTtcbiAgICAgICAgdmFsdWVfZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIHZhciBpbnB1dCA9IHZhbHVlX2VsZW1lbnQ7XG4gICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGRpYWxvZy5pc19tb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDI3KSB7XG4gICAgICAgICAgICAgICAgLy9FU0NcbiAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09IDEzICYmIGUudGFyZ2V0LmxvY2FsTmFtZSAhPSBcInRleHRhcmVhXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgYnV0dG9uID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoXCJidXR0b25cIik7XG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhhdC5zZXREaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIG9mZnNldHggPSAtMjA7XG4gICAgICAgIHZhciBvZmZzZXR5ID0gLTIwO1xuICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgb2Zmc2V0eCAtPSByZWN0LmxlZnQ7XG4gICAgICAgICAgICBvZmZzZXR5IC09IHJlY3QudG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBkaWFsb2cuc3R5bGUubGVmdCA9IGV2ZW50LmNsaWVudFggKyBvZmZzZXR4ICsgXCJweFwiO1xuICAgICAgICAgICAgZGlhbG9nLnN0eWxlLnRvcCA9IGV2ZW50LmNsaWVudFkgKyBvZmZzZXR5ICsgXCJweFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlhbG9nLnN0eWxlLmxlZnQgPSBjYW52YXMud2lkdGggKiAwLjUgKyBvZmZzZXR4ICsgXCJweFwiO1xuICAgICAgICAgICAgZGlhbG9nLnN0eWxlLnRvcCA9IGNhbnZhcy5oZWlnaHQgKiAwLjUgKyBvZmZzZXR5ICsgXCJweFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgIH0sIDEwKTtcblxuICAgICAgICByZXR1cm4gZGlhbG9nO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMuc2VhcmNoX2xpbWl0ID0gLTE7XG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zaG93U2VhcmNoQm94ID0gZnVuY3Rpb24oZXZlbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gcHJvcG9zZWQgZGVmYXVsdHNcbiAgICAgICAgdmFyIGRlZl9vcHRpb25zID0geyBzbG90X2Zyb206IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICxub2RlX2Zyb206IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICxub2RlX3RvOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAsZG9fdHlwZV9maWx0ZXI6IExpdGVHcmFwaC5zZWFyY2hfZmlsdGVyX2VuYWJsZWQgLy8gVE9ETyBjaGVjayBmb3IgcmVnaXN0ZXJlZF9zbG90X1tpbi9vdXRdX3R5cGVzIG5vdCBlbXB0eSAvLyB0aGlzIHdpbGwgYmUgY2hlY2tlZCBmb3IgZnVuY3Rpb25hbGl0eSBlbmFibGVkIDogZmlsdGVyIG9uIHNsb3QgdHlwZSwgaW4gYW5kIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgLHR5cGVfZmlsdGVyX2luOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2UgYXJlIGRlZmF1bHQ6IHBhc3MgdG8gc2V0IGluaXRpYWxseSBzZXQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAsdHlwZV9maWx0ZXJfb3V0OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLHNob3dfZ2VuZXJhbF9pZl9ub25lX29uX3R5cGVmaWx0ZXI6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICxzaG93X2dlbmVyYWxfYWZ0ZXJfdHlwZWZpbHRlcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAsaGlkZV9vbl9tb3VzZV9sZWF2ZTogTGl0ZUdyYXBoLnNlYXJjaF9oaWRlX29uX21vdXNlX2xlYXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAsc2hvd19hbGxfaWZfZW1wdHk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICxzaG93X2FsbF9vbl9vcGVuOiBMaXRlR3JhcGguc2VhcmNoX3Nob3dfYWxsX29uX29wZW5cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oZGVmX29wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICBcblx0XHQvL2NvbnNvbGUubG9nKG9wdGlvbnMpO1xuXHRcdFxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBpbnB1dF9odG1sID0gXCJcIjtcbiAgICAgICAgdmFyIGdyYXBoY2FudmFzID0gTEdyYXBoQ2FudmFzLmFjdGl2ZV9jYW52YXM7XG4gICAgICAgIHZhciBjYW52YXMgPSBncmFwaGNhbnZhcy5jYW52YXM7XG4gICAgICAgIHZhciByb290X2RvY3VtZW50ID0gY2FudmFzLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cbiAgICAgICAgdmFyIGRpYWxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpYWxvZy5jbGFzc05hbWUgPSBcImxpdGVncmFwaCBsaXRlc2VhcmNoYm94IGdyYXBoZGlhbG9nIHJvdW5kZWRcIjtcbiAgICAgICAgZGlhbG9nLmlubmVySFRNTCA9IFwiPHNwYW4gY2xhc3M9J25hbWUnPlNlYXJjaDwvc3Bhbj4gPGlucHV0IGF1dG9mb2N1cyB0eXBlPSd0ZXh0JyBjbGFzcz0ndmFsdWUgcm91bmRlZCcvPlwiO1xuICAgICAgICBpZiAob3B0aW9ucy5kb190eXBlX2ZpbHRlcil7XG4gICAgICAgICAgICBkaWFsb2cuaW5uZXJIVE1MICs9IFwiPHNlbGVjdCBjbGFzcz0nc2xvdF9pbl90eXBlX2ZpbHRlcic+PG9wdGlvbiB2YWx1ZT0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcbiAgICAgICAgICAgIGRpYWxvZy5pbm5lckhUTUwgKz0gXCI8c2VsZWN0IGNsYXNzPSdzbG90X291dF90eXBlX2ZpbHRlcic+PG9wdGlvbiB2YWx1ZT0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcbiAgICAgICAgfVxuICAgICAgICBkaWFsb2cuaW5uZXJIVE1MICs9IFwiPGRpdiBjbGFzcz0naGVscGVyJz48L2Rpdj5cIjtcbiAgICAgICAgXG4gICAgICAgIGlmKCByb290X2RvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IClcblx0ICAgICAgICByb290X2RvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50LmFwcGVuZENoaWxkKGRpYWxvZyk7XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHQgICAgcm9vdF9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpYWxvZyk7XG5cdFx0XHRyb290X2RvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdH1cbiAgICAgICAgLy8gZGlhbG9nIGVsZW1lbnQgaGFzIGJlZW4gYXBwZW5kZWRcbiAgICAgICAgXG4gICAgICAgIGlmIChvcHRpb25zLmRvX3R5cGVfZmlsdGVyKXtcbiAgICAgICAgICAgIHZhciBzZWxJbiA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKFwiLnNsb3RfaW5fdHlwZV9maWx0ZXJcIik7XG4gICAgICAgICAgICB2YXIgc2VsT3V0ID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoXCIuc2xvdF9vdXRfdHlwZV9maWx0ZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGRpYWxvZy5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhhdC5zZWFyY2hfYm94ID0gbnVsbDtcblx0XHRcdHRoaXMuYmx1cigpO1xuICAgICAgICAgICAgY2FudmFzLmZvY3VzKCk7XG5cdFx0XHRyb290X2RvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBcIlwiO1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuY2FudmFzLmZvY3VzKCk7XG4gICAgICAgICAgICB9LCAyMCk7IC8vaW1wb3J0YW50LCBpZiBjYW52YXMgbG9zZXMgZm9jdXMga2V5cyB3b250IGJlIGNhcHR1cmVkXG4gICAgICAgICAgICBpZiAoZGlhbG9nLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBkaWFsb2cucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaWFsb2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLmRzLnNjYWxlID4gMSkge1xuICAgICAgICAgICAgZGlhbG9nLnN0eWxlLnRyYW5zZm9ybSA9IFwic2NhbGUoXCIgKyB0aGlzLmRzLnNjYWxlICsgXCIpXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoaWRlIG9uIG1vdXNlIGxlYXZlXG4gICAgICAgIGlmKG9wdGlvbnMuaGlkZV9vbl9tb3VzZV9sZWF2ZSl7XG4gICAgICAgICAgICB2YXIgcHJldmVudF90aW1lb3V0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgdGltZW91dF9jbG9zZSA9IG51bGw7XG4gICAgICAgICAgICBMaXRlR3JhcGgucG9pbnRlckxpc3RlbmVyQWRkKGRpYWxvZyxcImVudGVyXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dF9jbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dF9jbG9zZSk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRfY2xvc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgTGl0ZUdyYXBoLnBvaW50ZXJMaXN0ZW5lckFkZChkaWFsb2csXCJsZWF2ZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZlbnRfdGltZW91dCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGltZW91dF9jbG9zZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGlmIGZpbHRlcmluZywgY2hlY2sgZm9jdXMgY2hhbmdlZCB0byBjb21ib2JveGVzIGFuZCBwcmV2ZW50IGNsb3NpbmdcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRvX3R5cGVfZmlsdGVyKXtcbiAgICAgICAgICAgICAgICBzZWxJbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50X3RpbWVvdXQrKztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxJbi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgcHJldmVudF90aW1lb3V0ID0gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxJbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudF90aW1lb3V0ID0gLTE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VsT3V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnRfdGltZW91dCsrO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbE91dC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgcHJldmVudF90aW1lb3V0ID0gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxPdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnRfdGltZW91dCA9IC0xO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoYXQuc2VhcmNoX2JveCkge1xuICAgICAgICAgICAgdGhhdC5zZWFyY2hfYm94LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5zZWFyY2hfYm94ID0gZGlhbG9nO1xuXG4gICAgICAgIHZhciBoZWxwZXIgPSBkaWFsb2cucXVlcnlTZWxlY3RvcihcIi5oZWxwZXJcIik7XG5cbiAgICAgICAgdmFyIGZpcnN0ID0gbnVsbDtcbiAgICAgICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBudWxsO1xuXG4gICAgICAgIHZhciBpbnB1dCA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKFwiaW5wdXRcIik7XG4gICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmKHRoYXQuc2VhcmNoX2JveClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAzOCkge1xuICAgICAgICAgICAgICAgICAgICAvL1VQXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVNlbGVjdGlvbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT0gNDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9ET1dOXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVNlbGVjdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PSAyNykge1xuICAgICAgICAgICAgICAgICAgICAvL0VTQ1xuICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PSAxMykge1xuICAgICAgICAgICAgICAgICAgICByZWZyZXNoSGVscGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHNlbGVjdGVkLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdChmaXJzdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHJlZnJlc2hIZWxwZXIsIDI1MCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIGlmIHNob3VsZCBmaWx0ZXIgb24gdHlwZSwgbG9hZCBhbmQgZmlsbCBzZWxlY3RlZCBhbmQgY2hvb3NlIGVsZW1lbnRzIGlmIHBhc3NlZFxuICAgICAgICBpZiAob3B0aW9ucy5kb190eXBlX2ZpbHRlcil7XG4gICAgICAgICAgICBpZiAoc2VsSW4pe1xuICAgICAgICAgICAgICAgIHZhciBhU2xvdHMgPSBMaXRlR3JhcGguc2xvdF90eXBlc19pbjtcbiAgICAgICAgICAgICAgICB2YXIgblNsb3RzID0gYVNsb3RzLmxlbmd0aDsgLy8gdGhpcyBmb3Igb2JqZWN0IDo6IE9iamVjdC5rZXlzKGFTbG90cykubGVuZ3RoO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnR5cGVfZmlsdGVyX2luID09IExpdGVHcmFwaC5FVkVOVCB8fCBvcHRpb25zLnR5cGVfZmlsdGVyX2luID09IExpdGVHcmFwaC5BQ1RJT04pXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudHlwZV9maWx0ZXJfaW4gPSBcIl9ldmVudF9cIjtcbiAgICAgICAgICAgICAgICAvKiB0aGlzIHdpbGwgZmlsdGVyIG9uICogLi4gYnV0IGJldHRlciBkbyBpdCBtYW51YWxseSBpbiBjYXNlXG4gICAgICAgICAgICAgICAgZWxzZSBpZihvcHRpb25zLnR5cGVfZmlsdGVyX2luID09PSBcIlwiIHx8IG9wdGlvbnMudHlwZV9maWx0ZXJfaW4gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudHlwZV9maWx0ZXJfaW4gPSBcIipcIjsqL1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlLPTA7IGlLPG5TbG90czsgaUsrKyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0LnZhbHVlID0gYVNsb3RzW2lLXTtcbiAgICAgICAgICAgICAgICAgICAgb3B0LmlubmVySFRNTCA9IGFTbG90c1tpS107XG4gICAgICAgICAgICAgICAgICAgIHNlbEluLmFwcGVuZENoaWxkKG9wdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKG9wdGlvbnMudHlwZV9maWx0ZXJfaW4gIT09ZmFsc2UgJiYgKG9wdGlvbnMudHlwZV9maWx0ZXJfaW4rXCJcIikudG9Mb3dlckNhc2UoKSA9PSAoYVNsb3RzW2lLXStcIlwiKS50b0xvd2VyQ2FzZSgpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2VsSW4uc2VsZWN0ZWRJbmRleCAuLlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0LnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coXCJjb21wYXJpbmcgSU4gXCIrb3B0aW9ucy50eXBlX2ZpbHRlcl9pbitcIiA6OiBcIithU2xvdHNbaUtdKTtcblx0ICAgICAgICAgICAgICAgIH1lbHNle1xuXHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcImNvbXBhcmluZyBPVVQgXCIrb3B0aW9ucy50eXBlX2ZpbHRlcl9pbitcIiA6OiBcIithU2xvdHNbaUtdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cbiAgICAgICAgICAgICAgICBzZWxJbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEhlbHBlcigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbE91dCl7XG4gICAgICAgICAgICAgICAgdmFyIGFTbG90cyA9IExpdGVHcmFwaC5zbG90X3R5cGVzX291dDtcbiAgICAgICAgICAgICAgICB2YXIgblNsb3RzID0gYVNsb3RzLmxlbmd0aDsgLy8gdGhpcyBmb3Igb2JqZWN0IDo6IE9iamVjdC5rZXlzKGFTbG90cykubGVuZ3RoOyBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50eXBlX2ZpbHRlcl9vdXQgPT0gTGl0ZUdyYXBoLkVWRU5UIHx8IG9wdGlvbnMudHlwZV9maWx0ZXJfb3V0ID09IExpdGVHcmFwaC5BQ1RJT04pXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudHlwZV9maWx0ZXJfb3V0ID0gXCJfZXZlbnRfXCI7XG4gICAgICAgICAgICAgICAgLyogdGhpcyB3aWxsIGZpbHRlciBvbiAqIC4uIGJ1dCBiZXR0ZXIgZG8gaXQgbWFudWFsbHkgaW4gY2FzZVxuICAgICAgICAgICAgICAgIGVsc2UgaWYob3B0aW9ucy50eXBlX2ZpbHRlcl9vdXQgPT09IFwiXCIgfHwgb3B0aW9ucy50eXBlX2ZpbHRlcl9vdXQgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudHlwZV9maWx0ZXJfb3V0ID0gXCIqXCI7Ki9cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpSz0wOyBpSzxuU2xvdHM7IGlLKyspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIG9wdC52YWx1ZSA9IGFTbG90c1tpS107XG4gICAgICAgICAgICAgICAgICAgIG9wdC5pbm5lckhUTUwgPSBhU2xvdHNbaUtdO1xuICAgICAgICAgICAgICAgICAgICBzZWxPdXQuYXBwZW5kQ2hpbGQob3B0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYob3B0aW9ucy50eXBlX2ZpbHRlcl9vdXQgIT09ZmFsc2UgJiYgKG9wdGlvbnMudHlwZV9maWx0ZXJfb3V0K1wiXCIpLnRvTG93ZXJDYXNlKCkgPT0gKGFTbG90c1tpS10rXCJcIikudG9Mb3dlckNhc2UoKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NlbE91dC5zZWxlY3RlZEluZGV4IC4uXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbE91dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEhlbHBlcigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvL2NvbXB1dGUgYmVzdCBwb3NpdGlvblxuICAgICAgICB2YXIgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICB2YXIgbGVmdCA9ICggZXZlbnQgPyBldmVudC5jbGllbnRYIDogKHJlY3QubGVmdCArIHJlY3Qud2lkdGggKiAwLjUpICkgLSA4MDtcbiAgICAgICAgdmFyIHRvcCA9ICggZXZlbnQgPyBldmVudC5jbGllbnRZIDogKHJlY3QudG9wICsgcmVjdC5oZWlnaHQgKiAwLjUpICkgLSAyMDtcbiAgICAgICAgZGlhbG9nLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICBkaWFsb2cuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuXG5cdFx0Ly9UbyBhdm9pZCBvdXQgb2Ygc2NyZWVuIHByb2JsZW1zXG5cdFx0aWYoZXZlbnQubGF5ZXJZID4gKHJlY3QuaGVpZ2h0IC0gMjAwKSkgXG4gICAgICAgICAgICBoZWxwZXIuc3R5bGUubWF4SGVpZ2h0ID0gKHJlY3QuaGVpZ2h0IC0gZXZlbnQubGF5ZXJZIC0gMjApICsgXCJweFwiO1xuXG5cdFx0LypcbiAgICAgICAgdmFyIG9mZnNldHggPSAtMjA7XG4gICAgICAgIHZhciBvZmZzZXR5ID0gLTIwO1xuICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgb2Zmc2V0eCAtPSByZWN0LmxlZnQ7XG4gICAgICAgICAgICBvZmZzZXR5IC09IHJlY3QudG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBkaWFsb2cuc3R5bGUubGVmdCA9IGV2ZW50LmNsaWVudFggKyBvZmZzZXR4ICsgXCJweFwiO1xuICAgICAgICAgICAgZGlhbG9nLnN0eWxlLnRvcCA9IGV2ZW50LmNsaWVudFkgKyBvZmZzZXR5ICsgXCJweFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlhbG9nLnN0eWxlLmxlZnQgPSBjYW52YXMud2lkdGggKiAwLjUgKyBvZmZzZXR4ICsgXCJweFwiO1xuICAgICAgICAgICAgZGlhbG9nLnN0eWxlLnRvcCA9IGNhbnZhcy5oZWlnaHQgKiAwLjUgKyBvZmZzZXR5ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGRpYWxvZyk7XG5cdFx0Ki9cblxuICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICBpZiAob3B0aW9ucy5zaG93X2FsbF9vbl9vcGVuKSByZWZyZXNoSGVscGVyKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gc2VsZWN0KG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQub25TZWFyY2hCb3hTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5vblNlYXJjaEJveFNlbGVjdGlvbihuYW1lLCBldmVudCwgZ3JhcGhjYW52YXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRyYSA9IExpdGVHcmFwaC5zZWFyY2hib3hfZXh0cmFzW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGV4dHJhLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuXHRcdFx0XHRcdGdyYXBoY2FudmFzLmdyYXBoLmJlZm9yZUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IExpdGVHcmFwaC5jcmVhdGVOb2RlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wb3MgPSBncmFwaGNhbnZhcy5jb252ZXJ0RXZlbnRUb0NhbnZhc09mZnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoY2FudmFzLmdyYXBoLmFkZChub2RlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEgJiYgZXh0cmEuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhLmRhdGEucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gZXh0cmEuZGF0YS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkUHJvcGVydHkoIGksIGV4dHJhLmRhdGEucHJvcGVydGllc1tpXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5kYXRhLmlucHV0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuaW5wdXRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBleHRyYS5kYXRhLmlucHV0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFkZE91dHB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLmRhdGEuaW5wdXRzW2ldWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEuZGF0YS5pbnB1dHNbaV1bMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuZGF0YS5vdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5vdXRwdXRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBleHRyYS5kYXRhLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRPdXRwdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYS5kYXRhLm91dHB1dHNbaV1bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYS5kYXRhLm91dHB1dHNbaV1bMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuZGF0YS50aXRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudGl0bGUgPSBleHRyYS5kYXRhLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhLmRhdGEuanNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29uZmlndXJlKGV4dHJhLmRhdGEuanNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGpvaW4gbm9kZSBhZnRlciBpbnNlcnRpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubm9kZV9mcm9tKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpUyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlb2Ygb3B0aW9ucy5zbG90X2Zyb20pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaVMgPSBvcHRpb25zLm5vZGVfZnJvbS5maW5kT3V0cHV0U2xvdChvcHRpb25zLnNsb3RfZnJvbSk7ICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2xvdF9mcm9tLm5hbWUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaVMgPSBvcHRpb25zLm5vZGVfZnJvbS5maW5kT3V0cHV0U2xvdChvcHRpb25zLnNsb3RfZnJvbS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpUyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpUz09LTEgJiYgdHlwZW9mIG9wdGlvbnMuc2xvdF9mcm9tLnNsb3RfaW5kZXggIT09IFwidW5kZWZpbmVkXCIpIGlTID0gb3B0aW9ucy5zbG90X2Zyb20uc2xvdF9pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlTID0gb3B0aW9ucy5zbG90X2Zyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaVMgPSAwOyAvLyB0cnkgd2l0aCBmaXJzdCBpZiBubyBuYW1lIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm5vZGVfZnJvbS5vdXRwdXRzW2lTXSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlTIT09ZmFsc2UgJiYgaVM+LTEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm5vZGVfZnJvbS5jb25uZWN0QnlUeXBlKCBpUywgbm9kZSwgb3B0aW9ucy5ub2RlX2Zyb20ub3V0cHV0c1tpU10udHlwZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihcImNhbnQgZmluZCBzbG90IFwiICsgb3B0aW9ucy5zbG90X2Zyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm5vZGVfdG8pe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlTID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBvcHRpb25zLnNsb3RfZnJvbSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpUyA9IG9wdGlvbnMubm9kZV90by5maW5kSW5wdXRTbG90KG9wdGlvbnMuc2xvdF9mcm9tKTsgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zbG90X2Zyb20ubmFtZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpUyA9IG9wdGlvbnMubm9kZV90by5maW5kSW5wdXRTbG90KG9wdGlvbnMuc2xvdF9mcm9tLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlTID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlTPT0tMSAmJiB0eXBlb2Ygb3B0aW9ucy5zbG90X2Zyb20uc2xvdF9pbmRleCAhPT0gXCJ1bmRlZmluZWRcIikgaVMgPSBvcHRpb25zLnNsb3RfZnJvbS5zbG90X2luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaVMgPSBvcHRpb25zLnNsb3RfZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpUyA9IDA7IC8vIHRyeSB3aXRoIGZpcnN0IGlmIG5vIG5hbWUgc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubm9kZV90by5pbnB1dHNbaVNdICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaVMhPT1mYWxzZSAmJiBpUz4tMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubm9kZV90by5jb25uZWN0QnlUeXBlT3V0cHV0KGlTLG5vZGUsb3B0aW9ucy5ub2RlX3RvLmlucHV0c1tpU10udHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKFwiY2FudCBmaW5kIHNsb3Rfbm9kZVRPIFwiICsgb3B0aW9ucy5zbG90X2Zyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBncmFwaGNhbnZhcy5ncmFwaC5hZnRlckNoYW5nZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGFuZ2VTZWxlY3Rpb24oZm9yd2FyZCkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgPyBoZWxwZXIuY2hpbGROb2Rlc1swXVxuICAgICAgICAgICAgICAgICAgICA6IGhlbHBlci5jaGlsZE5vZGVzW2hlbHBlci5jaGlsZE5vZGVzLmxlbmd0aF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gZm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGVjdGVkLm5leHRTaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZWN0ZWQucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBwcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3RlZC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICBzZWxlY3RlZC5zY3JvbGxJbnRvVmlldyh7YmxvY2s6IFwiZW5kXCIsIGJlaGF2aW9yOiBcInNtb290aFwifSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWZyZXNoSGVscGVyKCkge1xuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgc3RyID0gaW5wdXQudmFsdWU7XG4gICAgICAgICAgICBmaXJzdCA9IG51bGw7XG4gICAgICAgICAgICBoZWxwZXIuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICAgIGlmICghc3RyICYmICFvcHRpb25zLnNob3dfYWxsX2lmX2VtcHR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhhdC5vblNlYXJjaEJveCkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gdGhhdC5vblNlYXJjaEJveChoZWxwZXIsIHN0ciwgZ3JhcGhjYW52YXMpO1xuICAgICAgICAgICAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVzdWx0KGxpc3RbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHZhciBmaWx0ZXIgPSBncmFwaGNhbnZhcy5maWx0ZXIgfHwgZ3JhcGhjYW52YXMuZ3JhcGguZmlsdGVyO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIGJ5IHR5cGUgcHJlcHJvY2Vzc1xuICAgICAgICAgICAgICAgIGlmKG9wdGlvbnMuZG9fdHlwZV9maWx0ZXIgJiYgdGhhdC5zZWFyY2hfYm94KXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNJbiA9IHRoYXQuc2VhcmNoX2JveC5xdWVyeVNlbGVjdG9yKFwiLnNsb3RfaW5fdHlwZV9maWx0ZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzT3V0ID0gdGhhdC5zZWFyY2hfYm94LnF1ZXJ5U2VsZWN0b3IoXCIuc2xvdF9vdXRfdHlwZV9maWx0ZXJcIik7XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzSW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNPdXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9leHRyYXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIExpdGVHcmFwaC5zZWFyY2hib3hfZXh0cmFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRyYSA9IExpdGVHcmFwaC5zZWFyY2hib3hfZXh0cmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKCFvcHRpb25zLnNob3dfYWxsX2lmX2VtcHR5IHx8IHN0cikgJiYgZXh0cmEuZGVzYy50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cdFx0XHRcdFx0dmFyIGN0b3IgPSBMaXRlR3JhcGgucmVnaXN0ZXJlZF9ub2RlX3R5cGVzWyBleHRyYS50eXBlIF07XG5cdFx0XHRcdFx0aWYoIGN0b3IgJiYgY3Rvci5maWx0ZXIgIT0gZmlsdGVyIClcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiggISBpbm5lcl90ZXN0X2ZpbHRlcihleHRyYS50eXBlKSApXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgYWRkUmVzdWx0KCBleHRyYS5kZXNjLCBcInNlYXJjaGJveF9leHRyYVwiICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggTEdyYXBoQ2FudmFzLnNlYXJjaF9saW1pdCAhPT0gLTEgJiYgYysrID4gTEdyYXBoQ2FudmFzLnNlYXJjaF9saW1pdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG5cdFx0XHRcdHZhciBmaWx0ZXJlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LnByb3RvdHlwZS5maWx0ZXIpIHsgLy9maWx0ZXIgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoIExpdGVHcmFwaC5yZWdpc3RlcmVkX25vZGVfdHlwZXMgKTsgLy90eXBlc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBrZXlzLmZpbHRlciggaW5uZXJfdGVzdF9maWx0ZXIgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHRcdFx0XHRcdGZpbHRlcmVkID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gTGl0ZUdyYXBoLnJlZ2lzdGVyZWRfbm9kZV90eXBlcykge1xuXHRcdFx0XHRcdFx0aWYoIGlubmVyX3Rlc3RfZmlsdGVyKGkpIClcblx0XHRcdFx0XHRcdFx0ZmlsdGVyZWQucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlcmVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0YWRkUmVzdWx0KGZpbHRlcmVkW2ldKTtcblx0XHRcdFx0XHRpZiAoIExHcmFwaENhbnZhcy5zZWFyY2hfbGltaXQgIT09IC0xICYmIGMrKyA+IExHcmFwaENhbnZhcy5zZWFyY2hfbGltaXQgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBhZGQgZ2VuZXJhbCB0eXBlIGlmIGZpbHRlcmluZ1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dfZ2VuZXJhbF9hZnRlcl90eXBlZmlsdGVyZWRcbiAgICAgICAgICAgICAgICAgICAgJiYgKHNJbi52YWx1ZSB8fCBzT3V0LnZhbHVlKSBcbiAgICAgICAgICAgICAgICApe1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZF9leHRyYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIExpdGVHcmFwaC5yZWdpc3RlcmVkX25vZGVfdHlwZXMpIHtcblx0XHRcdFx0XHRcdGlmKCBpbm5lcl90ZXN0X2ZpbHRlcihpLCB7aW5UeXBlT3ZlcnJpZGU6IHNJbiYmc0luLnZhbHVlP1wiKlwiOmZhbHNlLCBvdXRUeXBlT3ZlcnJpZGU6IHNPdXQmJnNPdXQudmFsdWU/XCIqXCI6ZmFsc2V9KSApXG5cdFx0XHRcdFx0XHRcdGZpbHRlcmVkX2V4dHJhLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJlZF9leHRyYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVzdWx0KGZpbHRlcmVkX2V4dHJhW2ldLCBcImdlbmVyaWNfdHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggTEdyYXBoQ2FudmFzLnNlYXJjaF9saW1pdCAhPT0gLTEgJiYgYysrID4gTEdyYXBoQ2FudmFzLnNlYXJjaF9saW1pdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpbCBmaWx0ZXJpbmcgZ2F2ZSBubyByZXN1bHRzXG4gICAgICAgICAgICAgICAgaWYgKChzSW4udmFsdWUgfHwgc091dC52YWx1ZSkgJiYgXG4gICAgICAgICAgICAgICAgICAgICggKGhlbHBlci5jaGlsZE5vZGVzLmxlbmd0aCA9PSAwICYmIG9wdGlvbnMuc2hvd19nZW5lcmFsX2lmX25vbmVfb25fdHlwZWZpbHRlcikgKVxuICAgICAgICAgICAgICAgICl7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkX2V4dHJhID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gTGl0ZUdyYXBoLnJlZ2lzdGVyZWRfbm9kZV90eXBlcykge1xuXHRcdFx0XHRcdFx0aWYoIGlubmVyX3Rlc3RfZmlsdGVyKGksIHtza2lwRmlsdGVyOiB0cnVlfSkgKVxuXHRcdFx0XHRcdFx0XHRmaWx0ZXJlZF9leHRyYS5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVyZWRfZXh0cmEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlc3VsdChmaWx0ZXJlZF9leHRyYVtpXSwgXCJub3RfaW5fZmlsdGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBMR3JhcGhDYW52YXMuc2VhcmNoX2xpbWl0ICE9PSAtMSAmJiBjKysgPiBMR3JhcGhDYW52YXMuc2VhcmNoX2xpbWl0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuXHRcdFx0XHRmdW5jdGlvbiBpbm5lcl90ZXN0X2ZpbHRlciggdHlwZSwgb3B0c0luIClcblx0XHRcdFx0e1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0c0luID0gb3B0c0luIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0c0RlZiA9IHsgc2tpcEZpbHRlcjogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICxpblR5cGVPdmVycmlkZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICxvdXRUeXBlT3ZlcnJpZGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdHMgPSBPYmplY3QuYXNzaWduKG9wdHNEZWYsb3B0c0luKTtcblx0XHRcdFx0XHR2YXIgY3RvciA9IExpdGVHcmFwaC5yZWdpc3RlcmVkX25vZGVfdHlwZXNbIHR5cGUgXTtcblx0XHRcdFx0XHRpZihmaWx0ZXIgJiYgY3Rvci5maWx0ZXIgIT0gZmlsdGVyIClcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCghb3B0aW9ucy5zaG93X2FsbF9pZl9lbXB0eSB8fCBzdHIpICYmIHR5cGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cikgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlsdGVyIGJ5IHNsb3QgSU4sIE9VVCB0eXBlc1xuICAgICAgICAgICAgICAgICAgICBpZihvcHRpb25zLmRvX3R5cGVfZmlsdGVyICYmICFvcHRzLnNraXBGaWx0ZXIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNUeXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNWID0gc0luLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuaW5UeXBlT3ZlcnJpZGUhPT1mYWxzZSkgc1YgPSBvcHRzLmluVHlwZU92ZXJyaWRlO1xuXHRcdFx0XHRcdFx0Ly9pZiAoc1YudG9Mb3dlckNhc2UoKSA9PSBcIl9ldmVudF9cIikgc1YgPSBMaXRlR3JhcGguRVZFTlQ7IC8vIC0xXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNJbiAmJiBzVil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIndpbGwgY2hlY2sgZmlsdGVyIGFnYWluc3QgXCIrc1YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMaXRlR3JhcGgucmVnaXN0ZXJlZF9zbG90X2luX3R5cGVzW3NWXSAmJiBMaXRlR3JhcGgucmVnaXN0ZXJlZF9zbG90X2luX3R5cGVzW3NWXS5ub2Rlcyl7IC8vIHR5cGUgaXMgc3RvcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5kZWJ1ZyhcImNoZWNrIFwiK3NUeXBlK1wiIGluIFwiK0xpdGVHcmFwaC5yZWdpc3RlcmVkX3Nsb3RfaW5fdHlwZXNbc1ZdLm5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvZXNJbmMgPSBMaXRlR3JhcGgucmVnaXN0ZXJlZF9zbG90X2luX3R5cGVzW3NWXS5ub2Rlcy5pbmNsdWRlcyhzVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb2VzSW5jIT09ZmFsc2Upe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhzVHlwZStcIiBIQVMgXCIrc1YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qY29uc29sZS5kZWJ1ZyhMaXRlR3JhcGgucmVnaXN0ZXJlZF9zbG90X2luX3R5cGVzW3NWXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygrXCIgRE9OVCBpbmNsdWRlcyBcIit0eXBlKTsqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc1YgPSBzT3V0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMub3V0VHlwZU92ZXJyaWRlIT09ZmFsc2UpIHNWID0gb3B0cy5vdXRUeXBlT3ZlcnJpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIChzVi50b0xvd2VyQ2FzZSgpID09IFwiX2V2ZW50X1wiKSBzViA9IExpdGVHcmFwaC5FVkVOVDsgLy8gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc091dCAmJiBzVil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInNlYXJjaCB3aWxsIGNoZWNrIGZpbHRlciBhZ2FpbnN0IFwiK3NWKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTGl0ZUdyYXBoLnJlZ2lzdGVyZWRfc2xvdF9vdXRfdHlwZXNbc1ZdICYmIExpdGVHcmFwaC5yZWdpc3RlcmVkX3Nsb3Rfb3V0X3R5cGVzW3NWXS5ub2Rlcyl7IC8vIHR5cGUgaXMgc3RvcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5kZWJ1ZyhcImNoZWNrIFwiK3NUeXBlK1wiIGluIFwiK0xpdGVHcmFwaC5yZWdpc3RlcmVkX3Nsb3Rfb3V0X3R5cGVzW3NWXS5ub2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb2VzSW5jID0gTGl0ZUdyYXBoLnJlZ2lzdGVyZWRfc2xvdF9vdXRfdHlwZXNbc1ZdLm5vZGVzLmluY2x1ZGVzKHNUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvZXNJbmMhPT1mYWxzZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHNUeXBlK1wiIEhBUyBcIitzVik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLypjb25zb2xlLmRlYnVnKExpdGVHcmFwaC5yZWdpc3RlcmVkX3Nsb3Rfb3V0X3R5cGVzW3NWXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygrXCIgRE9OVCBpbmNsdWRlcyBcIit0eXBlKTsqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFJlc3VsdCh0eXBlLCBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVscCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhlbHAuaW5uZXJUZXh0ID0gdHlwZTtcbiAgICAgICAgICAgICAgICBoZWxwLmRhdGFzZXRbXCJ0eXBlXCJdID0gZXNjYXBlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGhlbHAuY2xhc3NOYW1lID0gXCJsaXRlZ3JhcGggbGl0ZS1zZWFyY2gtaXRlbVwiO1xuICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVscC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhlbHAuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHVuZXNjYXBlKHRoaXMuZGF0YXNldFtcInR5cGVcIl0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBoZWxwZXIuYXBwZW5kQ2hpbGQoaGVscCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlhbG9nO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLnNob3dFZGl0UHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKCBub2RlLCBwcm9wZXJ0eSwgb3B0aW9ucyApIHtcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUucHJvcGVydGllc1twcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICB2YXIgaW5mbyA9IG5vZGUuZ2V0UHJvcGVydHlJbmZvKHByb3BlcnR5KTtcblx0XHR2YXIgdHlwZSA9IGluZm8udHlwZTtcblxuICAgICAgICB2YXIgaW5wdXRfaHRtbCA9IFwiXCI7XG5cbiAgICAgICAgaWYgKHR5cGUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlID09IFwibnVtYmVyXCIgfHwgdHlwZSA9PSBcImFycmF5XCIgfHwgdHlwZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpbnB1dF9odG1sID0gXCI8aW5wdXQgYXV0b2ZvY3VzIHR5cGU9J3RleHQnIGNsYXNzPSd2YWx1ZScvPlwiO1xuICAgICAgICB9IGVsc2UgaWYgKCAodHlwZSA9PSBcImVudW1cIiB8fCB0eXBlID09IFwiY29tYm9cIikgJiYgaW5mby52YWx1ZXMpIHtcbiAgICAgICAgICAgIGlucHV0X2h0bWwgPSBcIjxzZWxlY3QgYXV0b2ZvY3VzIHR5cGU9J3RleHQnIGNsYXNzPSd2YWx1ZSc+XCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGluZm8udmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSBpO1xuXHRcdFx0XHRpZiggaW5mby52YWx1ZXMuY29uc3RydWN0b3IgPT09IEFycmF5IClcblx0XHRcdFx0XHR2ID0gaW5mby52YWx1ZXNbaV07XG5cbiAgICAgICAgICAgICAgICBpbnB1dF9odG1sICs9XG4gICAgICAgICAgICAgICAgICAgIFwiPG9wdGlvbiB2YWx1ZT0nXCIgK1xuICAgICAgICAgICAgICAgICAgICB2ICtcbiAgICAgICAgICAgICAgICAgICAgXCInIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKHYgPT0gbm9kZS5wcm9wZXJ0aWVzW3Byb3BlcnR5XSA/IFwic2VsZWN0ZWRcIiA6IFwiXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCI+XCIgK1xuICAgICAgICAgICAgICAgICAgICBpbmZvLnZhbHVlc1tpXSArXG4gICAgICAgICAgICAgICAgICAgIFwiPC9vcHRpb24+XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dF9odG1sICs9IFwiPC9zZWxlY3Q+XCI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImJvb2xlYW5cIiB8fCB0eXBlID09IFwidG9nZ2xlXCIpIHtcbiAgICAgICAgICAgIGlucHV0X2h0bWwgPVxuICAgICAgICAgICAgICAgIFwiPGlucHV0IGF1dG9mb2N1cyB0eXBlPSdjaGVja2JveCcgY2xhc3M9J3ZhbHVlJyBcIiArXG4gICAgICAgICAgICAgICAgKG5vZGUucHJvcGVydGllc1twcm9wZXJ0eV0gPyBcImNoZWNrZWRcIiA6IFwiXCIpICtcbiAgICAgICAgICAgICAgICBcIi8+XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlhbG9nID0gdGhpcy5jcmVhdGVEaWFsb2coXG4gICAgICAgICAgICBcIjxzcGFuIGNsYXNzPSduYW1lJz5cIiArXG4gICAgICAgICAgICAgICAgKGluZm8ubGFiZWwgPyBpbmZvLmxhYmVsIDogcHJvcGVydHkpICtcbiAgICAgICAgICAgICAgICBcIjwvc3Bhbj5cIiArXG4gICAgICAgICAgICAgICAgaW5wdXRfaHRtbCArXG4gICAgICAgICAgICAgICAgXCI8YnV0dG9uPk9LPC9idXR0b24+XCIsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIGlucHV0ID0gZmFsc2U7XG4gICAgICAgIGlmICgodHlwZSA9PSBcImVudW1cIiB8fCB0eXBlID09IFwiY29tYm9cIikgJiYgaW5mby52YWx1ZXMpIHtcbiAgICAgICAgICAgIGlucHV0ID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoXCJzZWxlY3RcIik7XG4gICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBkaWFsb2cubW9kaWZpZWQoKTtcbiAgICAgICAgICAgICAgICBzZXRWYWx1ZShlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy92YXIgaW5kZXggPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgICAgICAvL3NldFZhbHVlKCBlLm9wdGlvbnNbZS5zZWxlY3RlZEluZGV4XS52YWx1ZSApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImJvb2xlYW5cIiB8fCB0eXBlID09IFwidG9nZ2xlXCIpIHtcbiAgICAgICAgICAgIGlucHV0ID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5tb2RpZmllZCgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSghIWlucHV0LmNoZWNrZWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXQgPSBkaWFsb2cucXVlcnlTZWxlY3RvcihcImlucHV0XCIpO1xuICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cblx0XHRcdFx0dmFyIHYgPSBub2RlLnByb3BlcnRpZXNbcHJvcGVydHldICE9PSB1bmRlZmluZWQgPyBub2RlLnByb3BlcnRpZXNbcHJvcGVydHldIDogXCJcIjtcblx0XHRcdFx0aWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHY7XG4gICAgICAgICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDI3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0VTQ1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFTlRFUlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXIoKTsgLy8gc2F2ZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSAhPSAxMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlhbG9nLm1vZGlmaWVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCkgaW5wdXQuZm9jdXMoKTtcblxuICAgICAgICB2YXIgYnV0dG9uID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoXCJidXR0b25cIik7XG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaW5uZXIpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlubmVyKCkge1xuICAgICAgICAgICAgc2V0VmFsdWUoaW5wdXQudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0VmFsdWUodmFsdWUpIHtcblxuXHRcdFx0aWYoaW5mbyAmJiBpbmZvLnZhbHVlcyAmJiBpbmZvLnZhbHVlcy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmIGluZm8udmFsdWVzW3ZhbHVlXSAhPSB1bmRlZmluZWQgKVxuXHRcdFx0XHR2YWx1ZSA9IGluZm8udmFsdWVzW3ZhbHVlXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLnByb3BlcnRpZXNbcHJvcGVydHldID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBcImFycmF5XCIgfHwgdHlwZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUucHJvcGVydGllc1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChub2RlLmdyYXBoKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5ncmFwaC5fdmVyc2lvbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUub25Qcm9wZXJ0eUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBub2RlLm9uUHJvcGVydHlDaGFuZ2VkKHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cdFx0XHRpZihvcHRpb25zLm9uY2xvc2UpXG5cdFx0XHRcdG9wdGlvbnMub25jbG9zZSgpO1xuICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICBub2RlLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgICAgICB9XG5cblx0XHRyZXR1cm4gZGlhbG9nO1xuICAgIH07XG5cbiAgICAvLyBUT0RPIHJlZmFjdG9yLCB0aGVlciBhcmUgZGlmZmVyZW50IGRpYWxvZywgc29tZSB1c2VzIGNyZWF0ZURpYWxvZywgc29tZSBkb250XG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5jcmVhdGVEaWFsb2cgPSBmdW5jdGlvbihodG1sLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZfb3B0aW9ucyA9IHsgY2hlY2tGb3JJbnB1dDogZmFsc2UsIGNsb3NlT25MZWF2ZTogdHJ1ZSwgY2xvc2VPbkxlYXZlX2NoZWNrTW9kaWZpZWQ6IHRydWUgfTtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oZGVmX29wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xuXG4gICAgICAgIHZhciBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaWFsb2cuY2xhc3NOYW1lID0gXCJncmFwaGRpYWxvZ1wiO1xuICAgICAgICBkaWFsb2cuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgZGlhbG9nLmlzX21vZGlmaWVkID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIG9mZnNldHggPSAtMjA7XG4gICAgICAgIHZhciBvZmZzZXR5ID0gLTIwO1xuICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgb2Zmc2V0eCAtPSByZWN0LmxlZnQ7XG4gICAgICAgICAgICBvZmZzZXR5IC09IHJlY3QudG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24pIHtcbiAgICAgICAgICAgIG9mZnNldHggKz0gb3B0aW9ucy5wb3NpdGlvblswXTtcbiAgICAgICAgICAgIG9mZnNldHkgKz0gb3B0aW9ucy5wb3NpdGlvblsxXTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmV2ZW50KSB7XG4gICAgICAgICAgICBvZmZzZXR4ICs9IG9wdGlvbnMuZXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgIG9mZnNldHkgKz0gb3B0aW9ucy5ldmVudC5jbGllbnRZO1xuICAgICAgICB9IC8vY2VudGVyZWRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXR4ICs9IHRoaXMuY2FudmFzLndpZHRoICogMC41O1xuICAgICAgICAgICAgb2Zmc2V0eSArPSB0aGlzLmNhbnZhcy5oZWlnaHQgKiAwLjU7XG4gICAgICAgIH1cblxuICAgICAgICBkaWFsb2cuc3R5bGUubGVmdCA9IG9mZnNldHggKyBcInB4XCI7XG4gICAgICAgIGRpYWxvZy5zdHlsZS50b3AgPSBvZmZzZXR5ICsgXCJweFwiO1xuXG4gICAgICAgIHRoaXMuY2FudmFzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZGlhbG9nKTtcbiAgICAgICAgXG4gICAgICAgIC8vIGFjaGVjayBmb3IgaW5wdXQgYW5kIHVzZSBkZWZhdWx0IGJlaGF2aW91cjogc2F2ZSBvbiBlbnRlciwgY2xvc2Ugb24gZXNjXG4gICAgICAgIGlmIChvcHRpb25zLmNoZWNrRm9ySW5wdXQpe1xuICAgICAgICAgICAgdmFyIGFJID0gW107XG4gICAgICAgICAgICB2YXIgZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGFJID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKSl7XG4gICAgICAgICAgICAgICAgYUkuZm9yRWFjaChmdW5jdGlvbihpWCkge1xuICAgICAgICAgICAgICAgICAgICBpWC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlhbG9nLm1vZGlmaWVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDI3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSAhPSAxMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCB2YWx1ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb2N1c2VkKSBpWC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBkaWFsb2cubW9kaWZpZWQgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgZGlhbG9nLmlzX21vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBkaWFsb2cuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChkaWFsb2cucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGRpYWxvZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRpYWxvZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIgZGlhbG9nQ2xvc2VUaW1lciA9IG51bGw7XG4gICAgICAgIHZhciBwcmV2ZW50X3RpbWVvdXQgPSBmYWxzZTtcbiAgICAgICAgZGlhbG9nLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChwcmV2ZW50X3RpbWVvdXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYob3B0aW9ucy5jbG9zZU9uTGVhdmUgfHwgTGl0ZUdyYXBoLmRpYWxvZ19jbG9zZV9vbl9tb3VzZV9sZWF2ZSlcbiAgICAgICAgICAgICAgICBpZiAoIWRpYWxvZy5pc19tb2RpZmllZCAmJiBMaXRlR3JhcGguZGlhbG9nX2Nsb3NlX29uX21vdXNlX2xlYXZlKVxuICAgICAgICAgICAgICAgICAgICBkaWFsb2dDbG9zZVRpbWVyID0gc2V0VGltZW91dChkaWFsb2cuY2xvc2UsIExpdGVHcmFwaC5kaWFsb2dfY2xvc2Vfb25fbW91c2VfbGVhdmVfZGVsYXkpOyAvL2RpYWxvZy5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGlhbG9nLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmKG9wdGlvbnMuY2xvc2VPbkxlYXZlIHx8IExpdGVHcmFwaC5kaWFsb2dfY2xvc2Vfb25fbW91c2VfbGVhdmUpXG4gICAgICAgICAgICAgICAgaWYoZGlhbG9nQ2xvc2VUaW1lcikgY2xlYXJUaW1lb3V0KGRpYWxvZ0Nsb3NlVGltZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNlbEluRGlhID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzZWxlY3RcIik7XG4gICAgICAgIGlmIChzZWxJbkRpYSl7XG4gICAgICAgICAgICAvLyBpZiBmaWx0ZXJpbmcsIGNoZWNrIGZvY3VzIGNoYW5nZWQgdG8gY29tYm9ib3hlcyBhbmQgcHJldmVudCBjbG9zaW5nXG4gICAgICAgICAgICBzZWxJbkRpYS5mb3JFYWNoKGZ1bmN0aW9uKHNlbEluKSB7XG4gICAgICAgICAgICAgICAgc2VsSW4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudF90aW1lb3V0Kys7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VsSW4uYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgIHByZXZlbnRfdGltZW91dCA9IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VsSW4uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnRfdGltZW91dCA9IC0xO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlhbG9nO1xuICAgIH07XG5cblx0TEdyYXBoQ2FudmFzLnByb3RvdHlwZS5jcmVhdGVQYW5lbCA9IGZ1bmN0aW9uKHRpdGxlLCBvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgcmVmX3dpbmRvdyA9IG9wdGlvbnMud2luZG93IHx8IHdpbmRvdztcblx0XHR2YXIgcm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0cm9vdC5jbGFzc05hbWUgPSBcImxpdGVncmFwaCBkaWFsb2dcIjtcblx0XHRyb290LmlubmVySFRNTCA9IFwiPGRpdiBjbGFzcz0nZGlhbG9nLWhlYWRlcic+PHNwYW4gY2xhc3M9J2RpYWxvZy10aXRsZSc+PC9zcGFuPjwvZGl2PjxkaXYgY2xhc3M9J2RpYWxvZy1jb250ZW50Jz48L2Rpdj48ZGl2IHN0eWxlPSdkaXNwbGF5Om5vbmU7JyBjbGFzcz0nZGlhbG9nLWFsdC1jb250ZW50Jz48L2Rpdj48ZGl2IGNsYXNzPSdkaWFsb2ctZm9vdGVyJz48L2Rpdj5cIjtcblx0XHRyb290LmhlYWRlciA9IHJvb3QucXVlcnlTZWxlY3RvcihcIi5kaWFsb2ctaGVhZGVyXCIpO1xuXG5cdFx0aWYob3B0aW9ucy53aWR0aClcblx0XHRcdHJvb3Quc3R5bGUud2lkdGggPSBvcHRpb25zLndpZHRoICsgKG9wdGlvbnMud2lkdGguY29uc3RydWN0b3IgPT09IE51bWJlciA/IFwicHhcIiA6IFwiXCIpO1xuXHRcdGlmKG9wdGlvbnMuaGVpZ2h0KVxuXHRcdFx0cm9vdC5zdHlsZS5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCArIChvcHRpb25zLmhlaWdodC5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyID8gXCJweFwiIDogXCJcIik7XG5cdFx0aWYob3B0aW9ucy5jbG9zYWJsZSlcblx0XHR7XG5cdFx0XHR2YXIgY2xvc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcblx0XHRcdGNsb3NlLmlubmVySFRNTCA9IFwiJiMxMDAwNTtcIjtcblx0XHRcdGNsb3NlLmNsYXNzTGlzdC5hZGQoXCJjbG9zZVwiKTtcblx0XHRcdGNsb3NlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJvb3QuY2xvc2UoKTtcblx0XHRcdH0pO1xuXHRcdFx0cm9vdC5oZWFkZXIuYXBwZW5kQ2hpbGQoY2xvc2UpO1xuXHRcdH1cblx0XHRyb290LnRpdGxlX2VsZW1lbnQgPSByb290LnF1ZXJ5U2VsZWN0b3IoXCIuZGlhbG9nLXRpdGxlXCIpO1xuXHRcdHJvb3QudGl0bGVfZWxlbWVudC5pbm5lclRleHQgPSB0aXRsZTtcblx0XHRyb290LmNvbnRlbnQgPSByb290LnF1ZXJ5U2VsZWN0b3IoXCIuZGlhbG9nLWNvbnRlbnRcIik7XG4gICAgICAgIHJvb3QuYWx0X2NvbnRlbnQgPSByb290LnF1ZXJ5U2VsZWN0b3IoXCIuZGlhbG9nLWFsdC1jb250ZW50XCIpO1xuXHRcdHJvb3QuZm9vdGVyID0gcm9vdC5xdWVyeVNlbGVjdG9yKFwiLmRpYWxvZy1mb290ZXJcIik7XG5cblx0XHRyb290LmNsb3NlID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHQgICAgaWYgKHJvb3Qub25DbG9zZSAmJiB0eXBlb2Ygcm9vdC5vbkNsb3NlID09IFwiZnVuY3Rpb25cIil7XG5cdFx0ICAgICAgICByb290Lm9uQ2xvc2UoKTtcblx0XHQgICAgfVxuICAgICAgICAgICAgaWYocm9vdC5wYXJlbnROb2RlKVxuXHRcdCAgICAgICAgcm9vdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHJvb3QpO1xuXHRcdCAgICAvKiBYWFggQ0hFQ0sgVEhJUyAqL1xuXHRcdCAgICBpZih0aGlzLnBhcmVudE5vZGUpe1xuXHRcdCAgICBcdHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKTtcblx0XHQgICAgfVxuXHRcdCAgICAvKiBYWFggdGhpcyB3YXMgbm90IHdvcmtpbmcsIHdhcyBmaXhlZCB3aXRoIGFuIElGLCBjaGVjayB0aGlzICovXG5cdFx0fVxuXG4gICAgICAgIC8vIGZ1bmN0aW9uIHRvIHN3YXAgcGFuZWwgY29udGVudFxuICAgICAgICByb290LnRvZ2dsZUFsdENvbnRlbnQgPSBmdW5jdGlvbihmb3JjZSl7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcmNlICE9IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICAgICAgICAgIHZhciB2VG8gPSBmb3JjZSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIHZhciB2QWx0ID0gZm9yY2UgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIjtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHZhciB2VG8gPSByb290LmFsdF9jb250ZW50LnN0eWxlLmRpc3BsYXkgIT0gXCJibG9ja1wiID8gXCJibG9ja1wiIDogXCJub25lXCI7XG4gICAgICAgICAgICAgICAgdmFyIHZBbHQgPSByb290LmFsdF9jb250ZW50LnN0eWxlLmRpc3BsYXkgIT0gXCJibG9ja1wiID8gXCJub25lXCIgOiBcImJsb2NrXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb290LmFsdF9jb250ZW50LnN0eWxlLmRpc3BsYXkgPSB2VG87XG4gICAgICAgICAgICByb290LmNvbnRlbnQuc3R5bGUuZGlzcGxheSA9IHZBbHQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJvb3QudG9nZ2xlRm9vdGVyVmlzaWJpbGl0eSA9IGZ1bmN0aW9uKGZvcmNlKXtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm9yY2UgIT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICAgICAgdmFyIHZUbyA9IGZvcmNlID8gXCJibG9ja1wiIDogXCJub25lXCI7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICB2YXIgdlRvID0gcm9vdC5mb290ZXIuc3R5bGUuZGlzcGxheSAhPSBcImJsb2NrXCIgPyBcImJsb2NrXCIgOiBcIm5vbmVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvb3QuZm9vdGVyLnN0eWxlLmRpc3BsYXkgPSB2VG87XG4gICAgICAgIH1cbiAgICAgICAgXG5cdFx0cm9vdC5jbGVhciA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHR0aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gXCJcIjtcblx0XHR9XG5cblx0XHRyb290LmFkZEhUTUwgPSBmdW5jdGlvbihjb2RlLCBjbGFzc25hbWUsIG9uX2Zvb3Rlcilcblx0XHR7XG5cdFx0XHR2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0XHRpZihjbGFzc25hbWUpXG5cdFx0XHRcdGVsZW0uY2xhc3NOYW1lID0gY2xhc3NuYW1lO1xuXHRcdFx0ZWxlbS5pbm5lckhUTUwgPSBjb2RlO1xuXHRcdFx0aWYob25fZm9vdGVyKVxuXHRcdFx0XHRyb290LmZvb3Rlci5hcHBlbmRDaGlsZChlbGVtKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0cm9vdC5jb250ZW50LmFwcGVuZENoaWxkKGVsZW0pO1xuXHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0fVxuXG5cdFx0cm9vdC5hZGRCdXR0b24gPSBmdW5jdGlvbiggbmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMgKVxuXHRcdHtcblx0XHRcdHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcblx0XHRcdGVsZW0uaW5uZXJUZXh0ID0gbmFtZTtcblx0XHRcdGVsZW0ub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0XHRlbGVtLmNsYXNzTGlzdC5hZGQoXCJidG5cIik7XG5cdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGNhbGxiYWNrKTtcblx0XHRcdHJvb3QuZm9vdGVyLmFwcGVuZENoaWxkKGVsZW0pO1xuXHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0fVxuXG5cdFx0cm9vdC5hZGRTZXBhcmF0b3IgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0dmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdFx0ZWxlbS5jbGFzc05hbWUgPSBcInNlcGFyYXRvclwiO1xuXHRcdFx0cm9vdC5jb250ZW50LmFwcGVuZENoaWxkKGVsZW0pO1xuXHRcdH1cblxuXHRcdHJvb3QuYWRkV2lkZ2V0ID0gZnVuY3Rpb24oIHR5cGUsIG5hbWUsIHZhbHVlLCBvcHRpb25zLCBjYWxsYmFjayApXG5cdFx0e1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHR2YXIgc3RyX3ZhbHVlID0gU3RyaW5nKHZhbHVlKTtcblx0XHRcdHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRpZih0eXBlID09IFwibnVtYmVyXCIpXG5cdFx0XHRcdHN0cl92YWx1ZSA9IHZhbHVlLnRvRml4ZWQoMyk7XG5cblx0XHRcdHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdGVsZW0uY2xhc3NOYW1lID0gXCJwcm9wZXJ0eVwiO1xuXHRcdFx0ZWxlbS5pbm5lckhUTUwgPSBcIjxzcGFuIGNsYXNzPSdwcm9wZXJ0eV9uYW1lJz48L3NwYW4+PHNwYW4gY2xhc3M9J3Byb3BlcnR5X3ZhbHVlJz48L3NwYW4+XCI7XG5cdFx0XHRlbGVtLnF1ZXJ5U2VsZWN0b3IoXCIucHJvcGVydHlfbmFtZVwiKS5pbm5lclRleHQgPSBvcHRpb25zLmxhYmVsIHx8IG5hbWU7XG5cdFx0XHR2YXIgdmFsdWVfZWxlbWVudCA9IGVsZW0ucXVlcnlTZWxlY3RvcihcIi5wcm9wZXJ0eV92YWx1ZVwiKTtcblx0XHRcdHZhbHVlX2VsZW1lbnQuaW5uZXJUZXh0ID0gc3RyX3ZhbHVlO1xuXHRcdFx0ZWxlbS5kYXRhc2V0W1wicHJvcGVydHlcIl0gPSBuYW1lO1xuXHRcdFx0ZWxlbS5kYXRhc2V0W1widHlwZVwiXSA9IG9wdGlvbnMudHlwZSB8fCB0eXBlO1xuXHRcdFx0ZWxlbS5vcHRpb25zID0gb3B0aW9ucztcblx0XHRcdGVsZW0udmFsdWUgPSB2YWx1ZTtcblxuXHRcdFx0aWYoIHR5cGUgPT0gXCJjb2RlXCIgKVxuXHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKXsgcm9vdC5pbm5lcl9zaG93Q29kZVBhZCggdGhpcy5kYXRhc2V0W1wicHJvcGVydHlcIl0gKTsgfSk7XG5cdFx0XHRlbHNlIGlmICh0eXBlID09IFwiYm9vbGVhblwiKVxuXHRcdFx0e1xuXHRcdFx0XHRlbGVtLmNsYXNzTGlzdC5hZGQoXCJib29sZWFuXCIpO1xuXHRcdFx0XHRpZih2YWx1ZSlcblx0XHRcdFx0XHRlbGVtLmNsYXNzTGlzdC5hZGQoXCJib29sLW9uXCIpO1xuXHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbigpeyBcblx0XHRcdFx0XHQvL3ZhciB2ID0gbm9kZS5wcm9wZXJ0aWVzW3RoaXMuZGF0YXNldFtcInByb3BlcnR5XCJdXTsgXG5cdFx0XHRcdFx0Ly9ub2RlLnNldFByb3BlcnR5KHRoaXMuZGF0YXNldFtcInByb3BlcnR5XCJdLCF2KTsgdGhpcy5pbm5lclRleHQgPSB2ID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7IFxuXHRcdFx0XHRcdHZhciBwcm9wbmFtZSA9IHRoaXMuZGF0YXNldFtcInByb3BlcnR5XCJdO1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSAhdGhpcy52YWx1ZTtcblx0XHRcdFx0XHR0aGlzLmNsYXNzTGlzdC50b2dnbGUoXCJib29sLW9uXCIpO1xuXHRcdFx0XHRcdHRoaXMucXVlcnlTZWxlY3RvcihcIi5wcm9wZXJ0eV92YWx1ZVwiKS5pbm5lclRleHQgPSB0aGlzLnZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG5cdFx0XHRcdFx0aW5uZXJDaGFuZ2UocHJvcG5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0eXBlID09IFwic3RyaW5nXCIgfHwgdHlwZSA9PSBcIm51bWJlclwiKVxuXHRcdFx0e1xuXHRcdFx0XHR2YWx1ZV9lbGVtZW50LnNldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiLHRydWUpO1xuXHRcdFx0XHR2YWx1ZV9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpeyBcblx0XHRcdFx0XHRpZihlLmNvZGUgPT0gXCJFbnRlclwiICYmICh0eXBlICE9IFwic3RyaW5nXCIgfHwgIWUuc2hpZnRLZXkpKSAvLyBhbGxvdyBmb3IgbXVsdGlsaW5lXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dmFsdWVfZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBmdW5jdGlvbigpeyBcblx0XHRcdFx0XHR2YXIgdiA9IHRoaXMuaW5uZXJUZXh0O1xuXHRcdFx0XHRcdHZhciBwcm9wbmFtZSA9IHRoaXMucGFyZW50Tm9kZS5kYXRhc2V0W1wicHJvcGVydHlcIl07XG5cdFx0XHRcdFx0dmFyIHByb3B0eXBlID0gdGhpcy5wYXJlbnROb2RlLmRhdGFzZXRbXCJ0eXBlXCJdO1xuXHRcdFx0XHRcdGlmKCBwcm9wdHlwZSA9PSBcIm51bWJlclwiKVxuXHRcdFx0XHRcdFx0diA9IE51bWJlcih2KTtcblx0XHRcdFx0XHRpbm5lckNoYW5nZShwcm9wbmFtZSwgdik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodHlwZSA9PSBcImVudW1cIiB8fCB0eXBlID09IFwiY29tYm9cIikge1xuXHRcdFx0XHR2YXIgc3RyX3ZhbHVlID0gTEdyYXBoQ2FudmFzLmdldFByb3BlcnR5UHJpbnRhYmxlVmFsdWUoIHZhbHVlLCBvcHRpb25zLnZhbHVlcyApO1xuXHRcdFx0XHR2YWx1ZV9lbGVtZW50LmlubmVyVGV4dCA9IHN0cl92YWx1ZTtcblxuXHRcdFx0XHR2YWx1ZV9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCl7IFxuXHRcdFx0XHRcdHZhciB2YWx1ZXMgPSBvcHRpb25zLnZhbHVlcyB8fCBbXTtcblx0XHRcdFx0XHR2YXIgcHJvcG5hbWUgPSB0aGlzLnBhcmVudE5vZGUuZGF0YXNldFtcInByb3BlcnR5XCJdO1xuXHRcdFx0XHRcdHZhciBlbGVtX3RoYXQgPSB0aGlzO1xuXHRcdFx0XHRcdHZhciBtZW51ID0gbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudSh2YWx1ZXMse1xuXHRcdFx0XHRcdFx0XHRldmVudDogZXZlbnQsXG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZTogXCJkYXJrXCIsXG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrOiBpbm5lcl9jbGlja2VkXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0cmVmX3dpbmRvdyk7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gaW5uZXJfY2xpY2tlZCh2LCBvcHRpb24sIGV2ZW50KSB7XG5cdFx0XHRcdFx0XHQvL25vZGUuc2V0UHJvcGVydHkocHJvcG5hbWUsdik7IFxuXHRcdFx0XHRcdFx0Ly9ncmFwaGNhbnZhcy5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0ZWxlbV90aGF0LmlubmVyVGV4dCA9IHY7XG5cdFx0XHRcdFx0XHRpbm5lckNoYW5nZShwcm9wbmFtZSx2KTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuICAgICAgICAgICAgfVxuXG5cdFx0XHRyb290LmNvbnRlbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XG5cblx0XHRcdGZ1bmN0aW9uIGlubmVyQ2hhbmdlKG5hbWUsIHZhbHVlKVxuXHRcdFx0e1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiY2hhbmdlXCIsbmFtZSx2YWx1ZSk7XG5cdFx0XHRcdC8vdGhhdC5kaXJ0eV9jYW52YXMgPSB0cnVlO1xuXHRcdFx0XHRpZihvcHRpb25zLmNhbGxiYWNrKVxuXHRcdFx0XHRcdG9wdGlvbnMuY2FsbGJhY2sobmFtZSx2YWx1ZSxvcHRpb25zKTtcblx0XHRcdFx0aWYoY2FsbGJhY2spXG5cdFx0XHRcdFx0Y2FsbGJhY2sobmFtZSx2YWx1ZSxvcHRpb25zKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0fVxuXG4gICAgICAgIGlmIChyb290Lm9uT3BlbiAmJiB0eXBlb2Ygcm9vdC5vbk9wZW4gPT0gXCJmdW5jdGlvblwiKSByb290Lm9uT3BlbigpO1xuICAgICAgICBcblx0XHRyZXR1cm4gcm9vdDtcblx0fTtcblxuXHRMR3JhcGhDYW52YXMuZ2V0UHJvcGVydHlQcmludGFibGVWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCB2YWx1ZXMpXG5cdHtcblx0XHRpZighdmFsdWVzKVxuXHRcdFx0cmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cblx0XHRpZih2YWx1ZXMuY29uc3RydWN0b3IgPT09IEFycmF5KVxuXHRcdHtcblx0XHRcdHJldHVybiBTdHJpbmcodmFsdWUpO1x0XHRcdFxuXHRcdH1cblxuXHRcdGlmKHZhbHVlcy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KVxuXHRcdHtcblx0XHRcdHZhciBkZXNjX3ZhbHVlID0gXCJcIjtcblx0XHRcdGZvcih2YXIgayBpbiB2YWx1ZXMpXG5cdFx0XHR7XG5cdFx0XHRcdGlmKHZhbHVlc1trXSAhPSB2YWx1ZSlcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0ZGVzY192YWx1ZSA9IGs7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFN0cmluZyh2YWx1ZSkgKyBcIiAoXCIrZGVzY192YWx1ZStcIilcIjtcblx0XHR9XG5cdH1cblxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuY2xvc2VQYW5lbHMgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgcGFuZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI25vZGUtcGFuZWxcIik7XG5cdFx0aWYocGFuZWwpXG5cdFx0XHRwYW5lbC5jbG9zZSgpO1xuICAgICAgICB2YXIgcGFuZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI29wdGlvbi1wYW5lbFwiKTtcblx0XHRpZihwYW5lbClcblx0XHRcdHBhbmVsLmNsb3NlKCk7XG4gICAgfVxuICAgIFxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuc2hvd1Nob3dHcmFwaE9wdGlvbnNQYW5lbCA9IGZ1bmN0aW9uKHJlZk9wdHMsIG9iRXYsIHJlZk1lbnUsIHJlZk1lbnUyKXtcbiAgICAgICAgaWYodGhpcy5jb25zdHJ1Y3RvciAmJiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgPT0gXCJIVE1MRGl2RWxlbWVudFwiKXtcbiAgICAgICAgICAgIC8vIGFzc3VtZSBjb21pbmcgZnJvbSB0aGUgbWVudSBldmVudCBjbGlja1xuICAgICAgICAgICAgaWYgKCFvYkV2IHx8ICFvYkV2LmV2ZW50IHx8ICFvYkV2LmV2ZW50LnRhcmdldCB8fCAhb2JFdi5ldmVudC50YXJnZXQubGdyYXBoY2FudmFzKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDYW52YXMgbm90IGZvdW5kXCIpOyAvLyBuZWVkIGEgcmVmIHRvIGNhbnZhcyBvYmpcbiAgICAgICAgICAgICAgICAvKmNvbnNvbGUuZGVidWcoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoZXZlbnQudGFyZ2V0KTsqL1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBncmFwaGNhbnZhcyA9IG9iRXYuZXZlbnQudGFyZ2V0LmxncmFwaGNhbnZhcztcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAvLyBhc3N1bWUgY2FsbGVkIGludGVybmFsbHlcbiAgICAgICAgICAgIHZhciBncmFwaGNhbnZhcyA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhcGhjYW52YXMuY2xvc2VQYW5lbHMoKTtcbiAgICAgICAgdmFyIHJlZl93aW5kb3cgPSBncmFwaGNhbnZhcy5nZXRDYW52YXNXaW5kb3coKTtcbiAgICAgICAgcGFuZWwgPSBncmFwaGNhbnZhcy5jcmVhdGVQYW5lbChcIk9wdGlvbnNcIix7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICx3aW5kb3c6IHJlZl93aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLG9uT3BlbjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoY2FudmFzLk9QVElPTlBBTkVMX0lTX09QRU4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICxvbkNsb3NlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhjYW52YXMuT1BUSU9OUEFORUxfSVNfT1BFTiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhjYW52YXMub3B0aW9uc19wYW5lbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgZ3JhcGhjYW52YXMub3B0aW9uc19wYW5lbCA9IHBhbmVsO1xuICAgICAgICBwYW5lbC5pZCA9IFwib3B0aW9uLXBhbmVsXCI7XG5cdFx0cGFuZWwuY2xhc3NMaXN0LmFkZChcInNldHRpbmdzXCIpO1xuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gaW5uZXJfcmVmcmVzaCgpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYW5lbC5jb250ZW50LmlubmVySFRNTCA9IFwiXCI7IC8vY2xlYXJcblxuICAgICAgICAgICAgdmFyIGZVcGRhdGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgb3B0aW9ucyl7XG4gICAgICAgICAgICAgICAgc3dpdGNoKG5hbWUpe1xuICAgICAgICAgICAgICAgICAgICAvKmNhc2UgXCJSZW5kZXIgbW9kZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FzZSBcIlwiLi4gXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy52YWx1ZXMgJiYgb3B0aW9ucy5rZXkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrViA9IE9iamVjdC52YWx1ZXMob3B0aW9ucy52YWx1ZXMpLmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrVj49MCAmJiBvcHRpb25zLnZhbHVlc1trVl0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwidXBkYXRlIGdyYXBoIG9wdGlvbnM6IFwiK29wdGlvbnMua2V5K1wiOiBcIitrVik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoY2FudmFzW29wdGlvbnMua2V5XSA9IGtWO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUuZGVidWcoZ3JhcGhjYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJ1bmV4cGVjdGVkIG9wdGlvbnNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7Ki9cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5kZWJ1ZyhcIndhbnQgdG8gdXBkYXRlIGdyYXBoIG9wdGlvbnM6IFwiK25hbWUrXCI6IFwiK3ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMua2V5KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gb3B0aW9ucy5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy52YWx1ZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gT2JqZWN0LnZhbHVlcyhvcHRpb25zLnZhbHVlcykuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUuZGVidWcoXCJ1cGRhdGUgZ3JhcGggb3B0aW9uOiBcIituYW1lK1wiOiBcIit2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaGNhbnZhc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gcGFuZWwuYWRkV2lkZ2V0KCBcInN0cmluZ1wiLCBcIkdyYXBoIG5hbWVcIiwgXCJcIiwge30sIGZVcGRhdGUpOyAvLyBpbXBsZW1lbnRcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGFQcm9wcyA9IExpdGVHcmFwaC5hdmFpbGFibGVDYW52YXNPcHRpb25zO1xuICAgICAgICAgICAgYVByb3BzLnNvcnQoKTtcbiAgICAgICAgICAgIGZvcih2YXIgcEkgaW4gYVByb3BzKXtcbiAgICAgICAgICAgICAgICB2YXIgcFggPSBhUHJvcHNbcEldO1xuICAgICAgICAgICAgICAgIHBhbmVsLmFkZFdpZGdldCggXCJib29sZWFuXCIsIHBYLCBncmFwaGNhbnZhc1twWF0sIHtrZXk6IHBYLCBvbjogXCJUcnVlXCIsIG9mZjogXCJGYWxzZVwifSwgZlVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBhTGlua3MgPSBbIGdyYXBoY2FudmFzLmxpbmtzX3JlbmRlcl9tb2RlIF07XG4gICAgICAgICAgICBwYW5lbC5hZGRXaWRnZXQoIFwiY29tYm9cIiwgXCJSZW5kZXIgbW9kZVwiLCBMaXRlR3JhcGguTElOS19SRU5ERVJfTU9ERVNbZ3JhcGhjYW52YXMubGlua3NfcmVuZGVyX21vZGVdLCB7a2V5OiBcImxpbmtzX3JlbmRlcl9tb2RlXCIsIHZhbHVlczogTGl0ZUdyYXBoLkxJTktfUkVOREVSX01PREVTfSwgZlVwZGF0ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHBhbmVsLmFkZFNlcGFyYXRvcigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYW5lbC5mb290ZXIuaW5uZXJIVE1MID0gXCJcIjsgLy8gY2xlYXJcblxuXHRcdH1cbiAgICAgICAgaW5uZXJfcmVmcmVzaCgpO1xuXG5cdFx0Z3JhcGhjYW52YXMuY2FudmFzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoIHBhbmVsICk7XG4gICAgfVxuICAgIFxuICAgIExHcmFwaENhbnZhcy5wcm90b3R5cGUuc2hvd1Nob3dOb2RlUGFuZWwgPSBmdW5jdGlvbiggbm9kZSApXG5cdHtcblx0XHR0aGlzLlNFTEVDVEVEX05PREUgPSBub2RlO1xuXHRcdHRoaXMuY2xvc2VQYW5lbHMoKTtcblx0XHR2YXIgcmVmX3dpbmRvdyA9IHRoaXMuZ2V0Q2FudmFzV2luZG93KCk7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgZ3JhcGhjYW52YXMgPSB0aGlzO1xuXHRcdHZhciBwYW5lbCA9IHRoaXMuY3JlYXRlUGFuZWwobm9kZS50aXRsZSB8fCBcIlwiLHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICx3aW5kb3c6IHJlZl93aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsb25PcGVuOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaGNhbnZhcy5OT0RFUEFORUxfSVNfT1BFTiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICxvbkNsb3NlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaGNhbnZhcy5OT0RFUEFORUxfSVNfT1BFTiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaGNhbnZhcy5ub2RlX3BhbmVsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgZ3JhcGhjYW52YXMubm9kZV9wYW5lbCA9IHBhbmVsO1xuXHRcdHBhbmVsLmlkID0gXCJub2RlLXBhbmVsXCI7XG5cdFx0cGFuZWwubm9kZSA9IG5vZGU7XG5cdFx0cGFuZWwuY2xhc3NMaXN0LmFkZChcInNldHRpbmdzXCIpO1xuXG5cdFx0ZnVuY3Rpb24gaW5uZXJfcmVmcmVzaCgpXG5cdFx0e1xuXHRcdFx0cGFuZWwuY29udGVudC5pbm5lckhUTUwgPSBcIlwiOyAvL2NsZWFyXG5cdFx0XHRwYW5lbC5hZGRIVE1MKFwiPHNwYW4gY2xhc3M9J25vZGVfdHlwZSc+XCIrbm9kZS50eXBlK1wiPC9zcGFuPjxzcGFuIGNsYXNzPSdub2RlX2Rlc2MnPlwiKyhub2RlLmNvbnN0cnVjdG9yLmRlc2MgfHwgXCJcIikrXCI8L3NwYW4+PHNwYW4gY2xhc3M9J3NlcGFyYXRvcic+PC9zcGFuPlwiKTtcblxuXHRcdFx0cGFuZWwuYWRkSFRNTChcIjxoMz5Qcm9wZXJ0aWVzPC9oMz5cIik7XG5cbiAgICAgICAgICAgIHZhciBmVXBkYXRlID0gZnVuY3Rpb24obmFtZSx2YWx1ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhjYW52YXMuZ3JhcGguYmVmb3JlQ2hhbmdlKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaChuYW1lKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlRpdGxlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRpdGxlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1vZGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrViA9IE9iamVjdC52YWx1ZXMoTGl0ZUdyYXBoLk5PREVfTU9ERVMpLmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtWPj0wICYmIExpdGVHcmFwaC5OT0RFX01PREVTW2tWXSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGFuZ2VNb2RlKGtWKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInVuZXhwZWN0ZWQgbW9kZTogXCIrdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJDb2xvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKExHcmFwaENhbnZhcy5ub2RlX2NvbG9yc1t2YWx1ZV0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29sb3IgPSBMR3JhcGhDYW52YXMubm9kZV9jb2xvcnNbdmFsdWVdLmNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYmdjb2xvciA9IExHcmFwaENhbnZhcy5ub2RlX2NvbG9yc1t2YWx1ZV0uYmdjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInVuZXhwZWN0ZWQgY29sb3I6IFwiK3ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0eShuYW1lLHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaGNhbnZhcy5ncmFwaC5hZnRlckNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoY2FudmFzLmRpcnR5X2NhbnZhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYW5lbC5hZGRXaWRnZXQoIFwic3RyaW5nXCIsIFwiVGl0bGVcIiwgbm9kZS50aXRsZSwge30sIGZVcGRhdGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYW5lbC5hZGRXaWRnZXQoIFwiY29tYm9cIiwgXCJNb2RlXCIsIExpdGVHcmFwaC5OT0RFX01PREVTW25vZGUubW9kZV0sIHt2YWx1ZXM6IExpdGVHcmFwaC5OT0RFX01PREVTfSwgZlVwZGF0ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBub2RlQ29sID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbG9yICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgIG5vZGVDb2wgPSBPYmplY3Qua2V5cyhMR3JhcGhDYW52YXMubm9kZV9jb2xvcnMpLmZpbHRlcihmdW5jdGlvbihuSyl7IHJldHVybiBMR3JhcGhDYW52YXMubm9kZV9jb2xvcnNbbktdLmNvbG9yID09IG5vZGUuY29sb3I7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYW5lbC5hZGRXaWRnZXQoIFwiY29tYm9cIiwgXCJDb2xvclwiLCBub2RlQ29sLCB7dmFsdWVzOiBPYmplY3Qua2V5cyhMR3JhcGhDYW52YXMubm9kZV9jb2xvcnMpfSwgZlVwZGF0ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcih2YXIgcE5hbWUgaW4gbm9kZS5wcm9wZXJ0aWVzKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBub2RlLnByb3BlcnRpZXNbcE5hbWVdO1xuXHRcdFx0XHR2YXIgaW5mbyA9IG5vZGUuZ2V0UHJvcGVydHlJbmZvKHBOYW1lKTtcblx0XHRcdFx0dmFyIHR5cGUgPSBpbmZvLnR5cGUgfHwgXCJzdHJpbmdcIjtcblxuXHRcdFx0XHQvL2luIGNhc2UgdGhlIHVzZXIgd2FudHMgY29udHJvbCBvdmVyIHRoZSBzaWRlIHBhbmVsIHdpZGdldFxuXHRcdFx0XHRpZiggbm9kZS5vbkFkZFByb3BlcnR5VG9QYW5lbCAmJiBub2RlLm9uQWRkUHJvcGVydHlUb1BhbmVsKHBOYW1lLHBhbmVsKSApXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0cGFuZWwuYWRkV2lkZ2V0KCBpbmZvLndpZGdldCB8fCBpbmZvLnR5cGUsIHBOYW1lLCB2YWx1ZSwgaW5mbywgZlVwZGF0ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHBhbmVsLmFkZFNlcGFyYXRvcigpO1xuXG5cdFx0XHRpZihub2RlLm9uU2hvd0N1c3RvbVBhbmVsSW5mbylcblx0XHRcdFx0bm9kZS5vblNob3dDdXN0b21QYW5lbEluZm8ocGFuZWwpO1xuXG4gICAgICAgICAgICBwYW5lbC5mb290ZXIuaW5uZXJIVE1MID0gXCJcIjsgLy8gY2xlYXJcblx0XHRcdHBhbmVsLmFkZEJ1dHRvbihcIkRlbGV0ZVwiLGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGlmKG5vZGUuYmxvY2tfZGVsZXRlKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0bm9kZS5ncmFwaC5yZW1vdmUobm9kZSk7XG5cdFx0XHRcdHBhbmVsLmNsb3NlKCk7XG5cdFx0XHR9KS5jbGFzc0xpc3QuYWRkKFwiZGVsZXRlXCIpO1xuXHRcdH1cblxuXHRcdHBhbmVsLmlubmVyX3Nob3dDb2RlUGFkID0gZnVuY3Rpb24oIHByb3BuYW1lIClcblx0XHR7XG4gICAgICAgICAgICBwYW5lbC5jbGFzc0xpc3QucmVtb3ZlKFwic2V0dGluZ3NcIik7XG4gICAgICAgICAgICBwYW5lbC5jbGFzc0xpc3QuYWRkKFwiY2VudGVyZWRcIik7XG5cbiAgICAgICAgICAgIFxuXHRcdFx0LyppZih3aW5kb3cuQ29kZUZsYXNrKSAvL2Rpc2FibGVkIGZvciBub3dcblx0XHRcdHtcblx0XHRcdFx0cGFuZWwuY29udGVudC5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9J2NvZGUnPjwvZGl2PlwiO1xuXHRcdFx0XHR2YXIgZmxhc2sgPSBuZXcgQ29kZUZsYXNrKCBcImRpdi5jb2RlXCIsIHsgbGFuZ3VhZ2U6ICdqcycgfSk7XG5cdFx0XHRcdGZsYXNrLnVwZGF0ZUNvZGUobm9kZS5wcm9wZXJ0aWVzW3Byb3BuYW1lXSk7XG5cdFx0XHRcdGZsYXNrLm9uVXBkYXRlKCBmdW5jdGlvbihjb2RlKSB7XG5cdFx0XHRcdFx0bm9kZS5zZXRQcm9wZXJ0eShwcm9wbmFtZSwgY29kZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0eyovXG5cdFx0XHRcdHBhbmVsLmFsdF9jb250ZW50LmlubmVySFRNTCA9IFwiPHRleHRhcmVhIGNsYXNzPSdjb2RlJz48L3RleHRhcmVhPlwiO1xuXHRcdFx0XHR2YXIgdGV4dGFyZWEgPSBwYW5lbC5hbHRfY29udGVudC5xdWVyeVNlbGVjdG9yKFwidGV4dGFyZWFcIik7XG4gICAgICAgICAgICAgICAgdmFyIGZEb25lV2l0aCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsLnRvZ2dsZUFsdENvbnRlbnQoZmFsc2UpOyAvL2lmKG5vZGVfcHJvcF9kaXYpIG5vZGVfcHJvcF9kaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjsgLy8gcGFuZWwuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwudG9nZ2xlRm9vdGVyVmlzaWJpbGl0eSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0ZXh0YXJlYSk7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsLmNsYXNzTGlzdC5hZGQoXCJzZXR0aW5nc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwuY2xhc3NMaXN0LnJlbW92ZShcImNlbnRlcmVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBpbm5lcl9yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuXHRcdFx0XHR0ZXh0YXJlYS52YWx1ZSA9IG5vZGUucHJvcGVydGllc1twcm9wbmFtZV07XG5cdFx0XHRcdHRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpe1xuXHRcdFx0XHRcdGlmKGUuY29kZSA9PSBcIkVudGVyXCIgJiYgZS5jdHJsS2V5IClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRub2RlLnNldFByb3BlcnR5KHByb3BuYW1lLCB0ZXh0YXJlYS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmRG9uZVdpdGgoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuICAgICAgICAgICAgICAgIHBhbmVsLnRvZ2dsZUFsdENvbnRlbnQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcGFuZWwudG9nZ2xlRm9vdGVyVmlzaWJpbGl0eShmYWxzZSk7XG5cdFx0XHRcdHRleHRhcmVhLnN0eWxlLmhlaWdodCA9IFwiY2FsYygxMDAlIC0gNDBweClcIjtcblx0XHRcdC8qfSovXG5cdFx0XHR2YXIgYXNzaWduID0gcGFuZWwuYWRkQnV0dG9uKCBcIkFzc2lnblwiLCBmdW5jdGlvbigpe1xuXHRcdFx0XHRub2RlLnNldFByb3BlcnR5KHByb3BuYW1lLCB0ZXh0YXJlYS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgZkRvbmVXaXRoKCk7XG5cdFx0XHR9KTtcblx0XHRcdHBhbmVsLmFsdF9jb250ZW50LmFwcGVuZENoaWxkKGFzc2lnbik7IC8vcGFuZWwuY29udGVudC5hcHBlbmRDaGlsZChhc3NpZ24pO1xuXHRcdFx0dmFyIGJ1dHRvbiA9IHBhbmVsLmFkZEJ1dHRvbiggXCJDbG9zZVwiLCBmRG9uZVdpdGgpO1xuXHRcdFx0YnV0dG9uLnN0eWxlLmZsb2F0ID0gXCJyaWdodFwiO1xuXHRcdFx0cGFuZWwuYWx0X2NvbnRlbnQuYXBwZW5kQ2hpbGQoYnV0dG9uKTsgLy8gcGFuZWwuY29udGVudC5hcHBlbmRDaGlsZChidXR0b24pO1xuXHRcdH1cblxuXHRcdGlubmVyX3JlZnJlc2goKTtcblxuXHRcdHRoaXMuY2FudmFzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoIHBhbmVsICk7XG5cdH1cblx0XG5cdExHcmFwaENhbnZhcy5wcm90b3R5cGUuc2hvd1N1YmdyYXBoUHJvcGVydGllc0RpYWxvZyA9IGZ1bmN0aW9uKG5vZGUpXG5cdHtcblx0XHRjb25zb2xlLmxvZyhcInNob3dpbmcgc3ViZ3JhcGggcHJvcGVydGllcyBkaWFsb2dcIik7XG5cblx0XHR2YXIgb2xkX3BhbmVsID0gdGhpcy5jYW52YXMucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yKFwiLnN1YmdyYXBoX2RpYWxvZ1wiKTtcblx0XHRpZihvbGRfcGFuZWwpXG5cdFx0XHRvbGRfcGFuZWwuY2xvc2UoKTtcblxuXHRcdHZhciBwYW5lbCA9IHRoaXMuY3JlYXRlUGFuZWwoXCJTdWJncmFwaCBJbnB1dHNcIix7Y2xvc2FibGU6dHJ1ZSwgd2lkdGg6IDUwMH0pO1xuXHRcdHBhbmVsLm5vZGUgPSBub2RlO1xuXHRcdHBhbmVsLmNsYXNzTGlzdC5hZGQoXCJzdWJncmFwaF9kaWFsb2dcIik7XG5cblx0XHRmdW5jdGlvbiBpbm5lcl9yZWZyZXNoKClcblx0XHR7XG5cdFx0XHRwYW5lbC5jbGVhcigpO1xuXG5cdFx0XHQvL3Nob3cgY3VycmVudHNcblx0XHRcdGlmKG5vZGUuaW5wdXRzKVxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbm9kZS5pbnB1dHMubGVuZ3RoOyArK2kpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgaW5wdXQgPSBub2RlLmlucHV0c1tpXTtcblx0XHRcdFx0XHRpZihpbnB1dC5ub3Rfc3ViZ3JhcGhfaW5wdXQpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR2YXIgaHRtbCA9IFwiPGJ1dHRvbj4mIzEwMDA1OzwvYnV0dG9uPiA8c3BhbiBjbGFzcz0nYnVsbGV0X2ljb24nPjwvc3Bhbj48c3BhbiBjbGFzcz0nbmFtZSc+PC9zcGFuPjxzcGFuIGNsYXNzPSd0eXBlJz48L3NwYW4+XCI7XG5cdFx0XHRcdFx0dmFyIGVsZW0gPSBwYW5lbC5hZGRIVE1MKGh0bWwsXCJzdWJncmFwaF9wcm9wZXJ0eVwiKTtcblx0XHRcdFx0XHRlbGVtLmRhdGFzZXRbXCJuYW1lXCJdID0gaW5wdXQubmFtZTtcblx0XHRcdFx0XHRlbGVtLmRhdGFzZXRbXCJzbG90XCJdID0gaTtcblx0XHRcdFx0XHRlbGVtLnF1ZXJ5U2VsZWN0b3IoXCIubmFtZVwiKS5pbm5lclRleHQgPSBpbnB1dC5uYW1lO1xuXHRcdFx0XHRcdGVsZW0ucXVlcnlTZWxlY3RvcihcIi50eXBlXCIpLmlubmVyVGV4dCA9IGlucHV0LnR5cGU7XG5cdFx0XHRcdFx0ZWxlbS5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGZ1bmN0aW9uKGUpe1xuXHRcdFx0XHRcdFx0bm9kZS5yZW1vdmVJbnB1dCggTnVtYmVyKCB0aGlzLnBhcmVudE5vZGUuZGF0YXNldFtcInNsb3RcIl0gKSApO1xuXHRcdFx0XHRcdFx0aW5uZXJfcmVmcmVzaCgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9hZGQgZXh0cmFcblx0XHR2YXIgaHRtbCA9IFwiICsgPHNwYW4gY2xhc3M9J2xhYmVsJz5OYW1lPC9zcGFuPjxpbnB1dCBjbGFzcz0nbmFtZScvPjxzcGFuIGNsYXNzPSdsYWJlbCc+VHlwZTwvc3Bhbj48aW5wdXQgY2xhc3M9J3R5cGUnPjwvaW5wdXQ+PGJ1dHRvbj4rPC9idXR0b24+XCI7XG5cdFx0dmFyIGVsZW0gPSBwYW5lbC5hZGRIVE1MKGh0bWwsXCJzdWJncmFwaF9wcm9wZXJ0eSBleHRyYVwiLCB0cnVlKTtcblx0XHRlbGVtLnF1ZXJ5U2VsZWN0b3IoXCJidXR0b25cIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpe1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzLnBhcmVudE5vZGU7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ucXVlcnlTZWxlY3RvcihcIi5uYW1lXCIpLnZhbHVlO1xuXHRcdFx0dmFyIHR5cGUgPSBlbGVtLnF1ZXJ5U2VsZWN0b3IoXCIudHlwZVwiKS52YWx1ZTtcblx0XHRcdGlmKCFuYW1lIHx8IG5vZGUuZmluZElucHV0U2xvdChuYW1lKSAhPSAtMSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0bm9kZS5hZGRJbnB1dChuYW1lLHR5cGUpO1xuXHRcdFx0ZWxlbS5xdWVyeVNlbGVjdG9yKFwiLm5hbWVcIikudmFsdWUgPSBcIlwiO1xuXHRcdFx0ZWxlbS5xdWVyeVNlbGVjdG9yKFwiLnR5cGVcIikudmFsdWUgPSBcIlwiO1xuXHRcdFx0aW5uZXJfcmVmcmVzaCgpO1xuXHRcdH0pO1xuXG5cdFx0aW5uZXJfcmVmcmVzaCgpO1xuXHQgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChwYW5lbCk7XG5cdFx0cmV0dXJuIHBhbmVsO1xuXHR9XG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5zaG93U3ViZ3JhcGhQcm9wZXJ0aWVzRGlhbG9nUmlnaHQgPSBmdW5jdGlvbiAobm9kZSkge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwic2hvd2luZyBzdWJncmFwaCBwcm9wZXJ0aWVzIGRpYWxvZ1wiKTtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAvLyBvbGRfcGFuZWwgaWYgb2xkX3BhbmVsIGlzIGV4aXN0IGNsb3NlIGl0XG4gICAgICAgIHZhciBvbGRfcGFuZWwgPSB0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoXCIuc3ViZ3JhcGhfZGlhbG9nXCIpO1xuICAgICAgICBpZiAob2xkX3BhbmVsKVxuICAgICAgICAgICAgb2xkX3BhbmVsLmNsb3NlKCk7XG4gICAgICAgIC8vIG5ldyBwYW5lbFxuICAgICAgICB2YXIgcGFuZWwgPSB0aGlzLmNyZWF0ZVBhbmVsKFwiU3ViZ3JhcGggT3V0cHV0c1wiLCB7IGNsb3NhYmxlOiB0cnVlLCB3aWR0aDogNTAwIH0pO1xuICAgICAgICBwYW5lbC5ub2RlID0gbm9kZTtcbiAgICAgICAgcGFuZWwuY2xhc3NMaXN0LmFkZChcInN1YmdyYXBoX2RpYWxvZ1wiKTtcblxuICAgICAgICBmdW5jdGlvbiBpbm5lcl9yZWZyZXNoKCkge1xuICAgICAgICAgICAgcGFuZWwuY2xlYXIoKTtcbiAgICAgICAgICAgIC8vc2hvdyBjdXJyZW50c1xuICAgICAgICAgICAgaWYgKG5vZGUub3V0cHV0cylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUub3V0cHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBub2RlLm91dHB1dHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5ub3Rfc3ViZ3JhcGhfb3V0cHV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBodG1sID0gXCI8YnV0dG9uPiYjMTAwMDU7PC9idXR0b24+IDxzcGFuIGNsYXNzPSdidWxsZXRfaWNvbic+PC9zcGFuPjxzcGFuIGNsYXNzPSduYW1lJz48L3NwYW4+PHNwYW4gY2xhc3M9J3R5cGUnPjwvc3Bhbj5cIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBwYW5lbC5hZGRIVE1MKGh0bWwsIFwic3ViZ3JhcGhfcHJvcGVydHlcIik7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uZGF0YXNldFtcIm5hbWVcIl0gPSBpbnB1dC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBlbGVtLmRhdGFzZXRbXCJzbG90XCJdID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5xdWVyeVNlbGVjdG9yKFwiLm5hbWVcIikuaW5uZXJUZXh0ID0gaW5wdXQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5xdWVyeVNlbGVjdG9yKFwiLnR5cGVcIikuaW5uZXJUZXh0ID0gaW5wdXQudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVPdXRwdXQoTnVtYmVyKHRoaXMucGFyZW50Tm9kZS5kYXRhc2V0W1wic2xvdFwiXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJfcmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2FkZCBleHRyYVxuICAgICAgICB2YXIgaHRtbCA9IFwiICsgPHNwYW4gY2xhc3M9J2xhYmVsJz5OYW1lPC9zcGFuPjxpbnB1dCBjbGFzcz0nbmFtZScvPjxzcGFuIGNsYXNzPSdsYWJlbCc+VHlwZTwvc3Bhbj48aW5wdXQgY2xhc3M9J3R5cGUnPjwvaW5wdXQ+PGJ1dHRvbj4rPC9idXR0b24+XCI7XG4gICAgICAgIHZhciBlbGVtID0gcGFuZWwuYWRkSFRNTChodG1sLCBcInN1YmdyYXBoX3Byb3BlcnR5IGV4dHJhXCIsIHRydWUpO1xuICAgICAgICBlbGVtLnF1ZXJ5U2VsZWN0b3IoXCIubmFtZVwiKS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxMykge1xuICAgICAgICAgICAgICAgIGFkZE91dHB1dC5hcHBseSh0aGlzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBlbGVtLnF1ZXJ5U2VsZWN0b3IoXCJidXR0b25cIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBhZGRPdXRwdXQuYXBwbHkodGhpcylcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGFkZE91dHB1dCgpIHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gdGhpcy5wYXJlbnROb2RlO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBlbGVtLnF1ZXJ5U2VsZWN0b3IoXCIubmFtZVwiKS52YWx1ZTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZWxlbS5xdWVyeVNlbGVjdG9yKFwiLnR5cGVcIikudmFsdWU7XG4gICAgICAgICAgICBpZiAoIW5hbWUgfHwgbm9kZS5maW5kT3V0cHV0U2xvdChuYW1lKSAhPSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBub2RlLmFkZE91dHB1dChuYW1lLCB0eXBlKTtcbiAgICAgICAgICAgIGVsZW0ucXVlcnlTZWxlY3RvcihcIi5uYW1lXCIpLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIGVsZW0ucXVlcnlTZWxlY3RvcihcIi50eXBlXCIpLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIGlubmVyX3JlZnJlc2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlubmVyX3JlZnJlc2goKTtcbiAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChwYW5lbCk7XG4gICAgICAgIHJldHVybiBwYW5lbDtcbiAgICB9XG5cdExHcmFwaENhbnZhcy5wcm90b3R5cGUuY2hlY2tQYW5lbHMgPSBmdW5jdGlvbigpXG5cdHtcblx0XHRpZighdGhpcy5jYW52YXMpXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIHBhbmVscyA9IHRoaXMuY2FudmFzLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChcIi5saXRlZ3JhcGguZGlhbG9nXCIpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBwYW5lbHMubGVuZ3RoOyArK2kpXG5cdFx0e1xuXHRcdFx0dmFyIHBhbmVsID0gcGFuZWxzW2ldO1xuXHRcdFx0aWYoICFwYW5lbC5ub2RlIClcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRpZiggIXBhbmVsLm5vZGUuZ3JhcGggfHwgcGFuZWwuZ3JhcGggIT0gdGhpcy5ncmFwaCApXG5cdFx0XHRcdHBhbmVsLmNsb3NlKCk7XG5cdFx0fVxuXHR9XG5cbiAgICBMR3JhcGhDYW52YXMub25NZW51Tm9kZUNvbGxhcHNlID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMsIGUsIG1lbnUsIG5vZGUpIHtcblx0XHRub2RlLmdyYXBoLmJlZm9yZUNoYW5nZSgvKj8qLyk7XG5cdFx0XG5cdFx0dmFyIGZBcHBseU11bHRpTm9kZSA9IGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0bm9kZS5jb2xsYXBzZSgpO1xuXHRcdH1cblx0XHRcblx0XHR2YXIgZ3JhcGhjYW52YXMgPSBMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcztcblx0XHRpZiAoIWdyYXBoY2FudmFzLnNlbGVjdGVkX25vZGVzIHx8IE9iamVjdC5rZXlzKGdyYXBoY2FudmFzLnNlbGVjdGVkX25vZGVzKS5sZW5ndGggPD0gMSl7XG5cdFx0XHRmQXBwbHlNdWx0aU5vZGUobm9kZSk7XG5cdFx0fWVsc2V7XG5cdFx0XHRmb3IgKHZhciBpIGluIGdyYXBoY2FudmFzLnNlbGVjdGVkX25vZGVzKSB7XG5cdFx0XHRcdGZBcHBseU11bHRpTm9kZShncmFwaGNhbnZhcy5zZWxlY3RlZF9ub2Rlc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdG5vZGUuZ3JhcGguYWZ0ZXJDaGFuZ2UoLyo/Ki8pO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMub25NZW51Tm9kZVBpbiA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zLCBlLCBtZW51LCBub2RlKSB7XG4gICAgICAgIG5vZGUucGluKCk7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5vbk1lbnVOb2RlTW9kZSA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zLCBlLCBtZW51LCBub2RlKSB7XG4gICAgICAgIG5ldyBMaXRlR3JhcGguQ29udGV4dE1lbnUoXG4gICAgICAgICAgICBMaXRlR3JhcGguTk9ERV9NT0RFUyxcbiAgICAgICAgICAgIHsgZXZlbnQ6IGUsIGNhbGxiYWNrOiBpbm5lcl9jbGlja2VkLCBwYXJlbnRNZW51OiBtZW51LCBub2RlOiBub2RlIH1cbiAgICAgICAgKTtcblxuICAgICAgICBmdW5jdGlvbiBpbm5lcl9jbGlja2VkKHYpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBrViA9IE9iamVjdC52YWx1ZXMoTGl0ZUdyYXBoLk5PREVfTU9ERVMpLmluZGV4T2Yodik7XG4gICAgICAgICAgICB2YXIgZkFwcGx5TXVsdGlOb2RlID0gZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRcdGlmIChrVj49MCAmJiBMaXRlR3JhcGguTk9ERV9NT0RFU1trVl0pXG5cdFx0XHRcdFx0bm9kZS5jaGFuZ2VNb2RlKGtWKTtcblx0XHRcdFx0ZWxzZXtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJ1bmV4cGVjdGVkIG1vZGU6IFwiK3YpO1xuXHRcdFx0XHRcdG5vZGUuY2hhbmdlTW9kZShMaXRlR3JhcGguQUxXQVlTKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR2YXIgZ3JhcGhjYW52YXMgPSBMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcztcblx0XHRcdGlmICghZ3JhcGhjYW52YXMuc2VsZWN0ZWRfbm9kZXMgfHwgT2JqZWN0LmtleXMoZ3JhcGhjYW52YXMuc2VsZWN0ZWRfbm9kZXMpLmxlbmd0aCA8PSAxKXtcblx0XHRcdFx0ZkFwcGx5TXVsdGlOb2RlKG5vZGUpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGZvciAodmFyIGkgaW4gZ3JhcGhjYW52YXMuc2VsZWN0ZWRfbm9kZXMpIHtcblx0XHRcdFx0XHRmQXBwbHlNdWx0aU5vZGUoZ3JhcGhjYW52YXMuc2VsZWN0ZWRfbm9kZXNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5vbk1lbnVOb2RlQ29sb3JzID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMsIGUsIG1lbnUsIG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBcIm5vIG5vZGUgZm9yIGNvbG9yXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIHZhbHVlcy5wdXNoKHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgY29udGVudDpcbiAgICAgICAgICAgICAgICBcIjxzcGFuIHN0eWxlPSdkaXNwbGF5OiBibG9jazsgcGFkZGluZy1sZWZ0OiA0cHg7Jz5ObyBjb2xvcjwvc3Bhbj5cIlxuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIExHcmFwaENhbnZhcy5ub2RlX2NvbG9ycykge1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gTEdyYXBoQ2FudmFzLm5vZGVfY29sb3JzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6XG4gICAgICAgICAgICAgICAgICAgIFwiPHNwYW4gc3R5bGU9J2Rpc3BsYXk6IGJsb2NrOyBjb2xvcjogIzk5OTsgcGFkZGluZy1sZWZ0OiA0cHg7IGJvcmRlci1sZWZ0OiA4cHggc29saWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICBjb2xvci5jb2xvciArXG4gICAgICAgICAgICAgICAgICAgIFwiOyBiYWNrZ3JvdW5kLWNvbG9yOlwiICtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IuYmdjb2xvciArXG4gICAgICAgICAgICAgICAgICAgIFwiJz5cIiArXG4gICAgICAgICAgICAgICAgICAgIGkgK1xuICAgICAgICAgICAgICAgICAgICBcIjwvc3Bhbj5cIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBuZXcgTGl0ZUdyYXBoLkNvbnRleHRNZW51KHZhbHVlcywge1xuICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICBjYWxsYmFjazogaW5uZXJfY2xpY2tlZCxcbiAgICAgICAgICAgIHBhcmVudE1lbnU6IG1lbnUsXG4gICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlubmVyX2NsaWNrZWQodikge1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29sb3IgPSB2LnZhbHVlID8gTEdyYXBoQ2FudmFzLm5vZGVfY29sb3JzW3YudmFsdWVdIDogbnVsbDtcblx0XHRcdFxuXHRcdFx0dmFyIGZBcHBseUNvbG9yID0gZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRcdGlmIChjb2xvcikge1xuXHRcdFx0XHRcdGlmIChub2RlLmNvbnN0cnVjdG9yID09PSBMaXRlR3JhcGguTEdyYXBoR3JvdXApIHtcblx0XHRcdFx0XHRcdG5vZGUuY29sb3IgPSBjb2xvci5ncm91cGNvbG9yO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRub2RlLmNvbG9yID0gY29sb3IuY29sb3I7XG5cdFx0XHRcdFx0XHRub2RlLmJnY29sb3IgPSBjb2xvci5iZ2NvbG9yO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWxldGUgbm9kZS5jb2xvcjtcblx0XHRcdFx0XHRkZWxldGUgbm9kZS5iZ2NvbG9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHZhciBncmFwaGNhbnZhcyA9IExHcmFwaENhbnZhcy5hY3RpdmVfY2FudmFzO1xuXHRcdFx0aWYgKCFncmFwaGNhbnZhcy5zZWxlY3RlZF9ub2RlcyB8fCBPYmplY3Qua2V5cyhncmFwaGNhbnZhcy5zZWxlY3RlZF9ub2RlcykubGVuZ3RoIDw9IDEpe1xuXHRcdFx0XHRmQXBwbHlDb2xvcihub2RlKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRmb3IgKHZhciBpIGluIGdyYXBoY2FudmFzLnNlbGVjdGVkX25vZGVzKSB7XG5cdFx0XHRcdFx0ZkFwcGx5Q29sb3IoZ3JhcGhjYW52YXMuc2VsZWN0ZWRfbm9kZXNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG4gICAgICAgICAgICBub2RlLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMub25NZW51Tm9kZVNoYXBlcyA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zLCBlLCBtZW51LCBub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgdGhyb3cgXCJubyBub2RlIHBhc3NlZFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3IExpdGVHcmFwaC5Db250ZXh0TWVudShMaXRlR3JhcGguVkFMSURfU0hBUEVTLCB7XG4gICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBpbm5lcl9jbGlja2VkLFxuICAgICAgICAgICAgcGFyZW50TWVudTogbWVudSxcbiAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5uZXJfY2xpY2tlZCh2KSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cdFx0XHRub2RlLmdyYXBoLmJlZm9yZUNoYW5nZSgvKj8qLyk7IC8vbm9kZVxuICAgICAgICAgICAgXG5cdFx0XHR2YXIgZkFwcGx5TXVsdGlOb2RlID0gZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRcdG5vZGUuc2hhcGUgPSB2O1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZ3JhcGhjYW52YXMgPSBMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcztcblx0XHRcdGlmICghZ3JhcGhjYW52YXMuc2VsZWN0ZWRfbm9kZXMgfHwgT2JqZWN0LmtleXMoZ3JhcGhjYW52YXMuc2VsZWN0ZWRfbm9kZXMpLmxlbmd0aCA8PSAxKXtcblx0XHRcdFx0ZkFwcGx5TXVsdGlOb2RlKG5vZGUpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGZvciAodmFyIGkgaW4gZ3JhcGhjYW52YXMuc2VsZWN0ZWRfbm9kZXMpIHtcblx0XHRcdFx0XHRmQXBwbHlNdWx0aU5vZGUoZ3JhcGhjYW52YXMuc2VsZWN0ZWRfbm9kZXNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdG5vZGUuZ3JhcGguYWZ0ZXJDaGFuZ2UoLyo/Ki8pOyAvL25vZGVcbiAgICAgICAgICAgIG5vZGUuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIExHcmFwaENhbnZhcy5vbk1lbnVOb2RlUmVtb3ZlID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMsIGUsIG1lbnUsIG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBcIm5vIG5vZGUgcGFzc2VkXCI7XG4gICAgICAgIH1cblxuXHRcdHZhciBncmFwaCA9IG5vZGUuZ3JhcGg7XG5cdFx0Z3JhcGguYmVmb3JlQ2hhbmdlKCk7XG4gICAgICAgIFxuXHRcdFxuXHRcdHZhciBmQXBwbHlNdWx0aU5vZGUgPSBmdW5jdGlvbihub2RlKXtcblx0XHRcdGlmIChub2RlLnJlbW92YWJsZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Z3JhcGgucmVtb3ZlKG5vZGUpO1xuXHRcdH1cblxuXHRcdHZhciBncmFwaGNhbnZhcyA9IExHcmFwaENhbnZhcy5hY3RpdmVfY2FudmFzO1xuXHRcdGlmICghZ3JhcGhjYW52YXMuc2VsZWN0ZWRfbm9kZXMgfHwgT2JqZWN0LmtleXMoZ3JhcGhjYW52YXMuc2VsZWN0ZWRfbm9kZXMpLmxlbmd0aCA8PSAxKXtcblx0XHRcdGZBcHBseU11bHRpTm9kZShub2RlKTtcblx0XHR9ZWxzZXtcblx0XHRcdGZvciAodmFyIGkgaW4gZ3JhcGhjYW52YXMuc2VsZWN0ZWRfbm9kZXMpIHtcblx0XHRcdFx0ZkFwcGx5TXVsdGlOb2RlKGdyYXBoY2FudmFzLnNlbGVjdGVkX25vZGVzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Z3JhcGguYWZ0ZXJDaGFuZ2UoKTtcbiAgICAgICAgbm9kZS5zZXREaXJ0eUNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLm9uTWVudU5vZGVUb1N1YmdyYXBoID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMsIGUsIG1lbnUsIG5vZGUpIHtcblx0XHR2YXIgZ3JhcGggPSBub2RlLmdyYXBoO1xuXHRcdHZhciBncmFwaGNhbnZhcyA9IExHcmFwaENhbnZhcy5hY3RpdmVfY2FudmFzO1xuXHRcdGlmKCFncmFwaGNhbnZhcykgLy8/P1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dmFyIG5vZGVzX2xpc3QgPSBPYmplY3QudmFsdWVzKCBncmFwaGNhbnZhcy5zZWxlY3RlZF9ub2RlcyB8fCB7fSApO1xuXHRcdGlmKCAhbm9kZXNfbGlzdC5sZW5ndGggKVxuXHRcdFx0bm9kZXNfbGlzdCA9IFsgbm9kZSBdO1xuXG5cdFx0dmFyIHN1YmdyYXBoX25vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZShcImdyYXBoL3N1YmdyYXBoXCIpO1xuXHRcdHN1YmdyYXBoX25vZGUucG9zID0gbm9kZS5wb3MuY29uY2F0KCk7XG5cdFx0Z3JhcGguYWRkKHN1YmdyYXBoX25vZGUpO1xuXG5cdFx0c3ViZ3JhcGhfbm9kZS5idWlsZEZyb21Ob2Rlcyggbm9kZXNfbGlzdCApO1xuXG5cdFx0Z3JhcGhjYW52YXMuZGVzZWxlY3RBbGxOb2RlcygpO1xuICAgICAgICBub2RlLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMub25NZW51Tm9kZUNsb25lID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMsIGUsIG1lbnUsIG5vZGUpIHtcbiAgICAgICAgXG5cdFx0bm9kZS5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgXG5cdFx0dmFyIG5ld1NlbGVjdGVkID0ge307XG5cdFx0XG5cdFx0dmFyIGZBcHBseU11bHRpTm9kZSA9IGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0aWYgKG5vZGUuY2xvbmFibGUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBuZXdub2RlID0gbm9kZS5jbG9uZSgpO1xuXHRcdFx0aWYgKCFuZXdub2RlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdG5ld25vZGUucG9zID0gW25vZGUucG9zWzBdICsgNSwgbm9kZS5wb3NbMV0gKyA1XTtcblx0XHRcdG5vZGUuZ3JhcGguYWRkKG5ld25vZGUpO1xuXHRcdFx0bmV3U2VsZWN0ZWRbbmV3bm9kZS5pZF0gPSBuZXdub2RlO1xuXHRcdH1cblxuXHRcdHZhciBncmFwaGNhbnZhcyA9IExHcmFwaENhbnZhcy5hY3RpdmVfY2FudmFzO1xuXHRcdGlmICghZ3JhcGhjYW52YXMuc2VsZWN0ZWRfbm9kZXMgfHwgT2JqZWN0LmtleXMoZ3JhcGhjYW52YXMuc2VsZWN0ZWRfbm9kZXMpLmxlbmd0aCA8PSAxKXtcblx0XHRcdGZBcHBseU11bHRpTm9kZShub2RlKTtcblx0XHR9ZWxzZXtcblx0XHRcdGZvciAodmFyIGkgaW4gZ3JhcGhjYW52YXMuc2VsZWN0ZWRfbm9kZXMpIHtcblx0XHRcdFx0ZkFwcGx5TXVsdGlOb2RlKGdyYXBoY2FudmFzLnNlbGVjdGVkX25vZGVzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0aWYoT2JqZWN0LmtleXMobmV3U2VsZWN0ZWQpLmxlbmd0aCl7XG5cdFx0XHRncmFwaGNhbnZhcy5zZWxlY3ROb2RlcyhuZXdTZWxlY3RlZCk7XG5cdFx0fVxuXHRcdFxuXHRcdG5vZGUuZ3JhcGguYWZ0ZXJDaGFuZ2UoKTtcblxuICAgICAgICBub2RlLnNldERpcnR5Q2FudmFzKHRydWUsIHRydWUpO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMubm9kZV9jb2xvcnMgPSB7XG4gICAgICAgIHJlZDogeyBjb2xvcjogXCIjMzIyXCIsIGJnY29sb3I6IFwiIzUzM1wiLCBncm91cGNvbG9yOiBcIiNBODhcIiB9LFxuICAgICAgICBicm93bjogeyBjb2xvcjogXCIjMzMyOTIyXCIsIGJnY29sb3I6IFwiIzU5MzkzMFwiLCBncm91cGNvbG9yOiBcIiNiMDY2MzRcIiB9LFxuICAgICAgICBncmVlbjogeyBjb2xvcjogXCIjMjMyXCIsIGJnY29sb3I6IFwiIzM1M1wiLCBncm91cGNvbG9yOiBcIiM4QThcIiB9LFxuICAgICAgICBibHVlOiB7IGNvbG9yOiBcIiMyMjNcIiwgYmdjb2xvcjogXCIjMzM1XCIsIGdyb3VwY29sb3I6IFwiIzg4QVwiIH0sXG4gICAgICAgIHBhbGVfYmx1ZToge1xuICAgICAgICAgICAgY29sb3I6IFwiIzJhMzYzYlwiLFxuICAgICAgICAgICAgYmdjb2xvcjogXCIjM2Y1MTU5XCIsXG4gICAgICAgICAgICBncm91cGNvbG9yOiBcIiMzZjc4OWVcIlxuICAgICAgICB9LFxuICAgICAgICBjeWFuOiB7IGNvbG9yOiBcIiMyMzNcIiwgYmdjb2xvcjogXCIjMzU1XCIsIGdyb3VwY29sb3I6IFwiIzhBQVwiIH0sXG4gICAgICAgIHB1cnBsZTogeyBjb2xvcjogXCIjMzIzXCIsIGJnY29sb3I6IFwiIzUzNVwiLCBncm91cGNvbG9yOiBcIiNhMTMwOWJcIiB9LFxuICAgICAgICB5ZWxsb3c6IHsgY29sb3I6IFwiIzQzMlwiLCBiZ2NvbG9yOiBcIiM2NTNcIiwgZ3JvdXBjb2xvcjogXCIjYjU4YjJhXCIgfSxcbiAgICAgICAgYmxhY2s6IHsgY29sb3I6IFwiIzIyMlwiLCBiZ2NvbG9yOiBcIiMwMDBcIiwgZ3JvdXBjb2xvcjogXCIjNDQ0XCIgfVxuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmdldENhbnZhc01lbnVPcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gbnVsbDtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmdldE1lbnVPcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gdGhpcy5nZXRNZW51T3B0aW9ucygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiQWRkIE5vZGVcIixcbiAgICAgICAgICAgICAgICAgICAgaGFzX3N1Ym1lbnU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBMR3JhcGhDYW52YXMub25NZW51QWRkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7IGNvbnRlbnQ6IFwiQWRkIEdyb3VwXCIsIGNhbGxiYWNrOiBMR3JhcGhDYW52YXMub25Hcm91cEFkZCB9LFxuXHRcdFx0XHQvL3sgY29udGVudDogXCJBcnJhbmdlXCIsIGNhbGxiYWNrOiB0aGF0LmdyYXBoLmFycmFuZ2UgfSxcbiAgICAgICAgICAgICAgICAvL3tjb250ZW50OlwiQ29sbGFwc2UgQWxsXCIsIGNhbGxiYWNrOiBMR3JhcGhDYW52YXMub25NZW51Q29sbGFwc2VBbGwgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIC8qaWYgKExpdGVHcmFwaC5zaG93Q2FudmFzT3B0aW9ucyl7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKHsgY29udGVudDogXCJPcHRpb25zXCIsIGNhbGxiYWNrOiB0aGF0LnNob3dTaG93R3JhcGhPcHRpb25zUGFuZWwgfSk7XG4gICAgICAgICAgICB9Ki9cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuc2VsZWN0ZWRfbm9kZXMpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIkFsaWduXCIsXG4gICAgICAgICAgICAgICAgICAgIGhhc19zdWJtZW51OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogTEdyYXBoQ2FudmFzLm9uR3JvdXBBbGlnbixcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fZ3JhcGhfc3RhY2sgJiYgdGhpcy5fZ3JhcGhfc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHVzaChudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiQ2xvc2Ugc3ViZ3JhcGhcIixcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHRoaXMuY2xvc2VTdWJncmFwaC5iaW5kKHRoaXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5nZXRFeHRyYU1lbnVPcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgZXh0cmEgPSB0aGlzLmdldEV4dHJhTWVudU9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5jb25jYXQoZXh0cmEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfTtcblxuICAgIC8vY2FsbGVkIGJ5IHByb2Nlc3NDb250ZXh0TWVudSB0byBleHRyYWN0IHRoZSBtZW51IGxpc3RcbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmdldE5vZGVNZW51T3B0aW9ucyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBudWxsO1xuXG4gICAgICAgIGlmIChub2RlLmdldE1lbnVPcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gbm9kZS5nZXRNZW51T3B0aW9ucyh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIklucHV0c1wiLFxuICAgICAgICAgICAgICAgICAgICBoYXNfc3VibWVudTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBMR3JhcGhDYW52YXMuc2hvd01lbnVOb2RlT3B0aW9uYWxJbnB1dHNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJPdXRwdXRzXCIsXG4gICAgICAgICAgICAgICAgICAgIGhhc19zdWJtZW51OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5zaG93TWVudU5vZGVPcHRpb25hbE91dHB1dHNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICAgICAgaGFzX3N1Ym1lbnU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBMR3JhcGhDYW52YXMub25TaG93TWVudU5vZGVQcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJUaXRsZVwiLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogTEdyYXBoQ2FudmFzLm9uU2hvd1Byb3BlcnR5RWRpdG9yXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiTW9kZVwiLFxuICAgICAgICAgICAgICAgICAgICBoYXNfc3VibWVudTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVOb2RlTW9kZVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgaWYobm9kZS5yZXNpemFibGUgIT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlJlc2l6ZVwiLCBjYWxsYmFjazogTEdyYXBoQ2FudmFzLm9uTWVudVJlc2l6ZU5vZGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMucHVzaChcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiQ29sbGFwc2VcIixcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVOb2RlQ29sbGFwc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHsgY29udGVudDogXCJQaW5cIiwgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVOb2RlUGluIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIkNvbG9yc1wiLFxuICAgICAgICAgICAgICAgICAgICBoYXNfc3VibWVudTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVOb2RlQ29sb3JzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiU2hhcGVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGhhc19zdWJtZW51OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogTEdyYXBoQ2FudmFzLm9uTWVudU5vZGVTaGFwZXNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5vbkdldElucHV0cykge1xuICAgICAgICAgICAgdmFyIGlucHV0cyA9IG5vZGUub25HZXRJbnB1dHMoKTtcbiAgICAgICAgICAgIGlmIChpbnB1dHMgJiYgaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNbMF0uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLm9uR2V0T3V0cHV0cykge1xuICAgICAgICAgICAgdmFyIG91dHB1dHMgPSBub2RlLm9uR2V0T3V0cHV0cygpO1xuICAgICAgICAgICAgaWYgKG91dHB1dHMgJiYgb3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zWzFdLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5nZXRFeHRyYU1lbnVPcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgZXh0cmEgPSBub2RlLmdldEV4dHJhTWVudU9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBleHRyYS5jb25jYXQob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5jbG9uYWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29udGVudDogXCJDbG9uZVwiLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBMR3JhcGhDYW52YXMub25NZW51Tm9kZUNsb25lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG5cdFx0aWYoMCkgLy9UT0RPXG5cdFx0b3B0aW9ucy5wdXNoKHtcblx0XHRcdGNvbnRlbnQ6IFwiVG8gU3ViZ3JhcGhcIixcblx0XHRcdGNhbGxiYWNrOiBMR3JhcGhDYW52YXMub25NZW51Tm9kZVRvU3ViZ3JhcGhcblx0XHR9KTtcblxuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5zZWxlY3RlZF9ub2RlcykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBcIkFsaWduIFNlbGVjdGVkIFRvXCIsXG4gICAgICAgICAgICAgICAgaGFzX3N1Ym1lbnU6IHRydWUsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk5vZGVBbGlnbixcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuXHRcdG9wdGlvbnMucHVzaChudWxsLCB7XG5cdFx0XHRjb250ZW50OiBcIlJlbW92ZVwiLFxuXHRcdFx0ZGlzYWJsZWQ6ICEobm9kZS5yZW1vdmFibGUgIT09IGZhbHNlICYmICFub2RlLmJsb2NrX2RlbGV0ZSApLFxuXHRcdFx0Y2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVOb2RlUmVtb3ZlXG5cdFx0fSk7XG5cbiAgICAgICAgaWYgKG5vZGUuZ3JhcGggJiYgbm9kZS5ncmFwaC5vbkdldE5vZGVNZW51T3B0aW9ucykge1xuICAgICAgICAgICAgbm9kZS5ncmFwaC5vbkdldE5vZGVNZW51T3B0aW9ucyhvcHRpb25zLCBub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH07XG5cbiAgICBMR3JhcGhDYW52YXMucHJvdG90eXBlLmdldEdyb3VwTWVudU9wdGlvbnMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBvID0gW1xuICAgICAgICAgICAgeyBjb250ZW50OiBcIlRpdGxlXCIsIGNhbGxiYWNrOiBMR3JhcGhDYW52YXMub25TaG93UHJvcGVydHlFZGl0b3IgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBcIkNvbG9yXCIsXG4gICAgICAgICAgICAgICAgaGFzX3N1Ym1lbnU6IHRydWUsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVOb2RlQ29sb3JzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiRm9udCBzaXplXCIsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IFwiZm9udF9zaXplXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJOdW1iZXJcIixcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogTEdyYXBoQ2FudmFzLm9uU2hvd1Byb3BlcnR5RWRpdG9yXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHsgY29udGVudDogXCJSZW1vdmVcIiwgY2FsbGJhY2s6IExHcmFwaENhbnZhcy5vbk1lbnVOb2RlUmVtb3ZlIH1cbiAgICAgICAgXTtcblxuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgTEdyYXBoQ2FudmFzLnByb3RvdHlwZS5wcm9jZXNzQ29udGV4dE1lbnUgPSBmdW5jdGlvbihub2RlLCBldmVudCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBjYW52YXMgPSBMR3JhcGhDYW52YXMuYWN0aXZlX2NhbnZhcztcbiAgICAgICAgdmFyIHJlZl93aW5kb3cgPSBjYW52YXMuZ2V0Q2FudmFzV2luZG93KCk7XG5cbiAgICAgICAgdmFyIG1lbnVfaW5mbyA9IG51bGw7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgY2FsbGJhY2s6IGlubmVyX29wdGlvbl9jbGlja2VkLFxuICAgICAgICAgICAgZXh0cmE6IG5vZGVcbiAgICAgICAgfTtcblxuXHRcdGlmKG5vZGUpXG5cdFx0XHRvcHRpb25zLnRpdGxlID0gbm9kZS50eXBlO1xuXG4gICAgICAgIC8vY2hlY2sgaWYgbW91c2UgaXMgaW4gaW5wdXRcbiAgICAgICAgdmFyIHNsb3QgPSBudWxsO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgc2xvdCA9IG5vZGUuZ2V0U2xvdEluUG9zaXRpb24oZXZlbnQuY2FudmFzWCwgZXZlbnQuY2FudmFzWSk7XG4gICAgICAgICAgICBMR3JhcGhDYW52YXMuYWN0aXZlX25vZGUgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgICAgIC8vb24gc2xvdFxuICAgICAgICAgICAgbWVudV9pbmZvID0gW107XG4gICAgICAgICAgICBpZiAobm9kZS5nZXRTbG90TWVudU9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBtZW51X2luZm8gPSBub2RlLmdldFNsb3RNZW51T3B0aW9ucyhzbG90KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBzbG90ICYmXG4gICAgICAgICAgICAgICAgICAgIHNsb3Qub3V0cHV0ICYmXG4gICAgICAgICAgICAgICAgICAgIHNsb3Qub3V0cHV0LmxpbmtzICYmXG4gICAgICAgICAgICAgICAgICAgIHNsb3Qub3V0cHV0LmxpbmtzLmxlbmd0aFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBtZW51X2luZm8ucHVzaCh7IGNvbnRlbnQ6IFwiRGlzY29ubmVjdCBMaW5rc1wiLCBzbG90OiBzbG90IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgX3Nsb3QgPSBzbG90LmlucHV0IHx8IHNsb3Qub3V0cHV0O1xuICAgICAgICAgICAgICAgIGlmIChfc2xvdC5yZW1vdmFibGUpe1xuICAgICAgICAgICAgICAgIFx0bWVudV9pbmZvLnB1c2goXG5cdCAgICAgICAgICAgICAgICAgICAgX3Nsb3QubG9ja2VkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgID8gXCJDYW5ub3QgcmVtb3ZlXCJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgOiB7IGNvbnRlbnQ6IFwiUmVtb3ZlIFNsb3RcIiwgc2xvdDogc2xvdCB9XG5cdCAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgXHR9XG4gICAgICAgICAgICAgICAgaWYgKCFfc2xvdC5uYW1lTG9ja2VkKXtcblx0ICAgICAgICAgICAgICAgIG1lbnVfaW5mby5wdXNoKHsgY29udGVudDogXCJSZW5hbWUgU2xvdFwiLCBzbG90OiBzbG90IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMudGl0bGUgPVxuICAgICAgICAgICAgICAgIChzbG90LmlucHV0ID8gc2xvdC5pbnB1dC50eXBlIDogc2xvdC5vdXRwdXQudHlwZSkgfHwgXCIqXCI7XG4gICAgICAgICAgICBpZiAoc2xvdC5pbnB1dCAmJiBzbG90LmlucHV0LnR5cGUgPT0gTGl0ZUdyYXBoLkFDVElPTikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudGl0bGUgPSBcIkFjdGlvblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNsb3Qub3V0cHV0ICYmIHNsb3Qub3V0cHV0LnR5cGUgPT0gTGl0ZUdyYXBoLkVWRU5UKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50aXRsZSA9IFwiRXZlbnRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgLy9vbiBub2RlXG4gICAgICAgICAgICAgICAgbWVudV9pbmZvID0gdGhpcy5nZXROb2RlTWVudU9wdGlvbnMobm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lbnVfaW5mbyA9IHRoaXMuZ2V0Q2FudmFzTWVudU9wdGlvbnMoKTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyYXBoLmdldEdyb3VwT25Qb3MoXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmNhbnZhc1gsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmNhbnZhc1lcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAvL29uIGdyb3VwXG4gICAgICAgICAgICAgICAgICAgIG1lbnVfaW5mby5wdXNoKG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiRWRpdCBHcm91cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzX3N1Ym1lbnU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJtZW51OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiR3JvdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogZ3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogdGhpcy5nZXRHcm91cE1lbnVPcHRpb25zKGdyb3VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3Nob3cgbWVudVxuICAgICAgICBpZiAoIW1lbnVfaW5mbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1lbnUgPSBuZXcgTGl0ZUdyYXBoLkNvbnRleHRNZW51KG1lbnVfaW5mbywgb3B0aW9ucywgcmVmX3dpbmRvdyk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5uZXJfb3B0aW9uX2NsaWNrZWQodiwgb3B0aW9ucywgZSkge1xuICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodi5jb250ZW50ID09IFwiUmVtb3ZlIFNsb3RcIikge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gdi5zbG90O1xuICAgICAgICAgICAgICAgIG5vZGUuZ3JhcGguYmVmb3JlQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVJbnB1dChpbmZvLnNsb3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5mby5vdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVPdXRwdXQoaW5mby5zbG90KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5ncmFwaC5hZnRlckNoYW5nZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodi5jb250ZW50ID09IFwiRGlzY29ubmVjdCBMaW5rc1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSB2LnNsb3Q7XG4gICAgICAgICAgICAgICAgbm9kZS5ncmFwaC5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5vdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kaXNjb25uZWN0T3V0cHV0KGluZm8uc2xvdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmZvLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZGlzY29ubmVjdElucHV0KGluZm8uc2xvdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUuZ3JhcGguYWZ0ZXJDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYuY29udGVudCA9PSBcIlJlbmFtZSBTbG90XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHYuc2xvdDtcbiAgICAgICAgICAgICAgICB2YXIgc2xvdF9pbmZvID0gaW5mby5pbnB1dFxuICAgICAgICAgICAgICAgICAgICA/IG5vZGUuZ2V0SW5wdXRJbmZvKGluZm8uc2xvdClcbiAgICAgICAgICAgICAgICAgICAgOiBub2RlLmdldE91dHB1dEluZm8oaW5mby5zbG90KTtcbiAgICAgICAgICAgICAgICB2YXIgZGlhbG9nID0gdGhhdC5jcmVhdGVEaWFsb2coXG4gICAgICAgICAgICAgICAgICAgIFwiPHNwYW4gY2xhc3M9J25hbWUnPk5hbWU8L3NwYW4+PGlucHV0IGF1dG9mb2N1cyB0eXBlPSd0ZXh0Jy8+PGJ1dHRvbj5PSzwvYnV0dG9uPlwiLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBkaWFsb2cucXVlcnlTZWxlY3RvcihcImlucHV0XCIpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCAmJiBzbG90X2luZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBzbG90X2luZm8ubGFiZWwgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBcdG5vZGUuZ3JhcGguYmVmb3JlQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3RfaW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RfaW5mby5sYWJlbCA9IGlucHV0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXREaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5ncmFwaC5hZnRlckNoYW5nZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaWFsb2cucXVlcnlTZWxlY3RvcihcImJ1dHRvblwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaW5uZXIpO1xuICAgICAgICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLmlzX21vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAyNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9FU0NcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PSAxMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXIoKTsgLy8gc2F2ZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSAhPSAxMyAmJiBlLnRhcmdldC5sb2NhbE5hbWUgIT0gXCJ0ZXh0YXJlYVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vaWYodi5jYWxsYmFjaylcbiAgICAgICAgICAgIC8vXHRyZXR1cm4gdi5jYWxsYmFjay5jYWxsKHRoYXQsIG5vZGUsIG9wdGlvbnMsIGUsIG1lbnUsIHRoYXQsIGV2ZW50ICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9BUEkgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIGZ1bmN0aW9uIGNvbXBhcmVPYmplY3RzKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBhKSB7XG4gICAgICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBMaXRlR3JhcGguY29tcGFyZU9iamVjdHMgPSBjb21wYXJlT2JqZWN0cztcblxuICAgIGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChcbiAgICAgICAgICAgIChiWzBdIC0gYVswXSkgKiAoYlswXSAtIGFbMF0pICsgKGJbMV0gLSBhWzFdKSAqIChiWzFdIC0gYVsxXSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgTGl0ZUdyYXBoLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5cbiAgICBmdW5jdGlvbiBjb2xvclRvU3RyaW5nKGMpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIFwicmdiYShcIiArXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGNbMF0gKiAyNTUpLnRvRml4ZWQoKSArXG4gICAgICAgICAgICBcIixcIiArXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGNbMV0gKiAyNTUpLnRvRml4ZWQoKSArXG4gICAgICAgICAgICBcIixcIiArXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGNbMl0gKiAyNTUpLnRvRml4ZWQoKSArXG4gICAgICAgICAgICBcIixcIiArXG4gICAgICAgICAgICAoYy5sZW5ndGggPT0gNCA/IGNbM10udG9GaXhlZCgyKSA6IFwiMS4wXCIpICtcbiAgICAgICAgICAgIFwiKVwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIExpdGVHcmFwaC5jb2xvclRvU3RyaW5nID0gY29sb3JUb1N0cmluZztcblxuICAgIGZ1bmN0aW9uIGlzSW5zaWRlUmVjdGFuZ2xlKHgsIHksIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBpZiAobGVmdCA8IHggJiYgbGVmdCArIHdpZHRoID4geCAmJiB0b3AgPCB5ICYmIHRvcCArIGhlaWdodCA+IHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgTGl0ZUdyYXBoLmlzSW5zaWRlUmVjdGFuZ2xlID0gaXNJbnNpZGVSZWN0YW5nbGU7XG5cbiAgICAvL1ttaW54LG1pbnksbWF4eCxtYXh5XVxuICAgIGZ1bmN0aW9uIGdyb3dCb3VuZGluZyhib3VuZGluZywgeCwgeSkge1xuICAgICAgICBpZiAoeCA8IGJvdW5kaW5nWzBdKSB7XG4gICAgICAgICAgICBib3VuZGluZ1swXSA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCA+IGJvdW5kaW5nWzJdKSB7XG4gICAgICAgICAgICBib3VuZGluZ1syXSA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeSA8IGJvdW5kaW5nWzFdKSB7XG4gICAgICAgICAgICBib3VuZGluZ1sxXSA9IHk7XG4gICAgICAgIH0gZWxzZSBpZiAoeSA+IGJvdW5kaW5nWzNdKSB7XG4gICAgICAgICAgICBib3VuZGluZ1szXSA9IHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTGl0ZUdyYXBoLmdyb3dCb3VuZGluZyA9IGdyb3dCb3VuZGluZztcblxuICAgIC8vcG9pbnQgaW5zaWRlIGJvdW5kaW5nIGJveFxuICAgIGZ1bmN0aW9uIGlzSW5zaWRlQm91bmRpbmcocCwgYmIpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgcFswXSA8IGJiWzBdWzBdIHx8XG4gICAgICAgICAgICBwWzFdIDwgYmJbMF1bMV0gfHxcbiAgICAgICAgICAgIHBbMF0gPiBiYlsxXVswXSB8fFxuICAgICAgICAgICAgcFsxXSA+IGJiWzFdWzFdXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBMaXRlR3JhcGguaXNJbnNpZGVCb3VuZGluZyA9IGlzSW5zaWRlQm91bmRpbmc7XG5cbiAgICAvL2JvdW5kaW5nIG92ZXJsYXAsIGZvcm1hdDogWyBzdGFydHgsIHN0YXJ0eSwgd2lkdGgsIGhlaWdodCBdXG4gICAgZnVuY3Rpb24gb3ZlcmxhcEJvdW5kaW5nKGEsIGIpIHtcbiAgICAgICAgdmFyIEFfZW5kX3ggPSBhWzBdICsgYVsyXTtcbiAgICAgICAgdmFyIEFfZW5kX3kgPSBhWzFdICsgYVszXTtcbiAgICAgICAgdmFyIEJfZW5kX3ggPSBiWzBdICsgYlsyXTtcbiAgICAgICAgdmFyIEJfZW5kX3kgPSBiWzFdICsgYlszXTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBhWzBdID4gQl9lbmRfeCB8fFxuICAgICAgICAgICAgYVsxXSA+IEJfZW5kX3kgfHxcbiAgICAgICAgICAgIEFfZW5kX3ggPCBiWzBdIHx8XG4gICAgICAgICAgICBBX2VuZF95IDwgYlsxXVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgTGl0ZUdyYXBoLm92ZXJsYXBCb3VuZGluZyA9IG92ZXJsYXBCb3VuZGluZztcblxuICAgIC8vQ29udmVydCBhIGhleCB2YWx1ZSB0byBpdHMgZGVjaW1hbCB2YWx1ZSAtIHRoZSBpbnB1dHRlZCBoZXggbXVzdCBiZSBpbiB0aGVcbiAgICAvL1x0Zm9ybWF0IG9mIGEgaGV4IHRyaXBsZXQgLSB0aGUga2luZCB3ZSB1c2UgZm9yIEhUTUwgY29sb3Vycy4gVGhlIGZ1bmN0aW9uXG4gICAgLy9cdHdpbGwgcmV0dXJuIGFuIGFycmF5IHdpdGggdGhyZWUgdmFsdWVzLlxuICAgIGZ1bmN0aW9uIGhleDJudW0oaGV4KSB7XG4gICAgICAgIGlmIChoZXguY2hhckF0KDApID09IFwiI1wiKSB7XG4gICAgICAgICAgICBoZXggPSBoZXguc2xpY2UoMSk7XG4gICAgICAgIH0gLy9SZW1vdmUgdGhlICcjJyBjaGFyIC0gaWYgdGhlcmUgaXMgb25lLlxuICAgICAgICBoZXggPSBoZXgudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdmFyIGhleF9hbHBoYWJldHMgPSBcIjAxMjM0NTY3ODlBQkNERUZcIjtcbiAgICAgICAgdmFyIHZhbHVlID0gbmV3IEFycmF5KDMpO1xuICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgIHZhciBpbnQxLCBpbnQyO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkgKz0gMikge1xuICAgICAgICAgICAgaW50MSA9IGhleF9hbHBoYWJldHMuaW5kZXhPZihoZXguY2hhckF0KGkpKTtcbiAgICAgICAgICAgIGludDIgPSBoZXhfYWxwaGFiZXRzLmluZGV4T2YoaGV4LmNoYXJBdChpICsgMSkpO1xuICAgICAgICAgICAgdmFsdWVba10gPSBpbnQxICogMTYgKyBpbnQyO1xuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBMaXRlR3JhcGguaGV4Mm51bSA9IGhleDJudW07XG5cbiAgICAvL0dpdmUgYSBhcnJheSB3aXRoIHRocmVlIHZhbHVlcyBhcyB0aGUgYXJndW1lbnQgYW5kIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVyblxuICAgIC8vXHR0aGUgY29ycmVzcG9uZGluZyBoZXggdHJpcGxldC5cbiAgICBmdW5jdGlvbiBudW0yaGV4KHRyaXBsZXQpIHtcbiAgICAgICAgdmFyIGhleF9hbHBoYWJldHMgPSBcIjAxMjM0NTY3ODlBQkNERUZcIjtcbiAgICAgICAgdmFyIGhleCA9IFwiI1wiO1xuICAgICAgICB2YXIgaW50MSwgaW50MjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgIGludDEgPSB0cmlwbGV0W2ldIC8gMTY7XG4gICAgICAgICAgICBpbnQyID0gdHJpcGxldFtpXSAlIDE2O1xuXG4gICAgICAgICAgICBoZXggKz0gaGV4X2FscGhhYmV0cy5jaGFyQXQoaW50MSkgKyBoZXhfYWxwaGFiZXRzLmNoYXJBdChpbnQyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4O1xuICAgIH1cblxuICAgIExpdGVHcmFwaC5udW0yaGV4ID0gbnVtMmhleDtcblxuICAgIC8qIExpdGVHcmFwaCBHVUkgZWxlbWVudHMgdXNlZCBmb3IgY2FudmFzIGVkaXRpbmcgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIENvbnRleHRNZW51IGZyb20gTGl0ZUdVSVxuICAgICAqXG4gICAgICogQGNsYXNzIENvbnRleHRNZW51XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIChhbGxvd3Mgb2JqZWN0IHsgdGl0bGU6IFwiTmljZSB0ZXh0XCIsIGNhbGxiYWNrOiBmdW5jdGlvbiAuLi4gfSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBbb3B0aW9uYWxdIFNvbWUgb3B0aW9uczpcXFxuICAgICAqIC0gdGl0bGU6IHRpdGxlIHRvIHNob3cgb24gdG9wIG9mIHRoZSBtZW51XG4gICAgICogLSBjYWxsYmFjazogZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGFuIG9wdGlvbiBpcyBjbGlja2VkLCBpdCByZWNlaXZlcyB0aGUgaXRlbSBpbmZvcm1hdGlvblxuICAgICAqIC0gaWdub3JlX2l0ZW1fY2FsbGJhY2tzOiBpZ25vcmVzIHRoZSBjYWxsYmFjayBpbnNpZGUgdGhlIGl0ZW0sIGl0IGp1c3QgY2FsbHMgdGhlIG9wdGlvbnMuY2FsbGJhY2tcbiAgICAgKiAtIGV2ZW50OiB5b3UgY2FuIHBhc3MgYSBNb3VzZUV2ZW50LCB0aGlzIHdheSB0aGUgQ29udGV4dE1lbnUgYXBwZWFycyBpbiB0aGF0IHBvc2l0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29udGV4dE1lbnUodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgLy90byBsaW5rIGEgbWVudSB3aXRoIGl0cyBwYXJlbnRcbiAgICAgICAgaWYgKG9wdGlvbnMucGFyZW50TWVudSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFyZW50TWVudS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwicGFyZW50TWVudSBtdXN0IGJlIG9mIGNsYXNzIENvbnRleHRNZW51LCBpZ25vcmluZyBpdFwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmVudE1lbnUgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE1lbnUgPSBvcHRpb25zLnBhcmVudE1lbnU7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRNZW51LmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50TWVudS5jdXJyZW50X3N1Ym1lbnUgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblx0XHR2YXIgZXZlbnRDbGFzcyA9IG51bGw7XG5cdFx0aWYob3B0aW9ucy5ldmVudCkgLy91c2Ugc3RyaW5ncyBiZWNhdXNlIGNvbXBhcmluZyBjbGFzc2VzIGJldHdlZW4gd2luZG93cyBkb2VzbnQgd29ya1xuXHRcdFx0ZXZlbnRDbGFzcyA9IG9wdGlvbnMuZXZlbnQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgaWYgKCBldmVudENsYXNzICE9PSBcIk1vdXNlRXZlbnRcIiAmJlxuICAgICAgICAgICAgZXZlbnRDbGFzcyAhPT0gXCJDdXN0b21FdmVudFwiICYmXG5cdFx0XHRldmVudENsYXNzICE9PSBcIlBvaW50ZXJFdmVudFwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkV2ZW50IHBhc3NlZCB0byBDb250ZXh0TWVudSBpcyBub3Qgb2YgdHlwZSBNb3VzZUV2ZW50IG9yIEN1c3RvbUV2ZW50LiBJZ25vcmluZyBpdC4gKFwiK2V2ZW50Q2xhc3MrXCIpXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvcHRpb25zLmV2ZW50ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgcm9vdC5jbGFzc05hbWUgPSBcImxpdGVncmFwaCBsaXRlY29udGV4dG1lbnUgbGl0ZW1lbnViYXItcGFuZWxcIjtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByb290LmNsYXNzTmFtZSArPSBcIiBcIiArIG9wdGlvbnMuY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJvb3Quc3R5bGUubWluV2lkdGggPSAxMDA7XG4gICAgICAgIHJvb3Quc3R5bGUubWluSGVpZ2h0ID0gMTAwO1xuICAgICAgICByb290LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJvb3Quc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgICAgICB9LCAxMDApOyAvL2RlbGF5IHNvIHRoZSBtb3VzZSB1cCBldmVudCBpcyBub3QgY2F1Z2h0IGJ5IHRoaXMgZWxlbWVudFxuXG4gICAgICAgIC8vdGhpcyBwcmV2ZW50cyB0aGUgZGVmYXVsdCBjb250ZXh0IGJyb3dzZXIgbWVudSB0byBvcGVuIGluIGNhc2UgdGhpcyBtZW51IHdhcyBjcmVhdGVkIHdoZW4gcHJlc3NpbmcgcmlnaHQgYnV0dG9uXG5cdFx0TGl0ZUdyYXBoLnBvaW50ZXJMaXN0ZW5lckFkZChyb290LFwidXBcIixcbiAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcblx0XHRcdCAgXHQvL2NvbnNvbGUubG9nKFwicG9pbnRlcmV2ZW50czogQ29udGV4dE1lbnUgdXAgcm9vdCBwcmV2ZW50XCIpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwiY29udGV4dG1lbnVcIixcbiAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gIT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvL3JpZ2h0IGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuXG4gICAgICAgIExpdGVHcmFwaC5wb2ludGVyTGlzdGVuZXJBZGQocm9vdCxcImRvd25cIixcbiAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcblx0XHRcdCAgXHQvL2NvbnNvbGUubG9nKFwicG9pbnRlcmV2ZW50czogQ29udGV4dE1lbnUgZG93blwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gPT0gMikge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcblxuICAgICAgICBmdW5jdGlvbiBvbl9tb3VzZV93aGVlbChlKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gcGFyc2VJbnQocm9vdC5zdHlsZS50b3ApO1xuICAgICAgICAgICAgcm9vdC5zdHlsZS50b3AgPVxuICAgICAgICAgICAgICAgIChwb3MgKyBlLmRlbHRhWSAqIG9wdGlvbnMuc2Nyb2xsX3NwZWVkKS50b0ZpeGVkKCkgKyBcInB4XCI7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5zY3JvbGxfc3BlZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2Nyb2xsX3NwZWVkID0gMC4xO1xuICAgICAgICB9XG5cbiAgICAgICAgcm9vdC5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgb25fbW91c2Vfd2hlZWwsIHRydWUpO1xuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXdoZWVsXCIsIG9uX21vdXNlX3doZWVsLCB0cnVlKTtcblxuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuXG4gICAgICAgIC8vdGl0bGVcbiAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gXCJsaXRlbWVudS10aXRsZVwiO1xuICAgICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBvcHRpb25zLnRpdGxlO1xuICAgICAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZW50cmllc1xuICAgICAgICB2YXIgbnVtID0gMDtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHZhbHVlcy5jb25zdHJ1Y3RvciA9PSBBcnJheSA/IHZhbHVlc1tpXSA6IGk7XG4gICAgICAgICAgICBpZiAobmFtZSAhPSBudWxsICYmIG5hbWUuY29uc3RydWN0b3IgIT09IFN0cmluZykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLmNvbnRlbnQgPT09IHVuZGVmaW5lZCA/IFN0cmluZyhuYW1lKSA6IG5hbWUuY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIHRoaXMuYWRkSXRlbShuYW1lLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBudW0rKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2xvc2Ugb24gbGVhdmU/IHRvdWNoIGVuYWJsZWQgZGV2aWNlcyB3b24ndCB3b3JrIFRPRE8gdXNlIGEgZ2xvYmFsIGRldmljZSBkZXRlY3RvciBhbmQgY29uZGl0aW9uIG9uIHRoYXRcbiAgICAgICAgLypMaXRlR3JhcGgucG9pbnRlckxpc3RlbmVyQWRkKHJvb3QsXCJsZWF2ZVwiLCBmdW5jdGlvbihlKSB7XG5cdFx0ICBcdGNvbnNvbGUubG9nKFwicG9pbnRlcmV2ZW50czogQ29udGV4dE1lbnUgbGVhdmVcIik7XG4gICAgICAgICAgICBpZiAodGhhdC5sb2NrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3QuY2xvc2luZ190aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyb290LmNsb3NpbmdfdGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm9vdC5jbG9zaW5nX3RpbWVyID0gc2V0VGltZW91dCh0aGF0LmNsb3NlLmJpbmQodGhhdCwgZSksIDUwMCk7XG4gICAgICAgICAgICAvL3RoYXQuY2xvc2UoZSk7XG4gICAgICAgIH0pOyovXG5cblx0XHRMaXRlR3JhcGgucG9pbnRlckxpc3RlbmVyQWRkKHJvb3QsXCJlbnRlclwiLCBmdW5jdGlvbihlKSB7XG5cdFx0ICBcdC8vY29uc29sZS5sb2coXCJwb2ludGVyZXZlbnRzOiBDb250ZXh0TWVudSBlbnRlclwiKTtcbiAgICAgICAgICAgIGlmIChyb290LmNsb3NpbmdfdGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocm9vdC5jbG9zaW5nX3RpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9pbnNlcnQgYmVmb3JlIGNoZWNraW5nIHBvc2l0aW9uXG4gICAgICAgIHZhciByb290X2RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIGlmIChvcHRpb25zLmV2ZW50KSB7XG4gICAgICAgICAgICByb290X2RvY3VtZW50ID0gb3B0aW9ucy5ldmVudC50YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcm9vdF9kb2N1bWVudCkge1xuICAgICAgICAgICAgcm9vdF9kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB9XG5cblx0XHRpZiggcm9vdF9kb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCApXG5cdCAgICAgICAgcm9vdF9kb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudC5hcHBlbmRDaGlsZChyb290KTtcblx0XHRlbHNlXG5cdFx0ICAgIHJvb3RfZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyb290KTtcblxuICAgICAgICAvL2NvbXB1dGUgYmVzdCBwb3NpdGlvblxuICAgICAgICB2YXIgbGVmdCA9IG9wdGlvbnMubGVmdCB8fCAwO1xuICAgICAgICB2YXIgdG9wID0gb3B0aW9ucy50b3AgfHwgMDtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXZlbnQpIHtcbiAgICAgICAgICAgIGxlZnQgPSBvcHRpb25zLmV2ZW50LmNsaWVudFggLSAxMDtcbiAgICAgICAgICAgIHRvcCA9IG9wdGlvbnMuZXZlbnQuY2xpZW50WSAtIDEwO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUpIHtcbiAgICAgICAgICAgICAgICB0b3AgLT0gMjA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcmVudE1lbnUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IG9wdGlvbnMucGFyZW50TWVudS5yb290LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSByZWN0LmxlZnQgKyByZWN0LndpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYm9keV9yZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciByb290X3JlY3QgPSByb290LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0aWYoYm9keV9yZWN0LmhlaWdodCA9PSAwKVxuXHRcdFx0XHRjb25zb2xlLmVycm9yKFwiZG9jdW1lbnQuYm9keSBoZWlnaHQgaXMgMC4gVGhhdCBpcyBkYW5nZXJvdXMsIHNldCBodG1sLGJvZHkgeyBoZWlnaHQ6IDEwMCU7IH1cIik7XG5cbiAgICAgICAgICAgIGlmIChib2R5X3JlY3Qud2lkdGggJiYgbGVmdCA+IGJvZHlfcmVjdC53aWR0aCAtIHJvb3RfcmVjdC53aWR0aCAtIDEwKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGJvZHlfcmVjdC53aWR0aCAtIHJvb3RfcmVjdC53aWR0aCAtIDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJvZHlfcmVjdC5oZWlnaHQgJiYgdG9wID4gYm9keV9yZWN0LmhlaWdodCAtIHJvb3RfcmVjdC5oZWlnaHQgLSAxMCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IGJvZHlfcmVjdC5oZWlnaHQgLSByb290X3JlY3QuaGVpZ2h0IC0gMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByb290LnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICByb290LnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcblxuICAgICAgICBpZiAob3B0aW9ucy5zY2FsZSkge1xuICAgICAgICAgICAgcm9vdC5zdHlsZS50cmFuc2Zvcm0gPSBcInNjYWxlKFwiICsgb3B0aW9ucy5zY2FsZSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQ29udGV4dE1lbnUucHJvdG90eXBlLmFkZEl0ZW0gPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBcImxpdGVtZW51LWVudHJ5IHN1Ym1lbnVcIjtcblxuICAgICAgICB2YXIgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInNlcGFyYXRvclwiKTtcbiAgICAgICAgICAgIC8vZWxlbWVudC5pbm5lckhUTUwgPSBcIjxoci8+XCJcbiAgICAgICAgICAgIC8vY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IHZhbHVlICYmIHZhbHVlLnRpdGxlID8gdmFsdWUudGl0bGUgOiBuYW1lO1xuICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnN1Ym1lbnUgfHwgdmFsdWUuaGFzX3N1Ym1lbnUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaGFzX3N1Ym1lbnVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZGF0YXNldFtcInZhbHVlXCJdID0gbmFtZTtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9uY2xpY2tfY2FsbGJhY2sgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5kYXRhc2V0W1widmFsdWVcIl0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IFwiIFwiICsgdmFsdWUuY2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yb290LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBpbm5lcl9vbmNsaWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRpc2FibGVkICYmIG9wdGlvbnMuYXV0b29wZW4pIHtcblx0XHRcdExpdGVHcmFwaC5wb2ludGVyTGlzdGVuZXJBZGQoZWxlbWVudCxcImVudGVyXCIsaW5uZXJfb3Zlcik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbm5lcl9vdmVyKGUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICBpZiAoIXZhbHVlIHx8ICF2YWx1ZS5oYXNfc3VibWVudSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaWYgaXQgaXMgYSBzdWJtZW51LCBhdXRvb3BlbiBsaWtlIHRoZSBpdGVtIHdhcyBjbGlja2VkXG4gICAgICAgICAgICBpbm5lcl9vbmNsaWNrLmNhbGwodGhpcywgZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL21lbnUgb3B0aW9uIGNsaWNrZWRcbiAgICAgICAgZnVuY3Rpb24gaW5uZXJfb25jbGljayhlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGNsb3NlX3BhcmVudCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICh0aGF0LmN1cnJlbnRfc3VibWVudSkge1xuICAgICAgICAgICAgICAgIHRoYXQuY3VycmVudF9zdWJtZW51LmNsb3NlKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2dsb2JhbCBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IG9wdGlvbnMuY2FsbGJhY2suY2FsbChcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubm9kZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKHIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VfcGFyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3NwZWNpYWwgY2FzZXNcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgICAgICAgIW9wdGlvbnMuaWdub3JlX2l0ZW1fY2FsbGJhY2tzICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmRpc2FibGVkICE9PSB0cnVlXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vaXRlbSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHZhbHVlLmNhbGxiYWNrLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmV4dHJhXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZV9wYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuc3VibWVudSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLnN1Ym1lbnUub3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJDb250ZXh0TWVudSBzdWJtZW51IG5lZWRzIG9wdGlvbnNcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgc3VibWVudSA9IG5ldyB0aGF0LmNvbnN0cnVjdG9yKHZhbHVlLnN1Ym1lbnUub3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHZhbHVlLnN1Ym1lbnUuY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE1lbnU6IHRoYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVfaXRlbV9jYWxsYmFja3M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc3VibWVudS5pZ25vcmVfaXRlbV9jYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdmFsdWUuc3VibWVudS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiB2YWx1ZS5zdWJtZW51LmV4dHJhLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b29wZW46IG9wdGlvbnMuYXV0b29wZW5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlX3BhcmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNsb3NlX3BhcmVudCAmJiAhdGhhdC5sb2NrKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcblxuICAgIENvbnRleHRNZW51LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKGUsIGlnbm9yZV9wYXJlbnRfbWVudSkge1xuICAgICAgICBpZiAodGhpcy5yb290LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50TWVudSAmJiAhaWdub3JlX3BhcmVudF9tZW51KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudE1lbnUubG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRNZW51LmN1cnJlbnRfc3VibWVudSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRNZW51LmNsb3NlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIGUgJiZcbiAgICAgICAgICAgICAgICAhQ29udGV4dE1lbnUuaXNDdXJzb3JPdmVyRWxlbWVudChlLCB0aGlzLnBhcmVudE1lbnUucm9vdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIENvbnRleHRNZW51LnRyaWdnZXIodGhpcy5wYXJlbnRNZW51LnJvb3QsIExpdGVHcmFwaC5wb2ludGVyZXZlbnRzX21ldGhvZCtcImxlYXZlXCIsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRfc3VibWVudSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50X3N1Ym1lbnUuY2xvc2UoZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5yb290LmNsb3NpbmdfdGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJvb3QuY2xvc2luZ190aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFRPRE8gaW1wbGVtZW50IDogTGl0ZUdyYXBoLmNvbnRleHRNZW51Q2xvc2VkKCk7IDo6IGtlZXAgdHJhY2sgb2Ygb3BlbmVkIC8gY2xvc2VkIC8gY3VycmVudCBDb250ZXh0TWVudVxuICAgICAgICAvLyBvbiBrZXkgcHJlc3MsIGFsbG93IGZpbHRlcmluZy9zZWxlY3RpbmcgdGhlIGNvbnRleHQgbWVudSBlbGVtZW50c1xuICAgIH07XG5cbiAgICAvL3RoaXMgY29kZSBpcyB1c2VkIHRvIHRyaWdnZXIgZXZlbnRzIGVhc2lseSAodXNlZCBpbiB0aGUgY29udGV4dCBtZW51IG1vdXNlbGVhdmVcbiAgICBDb250ZXh0TWVudS50cmlnZ2VyID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnRfbmFtZSwgcGFyYW1zLCBvcmlnaW4pIHtcbiAgICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnRfbmFtZSwgdHJ1ZSwgdHJ1ZSwgcGFyYW1zKTsgLy9jYW5CdWJibGUsIGNhbmNlbGFibGUsIGRldGFpbFxuICAgICAgICBldnQuc3JjRWxlbWVudCA9IG9yaWdpbjtcbiAgICAgICAgaWYgKGVsZW1lbnQuZGlzcGF0Y2hFdmVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5fX2V2ZW50cykge1xuICAgICAgICAgICAgZWxlbWVudC5fX2V2ZW50cy5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9lbHNlIG5vdGhpbmcgc2VlbXMgYmluZGVkIGhlcmUgc28gbm90aGluZyB0byBkb1xuICAgICAgICByZXR1cm4gZXZ0O1xuICAgIH07XG5cbiAgICAvL3JldHVybnMgdGhlIHRvcCBtb3N0IG1lbnVcbiAgICBDb250ZXh0TWVudS5wcm90b3R5cGUuZ2V0VG9wTWVudSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmVudE1lbnUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucGFyZW50TWVudS5nZXRUb3BNZW51KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIENvbnRleHRNZW51LnByb3RvdHlwZS5nZXRGaXJzdEV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFyZW50TWVudSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wYXJlbnRNZW51LmdldEZpcnN0RXZlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmV2ZW50O1xuICAgIH07XG5cbiAgICBDb250ZXh0TWVudS5pc0N1cnNvck92ZXJFbGVtZW50ID0gZnVuY3Rpb24oZXZlbnQsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBldmVudC5jbGllbnRYO1xuICAgICAgICB2YXIgdG9wID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0b3AgPiByZWN0LnRvcCAmJlxuICAgICAgICAgICAgdG9wIDwgcmVjdC50b3AgKyByZWN0LmhlaWdodCAmJlxuICAgICAgICAgICAgbGVmdCA+IHJlY3QubGVmdCAmJlxuICAgICAgICAgICAgbGVmdCA8IHJlY3QubGVmdCArIHJlY3Qud2lkdGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5Db250ZXh0TWVudSA9IENvbnRleHRNZW51O1xuXG4gICAgTGl0ZUdyYXBoLmNsb3NlQWxsQ29udGV4dE1lbnVzID0gZnVuY3Rpb24ocmVmX3dpbmRvdykge1xuICAgICAgICByZWZfd2luZG93ID0gcmVmX3dpbmRvdyB8fCB3aW5kb3c7XG5cbiAgICAgICAgdmFyIGVsZW1lbnRzID0gcmVmX3dpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmxpdGVjb250ZXh0bWVudVwiKTtcbiAgICAgICAgaWYgKCFlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0W2ldLmNsb3NlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldLmNsb3NlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdFtpXS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocmVzdWx0W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMaXRlR3JhcGguZXh0ZW5kQ2xhc3MgPSBmdW5jdGlvbih0YXJnZXQsIG9yaWdpbikge1xuICAgICAgICBmb3IgKHZhciBpIGluIG9yaWdpbikge1xuICAgICAgICAgICAgLy9jb3B5IGNsYXNzIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGlmICh0YXJnZXQuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFtpXSA9IG9yaWdpbltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcmlnaW4ucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAvL2NvcHkgcHJvdG90eXBlIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gb3JpZ2luLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vb25seSBlbnVtZXJhYmxlXG4gICAgICAgICAgICAgICAgaWYgKCFvcmlnaW4ucHJvdG90eXBlLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQucHJvdG90eXBlLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vYXZvaWQgb3ZlcndyaXRpbmcgZXhpc3Rpbmcgb25lc1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2NvcHkgZ2V0dGVyc1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW4ucHJvdG90eXBlLl9fbG9va3VwR2V0dGVyX18oaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKFxuICAgICAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbi5wcm90b3R5cGUuX19sb29rdXBHZXR0ZXJfXyhpKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wcm90b3R5cGVbaV0gPSBvcmlnaW4ucHJvdG90eXBlW2ldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vYW5kIHNldHRlcnNcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luLnByb3RvdHlwZS5fX2xvb2t1cFNldHRlcl9fKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4ucHJvdG90eXBlLl9fbG9va3VwU2V0dGVyX18oaSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG5cdC8vdXNlZCBieSBzb21lIHdpZGdldHMgdG8gcmVuZGVyIGEgY3VydmUgZWRpdG9yXG5cdGZ1bmN0aW9uIEN1cnZlRWRpdG9yKCBwb2ludHMgKVxuXHR7XG5cdFx0dGhpcy5wb2ludHMgPSBwb2ludHM7XG5cdFx0dGhpcy5zZWxlY3RlZCA9IC0xO1xuXHRcdHRoaXMubmVhcmVzdCA9IC0xO1xuXHRcdHRoaXMuc2l6ZSA9IG51bGw7IC8vc3RvcmVzIGxhc3Qgc2l6ZSB1c2VkXG5cdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5tYXJnaW4gPSA1O1xuXHR9XG5cblx0Q3VydmVFZGl0b3Iuc2FtcGxlQ3VydmUgPSBmdW5jdGlvbihmLHBvaW50cylcblx0e1xuXHRcdGlmKCFwb2ludHMpXG5cdFx0XHRyZXR1cm47XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyArK2kpXG5cdFx0e1xuXHRcdFx0dmFyIHAgPSBwb2ludHNbaV07XG5cdFx0XHR2YXIgcG4gPSBwb2ludHNbaSsxXTtcblx0XHRcdGlmKHBuWzBdIDwgZilcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR2YXIgciA9IChwblswXSAtIHBbMF0pO1xuXHRcdFx0aWYoIE1hdGguYWJzKHIpIDwgMC4wMDAwMSApXG5cdFx0XHRcdHJldHVybiBwWzFdO1xuXHRcdFx0dmFyIGxvY2FsX2YgPSAoZiAtIHBbMF0pIC8gcjtcblx0XHRcdHJldHVybiBwWzFdICogKDEuMCAtIGxvY2FsX2YpICsgcG5bMV0gKiBsb2NhbF9mO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdEN1cnZlRWRpdG9yLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oIGN0eCwgc2l6ZSwgZ3JhcGhjYW52YXMsIGJhY2tncm91bmRfY29sb3IsIGxpbmVfY29sb3IsIGluYWN0aXZlIClcblx0e1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRpZighcG9pbnRzKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMuc2l6ZSA9IHNpemU7XG5cdFx0dmFyIHcgPSBzaXplWzBdIC0gdGhpcy5tYXJnaW4gKiAyO1xuXHRcdHZhciBoID0gc2l6ZVsxXSAtIHRoaXMubWFyZ2luICogMjtcblxuXHRcdGxpbmVfY29sb3IgPSBsaW5lX2NvbG9yIHx8IFwiIzY2NlwiO1xuXG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHgudHJhbnNsYXRlKHRoaXMubWFyZ2luLHRoaXMubWFyZ2luKTtcblxuXHRcdGlmKGJhY2tncm91bmRfY29sb3IpXG5cdFx0e1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IFwiIzExMVwiO1xuXHRcdFx0Y3R4LmZpbGxSZWN0KDAsMCx3LGgpO1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IFwiIzIyMlwiO1xuXHRcdFx0Y3R4LmZpbGxSZWN0KHcqMC41LDAsMSxoKTtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IFwiIzMzM1wiO1xuXHRcdFx0Y3R4LnN0cm9rZVJlY3QoMCwwLHcsaCk7XG5cdFx0fVxuXHRcdGN0eC5zdHJva2VTdHlsZSA9IGxpbmVfY29sb3I7XG5cdFx0aWYoaW5hY3RpdmUpXG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSAwLjU7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpXG5cdFx0e1xuXHRcdFx0dmFyIHAgPSBwb2ludHNbaV07XG5cdFx0XHRjdHgubGluZVRvKCBwWzBdICogdywgKDEuMCAtIHBbMV0pICogaCApO1xuXHRcdH1cblx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0Y3R4Lmdsb2JhbEFscGhhID0gMTtcblx0XHRpZighaW5hY3RpdmUpXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgcCA9IHBvaW50c1tpXTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRoaXMuc2VsZWN0ZWQgPT0gaSA/IFwiI0ZGRlwiIDogKHRoaXMubmVhcmVzdCA9PSBpID8gXCIjREREXCIgOiBcIiNBQUFcIik7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4LmFyYyggcFswXSAqIHcsICgxLjAgLSBwWzFdKSAqIGgsIDIsIDAsIE1hdGguUEkgKiAyICk7XG5cdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHR9XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fVxuXG5cdC8vbG9jYWxwb3MgaXMgbW91c2UgaW4gY3VydmUgZWRpdG9yIHNwYWNlXG5cdEN1cnZlRWRpdG9yLnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKCBsb2NhbHBvcywgZ3JhcGhjYW52YXMgKVxuXHR7XG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdGlmKCFwb2ludHMpXG5cdFx0XHRyZXR1cm47XG5cdFx0aWYoIGxvY2FscG9zWzFdIDwgMCApXG5cdFx0XHRyZXR1cm47XG5cblx0XHQvL3RoaXMuY2FwdHVyZUlucHV0KHRydWUpO1xuXHRcdHZhciB3ID0gdGhpcy5zaXplWzBdIC0gdGhpcy5tYXJnaW4gKiAyO1xuXHRcdHZhciBoID0gdGhpcy5zaXplWzFdIC0gdGhpcy5tYXJnaW4gKiAyO1xuXHRcdHZhciB4ID0gbG9jYWxwb3NbMF0gLSB0aGlzLm1hcmdpbjtcblx0XHR2YXIgeSA9IGxvY2FscG9zWzFdIC0gdGhpcy5tYXJnaW47XG5cdFx0dmFyIHBvcyA9IFt4LHldO1xuXHRcdHZhciBtYXhfZGlzdCA9IDMwIC8gZ3JhcGhjYW52YXMuZHMuc2NhbGU7XG5cdFx0Ly9zZWFyY2ggY2xvc2VyIG9uZVxuXHRcdHRoaXMuc2VsZWN0ZWQgPSB0aGlzLmdldENsb3NlclBvaW50KHBvcywgbWF4X2Rpc3QpO1xuXHRcdC8vY3JlYXRlIG9uZVxuXHRcdGlmKHRoaXMuc2VsZWN0ZWQgPT0gLTEpXG5cdFx0e1xuXHRcdFx0dmFyIHBvaW50ID0gW3ggLyB3LCAxIC0geSAvIGhdO1xuXHRcdFx0cG9pbnRzLnB1c2gocG9pbnQpO1xuXHRcdFx0cG9pbnRzLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGFbMF0gLSBiWzBdOyB9KTtcblx0XHRcdHRoaXMuc2VsZWN0ZWQgPSBwb2ludHMuaW5kZXhPZihwb2ludCk7XG5cdFx0XHR0aGlzLm11c3RfdXBkYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0aWYodGhpcy5zZWxlY3RlZCAhPSAtMSlcblx0XHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Q3VydmVFZGl0b3IucHJvdG90eXBlLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24oIGxvY2FscG9zLCBncmFwaGNhbnZhcyApXG5cdHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdFx0aWYoIXBvaW50cylcblx0XHRcdHJldHVybjtcblx0XHR2YXIgcyA9IHRoaXMuc2VsZWN0ZWQ7XG5cdFx0aWYocyA8IDApXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIHggPSAobG9jYWxwb3NbMF0gLSB0aGlzLm1hcmdpbikgLyAodGhpcy5zaXplWzBdIC0gdGhpcy5tYXJnaW4gKiAyICk7XG5cdFx0dmFyIHkgPSAobG9jYWxwb3NbMV0gLSB0aGlzLm1hcmdpbikgLyAodGhpcy5zaXplWzFdIC0gdGhpcy5tYXJnaW4gKiAyICk7XG5cdFx0dmFyIGN1cnZlcG9zID0gWyhsb2NhbHBvc1swXSAtIHRoaXMubWFyZ2luKSwobG9jYWxwb3NbMV0gLSB0aGlzLm1hcmdpbildO1xuXHRcdHZhciBtYXhfZGlzdCA9IDMwIC8gZ3JhcGhjYW52YXMuZHMuc2NhbGU7XG5cdFx0dGhpcy5fbmVhcmVzdCA9IHRoaXMuZ2V0Q2xvc2VyUG9pbnQoY3VydmVwb3MsIG1heF9kaXN0KTtcblx0XHR2YXIgcG9pbnQgPSBwb2ludHNbc107XG5cdFx0aWYocG9pbnQpXG5cdFx0e1xuXHRcdFx0dmFyIGlzX2VkZ2VfcG9pbnQgPSBzID09IDAgfHwgcyA9PSBwb2ludHMubGVuZ3RoIC0gMTtcblx0XHRcdGlmKCAhaXNfZWRnZV9wb2ludCAmJiAobG9jYWxwb3NbMF0gPCAtMTAgfHwgbG9jYWxwb3NbMF0gPiB0aGlzLnNpemVbMF0gKyAxMCB8fCBsb2NhbHBvc1sxXSA8IC0xMCB8fCBsb2NhbHBvc1sxXSA+IHRoaXMuc2l6ZVsxXSArIDEwKSApXG5cdFx0XHR7XG5cdFx0XHRcdHBvaW50cy5zcGxpY2UocywxKTtcblx0XHRcdFx0dGhpcy5zZWxlY3RlZCA9IC0xO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiggIWlzX2VkZ2VfcG9pbnQgKSAvL25vdCBlZGdlc1xuXHRcdFx0XHRwb2ludFswXSA9IGNsYW1wKHgsIDAsIDEpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRwb2ludFswXSA9IHMgPT0gMCA/IDAgOiAxO1xuXHRcdFx0cG9pbnRbMV0gPSAxLjAgLSBjbGFtcCh5LCAwLCAxKTtcblx0XHRcdHBvaW50cy5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiBhWzBdIC0gYlswXTsgfSk7XG5cdFx0XHR0aGlzLnNlbGVjdGVkID0gcG9pbnRzLmluZGV4T2YocG9pbnQpO1xuXHRcdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0Q3VydmVFZGl0b3IucHJvdG90eXBlLm9uTW91c2VVcCA9IGZ1bmN0aW9uKCBsb2NhbHBvcywgZ3JhcGhjYW52YXMgKVxuXHR7XG5cdFx0dGhpcy5zZWxlY3RlZCA9IC0xO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdEN1cnZlRWRpdG9yLnByb3RvdHlwZS5nZXRDbG9zZXJQb2ludCA9IGZ1bmN0aW9uKHBvcywgbWF4X2Rpc3QpXG5cdHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdFx0aWYoIXBvaW50cylcblx0XHRcdHJldHVybiAtMTtcblx0XHRtYXhfZGlzdCA9IG1heF9kaXN0IHx8IDMwO1xuXHRcdHZhciB3ID0gKHRoaXMuc2l6ZVswXSAtIHRoaXMubWFyZ2luICogMik7XG5cdFx0dmFyIGggPSAodGhpcy5zaXplWzFdIC0gdGhpcy5tYXJnaW4gKiAyKTtcblx0XHR2YXIgbnVtID0gcG9pbnRzLmxlbmd0aDtcblx0XHR2YXIgcDIgPSBbMCwwXTtcblx0XHR2YXIgbWluX2Rpc3QgPSAxMDAwMDAwO1xuXHRcdHZhciBjbG9zZXN0ID0gLTE7XG5cdFx0dmFyIGxhc3RfdmFsaWQgPSAtMTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbnVtOyArK2kpXG5cdFx0e1xuXHRcdFx0dmFyIHAgPSBwb2ludHNbaV07XG5cdFx0XHRwMlswXSA9IHBbMF0gKiB3O1xuXHRcdFx0cDJbMV0gPSAoMS4wIC0gcFsxXSkgKiBoO1xuXHRcdFx0aWYocDJbMF0gPCBwb3NbMF0pXG5cdFx0XHRcdGxhc3RfdmFsaWQgPSBpO1xuXHRcdFx0dmFyIGRpc3QgPSB2ZWMyLmRpc3RhbmNlKHBvcyxwMik7XG5cdFx0XHRpZihkaXN0ID4gbWluX2Rpc3QgfHwgZGlzdCA+IG1heF9kaXN0KVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdGNsb3Nlc3QgPSBpO1xuXHRcdFx0bWluX2Rpc3QgPSBkaXN0O1xuXHRcdH1cblx0XHRyZXR1cm4gY2xvc2VzdDtcblx0fVxuXG5cdExpdGVHcmFwaC5DdXJ2ZUVkaXRvciA9IEN1cnZlRWRpdG9yO1xuXG4gICAgLy91c2VkIHRvIGNyZWF0ZSBub2RlcyBmcm9tIHdyYXBwaW5nIGZ1bmN0aW9uc1xuICAgIExpdGVHcmFwaC5nZXRQYXJhbWV0ZXJOYW1lcyA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jICsgXCJcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bL11bL10uKiQvZ20sIFwiXCIpIC8vIHN0cmlwIHNpbmdsZS1saW5lIGNvbW1lbnRzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCBcIlwiKSAvLyBzdHJpcCB3aGl0ZSBzcGFjZVxuICAgICAgICAgICAgLnJlcGxhY2UoL1svXVsqXVteLypdKlsqXVsvXS9nLCBcIlwiKSAvLyBzdHJpcCBtdWx0aS1saW5lIGNvbW1lbnRzICAvKiovXG4gICAgICAgICAgICAuc3BsaXQoXCIpe1wiLCAxKVswXVxuICAgICAgICAgICAgLnJlcGxhY2UoL15bXihdKlsoXS8sIFwiXCIpIC8vIGV4dHJhY3QgdGhlIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIC5yZXBsYWNlKC89W14sXSsvZywgXCJcIikgLy8gc3RyaXAgYW55IEVTNiBkZWZhdWx0c1xuICAgICAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKTsgLy8gc3BsaXQgJiBmaWx0ZXIgW1wiXCJdXG4gICAgfTtcblxuXHQvKiBoZWxwZXIgZm9yIGludGVyYWN0aW9uOiBwb2ludGVyLCB0b3VjaCwgbW91c2UgTGlzdGVuZXJzXG5cdHVzZWQgYnkgTEdyYXBoQ2FudmFzIERyYWdBbmRTY2FsZSBDb250ZXh0TWVudSovXG5cdExpdGVHcmFwaC5wb2ludGVyTGlzdGVuZXJBZGQgPSBmdW5jdGlvbihvRE9NLCBzRXZJbiwgZkNhbGwsIGNhcHR1cmU9ZmFsc2UpIHtcblx0XHRpZiAoIW9ET00gfHwgIW9ET00uYWRkRXZlbnRMaXN0ZW5lciB8fCAhc0V2SW4gfHwgdHlwZW9mIGZDYWxsIT09XCJmdW5jdGlvblwiKXtcblx0XHRcdC8vY29uc29sZS5sb2coXCJjYW50IHBvaW50ZXJMaXN0ZW5lckFkZCBcIitvRE9NK1wiLCBcIitzRXZlbnQrXCIsIFwiK2ZDYWxsKTtcblx0XHRcdHJldHVybjsgLy8gLS0gYnJlYWsgLS1cblx0XHR9XG5cdFx0XG5cdFx0dmFyIHNNZXRob2QgPSBMaXRlR3JhcGgucG9pbnRlcmV2ZW50c19tZXRob2Q7XG5cdFx0dmFyIHNFdmVudCA9IHNFdkluO1xuXHRcdFxuXHRcdC8vIFVOREVSIENPTlNUUlVDVElPTlxuXHRcdC8vIGNvbnZlcnQgcG9pbnRlcmV2ZW50cyB0byB0b3VjaCBldmVudCB3aGVuIG5vdCBhdmFpbGFibGVcblx0XHRpZiAoc01ldGhvZD09XCJwb2ludGVyXCIgJiYgIXdpbmRvdy5Qb2ludGVyRXZlbnQpeyBcblx0XHRcdGNvbnNvbGUud2FybihcInNNZXRob2Q9PSdwb2ludGVyJyAmJiAhd2luZG93LlBvaW50ZXJFdmVudFwiKTtcblx0XHRcdGNvbnNvbGUubG9nKFwiQ29udmVydGluZyBwb2ludGVyW1wiK3NFdmVudCtcIl0gOiBkb3duIG1vdmUgdXAgY2FuY2VsIGVudGVyIFRPIHRvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kLCBldGMgLi5cIik7XG5cdFx0XHRzd2l0Y2goc0V2ZW50KXtcblx0XHRcdFx0Y2FzZSBcImRvd25cIjp7XG5cdFx0XHRcdFx0c01ldGhvZCA9IFwidG91Y2hcIjtcblx0XHRcdFx0XHRzRXZlbnQgPSBcInN0YXJ0XCI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBcIm1vdmVcIjp7XG5cdFx0XHRcdFx0c01ldGhvZCA9IFwidG91Y2hcIjtcblx0XHRcdFx0XHQvL3NFdmVudCA9IFwibW92ZVwiO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgXCJ1cFwiOntcblx0XHRcdFx0XHRzTWV0aG9kID0gXCJ0b3VjaFwiO1xuXHRcdFx0XHRcdHNFdmVudCA9IFwiZW5kXCI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBcImNhbmNlbFwiOntcblx0XHRcdFx0XHRzTWV0aG9kID0gXCJ0b3VjaFwiO1xuXHRcdFx0XHRcdC8vc0V2ZW50ID0gXCJjYW5jZWxcIjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIFwiZW50ZXJcIjp7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJkZWJ1ZzogU2hvdWxkIEkgc2VuZCBhIG1vdmUgZXZlbnQ/XCIpOyAvLyA/Pz9cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBjYXNlIFwib3ZlclwiOiBjYXNlIFwib3V0XCI6IG5vdCB1c2VkIGF0IG5vd1xuXHRcdFx0XHRkZWZhdWx0Ontcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJQb2ludGVyRXZlbnQgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGJyb3dzZXIgPyBUaGUgZXZlbnQgXCIrc0V2ZW50K1wiIHdvdWxkIG5vdCBiZSBjYWxsZWRcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRzd2l0Y2goc0V2ZW50KXtcblx0XHRcdC8vYm90aCBwb2ludGVyIGFuZCBtb3ZlIGV2ZW50c1xuXHRcdFx0Y2FzZSBcImRvd25cIjogY2FzZSBcInVwXCI6IGNhc2UgXCJtb3ZlXCI6IGNhc2UgXCJvdmVyXCI6IGNhc2UgXCJvdXRcIjogY2FzZSBcImVudGVyXCI6XG5cdFx0XHR7XG5cdFx0XHRcdG9ET00uYWRkRXZlbnRMaXN0ZW5lcihzTWV0aG9kK3NFdmVudCwgZkNhbGwsIGNhcHR1cmUpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gb25seSBwb2ludGVyZXZlbnRzXG5cdFx0XHRjYXNlIFwibGVhdmVcIjogY2FzZSBcImNhbmNlbFwiOiBjYXNlIFwiZ290cG9pbnRlcmNhcHR1cmVcIjogY2FzZSBcImxvc3Rwb2ludGVyY2FwdHVyZVwiOlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoc01ldGhvZCE9XCJtb3VzZVwiKXtcblx0XHRcdFx0XHRyZXR1cm4gb0RPTS5hZGRFdmVudExpc3RlbmVyKHNNZXRob2Qrc0V2ZW50LCBmQ2FsbCwgY2FwdHVyZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIG5vdCBcInBvaW50ZXJcIiB8fCBcIm1vdXNlXCJcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBvRE9NLmFkZEV2ZW50TGlzdGVuZXIoc0V2ZW50LCBmQ2FsbCwgY2FwdHVyZSk7XG5cdFx0fVxuXHR9XG5cdExpdGVHcmFwaC5wb2ludGVyTGlzdGVuZXJSZW1vdmUgPSBmdW5jdGlvbihvRE9NLCBzRXZlbnQsIGZDYWxsLCBjYXB0dXJlPWZhbHNlKSB7XG5cdFx0aWYgKCFvRE9NIHx8ICFvRE9NLnJlbW92ZUV2ZW50TGlzdGVuZXIgfHwgIXNFdmVudCB8fCB0eXBlb2YgZkNhbGwhPT1cImZ1bmN0aW9uXCIpe1xuXHRcdFx0Ly9jb25zb2xlLmxvZyhcImNhbnQgcG9pbnRlckxpc3RlbmVyUmVtb3ZlIFwiK29ET00rXCIsIFwiK3NFdmVudCtcIiwgXCIrZkNhbGwpO1xuXHRcdFx0cmV0dXJuOyAvLyAtLSBicmVhayAtLVxuXHRcdH1cblx0XHRzd2l0Y2goc0V2ZW50KXtcblx0XHRcdC8vYm90aCBwb2ludGVyIGFuZCBtb3ZlIGV2ZW50c1xuXHRcdFx0Y2FzZSBcImRvd25cIjogY2FzZSBcInVwXCI6IGNhc2UgXCJtb3ZlXCI6IGNhc2UgXCJvdmVyXCI6IGNhc2UgXCJvdXRcIjogY2FzZSBcImVudGVyXCI6XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChMaXRlR3JhcGgucG9pbnRlcmV2ZW50c19tZXRob2Q9PVwicG9pbnRlclwiIHx8IExpdGVHcmFwaC5wb2ludGVyZXZlbnRzX21ldGhvZD09XCJtb3VzZVwiKXtcblx0XHRcdFx0XHRvRE9NLnJlbW92ZUV2ZW50TGlzdGVuZXIoTGl0ZUdyYXBoLnBvaW50ZXJldmVudHNfbWV0aG9kK3NFdmVudCwgZkNhbGwsIGNhcHR1cmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBvbmx5IHBvaW50ZXJldmVudHNcblx0XHRcdGNhc2UgXCJsZWF2ZVwiOiBjYXNlIFwiY2FuY2VsXCI6IGNhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOiBjYXNlIFwibG9zdHBvaW50ZXJjYXB0dXJlXCI6XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChMaXRlR3JhcGgucG9pbnRlcmV2ZW50c19tZXRob2Q9PVwicG9pbnRlclwiKXtcblx0XHRcdFx0XHRyZXR1cm4gb0RPTS5yZW1vdmVFdmVudExpc3RlbmVyKExpdGVHcmFwaC5wb2ludGVyZXZlbnRzX21ldGhvZCtzRXZlbnQsIGZDYWxsLCBjYXB0dXJlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gbm90IFwicG9pbnRlclwiIHx8IFwibW91c2VcIlxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIG9ET00ucmVtb3ZlRXZlbnRMaXN0ZW5lcihzRXZlbnQsIGZDYWxsLCBjYXB0dXJlKTtcblx0XHR9XG5cdH1cblxuICAgIGZ1bmN0aW9uIGNsYW1wKHYsIGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPiB2ID8gYSA6IGIgPCB2ID8gYiA6IHY7XG4gICAgfTtcbiAgICBnbG9iYWwuY2xhbXAgPSBjbGFtcDtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgJiYgIXdpbmRvd1tcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiXSkge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgICB9O1xuICAgIH1cbn0pKHRoaXMpO1xuXG5pZiAodHlwZW9mIGV4cG9ydHMgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGV4cG9ydHMuTGl0ZUdyYXBoID0gdGhpcy5MaXRlR3JhcGg7XG4gICAgZXhwb3J0cy5MR3JhcGggPSB0aGlzLkxHcmFwaDtcbiAgICBleHBvcnRzLkxMaW5rID0gdGhpcy5MTGluaztcbiAgICBleHBvcnRzLkxHcmFwaE5vZGUgPSB0aGlzLkxHcmFwaE5vZGU7XG4gICAgZXhwb3J0cy5MR3JhcGhHcm91cCA9IHRoaXMuTEdyYXBoR3JvdXA7XG4gICAgZXhwb3J0cy5EcmFnQW5kU2NhbGUgPSB0aGlzLkRyYWdBbmRTY2FsZTtcbiAgICBleHBvcnRzLkxHcmFwaENhbnZhcyA9IHRoaXMuTEdyYXBoQ2FudmFzO1xuICAgIGV4cG9ydHMuQ29udGV4dE1lbnUgPSB0aGlzLkNvbnRleHRNZW51O1xufVxuXG5cbi8vYmFzaWMgbm9kZXNcclxuKGZ1bmN0aW9uKGdsb2JhbCkge1xyXG4gICAgdmFyIExpdGVHcmFwaCA9IGdsb2JhbC5MaXRlR3JhcGg7XHJcblxyXG4gICAgLy9Db25zdGFudFxyXG4gICAgZnVuY3Rpb24gVGltZSgpIHtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcImluIG1zXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiaW4gc2VjXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIFRpbWUudGl0bGUgPSBcIlRpbWVcIjtcclxuICAgIFRpbWUuZGVzYyA9IFwiVGltZVwiO1xyXG5cclxuICAgIFRpbWUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLmdyYXBoLmdsb2JhbHRpbWUgKiAxMDAwKTtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMSwgdGhpcy5ncmFwaC5nbG9iYWx0aW1lKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy90aW1lXCIsIFRpbWUpO1xyXG5cclxuICAgIC8vU3ViZ3JhcGg6IGEgbm9kZSB0aGF0IGNvbnRhaW5zIGEgZ3JhcGhcclxuICAgIGZ1bmN0aW9uIFN1YmdyYXBoKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGlzLnNpemUgPSBbMTQwLCA4MF07XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBlbmFibGVkOiB0cnVlIH07XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy9jcmVhdGUgaW5uZXIgZ3JhcGhcclxuICAgICAgICB0aGlzLnN1YmdyYXBoID0gbmV3IExpdGVHcmFwaC5MR3JhcGgoKTtcclxuICAgICAgICB0aGlzLnN1YmdyYXBoLl9zdWJncmFwaF9ub2RlID0gdGhpcztcclxuICAgICAgICB0aGlzLnN1YmdyYXBoLl9pc19zdWJncmFwaCA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuc3ViZ3JhcGgub25UcmlnZ2VyID0gdGhpcy5vblN1YmdyYXBoVHJpZ2dlci5iaW5kKHRoaXMpO1xyXG5cclxuXHRcdC8vbm9kZXMgaW5wdXQgbm9kZSBhZGRlZCBpbnNpZGVcclxuICAgICAgICB0aGlzLnN1YmdyYXBoLm9uSW5wdXRBZGRlZCA9IHRoaXMub25TdWJncmFwaE5ld0lucHV0LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zdWJncmFwaC5vbklucHV0UmVuYW1lZCA9IHRoaXMub25TdWJncmFwaFJlbmFtZWRJbnB1dC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc3ViZ3JhcGgub25JbnB1dFR5cGVDaGFuZ2VkID0gdGhpcy5vblN1YmdyYXBoVHlwZUNoYW5nZUlucHV0LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zdWJncmFwaC5vbklucHV0UmVtb3ZlZCA9IHRoaXMub25TdWJncmFwaFJlbW92ZWRJbnB1dC5iaW5kKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLnN1YmdyYXBoLm9uT3V0cHV0QWRkZWQgPSB0aGlzLm9uU3ViZ3JhcGhOZXdPdXRwdXQuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnN1YmdyYXBoLm9uT3V0cHV0UmVuYW1lZCA9IHRoaXMub25TdWJncmFwaFJlbmFtZWRPdXRwdXQuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnN1YmdyYXBoLm9uT3V0cHV0VHlwZUNoYW5nZWQgPSB0aGlzLm9uU3ViZ3JhcGhUeXBlQ2hhbmdlT3V0cHV0LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zdWJncmFwaC5vbk91dHB1dFJlbW92ZWQgPSB0aGlzLm9uU3ViZ3JhcGhSZW1vdmVkT3V0cHV0LmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgU3ViZ3JhcGgudGl0bGUgPSBcIlN1YmdyYXBoXCI7XHJcbiAgICBTdWJncmFwaC5kZXNjID0gXCJHcmFwaCBpbnNpZGUgYSBub2RlXCI7XHJcbiAgICBTdWJncmFwaC50aXRsZV9jb2xvciA9IFwiIzMzNFwiO1xyXG5cclxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wiZW5hYmxlZFwiLCBcImJvb2xlYW5cIl1dO1xyXG4gICAgfTtcclxuXHJcblx0LypcclxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vbkRyYXdUaXRsZSA9IGZ1bmN0aW9uKGN0eCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjNTU1XCI7XHJcbiAgICAgICAgdmFyIHcgPSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQ7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLnNpemVbMF0gLSB3O1xyXG4gICAgICAgIGN0eC5maWxsUmVjdCh4LCAtdywgdywgdyk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzMzM1wiO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHgubW92ZVRvKHggKyB3ICogMC4yLCAtdyAqIDAuNik7XHJcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgdyAqIDAuOCwgLXcgKiAwLjYpO1xyXG4gICAgICAgIGN0eC5saW5lVG8oeCArIHcgKiAwLjUsIC13ICogMC4zKTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgfTtcclxuXHQqL1xyXG5cclxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vbkRibENsaWNrID0gZnVuY3Rpb24oZSwgcG9zLCBncmFwaGNhbnZhcykge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBncmFwaGNhbnZhcy5vcGVuU3ViZ3JhcGgodGhhdC5zdWJncmFwaCk7XHJcbiAgICAgICAgfSwgMTApO1xyXG4gICAgfTtcclxuXHJcblx0LypcclxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKGUsIHBvcywgZ3JhcGhjYW52YXMpIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICF0aGlzLmZsYWdzLmNvbGxhcHNlZCAmJlxyXG4gICAgICAgICAgICBwb3NbMF0gPiB0aGlzLnNpemVbMF0gLSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgJiZcclxuICAgICAgICAgICAgcG9zWzFdIDwgMFxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBncmFwaGNhbnZhcy5vcGVuU3ViZ3JhcGgodGhhdC5zdWJncmFwaCk7XHJcbiAgICAgICAgICAgIH0sIDEwKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cdCovXHJcblxyXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xyXG4gICAgICAgIHRoaXMuc3ViZ3JhcGgub25BY3Rpb24oYWN0aW9uLCBwYXJhbSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcImVuYWJsZWRcIik7XHJcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zZW5kIGlucHV0cyB0byBzdWJncmFwaCBnbG9iYWwgaW5wdXRzXHJcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN1YmdyYXBoLnNldElucHV0RGF0YShpbnB1dC5uYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZXhlY3V0ZVxyXG4gICAgICAgIHRoaXMuc3ViZ3JhcGgucnVuU3RlcCgpO1xyXG5cclxuICAgICAgICAvL3NlbmQgc3ViZ3JhcGggZ2xvYmFsIG91dHB1dHMgdG8gb3V0cHV0c1xyXG4gICAgICAgIGlmICh0aGlzLm91dHB1dHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnN1YmdyYXBoLmdldE91dHB1dERhdGEob3V0cHV0Lm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKGksIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLnNlbmRFdmVudFRvQWxsTm9kZXMgPSBmdW5jdGlvbihldmVudG5hbWUsIHBhcmFtLCBtb2RlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN1YmdyYXBoLnNlbmRFdmVudFRvQWxsTm9kZXMoZXZlbnRuYW1lLCBwYXJhbSwgbW9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uIChjdHgsIGdyYXBoY2FudmFzLCBjYW52YXMsIHBvcykge1xyXG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy5zaXplWzFdIC0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICsgMC41O1xyXG4gICAgICAgIC8vIGJ1dHRvblxyXG4gICAgICAgIHZhciBvdmVyID0gTGl0ZUdyYXBoLmlzSW5zaWRlUmVjdGFuZ2xlKHBvc1swXSwgcG9zWzFdLCB0aGlzLnBvc1swXSwgdGhpcy5wb3NbMV0gKyB5LCB0aGlzLnNpemVbMF0sIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCk7XHJcbiAgICAgICAgbGV0IG92ZXJsZWZ0ID0gTGl0ZUdyYXBoLmlzSW5zaWRlUmVjdGFuZ2xlKHBvc1swXSwgcG9zWzFdLCB0aGlzLnBvc1swXSwgdGhpcy5wb3NbMV0gKyB5LCB0aGlzLnNpemVbMF0gLyAyLCBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQpXHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG92ZXIgPyBcIiM1NTVcIiA6IFwiIzIyMlwiO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBpZiAodGhpcy5fc2hhcGUgPT0gTGl0ZUdyYXBoLkJPWF9TSEFQRSkge1xyXG4gICAgICAgICAgICBpZiAob3ZlcmxlZnQpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5yZWN0KDAsIHksIHRoaXMuc2l6ZVswXSAvIDIgKyAxLCBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3R4LnJlY3QodGhpcy5zaXplWzBdIC8gMiwgeSwgdGhpcy5zaXplWzBdIC8gMiArIDEsIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChvdmVybGVmdCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LnJvdW5kUmVjdCgwLCB5LCB0aGlzLnNpemVbMF0gLyAyICsgMSwgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hULCBbMCwwLCA4LDhdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN0eC5yb3VuZFJlY3QodGhpcy5zaXplWzBdIC8gMiwgeSwgdGhpcy5zaXplWzBdIC8gMiArIDEsIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCwgWzAsMCwgOCw4XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG92ZXIpIHtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgeSwgdGhpcy5zaXplWzBdICsgMSwgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYnV0dG9uXHJcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgY3R4LmZvbnQgPSBcIjI0cHggQXJpYWxcIjtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3ZlciA/IFwiI0RERFwiIDogXCIjOTk5XCI7XHJcbiAgICAgICAgY3R4LmZpbGxUZXh0KFwiK1wiLCB0aGlzLnNpemVbMF0gKiAwLjI1LCB5ICsgMjQpO1xyXG4gICAgICAgIGN0eC5maWxsVGV4dChcIitcIiwgdGhpcy5zaXplWzBdICogMC43NSwgeSArIDI0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdWJncmFwaC5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbihlLCBsb2NhbHBvcywgZ3JhcGhjYW52YXMpXHJcbiAgICAvLyB7XHJcbiAgICAvLyBcdHZhciB5ID0gdGhpcy5zaXplWzFdIC0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICsgMC41O1xyXG4gICAgLy8gXHRpZihsb2NhbHBvc1sxXSA+IHkpXHJcbiAgICAvLyBcdHtcclxuICAgIC8vIFx0XHRncmFwaGNhbnZhcy5zaG93U3ViZ3JhcGhQcm9wZXJ0aWVzRGlhbG9nKHRoaXMpO1xyXG4gICAgLy8gXHR9XHJcbiAgICAvLyB9XHJcbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZSwgbG9jYWxwb3MsIGdyYXBoY2FudmFzKSB7XHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLnNpemVbMV0gLSBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQgKyAwLjU7XHJcbiAgICAgICAgY29uc29sZS5sb2coMClcclxuICAgICAgICBpZiAobG9jYWxwb3NbMV0gPiB5KSB7XHJcbiAgICAgICAgICAgIGlmIChsb2NhbHBvc1swXSA8IHRoaXMuc2l6ZVswXSAvIDIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKDEpXHJcbiAgICAgICAgICAgICAgICBncmFwaGNhbnZhcy5zaG93U3ViZ3JhcGhQcm9wZXJ0aWVzRGlhbG9nKHRoaXMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coMilcclxuICAgICAgICAgICAgICAgIGdyYXBoY2FudmFzLnNob3dTdWJncmFwaFByb3BlcnRpZXNEaWFsb2dSaWdodCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHRTdWJncmFwaC5wcm90b3R5cGUuY29tcHV0ZVNpemUgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0dmFyIG51bV9pbnB1dHMgPSB0aGlzLmlucHV0cyA/IHRoaXMuaW5wdXRzLmxlbmd0aCA6IDA7XHJcblx0XHR2YXIgbnVtX291dHB1dHMgPSB0aGlzLm91dHB1dHMgPyB0aGlzLm91dHB1dHMubGVuZ3RoIDogMDtcclxuXHRcdHJldHVybiBbIDIwMCwgTWF0aC5tYXgobnVtX2lucHV0cyxudW1fb3V0cHV0cykgKiBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCArIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCBdO1xyXG5cdH1cclxuXHJcbiAgICAvLyoqKiogSU5QVVRTICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25TdWJncmFwaFRyaWdnZXIgPSBmdW5jdGlvbihldmVudCwgcGFyYW0pIHtcclxuICAgICAgICB2YXIgc2xvdCA9IHRoaXMuZmluZE91dHB1dFNsb3QoZXZlbnQpO1xyXG4gICAgICAgIGlmIChzbG90ICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlclNsb3Qoc2xvdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25TdWJncmFwaE5ld0lucHV0ID0gZnVuY3Rpb24obmFtZSwgdHlwZSkge1xyXG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5maW5kSW5wdXRTbG90KG5hbWUpO1xyXG4gICAgICAgIGlmIChzbG90ID09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vYWRkIGlucHV0IHRvIHRoZSBub2RlXHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQobmFtZSwgdHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25TdWJncmFwaFJlbmFtZWRJbnB1dCA9IGZ1bmN0aW9uKG9sZG5hbWUsIG5hbWUpIHtcclxuICAgICAgICB2YXIgc2xvdCA9IHRoaXMuZmluZElucHV0U2xvdChvbGRuYW1lKTtcclxuICAgICAgICBpZiAoc2xvdCA9PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbmZvID0gdGhpcy5nZXRJbnB1dEluZm8oc2xvdCk7XHJcbiAgICAgICAgaW5mby5uYW1lID0gbmFtZTtcclxuICAgIH07XHJcblxyXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLm9uU3ViZ3JhcGhUeXBlQ2hhbmdlSW5wdXQgPSBmdW5jdGlvbihuYW1lLCB0eXBlKSB7XHJcbiAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmZpbmRJbnB1dFNsb3QobmFtZSk7XHJcbiAgICAgICAgaWYgKHNsb3QgPT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW5mbyA9IHRoaXMuZ2V0SW5wdXRJbmZvKHNsb3QpO1xyXG4gICAgICAgIGluZm8udHlwZSA9IHR5cGU7XHJcbiAgICB9O1xyXG5cclxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vblN1YmdyYXBoUmVtb3ZlZElucHV0ID0gZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5maW5kSW5wdXRTbG90KG5hbWUpO1xyXG4gICAgICAgIGlmIChzbG90ID09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZW1vdmVJbnB1dChzbG90KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8qKioqIE9VVFBVVFMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vblN1YmdyYXBoTmV3T3V0cHV0ID0gZnVuY3Rpb24obmFtZSwgdHlwZSkge1xyXG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5maW5kT3V0cHV0U2xvdChuYW1lKTtcclxuICAgICAgICBpZiAoc2xvdCA9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZE91dHB1dChuYW1lLCB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5vblN1YmdyYXBoUmVuYW1lZE91dHB1dCA9IGZ1bmN0aW9uKG9sZG5hbWUsIG5hbWUpIHtcclxuICAgICAgICB2YXIgc2xvdCA9IHRoaXMuZmluZE91dHB1dFNsb3Qob2xkbmFtZSk7XHJcbiAgICAgICAgaWYgKHNsb3QgPT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW5mbyA9IHRoaXMuZ2V0T3V0cHV0SW5mbyhzbG90KTtcclxuICAgICAgICBpbmZvLm5hbWUgPSBuYW1lO1xyXG4gICAgfTtcclxuXHJcbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25TdWJncmFwaFR5cGVDaGFuZ2VPdXRwdXQgPSBmdW5jdGlvbihuYW1lLCB0eXBlKSB7XHJcbiAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmZpbmRPdXRwdXRTbG90KG5hbWUpO1xyXG4gICAgICAgIGlmIChzbG90ID09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluZm8gPSB0aGlzLmdldE91dHB1dEluZm8oc2xvdCk7XHJcbiAgICAgICAgaW5mby50eXBlID0gdHlwZTtcclxuICAgIH07XHJcblxyXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLm9uU3ViZ3JhcGhSZW1vdmVkT3V0cHV0ID0gZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5maW5kT3V0cHV0U2xvdChuYW1lKTtcclxuICAgICAgICBpZiAoc2xvdCA9PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVtb3ZlT3V0cHV0KHNsb3QpO1xyXG4gICAgfTtcclxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLmdldEV4dHJhTWVudU9wdGlvbnMgPSBmdW5jdGlvbihncmFwaGNhbnZhcykge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50OiBcIk9wZW5cIixcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBncmFwaGNhbnZhcy5vcGVuU3ViZ3JhcGgodGhhdC5zdWJncmFwaCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuXHJcbiAgICBTdWJncmFwaC5wcm90b3R5cGUub25SZXNpemUgPSBmdW5jdGlvbihzaXplKSB7XHJcbiAgICAgICAgc2l6ZVsxXSArPSAyMDtcclxuICAgIH07XHJcblxyXG4gICAgU3ViZ3JhcGgucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBkYXRhID0gTGl0ZUdyYXBoLkxHcmFwaE5vZGUucHJvdG90eXBlLnNlcmlhbGl6ZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGRhdGEuc3ViZ3JhcGggPSB0aGlzLnN1YmdyYXBoLnNlcmlhbGl6ZSgpO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfTtcclxuICAgIC8vbm8gbmVlZCB0byBkZWZpbmUgbm9kZS5jb25maWd1cmUsIHRoZSBkZWZhdWx0IG1ldGhvZCBkZXRlY3RzIG5vZGUuc3ViZ3JhcGggYW5kIHBhc3NlcyB0aGUgb2JqZWN0IHRvIG5vZGUuc3ViZ3JhcGguY29uZmlndXJlKClcclxuXHJcbiAgICBTdWJncmFwaC5wcm90b3R5cGUucmVhc3NpZ25TdWJncmFwaFVVSURzID0gZnVuY3Rpb24oZ3JhcGgpIHtcclxuICAgICAgICBjb25zdCBpZE1hcCA9IHsgbm9kZUlEczoge30sIGxpbmtJRHM6IHt9IH1cclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGdyYXBoLm5vZGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZElEID0gbm9kZS5pZFxyXG4gICAgICAgICAgICBjb25zdCBuZXdJRCA9IExpdGVHcmFwaC51dWlkdjQoKVxyXG4gICAgICAgICAgICBub2RlLmlkID0gbmV3SURcclxuXHJcbiAgICAgICAgICAgIGlmIChpZE1hcC5ub2RlSURzW29sZElEXSB8fCBpZE1hcC5ub2RlSURzW25ld0lEXSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXcvb2xkIG5vZGUgVVVJRCB3YXNuJ3QgdW5pcXVlIGluIGNoYW5nZWQgbWFwISAke29sZElEfSAke25ld0lEfWApXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlkTWFwLm5vZGVJRHNbb2xkSURdID0gbmV3SURcclxuICAgICAgICAgICAgaWRNYXAubm9kZUlEc1tuZXdJRF0gPSBvbGRJRFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBsaW5rIG9mIGdyYXBoLmxpbmtzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZElEID0gbGlua1swXVxyXG4gICAgICAgICAgICBjb25zdCBuZXdJRCA9IExpdGVHcmFwaC51dWlkdjQoKTtcclxuICAgICAgICAgICAgbGlua1swXSA9IG5ld0lEXHJcblxyXG4gICAgICAgICAgICBpZiAoaWRNYXAubGlua0lEc1tvbGRJRF0gfHwgaWRNYXAubGlua0lEc1tuZXdJRF0pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTmV3L29sZCBsaW5rIFVVSUQgd2Fzbid0IHVuaXF1ZSBpbiBjaGFuZ2VkIG1hcCEgJHtvbGRJRH0gJHtuZXdJRH1gKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZE1hcC5saW5rSURzW29sZElEXSA9IG5ld0lEXHJcbiAgICAgICAgICAgIGlkTWFwLmxpbmtJRHNbbmV3SURdID0gb2xkSURcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVGcm9tID0gbGlua1sxXVxyXG4gICAgICAgICAgICBjb25zdCBub2RlVG8gPSBsaW5rWzNdXHJcblxyXG4gICAgICAgICAgICBpZiAoIWlkTWFwLm5vZGVJRHNbbm9kZUZyb21dKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9sZCBub2RlIFVVSUQgbm90IGZvdW5kIGluIG1hcHBpbmchICR7bm9kZUZyb219YClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGlua1sxXSA9IGlkTWFwLm5vZGVJRHNbbm9kZUZyb21dXHJcblxyXG4gICAgICAgICAgICBpZiAoIWlkTWFwLm5vZGVJRHNbbm9kZVRvXSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPbGQgbm9kZSBVVUlEIG5vdCBmb3VuZCBpbiBtYXBwaW5nISAke25vZGVUb31gKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsaW5rWzNdID0gaWRNYXAubm9kZUlEc1tub2RlVG9dXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZWNvbm5lY3QgbGlua3NcclxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZ3JhcGgubm9kZXMpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuaW5wdXRzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIG5vZGUuaW5wdXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmxpbmspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQubGluayA9IGlkTWFwLmxpbmtJRHNbaW5wdXQubGlua11cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5vZGUub3V0cHV0cykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBvdXRwdXQgb2Ygbm9kZS5vdXRwdXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5saW5rcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQubGlua3MgPSBvdXRwdXQubGlua3MubWFwKGwgPT4gaWRNYXAubGlua0lEc1tsXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZWN1cnNlIVxyXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBncmFwaC5ub2Rlcykge1xyXG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcImdyYXBoL3N1YmdyYXBoXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlID0gcmVhc3NpZ25HcmFwaFVVSURzKG5vZGUuc3ViZ3JhcGgpO1xyXG4gICAgICAgICAgICAgICAgaWRNYXAubm9kZUlEcy5hc3NpZ24obWVyZ2Uubm9kZUlEcylcclxuICAgICAgICAgICAgICAgIGlkTWFwLmxpbmtJRHMuYXNzaWduKG1lcmdlLmxpbmtJRHMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFN1YmdyYXBoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUodGhpcy50eXBlKTtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuc2VyaWFsaXplKCk7XHJcblxyXG4gICAgICAgIGlmIChMaXRlR3JhcGgudXNlX3V1aWRzKSB7XHJcbiAgICAgICAgICAgIC8vIExHcmFwaC5zZXJpYWxpemUoKSBzZWVtcyB0byByZXVzZSBvYmplY3RzIGluIHRoZSBvcmlnaW5hbCBncmFwaC4gQnV0IHdlXHJcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gY2hhbmdlIG5vZGUgSURzIGhlcmUsIHNvIGNsb25lIGl0IGZpcnN0LlxyXG4gICAgICAgICAgICBjb25zdCBzdWJncmFwaCA9IExpdGVHcmFwaC5jbG9uZU9iamVjdChkYXRhLnN1YmdyYXBoKVxyXG5cclxuICAgICAgICAgICAgdGhpcy5yZWFzc2lnblN1YmdyYXBoVVVJRHMoc3ViZ3JhcGgpO1xyXG5cclxuICAgICAgICAgICAgZGF0YS5zdWJncmFwaCA9IHN1YmdyYXBoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGVsZXRlIGRhdGFbXCJpZFwiXTtcclxuICAgICAgICBkZWxldGUgZGF0YVtcImlucHV0c1wiXTtcclxuICAgICAgICBkZWxldGUgZGF0YVtcIm91dHB1dHNcIl07XHJcbiAgICAgICAgbm9kZS5jb25maWd1cmUoZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9O1xyXG5cclxuXHRTdWJncmFwaC5wcm90b3R5cGUuYnVpbGRGcm9tTm9kZXMgPSBmdW5jdGlvbihub2RlcylcclxuXHR7XHJcblx0XHQvL2NsZWFyIGFsbD9cclxuXHRcdC8vVE9ET1xyXG5cclxuXHRcdC8vbm9kZXMgdGhhdCBjb25uZWN0IGRhdGEgYmV0d2VlbiBwYXJlbnQgZ3JhcGggYW5kIHN1YmdyYXBoXHJcblx0XHR2YXIgc3ViZ3JhcGhfaW5wdXRzID0gW107XHJcblx0XHR2YXIgc3ViZ3JhcGhfb3V0cHV0cyA9IFtdO1xyXG5cclxuXHRcdC8vbWFyayBpbm5lciBub2Rlc1xyXG5cdFx0dmFyIGlkcyA9IHt9O1xyXG5cdFx0dmFyIG1pbl94ID0gMDtcclxuXHRcdHZhciBtYXhfeCA9IDA7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpXHJcblx0XHR7XHJcblx0XHRcdHZhciBub2RlID0gbm9kZXNbaV07XHJcblx0XHRcdGlkc1sgbm9kZS5pZCBdID0gbm9kZTtcclxuXHRcdFx0bWluX3ggPSBNYXRoLm1pbiggbm9kZS5wb3NbMF0sIG1pbl94ICk7XHJcblx0XHRcdG1heF94ID0gTWF0aC5tYXgoIG5vZGUucG9zWzBdLCBtaW5feCApO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHR2YXIgbGFzdF9pbnB1dF95ID0gMDtcclxuXHRcdHZhciBsYXN0X291dHB1dF95ID0gMDtcclxuXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpXHJcblx0XHR7XHJcblx0XHRcdHZhciBub2RlID0gbm9kZXNbaV07XHJcblx0XHRcdC8vY2hlY2sgaW5wdXRzXHJcblx0XHRcdGlmKCBub2RlLmlucHV0cyApXHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IG5vZGUuaW5wdXRzLmxlbmd0aDsgKytqKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHZhciBpbnB1dCA9IG5vZGUuaW5wdXRzW2pdO1xyXG5cdFx0XHRcdFx0aWYoICFpbnB1dCB8fCAhaW5wdXQubGluayApXHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0dmFyIGxpbmsgPSBub2RlLmdyYXBoLmxpbmtzWyBpbnB1dC5saW5rIF07XHJcblx0XHRcdFx0XHRpZighbGluaylcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRpZiggaWRzWyBsaW5rLm9yaWdpbl9pZCBdIClcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHQvL3RoaXMuYWRkSW5wdXQoaW5wdXQubmFtZSxsaW5rLnR5cGUpO1xyXG5cdFx0XHRcdFx0dGhpcy5zdWJncmFwaC5hZGRJbnB1dChpbnB1dC5uYW1lLGxpbmsudHlwZSk7XHJcblx0XHRcdFx0XHQvKlxyXG5cdFx0XHRcdFx0dmFyIGlucHV0X25vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZShcImdyYXBoL2lucHV0XCIpO1xyXG5cdFx0XHRcdFx0dGhpcy5zdWJncmFwaC5hZGQoIGlucHV0X25vZGUgKTtcclxuXHRcdFx0XHRcdGlucHV0X25vZGUucG9zID0gW21pbl94IC0gMjAwLCBsYXN0X2lucHV0X3kgXTtcclxuXHRcdFx0XHRcdGxhc3RfaW5wdXRfeSArPSAxMDA7XHJcblx0XHRcdFx0XHQqL1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdC8vY2hlY2sgb3V0cHV0c1xyXG5cdFx0XHRpZiggbm9kZS5vdXRwdXRzIClcclxuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgbm9kZS5vdXRwdXRzLmxlbmd0aDsgKytqKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHZhciBvdXRwdXQgPSBub2RlLm91dHB1dHNbal07XHJcblx0XHRcdFx0XHRpZiggIW91dHB1dCB8fCAhb3V0cHV0LmxpbmtzIHx8ICFvdXRwdXQubGlua3MubGVuZ3RoIClcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR2YXIgaXNfZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHRcdFx0XHRcdGZvcih2YXIgayA9IDA7IGsgPCBvdXRwdXQubGlua3MubGVuZ3RoOyArK2spXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHZhciBsaW5rID0gbm9kZS5ncmFwaC5saW5rc1sgb3V0cHV0LmxpbmtzW2tdIF07XHJcblx0XHRcdFx0XHRcdGlmKCFsaW5rKVxyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHRpZiggaWRzWyBsaW5rLnRhcmdldF9pZCBdIClcclxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0aXNfZXh0ZXJuYWwgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKCFpc19leHRlcm5hbClcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHQvL3RoaXMuYWRkT3V0cHV0KG91dHB1dC5uYW1lLG91dHB1dC50eXBlKTtcclxuXHRcdFx0XHRcdC8qXHJcblx0XHRcdFx0XHR2YXIgb3V0cHV0X25vZGUgPSBMaXRlR3JhcGguY3JlYXRlTm9kZShcImdyYXBoL291dHB1dFwiKTtcclxuXHRcdFx0XHRcdHRoaXMuc3ViZ3JhcGguYWRkKCBvdXRwdXRfbm9kZSApO1xyXG5cdFx0XHRcdFx0b3V0cHV0X25vZGUucG9zID0gW21heF94ICsgNTAsIGxhc3Rfb3V0cHV0X3kgXTtcclxuXHRcdFx0XHRcdGxhc3Rfb3V0cHV0X3kgKz0gMTAwO1xyXG5cdFx0XHRcdFx0Ki9cclxuXHRcdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9kZXRlY3QgaW5wdXRzIGFuZCBvdXRwdXRzXHJcblx0XHRcdC8vc3BsaXQgZXZlcnkgY29ubmVjdGlvbiBpbiB0d28gZGF0YV9jb25uZWN0aW9uIG5vZGVzXHJcblx0XHRcdC8va2VlcCB0cmFjayBvZiBpbnRlcm5hbCBjb25uZWN0aW9uc1xyXG5cdFx0XHQvL2Nvbm5lY3QgZXh0ZXJuYWwgY29ubmVjdGlvbnNcclxuXHJcblx0XHQvL2Nsb25lIG5vZGVzIGluc2lkZSBzdWJncmFwaCBhbmQgdHJ5IHRvIHJlY29ubmVjdCB0aGVtXHJcblxyXG5cdFx0Ly9jb25uZWN0IGVkZ2Ugc3ViZ3JhcGggbm9kZXMgdG8gZXh0YXJuYWwgY29ubmVjdGlvbnMgbm9kZXNcclxuXHR9XHJcblxyXG4gICAgTGl0ZUdyYXBoLlN1YmdyYXBoID0gU3ViZ3JhcGg7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImdyYXBoL3N1YmdyYXBoXCIsIFN1YmdyYXBoKTtcclxuXHJcbiAgICAvL0lucHV0IGZvciBhIHN1YmdyYXBoXHJcbiAgICBmdW5jdGlvbiBHcmFwaElucHV0KCkge1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwibnVtYmVyXCIpO1xyXG5cclxuICAgICAgICB0aGlzLm5hbWVfaW5fZ3JhcGggPSBcIlwiO1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuXHRcdFx0bmFtZTogXCJcIixcclxuXHRcdFx0dHlwZTogXCJudW1iZXJcIixcclxuXHRcdFx0dmFsdWU6IDBcclxuXHRcdH07IFxyXG5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIHRoaXMubmFtZV93aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcclxuICAgICAgICAgICAgXCJ0ZXh0XCIsXHJcbiAgICAgICAgICAgIFwiTmFtZVwiLFxyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubmFtZSxcclxuICAgICAgICAgICAgZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhhdC5zZXRQcm9wZXJ0eShcIm5hbWVcIix2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy50eXBlX3dpZGdldCA9IHRoaXMuYWRkV2lkZ2V0KFxyXG4gICAgICAgICAgICBcInRleHRcIixcclxuICAgICAgICAgICAgXCJUeXBlXCIsXHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy50eXBlLFxyXG4gICAgICAgICAgICBmdW5jdGlvbih2KSB7XHJcblx0XHRcdFx0dGhhdC5zZXRQcm9wZXJ0eShcInR5cGVcIix2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRoaXMudmFsdWVfd2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXHJcbiAgICAgICAgICAgIFwibnVtYmVyXCIsXHJcbiAgICAgICAgICAgIFwiVmFsdWVcIixcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlLFxyXG4gICAgICAgICAgICBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnNldFByb3BlcnR5KFwidmFsdWVcIix2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRoaXMud2lkZ2V0c191cCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzE4MCwgOTBdO1xyXG4gICAgfVxyXG5cclxuICAgIEdyYXBoSW5wdXQudGl0bGUgPSBcIklucHV0XCI7XHJcbiAgICBHcmFwaElucHV0LmRlc2MgPSBcIklucHV0IG9mIHRoZSBncmFwaFwiO1xyXG5cclxuXHRHcmFwaElucHV0LnByb3RvdHlwZS5vbkNvbmZpZ3VyZSA9IGZ1bmN0aW9uKClcclxuXHJcblx0e1xyXG5cdFx0dGhpcy51cGRhdGVUeXBlKCk7XHJcblx0fVxyXG5cclxuXHQvL2Vuc3VyZXMgdGhlIHR5cGUgaW4gdGhlIG5vZGUgb3V0cHV0IGFuZCB0aGUgdHlwZSBpbiB0aGUgYXNzb2NpYXRlZCBncmFwaCBpbnB1dCBhcmUgdGhlIHNhbWVcclxuXHRHcmFwaElucHV0LnByb3RvdHlwZS51cGRhdGVUeXBlID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdHZhciB0eXBlID0gdGhpcy5wcm9wZXJ0aWVzLnR5cGU7XHJcblx0XHR0aGlzLnR5cGVfd2lkZ2V0LnZhbHVlID0gdHlwZTtcclxuXHJcblx0XHQvL3VwZGF0ZSBvdXRwdXRcclxuXHRcdGlmKHRoaXMub3V0cHV0c1swXS50eXBlICE9IHR5cGUpXHJcblx0XHR7XHJcblx0ICAgICAgICBpZiAoIUxpdGVHcmFwaC5pc1ZhbGlkQ29ubmVjdGlvbih0aGlzLm91dHB1dHNbMF0udHlwZSx0eXBlKSlcclxuXHRcdFx0XHR0aGlzLmRpc2Nvbm5lY3RPdXRwdXQoMCk7XHJcblx0XHRcdHRoaXMub3V0cHV0c1swXS50eXBlID0gdHlwZTtcclxuXHRcdH1cclxuXHJcblx0XHQvL3VwZGF0ZSB3aWRnZXRcclxuXHRcdGlmKHR5cGUgPT0gXCJudW1iZXJcIilcclxuXHRcdHtcclxuXHRcdFx0dGhpcy52YWx1ZV93aWRnZXQudHlwZSA9IFwibnVtYmVyXCI7XHJcblx0XHRcdHRoaXMudmFsdWVfd2lkZ2V0LnZhbHVlID0gMDtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYodHlwZSA9PSBcImJvb2xlYW5cIilcclxuXHRcdHtcclxuXHRcdFx0dGhpcy52YWx1ZV93aWRnZXQudHlwZSA9IFwidG9nZ2xlXCI7XHJcblx0XHRcdHRoaXMudmFsdWVfd2lkZ2V0LnZhbHVlID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYodHlwZSA9PSBcInN0cmluZ1wiKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLnZhbHVlX3dpZGdldC50eXBlID0gXCJ0ZXh0XCI7XHJcblx0XHRcdHRoaXMudmFsdWVfd2lkZ2V0LnZhbHVlID0gXCJcIjtcclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdHtcclxuXHRcdFx0dGhpcy52YWx1ZV93aWRnZXQudHlwZSA9IG51bGw7XHJcblx0XHRcdHRoaXMudmFsdWVfd2lkZ2V0LnZhbHVlID0gbnVsbDtcclxuXHRcdH1cclxuXHRcdHRoaXMucHJvcGVydGllcy52YWx1ZSA9IHRoaXMudmFsdWVfd2lkZ2V0LnZhbHVlO1xyXG5cclxuXHRcdC8vdXBkYXRlIGdyYXBoXHJcblx0XHRpZiAodGhpcy5ncmFwaCAmJiB0aGlzLm5hbWVfaW5fZ3JhcGgpIHtcclxuXHRcdFx0dGhpcy5ncmFwaC5jaGFuZ2VJbnB1dFR5cGUodGhpcy5uYW1lX2luX2dyYXBoLCB0eXBlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vdGhpcyBpcyBleGVjdXRlZCBBRlRFUiB0aGUgcHJvcGVydHkgaGFzIGNoYW5nZWRcclxuXHRHcmFwaElucHV0LnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsdilcclxuXHR7XHJcblx0XHRpZiggbmFtZSA9PSBcIm5hbWVcIiApXHJcblx0XHR7XHJcblx0XHRcdGlmICh2ID09IFwiXCIgfHwgdiA9PSB0aGlzLm5hbWVfaW5fZ3JhcGggfHwgdiA9PSBcImVuYWJsZWRcIikge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZih0aGlzLmdyYXBoKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aWYgKHRoaXMubmFtZV9pbl9ncmFwaCkge1xyXG5cdFx0XHRcdFx0Ly9hbHJlYWR5IGFkZGVkXHJcblx0XHRcdFx0XHR0aGlzLmdyYXBoLnJlbmFtZUlucHV0KCB0aGlzLm5hbWVfaW5fZ3JhcGgsIHYgKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5ncmFwaC5hZGRJbnB1dCggdiwgdGhpcy5wcm9wZXJ0aWVzLnR5cGUgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gLy93aGF0IGlmIG5vdD8hXHJcblx0XHRcdHRoaXMubmFtZV93aWRnZXQudmFsdWUgPSB2O1xyXG5cdFx0XHR0aGlzLm5hbWVfaW5fZ3JhcGggPSB2O1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiggbmFtZSA9PSBcInR5cGVcIiApXHJcblx0XHR7XHJcblx0XHRcdHRoaXMudXBkYXRlVHlwZSgpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiggbmFtZSA9PSBcInZhbHVlXCIgKVxyXG5cdFx0e1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcbiAgICBHcmFwaElucHV0LnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xyXG4gICAgfTtcclxuXHJcbiAgICBHcmFwaElucHV0LnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0pIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnR5cGUgPT0gTGl0ZUdyYXBoLkVWRU5UKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlclNsb3QoMCwgcGFyYW0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgR3JhcGhJbnB1dC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnByb3BlcnRpZXMubmFtZTtcclxuICAgICAgICAvL3JlYWQgZnJvbSBnbG9iYWwgaW5wdXRcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ3JhcGguaW5wdXRzW25hbWVdO1xyXG4gICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlICk7XHJcblx0XHRcdHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBkYXRhLnZhbHVlICE9PSB1bmRlZmluZWQgPyBkYXRhLnZhbHVlIDogdGhpcy5wcm9wZXJ0aWVzLnZhbHVlICk7XHJcbiAgICB9O1xyXG5cclxuICAgIEdyYXBoSW5wdXQucHJvdG90eXBlLm9uUmVtb3ZlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm5hbWVfaW5fZ3JhcGgpIHtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaC5yZW1vdmVJbnB1dCh0aGlzLm5hbWVfaW5fZ3JhcGgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLkdyYXBoSW5wdXQgPSBHcmFwaElucHV0O1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJncmFwaC9pbnB1dFwiLCBHcmFwaElucHV0KTtcclxuXHJcbiAgICAvL091dHB1dCBmb3IgYSBzdWJncmFwaFxyXG4gICAgZnVuY3Rpb24gR3JhcGhPdXRwdXQoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlwiLCBcIlwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5uYW1lX2luX2dyYXBoID0gXCJcIjtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IG5hbWU6IFwiXCIsIHR5cGU6IFwiXCIgfTtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnByb3BlcnRpZXMsIFwibmFtZVwiLCB7XHJcbiAgICAgICAgLy8gICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gICAgICAgICByZXR1cm4gdGhhdC5uYW1lX2luX2dyYXBoO1xyXG4gICAgICAgIC8vICAgICB9LFxyXG4gICAgICAgIC8vICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAvLyAgICAgICAgIGlmICh2ID09IFwiXCIgfHwgdiA9PSB0aGF0Lm5hbWVfaW5fZ3JhcGgpIHtcclxuICAgICAgICAvLyAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgLy8gICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgICBpZiAodGhhdC5uYW1lX2luX2dyYXBoKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgLy9hbHJlYWR5IGFkZGVkXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgdGhhdC5ncmFwaC5yZW5hbWVPdXRwdXQodGhhdC5uYW1lX2luX2dyYXBoLCB2KTtcclxuICAgICAgICAvLyAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgdGhhdC5ncmFwaC5hZGRPdXRwdXQodiwgdGhhdC5wcm9wZXJ0aWVzLnR5cGUpO1xyXG4gICAgICAgIC8vICAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICAgICAgdGhhdC5uYW1lX3dpZGdldC52YWx1ZSA9IHY7XHJcbiAgICAgICAgLy8gICAgICAgICB0aGF0Lm5hbWVfaW5fZ3JhcGggPSB2O1xyXG4gICAgICAgIC8vICAgICB9LFxyXG4gICAgICAgIC8vICAgICBlbnVtZXJhYmxlOiB0cnVlXHJcbiAgICAgICAgLy8gfSk7XHJcblxyXG4gICAgICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnByb3BlcnRpZXMsIFwidHlwZVwiLCB7XHJcbiAgICAgICAgLy8gICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gICAgICAgICByZXR1cm4gdGhhdC5pbnB1dHNbMF0udHlwZTtcclxuICAgICAgICAvLyAgICAgfSxcclxuICAgICAgICAvLyAgICAgc2V0OiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgLy8gICAgICAgICBpZiAodiA9PSBcImFjdGlvblwiIHx8IHYgPT0gXCJldmVudFwiKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgdiA9IExpdGVHcmFwaC5BQ1RJT047XHJcbiAgICAgICAgLy8gICAgICAgICB9XHJcblx0XHQvLyAgICAgICAgIGlmICghTGl0ZUdyYXBoLmlzVmFsaWRDb25uZWN0aW9uKHRoYXQuaW5wdXRzWzBdLnR5cGUsdikpXHJcblx0XHQvLyBcdFx0XHR0aGF0LmRpc2Nvbm5lY3RJbnB1dCgwKTtcclxuICAgICAgICAvLyAgICAgICAgIHRoYXQuaW5wdXRzWzBdLnR5cGUgPSB2O1xyXG4gICAgICAgIC8vICAgICAgICAgaWYgKHRoYXQubmFtZV9pbl9ncmFwaCkge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIC8vYWxyZWFkeSBhZGRlZFxyXG4gICAgICAgIC8vICAgICAgICAgICAgIHRoYXQuZ3JhcGguY2hhbmdlT3V0cHV0VHlwZShcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdGhhdC5uYW1lX2luX2dyYXBoLFxyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0aGF0LmlucHV0c1swXS50eXBlXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgKTtcclxuICAgICAgICAvLyAgICAgICAgIH1cclxuICAgICAgICAvLyAgICAgICAgIHRoYXQudHlwZV93aWRnZXQudmFsdWUgPSB2IHx8IFwiXCI7XHJcbiAgICAgICAgLy8gICAgIH0sXHJcbiAgICAgICAgLy8gICAgIGVudW1lcmFibGU6IHRydWVcclxuICAgICAgICAvLyB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5uYW1lX3dpZGdldCA9IHRoaXMuYWRkV2lkZ2V0KFwidGV4dFwiLFwiTmFtZVwiLHRoaXMucHJvcGVydGllcy5uYW1lLFwibmFtZVwiKTtcclxuICAgICAgICB0aGlzLnR5cGVfd2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJ0ZXh0XCIsXCJUeXBlXCIsdGhpcy5wcm9wZXJ0aWVzLnR5cGUsXCJ0eXBlXCIpO1xyXG4gICAgICAgIHRoaXMud2lkZ2V0c191cCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzE4MCwgNjBdO1xyXG4gICAgfVxyXG5cclxuICAgIEdyYXBoT3V0cHV0LnRpdGxlID0gXCJPdXRwdXRcIjtcclxuICAgIEdyYXBoT3V0cHV0LmRlc2MgPSBcIk91dHB1dCBvZiB0aGUgZ3JhcGhcIjtcclxuXHJcbiAgICBHcmFwaE91dHB1dC5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbiAobmFtZSwgdikge1xyXG4gICAgICAgIGlmIChuYW1lID09IFwibmFtZVwiKSB7XHJcbiAgICAgICAgICAgIGlmICh2ID09IFwiXCIgfHwgdiA9PSB0aGlzLm5hbWVfaW5fZ3JhcGggfHwgdiA9PSBcImVuYWJsZWRcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdyYXBoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uYW1lX2luX2dyYXBoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9hbHJlYWR5IGFkZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5yZW5hbWVPdXRwdXQodGhpcy5uYW1lX2luX2dyYXBoLCB2KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5hZGRPdXRwdXQodiwgdGhpcy5wcm9wZXJ0aWVzLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IC8vd2hhdCBpZiBub3Q/IVxyXG4gICAgICAgICAgICB0aGlzLm5hbWVfd2lkZ2V0LnZhbHVlID0gdjtcclxuICAgICAgICAgICAgdGhpcy5uYW1lX2luX2dyYXBoID0gdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PSBcInR5cGVcIikge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVR5cGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PSBcInZhbHVlXCIpIHtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAgXHJcbiAgICBHcmFwaE91dHB1dC5wcm90b3R5cGUudXBkYXRlVHlwZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdHlwZSA9IHRoaXMucHJvcGVydGllcy50eXBlO1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGVfd2lkZ2V0KVxyXG4gICAgICAgICAgICB0aGlzLnR5cGVfd2lkZ2V0LnZhbHVlID0gdHlwZTtcclxuXHJcbiAgICAgICAgLy91cGRhdGUgb3V0cHV0XHJcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRzWzBdLnR5cGUgIT0gdHlwZSkge1xyXG5cclxuXHRcdFx0aWYgKCB0eXBlID09IFwiYWN0aW9uXCIgfHwgdHlwZSA9PSBcImV2ZW50XCIpXHJcblx0ICAgICAgICAgICAgdHlwZSA9IExpdGVHcmFwaC5FVkVOVDtcclxuXHRcdFx0aWYgKCFMaXRlR3JhcGguaXNWYWxpZENvbm5lY3Rpb24odGhpcy5pbnB1dHNbMF0udHlwZSwgdHlwZSkpXHJcblx0XHRcdFx0dGhpcy5kaXNjb25uZWN0SW5wdXQoMCk7XHJcblx0XHRcdHRoaXMuaW5wdXRzWzBdLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy91cGRhdGUgZ3JhcGhcclxuICAgICAgICBpZiAodGhpcy5ncmFwaCAmJiB0aGlzLm5hbWVfaW5fZ3JhcGgpIHtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaC5jaGFuZ2VPdXRwdXRUeXBlKHRoaXMubmFtZV9pbl9ncmFwaCwgdHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgR3JhcGhPdXRwdXQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgdGhpcy5ncmFwaC5zZXRPdXRwdXREYXRhKHRoaXMucHJvcGVydGllcy5uYW1lLCB0aGlzLl92YWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEdyYXBoT3V0cHV0LnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0pIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnR5cGUgPT0gTGl0ZUdyYXBoLkFDVElPTikge1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoLnRyaWdnZXIoIHRoaXMucHJvcGVydGllcy5uYW1lLCBwYXJhbSApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgR3JhcGhPdXRwdXQucHJvdG90eXBlLm9uUmVtb3ZlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm5hbWVfaW5fZ3JhcGgpIHtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaC5yZW1vdmVPdXRwdXQodGhpcy5uYW1lX2luX2dyYXBoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEdyYXBoT3V0cHV0LnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGguR3JhcGhPdXRwdXQgPSBHcmFwaE91dHB1dDtcclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZ3JhcGgvb3V0cHV0XCIsIEdyYXBoT3V0cHV0KTtcclxuXHJcbiAgICAvL0NvbnN0YW50XHJcbiAgICBmdW5jdGlvbiBDb25zdGFudE51bWJlcigpIHtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInZhbHVlXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJ2YWx1ZVwiLCAxLjApO1xyXG4gICAgICAgIHRoaXMud2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcInZhbHVlXCIsMSxcInZhbHVlXCIpO1xyXG4gICAgICAgIHRoaXMud2lkZ2V0c191cCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzE4MCwgMzBdO1xyXG4gICAgfVxyXG5cclxuICAgIENvbnN0YW50TnVtYmVyLnRpdGxlID0gXCJDb25zdCBOdW1iZXJcIjtcclxuICAgIENvbnN0YW50TnVtYmVyLmRlc2MgPSBcIkNvbnN0YW50IG51bWJlclwiO1xyXG5cclxuICAgIENvbnN0YW50TnVtYmVyLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgcGFyc2VGbG9hdCh0aGlzLnByb3BlcnRpZXNbXCJ2YWx1ZVwiXSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBDb25zdGFudE51bWJlci5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGU7XHJcbiAgICB9O1xyXG5cclxuXHRDb25zdGFudE51bWJlci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbih2KVxyXG5cdHtcclxuXHRcdHRoaXMuc2V0UHJvcGVydHkoXCJ2YWx1ZVwiLHYpO1xyXG5cdH1cclxuXHJcbiAgICBDb25zdGFudE51bWJlci5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xyXG4gICAgICAgIC8vc2hvdyB0aGUgY3VycmVudCB2YWx1ZVxyXG4gICAgICAgIHRoaXMub3V0cHV0c1swXS5sYWJlbCA9IHRoaXMucHJvcGVydGllc1tcInZhbHVlXCJdLnRvRml4ZWQoMyk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvY29uc3RcIiwgQ29uc3RhbnROdW1iZXIpO1xyXG5cclxuICAgIGZ1bmN0aW9uIENvbnN0YW50Qm9vbGVhbigpIHtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcImJvb2xcIiwgXCJib29sZWFuXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJ2YWx1ZVwiLCB0cnVlKTtcclxuICAgICAgICB0aGlzLndpZGdldCA9IHRoaXMuYWRkV2lkZ2V0KFwidG9nZ2xlXCIsXCJ2YWx1ZVwiLHRydWUsXCJ2YWx1ZVwiKTtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZV93aWRnZXRzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLndpZGdldHNfdXAgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxNDAsIDMwXTtcclxuICAgIH1cclxuXHJcbiAgICBDb25zdGFudEJvb2xlYW4udGl0bGUgPSBcIkNvbnN0IEJvb2xlYW5cIjtcclxuICAgIENvbnN0YW50Qm9vbGVhbi5kZXNjID0gXCJDb25zdGFudCBib29sZWFuXCI7XHJcbiAgICBDb25zdGFudEJvb2xlYW4ucHJvdG90eXBlLmdldFRpdGxlID0gQ29uc3RhbnROdW1iZXIucHJvdG90eXBlLmdldFRpdGxlO1xyXG5cclxuICAgIENvbnN0YW50Qm9vbGVhbi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMucHJvcGVydGllc1tcInZhbHVlXCJdKTtcclxuICAgIH07XHJcblxyXG5cdENvbnN0YW50Qm9vbGVhbi5wcm90b3R5cGUuc2V0VmFsdWUgPSBDb25zdGFudE51bWJlci5wcm90b3R5cGUuc2V0VmFsdWU7XHJcblxyXG5cdENvbnN0YW50Qm9vbGVhbi5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBbW1widG9nZ2xlXCIsIExpdGVHcmFwaC5BQ1RJT05dXTtcclxuXHR9O1xyXG5cclxuXHRDb25zdGFudEJvb2xlYW4ucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uKVxyXG5cdHtcclxuXHRcdHRoaXMuc2V0VmFsdWUoICF0aGlzLnByb3BlcnRpZXMudmFsdWUgKTtcclxuXHR9XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy9ib29sZWFuXCIsIENvbnN0YW50Qm9vbGVhbik7XHJcblxyXG4gICAgZnVuY3Rpb24gQ29uc3RhbnRTdHJpbmcoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJzdHJpbmdcIiwgXCJzdHJpbmdcIik7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInZhbHVlXCIsIFwiXCIpO1xyXG4gICAgICAgIHRoaXMud2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJ0ZXh0XCIsXCJ2YWx1ZVwiLFwiXCIsXCJ2YWx1ZVwiKTsgIC8vbGluayB0byBwcm9wZXJ0eSB2YWx1ZVxyXG4gICAgICAgIHRoaXMud2lkZ2V0c191cCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzE4MCwgMzBdO1xyXG4gICAgfVxyXG5cclxuICAgIENvbnN0YW50U3RyaW5nLnRpdGxlID0gXCJDb25zdCBTdHJpbmdcIjtcclxuICAgIENvbnN0YW50U3RyaW5nLmRlc2MgPSBcIkNvbnN0YW50IHN0cmluZ1wiO1xyXG5cclxuICAgIENvbnN0YW50U3RyaW5nLnByb3RvdHlwZS5nZXRUaXRsZSA9IENvbnN0YW50TnVtYmVyLnByb3RvdHlwZS5nZXRUaXRsZTtcclxuXHJcbiAgICBDb25zdGFudFN0cmluZy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMucHJvcGVydGllc1tcInZhbHVlXCJdKTtcclxuICAgIH07XHJcblxyXG5cdENvbnN0YW50U3RyaW5nLnByb3RvdHlwZS5zZXRWYWx1ZSA9IENvbnN0YW50TnVtYmVyLnByb3RvdHlwZS5zZXRWYWx1ZTtcclxuXHJcblx0Q29uc3RhbnRTdHJpbmcucHJvdG90eXBlLm9uRHJvcEZpbGUgPSBmdW5jdGlvbihmaWxlKVxyXG5cdHtcclxuXHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG5cdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpXHJcblx0XHR7XHJcblx0XHRcdHRoYXQuc2V0UHJvcGVydHkoXCJ2YWx1ZVwiLGUudGFyZ2V0LnJlc3VsdCk7XHJcblx0XHR9XHJcblx0XHRyZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcclxuXHR9XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy9zdHJpbmdcIiwgQ29uc3RhbnRTdHJpbmcpO1xyXG5cclxuICAgIGZ1bmN0aW9uIENvbnN0YW50T2JqZWN0KCkge1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib2JqXCIsIFwib2JqZWN0XCIpO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxMjAsIDMwXTtcclxuXHRcdHRoaXMuX29iamVjdCA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIENvbnN0YW50T2JqZWN0LnRpdGxlID0gXCJDb25zdCBPYmplY3RcIjtcclxuICAgIENvbnN0YW50T2JqZWN0LmRlc2MgPSBcIkNvbnN0YW50IE9iamVjdFwiO1xyXG5cclxuICAgIENvbnN0YW50T2JqZWN0LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fb2JqZWN0KTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwiYmFzaWMvb2JqZWN0XCIsIENvbnN0YW50T2JqZWN0ICk7XHJcblxyXG4gICAgZnVuY3Rpb24gQ29uc3RhbnRGaWxlKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ1cmxcIiwgXCJzdHJpbmdcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJmaWxlXCIsIFwic3RyaW5nXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJ1cmxcIiwgXCJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInR5cGVcIiwgXCJ0ZXh0XCIpO1xyXG4gICAgICAgIHRoaXMud2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJ0ZXh0XCIsXCJ1cmxcIixcIlwiLFwidXJsXCIpO1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIENvbnN0YW50RmlsZS50aXRsZSA9IFwiQ29uc3QgRmlsZVwiO1xyXG4gICAgQ29uc3RhbnRGaWxlLmRlc2MgPSBcIkZldGNoZXMgYSBmaWxlIGZyb20gYW4gdXJsXCI7XHJcbiAgICBDb25zdGFudEZpbGVbXCJAdHlwZVwiXSA9IHsgdHlwZTogXCJlbnVtXCIsIHZhbHVlczogW1widGV4dFwiLFwiYXJyYXlidWZmZXJcIixcImJsb2JcIixcImpzb25cIl0gfTtcclxuXHJcbiAgICBDb25zdGFudEZpbGUucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcInVybFwiKVxyXG5cdFx0e1xyXG5cdFx0XHRpZiggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PSBcIlwiKVxyXG5cdFx0XHRcdHRoaXMuX2RhdGEgPSBudWxsO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aGlzLmZldGNoRmlsZSh2YWx1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG4gICAgQ29uc3RhbnRGaWxlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB1cmwgPSB0aGlzLmdldElucHV0RGF0YSgwKSB8fCB0aGlzLnByb3BlcnRpZXMudXJsO1xyXG5cdFx0aWYodXJsICYmICh1cmwgIT0gdGhpcy5fdXJsIHx8IHRoaXMuX3R5cGUgIT0gdGhpcy5wcm9wZXJ0aWVzLnR5cGUpKVxyXG5cdFx0XHR0aGlzLmZldGNoRmlsZSh1cmwpO1xyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl9kYXRhICk7XHJcbiAgICB9O1xyXG5cclxuXHRDb25zdGFudEZpbGUucHJvdG90eXBlLnNldFZhbHVlID0gQ29uc3RhbnROdW1iZXIucHJvdG90eXBlLnNldFZhbHVlO1xyXG5cclxuICAgIENvbnN0YW50RmlsZS5wcm90b3R5cGUuZmV0Y2hGaWxlID0gZnVuY3Rpb24odXJsKSB7XHJcblx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblx0XHRpZighdXJsIHx8IHVybC5jb25zdHJ1Y3RvciAhPT0gU3RyaW5nKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGF0Ll9kYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IG51bGw7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblx0XHR0aGlzLl90eXBlID0gdGhpcy5wcm9wZXJ0aWVzLnR5cGU7XHJcbiAgICAgICAgaWYgKHVybC5zdWJzdHIoMCwgNCkgPT0gXCJodHRwXCIgJiYgTGl0ZUdyYXBoLnByb3h5KSB7XHJcbiAgICAgICAgICAgIHVybCA9IExpdGVHcmFwaC5wcm94eSArIHVybC5zdWJzdHIodXJsLmluZGV4T2YoXCI6XCIpICsgMyk7XHJcbiAgICAgICAgfVxyXG5cdFx0ZmV0Y2godXJsKVxyXG5cdFx0LnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuXHRcdFx0aWYoIXJlc3BvbnNlLm9rKVxyXG5cdFx0XHRcdCB0aHJvdyBuZXcgRXJyb3IoXCJGaWxlIG5vdCBmb3VuZFwiKTtcclxuXHJcblx0XHRcdGlmKHRoYXQucHJvcGVydGllcy50eXBlID09IFwiYXJyYXlidWZmZXJcIilcclxuXHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcclxuXHRcdFx0ZWxzZSBpZih0aGF0LnByb3BlcnRpZXMudHlwZSA9PSBcInRleHRcIilcclxuXHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xyXG5cdFx0XHRlbHNlIGlmKHRoYXQucHJvcGVydGllcy50eXBlID09IFwianNvblwiKVxyXG5cdFx0XHRcdHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcblx0XHRcdGVsc2UgaWYodGhhdC5wcm9wZXJ0aWVzLnR5cGUgPT0gXCJibG9iXCIpXHJcblx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcclxuXHRcdH0pXHJcblx0XHQudGhlbihmdW5jdGlvbihkYXRhKSB7XHJcblx0XHRcdHRoYXQuX2RhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICB0aGF0LmJveGNvbG9yID0gXCIjQUVBXCI7XHJcblx0XHR9KVxyXG5cdFx0LmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XHJcblx0XHRcdHRoYXQuX2RhdGEgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGF0LmJveGNvbG9yID0gXCJyZWRcIjtcclxuXHRcdFx0Y29uc29sZS5lcnJvcihcImVycm9yIGZldGNoaW5nIGZpbGU6XCIsdXJsKTtcclxuXHRcdH0pO1xyXG4gICAgfTtcclxuXHJcblx0Q29uc3RhbnRGaWxlLnByb3RvdHlwZS5vbkRyb3BGaWxlID0gZnVuY3Rpb24oZmlsZSlcclxuXHR7XHJcblx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblx0XHR0aGlzLl91cmwgPSBmaWxlLm5hbWU7XHJcblx0XHR0aGlzLl90eXBlID0gdGhpcy5wcm9wZXJ0aWVzLnR5cGU7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMudXJsID0gZmlsZS5uYW1lO1xyXG5cdFx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcblx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZSlcclxuXHRcdHtcclxuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IFwiI0FFQVwiO1xyXG5cdFx0XHR2YXIgdiA9IGUudGFyZ2V0LnJlc3VsdDtcclxuXHRcdFx0aWYoIHRoYXQucHJvcGVydGllcy50eXBlID09IFwianNvblwiIClcclxuXHRcdFx0XHR2ID0gSlNPTi5wYXJzZSh2KTtcclxuXHRcdFx0dGhhdC5fZGF0YSA9IHY7XHJcblx0XHR9XHJcblx0XHRpZih0aGF0LnByb3BlcnRpZXMudHlwZSA9PSBcImFycmF5YnVmZmVyXCIpXHJcblx0XHRcdHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcclxuXHRcdGVsc2UgaWYodGhhdC5wcm9wZXJ0aWVzLnR5cGUgPT0gXCJ0ZXh0XCIgfHwgdGhhdC5wcm9wZXJ0aWVzLnR5cGUgPT0gXCJqc29uXCIpXHJcblx0XHRcdHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xyXG5cdFx0ZWxzZSBpZih0aGF0LnByb3BlcnRpZXMudHlwZSA9PSBcImJsb2JcIilcclxuXHRcdFx0cmV0dXJuIHJlYWRlci5yZWFkQXNCaW5hcnlTdHJpbmcoZmlsZSk7XHJcblx0fVxyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvZmlsZVwiLCBDb25zdGFudEZpbGUpO1xyXG5cclxuXHJcbi8vdG8gc3RvcmUganNvbiBvYmplY3RzXHJcbmZ1bmN0aW9uIEpTT05QYXJzZSgpIHtcclxuXHR0aGlzLmFkZElucHV0KFwicGFyc2VcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcblx0dGhpcy5hZGRJbnB1dChcImpzb25cIiwgXCJzdHJpbmdcIik7XHJcblx0dGhpcy5hZGRPdXRwdXQoXCJkb25lXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcblx0dGhpcy5hZGRPdXRwdXQoXCJvYmplY3RcIiwgXCJvYmplY3RcIik7XHJcblx0dGhpcy53aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcImJ1dHRvblwiLFwicGFyc2VcIixcIlwiLHRoaXMucGFyc2UuYmluZCh0aGlzKSk7XHJcblx0dGhpcy5fc3RyID0gbnVsbDtcclxuXHR0aGlzLl9vYmogPSBudWxsO1xyXG59XHJcblxyXG5KU09OUGFyc2UudGl0bGUgPSBcIkpTT04gUGFyc2VcIjtcclxuSlNPTlBhcnNlLmRlc2MgPSBcIlBhcnNlcyBKU09OIFN0cmluZyBpbnRvIG9iamVjdFwiO1xyXG5cclxuSlNPTlBhcnNlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKClcclxue1xyXG5cdGlmKCF0aGlzLl9zdHIpXHJcblx0XHRyZXR1cm47XHJcblxyXG5cdHRyeSB7XHJcblx0XHR0aGlzLl9zdHIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuXHRcdHRoaXMuX29iaiA9IEpTT04ucGFyc2UodGhpcy5fc3RyKTtcclxuXHRcdHRoaXMuYm94Y29sb3IgPSBcIiNBRUFcIjtcclxuXHRcdHRoaXMudHJpZ2dlclNsb3QoMCk7XHJcblx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHR0aGlzLmJveGNvbG9yID0gXCJyZWRcIjtcclxuXHR9XHJcbn1cclxuXHJcbkpTT05QYXJzZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5fc3RyID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcblx0dGhpcy5zZXRPdXRwdXREYXRhKDEsIHRoaXMuX29iaik7XHJcbn07XHJcblxyXG5KU09OUGFyc2UucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24obmFtZSkge1xyXG5cdGlmKG5hbWUgPT0gXCJwYXJzZVwiKVxyXG5cdFx0dGhpcy5wYXJzZSgpO1xyXG59XHJcblxyXG5MaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL2pzb25wYXJzZVwiLCBKU09OUGFyc2UpO1x0XHJcblxyXG5cdC8vdG8gc3RvcmUganNvbiBvYmplY3RzXHJcbiAgICBmdW5jdGlvbiBDb25zdGFudERhdGEoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJkYXRhXCIsIFwib2JqZWN0XCIpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJ2YWx1ZVwiLCBcIlwiKTtcclxuICAgICAgICB0aGlzLndpZGdldCA9IHRoaXMuYWRkV2lkZ2V0KFwidGV4dFwiLFwianNvblwiLFwiXCIsXCJ2YWx1ZVwiKTtcclxuICAgICAgICB0aGlzLndpZGdldHNfdXAgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxNDAsIDMwXTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgQ29uc3RhbnREYXRhLnRpdGxlID0gXCJDb25zdCBEYXRhXCI7XHJcbiAgICBDb25zdGFudERhdGEuZGVzYyA9IFwiQ29uc3RhbnQgRGF0YVwiO1xyXG5cclxuICAgIENvbnN0YW50RGF0YS5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMud2lkZ2V0LnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT0gXCJcIikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLmJveGNvbG9yID0gXCIjQUVBXCI7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBcInJlZFwiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgQ29uc3RhbnREYXRhLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdmFsdWUpO1xyXG4gICAgfTtcclxuXHJcblx0Q29uc3RhbnREYXRhLnByb3RvdHlwZS5zZXRWYWx1ZSA9IENvbnN0YW50TnVtYmVyLnByb3RvdHlwZS5zZXRWYWx1ZTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL2RhdGFcIiwgQ29uc3RhbnREYXRhKTtcclxuXHJcblx0Ly90byBzdG9yZSBqc29uIG9iamVjdHNcclxuICAgIGZ1bmN0aW9uIENvbnN0YW50QXJyYXkoKSB7XHJcblx0XHR0aGlzLl92YWx1ZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJqc29uXCIsIFwiXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiYXJyYXlPdXRcIiwgXCJhcnJheVwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwibGVuZ3RoXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJ2YWx1ZVwiLCBcIltdXCIpO1xyXG4gICAgICAgIHRoaXMud2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJ0ZXh0XCIsXCJhcnJheVwiLHRoaXMucHJvcGVydGllcy52YWx1ZSxcInZhbHVlXCIpO1xyXG4gICAgICAgIHRoaXMud2lkZ2V0c191cCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzE0MCwgNTBdO1xyXG4gICAgfVxyXG5cclxuICAgIENvbnN0YW50QXJyYXkudGl0bGUgPSBcIkNvbnN0IEFycmF5XCI7XHJcbiAgICBDb25zdGFudEFycmF5LmRlc2MgPSBcIkNvbnN0YW50IEFycmF5XCI7XHJcblxyXG4gICAgQ29uc3RhbnRBcnJheS5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMud2lkZ2V0LnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT0gXCJcIikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cnkge1xyXG5cdFx0XHRpZih2YWx1ZVswXSAhPSBcIltcIilcclxuXHQgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IEpTT04ucGFyc2UoXCJbXCIgKyB2YWx1ZSArIFwiXVwiKTtcclxuXHRcdFx0ZWxzZVxyXG5cdCAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBcIiNBRUFcIjtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwicmVkXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBDb25zdGFudEFycmF5LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0aWYodiAmJiB2Lmxlbmd0aCkgLy9jbG9uZVxyXG5cdFx0e1xyXG5cdFx0XHRpZighdGhpcy5fdmFsdWUpXHJcblx0XHRcdFx0dGhpcy5fdmFsdWUgPSBuZXcgQXJyYXkoKTtcclxuXHRcdFx0dGhpcy5fdmFsdWUubGVuZ3RoID0gdi5sZW5ndGg7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgKytpKVxyXG5cdFx0XHRcdHRoaXMuX3ZhbHVlW2ldID0gdltpXTtcclxuXHRcdH1cclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl92YWx1ZSk7XHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMSwgdGhpcy5fdmFsdWUgPyAoIHRoaXMuX3ZhbHVlLmxlbmd0aCB8fCAwKSA6IDAgKTtcclxuICAgIH07XHJcblxyXG5cdENvbnN0YW50QXJyYXkucHJvdG90eXBlLnNldFZhbHVlID0gQ29uc3RhbnROdW1iZXIucHJvdG90eXBlLnNldFZhbHVlO1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvYXJyYXlcIiwgQ29uc3RhbnRBcnJheSk7XHJcblxyXG5cdGZ1bmN0aW9uIFNldEFycmF5KClcclxuXHR7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImFyclwiLCBcImFycmF5XCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ2YWx1ZVwiLCBcIlwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcImFyclwiLCBcImFycmF5XCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBpbmRleDogMCB9O1xyXG4gICAgICAgIHRoaXMud2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcImlcIix0aGlzLnByb3BlcnRpZXMuaW5kZXgsXCJpbmRleFwiLHtwcmVjaXNpb246IDAsIHN0ZXA6IDEwLCBtaW46IDB9KTtcclxuXHR9XHJcblxyXG4gICAgU2V0QXJyYXkudGl0bGUgPSBcIlNldCBBcnJheVwiO1xyXG4gICAgU2V0QXJyYXkuZGVzYyA9IFwiU2V0cyBpbmRleCBvZiBhcnJheVwiO1xyXG5cclxuICAgIFNldEFycmF5LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYXJyID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRpZighYXJyKVxyXG5cdFx0XHRyZXR1cm47XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuXHRcdGlmKHYgPT09IHVuZGVmaW5lZCApXHJcblx0XHRcdHJldHVybjtcclxuXHRcdGlmKHRoaXMucHJvcGVydGllcy5pbmRleClcclxuXHRcdFx0YXJyWyBNYXRoLmZsb29yKHRoaXMucHJvcGVydGllcy5pbmRleCkgXSA9IHY7XHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCxhcnIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL3NldF9hcnJheVwiLCBTZXRBcnJheSApO1xyXG5cclxuICAgIGZ1bmN0aW9uIEFycmF5RWxlbWVudCgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiYXJyYXlcIiwgXCJhcnJheSx0YWJsZSxzdHJpbmdcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluZGV4XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwidmFsdWVcIiwgXCJcIik7XHJcblx0XHR0aGlzLmFkZFByb3BlcnR5KFwiaW5kZXhcIiwwKTtcclxuICAgIH1cclxuXHJcbiAgICBBcnJheUVsZW1lbnQudGl0bGUgPSBcIkFycmF5W2ldXCI7XHJcbiAgICBBcnJheUVsZW1lbnQuZGVzYyA9IFwiUmV0dXJucyBhbiBlbGVtZW50IGZyb20gYW4gYXJyYXlcIjtcclxuXHJcbiAgICBBcnJheUVsZW1lbnQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG5cdFx0aWYoaW5kZXggPT0gbnVsbClcclxuXHRcdFx0aW5kZXggPSB0aGlzLnByb3BlcnRpZXMuaW5kZXg7XHJcblx0XHRpZihhcnJheSA9PSBudWxsIHx8IGluZGV4ID09IG51bGwgKVxyXG5cdFx0XHRyZXR1cm47XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIGFycmF5W01hdGguZmxvb3IoTnVtYmVyKGluZGV4KSldICk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvYXJyYXlbXVwiLCBBcnJheUVsZW1lbnQpO1xyXG5cclxuICAgIGZ1bmN0aW9uIFRhYmxlRWxlbWVudCgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwidGFibGVcIiwgXCJ0YWJsZVwiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwicm93XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJjb2xcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ2YWx1ZVwiLCBcIlwiKTtcclxuXHRcdHRoaXMuYWRkUHJvcGVydHkoXCJyb3dcIiwwKTtcclxuXHRcdHRoaXMuYWRkUHJvcGVydHkoXCJjb2x1bW5cIiwwKTtcclxuICAgIH1cclxuXHJcbiAgICBUYWJsZUVsZW1lbnQudGl0bGUgPSBcIlRhYmxlW3Jvd11bY29sXVwiO1xyXG4gICAgVGFibGVFbGVtZW50LmRlc2MgPSBcIlJldHVybnMgYW4gZWxlbWVudCBmcm9tIGEgdGFibGVcIjtcclxuXHJcbiAgICBUYWJsZUVsZW1lbnQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0YWJsZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIHZhciByb3cgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICB2YXIgY29sID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XHJcblx0XHRpZihyb3cgPT0gbnVsbClcclxuXHRcdFx0cm93ID0gdGhpcy5wcm9wZXJ0aWVzLnJvdztcclxuXHRcdGlmKGNvbCA9PSBudWxsKVxyXG5cdFx0XHRjb2wgPSB0aGlzLnByb3BlcnRpZXMuY29sdW1uO1xyXG5cdFx0aWYodGFibGUgPT0gbnVsbCB8fCByb3cgPT0gbnVsbCB8fCBjb2wgPT0gbnVsbClcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0dmFyIHJvdyA9IHRhYmxlW01hdGguZmxvb3IoTnVtYmVyKHJvdykpXTtcclxuXHRcdGlmKHJvdylcclxuXHQgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCByb3dbTWF0aC5mbG9vcihOdW1iZXIoY29sKSldICk7XHJcblx0XHRlbHNlXHJcblx0ICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgbnVsbCApO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL3RhYmxlW11bXVwiLCBUYWJsZUVsZW1lbnQpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE9iamVjdFByb3BlcnR5KCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJvYmpcIiwgXCJvYmplY3RcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJwcm9wZXJ0eVwiLCAwKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwidmFsdWVcIiwgMCk7XHJcbiAgICAgICAgdGhpcy53aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcInRleHRcIixcInByb3AuXCIsXCJcIix0aGlzLnNldFZhbHVlLmJpbmQodGhpcykgKTtcclxuICAgICAgICB0aGlzLndpZGdldHNfdXAgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxNDAsIDMwXTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgT2JqZWN0UHJvcGVydHkudGl0bGUgPSBcIk9iamVjdCBwcm9wZXJ0eVwiO1xyXG4gICAgT2JqZWN0UHJvcGVydHkuZGVzYyA9IFwiT3V0cHV0cyB0aGUgcHJvcGVydHkgb2YgYW4gb2JqZWN0XCI7XHJcblxyXG4gICAgT2JqZWN0UHJvcGVydHkucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24odikge1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSA9IHY7XHJcbiAgICAgICAgdGhpcy53aWRnZXQudmFsdWUgPSB2O1xyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3RQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiaW4uXCIgKyB0aGlzLnByb3BlcnRpZXMudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3RQcm9wZXJ0eS5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMud2lkZ2V0LnZhbHVlID0gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIE9iamVjdFByb3BlcnR5LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIGRhdGFbdGhpcy5wcm9wZXJ0aWVzLnZhbHVlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL29iamVjdF9wcm9wZXJ0eVwiLCBPYmplY3RQcm9wZXJ0eSk7XHJcblxyXG4gICAgZnVuY3Rpb24gT2JqZWN0S2V5cygpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwib2JqXCIsIFwiXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwia2V5c1wiLCBcImFycmF5XCIpO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxNDAsIDMwXTtcclxuICAgIH1cclxuXHJcbiAgICBPYmplY3RLZXlzLnRpdGxlID0gXCJPYmplY3Qga2V5c1wiO1xyXG4gICAgT2JqZWN0S2V5cy5kZXNjID0gXCJPdXRwdXRzIGFuIGFycmF5IHdpdGggdGhlIGtleXMgb2YgYW4gb2JqZWN0XCI7XHJcblxyXG4gICAgT2JqZWN0S2V5cy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBPYmplY3Qua2V5cyhkYXRhKSApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy9vYmplY3Rfa2V5c1wiLCBPYmplY3RLZXlzKTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIFNldE9iamVjdCgpXHJcblx0e1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJvYmpcIiwgXCJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInZhbHVlXCIsIFwiXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib2JqXCIsIFwiXCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBwcm9wZXJ0eTogXCJcIiB9O1xyXG4gICAgICAgIHRoaXMubmFtZV93aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcInRleHRcIixcInByb3AuXCIsdGhpcy5wcm9wZXJ0aWVzLnByb3BlcnR5LFwicHJvcGVydHlcIik7XHJcblx0fVxyXG5cclxuICAgIFNldE9iamVjdC50aXRsZSA9IFwiU2V0IE9iamVjdFwiO1xyXG4gICAgU2V0T2JqZWN0LmRlc2MgPSBcIkFkZHMgcHJvcGVydGllc3J0eSB0byBvYmplY3RcIjtcclxuXHJcbiAgICBTZXRPYmplY3QucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBvYmogPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdGlmKCFvYmopXHJcblx0XHRcdHJldHVybjtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG5cdFx0aWYodiA9PT0gdW5kZWZpbmVkIClcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0aWYodGhpcy5wcm9wZXJ0aWVzLnByb3BlcnR5KVxyXG5cdFx0XHRvYmpbIHRoaXMucHJvcGVydGllcy5wcm9wZXJ0eSBdID0gdjtcclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLG9iaik7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvc2V0X29iamVjdFwiLCBTZXRPYmplY3QgKTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gTWVyZ2VPYmplY3RzKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJBXCIsIFwib2JqZWN0XCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJCXCIsIFwib2JqZWN0XCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwib2JqZWN0XCIpO1xyXG5cdFx0dGhpcy5fcmVzdWx0ID0ge307XHJcblx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblx0XHR0aGlzLmFkZFdpZGdldChcImJ1dHRvblwiLFwiY2xlYXJcIixcIlwiLGZ1bmN0aW9uKCl7XHJcblx0XHRcdHRoYXQuX3Jlc3VsdCA9IHt9O1xyXG5cdFx0fSk7XHJcblx0XHR0aGlzLnNpemUgPSB0aGlzLmNvbXB1dGVTaXplKCk7XHJcbiAgICB9XHJcblxyXG4gICAgTWVyZ2VPYmplY3RzLnRpdGxlID0gXCJNZXJnZSBPYmplY3RzXCI7XHJcbiAgICBNZXJnZU9iamVjdHMuZGVzYyA9IFwiQ3JlYXRlcyBhbiBvYmplY3QgY29weWluZyBwcm9wZXJ0aWVzIGZyb20gb3RoZXJzXCI7XHJcblxyXG4gICAgTWVyZ2VPYmplY3RzLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgQSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIHZhciBCID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcblx0XHR2YXIgQyA9IHRoaXMuX3Jlc3VsdDtcclxuXHRcdGlmKEEpXHJcblx0XHRcdGZvcih2YXIgaSBpbiBBKVxyXG5cdFx0XHRcdENbaV0gPSBBW2ldO1xyXG5cdFx0aWYoQilcclxuXHRcdFx0Zm9yKHZhciBpIGluIEIpXHJcblx0XHRcdFx0Q1tpXSA9IEJbaV07XHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCxDKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy9tZXJnZV9vYmplY3RzXCIsIE1lcmdlT2JqZWN0cyApO1xyXG5cclxuICAgIC8vU3RvcmUgYXMgdmFyaWFibGVcclxuICAgIGZ1bmN0aW9uIFZhcmlhYmxlKCkge1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs2MCwgMzBdO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgdmFybmFtZTogXCJteW5hbWVcIiwgY29udGFpbmVyOiBWYXJpYWJsZS5MSVRFR1JBUEggfTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBWYXJpYWJsZS50aXRsZSA9IFwiVmFyaWFibGVcIjtcclxuICAgIFZhcmlhYmxlLmRlc2MgPSBcInN0b3JlL3JlYWQgdmFyaWFibGUgdmFsdWVcIjtcclxuXHJcblx0VmFyaWFibGUuTElURUdSQVBIID0gMDsgLy9iZXR3ZWVuIGFsbCBncmFwaHNcclxuXHRWYXJpYWJsZS5HUkFQSCA9IDE7XHQvL29ubHkgaW5zaWRlIHRoaXMgZ3JhcGhcclxuXHRWYXJpYWJsZS5HTE9CQUxTQ09QRSA9IDI7XHQvL2F0dGFjaGVkIHRvIFdpbmRvd1xyXG5cclxuICAgIFZhcmlhYmxlW1wiQGNvbnRhaW5lclwiXSA9IHsgdHlwZTogXCJlbnVtXCIsIHZhbHVlczoge1wibGl0ZWdyYXBoXCI6VmFyaWFibGUuTElURUdSQVBILCBcImdyYXBoXCI6VmFyaWFibGUuR1JBUEgsXCJnbG9iYWxcIjogVmFyaWFibGUuR0xPQkFMU0NPUEV9IH07XHJcblxyXG4gICAgVmFyaWFibGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XHJcblxyXG5cdFx0aWYodGhpcy5pc0lucHV0Q29ubmVjdGVkKDApKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRcdGNvbnRhaW5lclsgdGhpcy5wcm9wZXJ0aWVzLnZhcm5hbWUgXSA9IHRoaXMudmFsdWU7XHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLnZhbHVlICk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIGNvbnRhaW5lclsgdGhpcy5wcm9wZXJ0aWVzLnZhcm5hbWUgXSApO1xyXG4gICAgfTtcclxuXHJcblx0VmFyaWFibGUucHJvdG90eXBlLmdldENvbnRhaW5lciA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHRzd2l0Y2godGhpcy5wcm9wZXJ0aWVzLmNvbnRhaW5lcilcclxuXHRcdHtcclxuXHRcdFx0Y2FzZSBWYXJpYWJsZS5HUkFQSDpcclxuXHRcdFx0XHRpZih0aGlzLmdyYXBoKVxyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZ3JhcGgudmFycztcclxuXHRcdFx0XHRyZXR1cm4ge307XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgVmFyaWFibGUuR0xPQkFMU0NPUEU6XHJcblx0XHRcdFx0cmV0dXJuIGdsb2JhbDtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBWYXJpYWJsZS5MSVRFR1JBUEg6XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0cmV0dXJuIExpdGVHcmFwaC5HbG9iYWxzO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcbiAgICBWYXJpYWJsZS5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnZhcm5hbWU7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvdmFyaWFibGVcIiwgVmFyaWFibGUpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGxlbmd0aCh2KSB7XHJcbiAgICAgICAgaWYodiAmJiB2Lmxlbmd0aCAhPSBudWxsKVxyXG5cdFx0XHRyZXR1cm4gTnVtYmVyKHYubGVuZ3RoKTtcclxuXHRcdHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIExpdGVHcmFwaC53cmFwRnVuY3Rpb25Bc05vZGUoXHJcbiAgICAgICAgXCJiYXNpYy9sZW5ndGhcIixcclxuICAgICAgICBsZW5ndGgsXHJcbiAgICAgICAgW1wiXCJdLFxyXG4gICAgICAgIFwibnVtYmVyXCJcclxuICAgICk7XHJcblxyXG4gICAgZnVuY3Rpb24gbGVuZ3RoKHYpIHtcclxuICAgICAgICBpZih2ICYmIHYubGVuZ3RoICE9IG51bGwpXHJcblx0XHRcdHJldHVybiBOdW1iZXIodi5sZW5ndGgpO1xyXG5cdFx0cmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgTGl0ZUdyYXBoLndyYXBGdW5jdGlvbkFzTm9kZShcclxuICAgICAgICBcImJhc2ljL25vdFwiLFxyXG4gICAgICAgIGZ1bmN0aW9uKGEpeyByZXR1cm4gIWE7IH0sXHJcbiAgICAgICAgW1wiXCJdLFxyXG4gICAgICAgIFwiYm9vbGVhblwiXHJcbiAgICApO1xyXG5cclxuXHRmdW5jdGlvbiBEb3dubG9hZERhdGEoKSB7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzYwLCAzMF07XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImRhdGFcIiwgMCApO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJkb3dubG9hZFwiLCBMaXRlR3JhcGguQUNUSU9OICk7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IGZpbGVuYW1lOiBcImRhdGEuanNvblwiIH07XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XHJcblx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblx0XHR0aGlzLmFkZFdpZGdldChcImJ1dHRvblwiLFwiRG93bmxvYWRcIixcIlwiLCBmdW5jdGlvbih2KXtcclxuXHRcdFx0aWYoIXRoYXQudmFsdWUpXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR0aGF0LmRvd25sb2FkQXNGaWxlKCk7XHJcblx0XHR9KTtcclxuICAgIH1cclxuXHJcbiAgICBEb3dubG9hZERhdGEudGl0bGUgPSBcIkRvd25sb2FkXCI7XHJcbiAgICBEb3dubG9hZERhdGEuZGVzYyA9IFwiRG93bmxvYWQgc29tZSBkYXRhXCI7XHJcblxyXG5cdERvd25sb2FkRGF0YS5wcm90b3R5cGUuZG93bmxvYWRBc0ZpbGUgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0aWYodGhpcy52YWx1ZSA9PSBudWxsKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIHN0ciA9IG51bGw7XHJcblx0XHRpZih0aGlzLnZhbHVlLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpXHJcblx0XHRcdHN0ciA9IHRoaXMudmFsdWU7XHJcblx0XHRlbHNlXHJcblx0XHRcdHN0ciA9IEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpO1xyXG5cclxuXHRcdHZhciBmaWxlID0gbmV3IEJsb2IoW3N0cl0pO1xyXG5cdFx0dmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoIGZpbGUgKTtcclxuXHRcdHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcblx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnaHJlZicsIHVybCk7XHJcblx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCB0aGlzLnByb3BlcnRpZXMuZmlsZW5hbWUgKTtcclxuXHRcdGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XHJcblx0XHRlbGVtZW50LmNsaWNrKCk7XHJcblx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xyXG5cdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKXsgVVJMLnJldm9rZU9iamVjdFVSTCggdXJsICk7IH0sIDEwMDAqNjAgKTsgLy93YWl0IG9uZSBtaW51dGUgdG8gcmV2b2tlIHVybFxyXG5cdH1cclxuXHJcbiAgICBEb3dubG9hZERhdGEucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xyXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKXsgdGhhdC5kb3dubG9hZEFzRmlsZSgpOyB9LCAxMDApOyAvL2RlZmVycmVkIHRvIGF2b2lkIGJsb2NraW5nIHRoZSByZW5kZXJlciB3aXRoIHRoZSBwb3B1cFxyXG5cdH1cclxuXHJcbiAgICBEb3dubG9hZERhdGEucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlucHV0c1swXSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBEb3dubG9hZERhdGEucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMuZmlsZW5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL2Rvd25sb2FkXCIsIERvd25sb2FkRGF0YSk7XHJcblxyXG5cclxuXHJcbiAgICAvL1dhdGNoIGEgdmFsdWUgaW4gdGhlIGVkaXRvclxyXG4gICAgZnVuY3Rpb24gV2F0Y2goKSB7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzYwLCAzMF07XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInZhbHVlXCIsIDAsIHsgbGFiZWw6IFwiXCIgfSk7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgV2F0Y2gudGl0bGUgPSBcIldhdGNoXCI7XHJcbiAgICBXYXRjaC5kZXNjID0gXCJTaG93IHZhbHVlIG9mIGlucHV0XCI7XHJcblxyXG4gICAgV2F0Y2gucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlucHV0c1swXSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBXYXRjaC5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRzWzBdLmxhYmVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50aXRsZTtcclxuICAgIH07XHJcblxyXG4gICAgV2F0Y2gudG9TdHJpbmcgPSBmdW5jdGlvbihvKSB7XHJcbiAgICAgICAgaWYgKG8gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvLmNvbnN0cnVjdG9yID09PSBOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG8udG9GaXhlZCgzKTtcclxuICAgICAgICB9IGVsc2UgaWYgKG8uY29uc3RydWN0b3IgPT09IEFycmF5KSB7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBcIltcIjtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gV2F0Y2gudG9TdHJpbmcob1tpXSkgKyAoaSArIDEgIT0gby5sZW5ndGggPyBcIixcIiA6IFwiXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0ciArPSBcIl1cIjtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKG8pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgV2F0Y2gucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcclxuICAgICAgICAvL3Nob3cgdGhlIGN1cnJlbnQgdmFsdWVcclxuICAgICAgICB0aGlzLmlucHV0c1swXS5sYWJlbCA9IFdhdGNoLnRvU3RyaW5nKHRoaXMudmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImJhc2ljL3dhdGNoXCIsIFdhdGNoKTtcclxuXHJcbiAgICAvL2luIGNhc2Ugb25lIHR5cGUgZG9lc250IG1hdGNoIG90aGVyIHR5cGUgYnV0IHlvdSB3YW50IHRvIGNvbm5lY3QgdGhlbSBhbnl3YXlcclxuICAgIGZ1bmN0aW9uIENhc3QoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIDApO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIDApO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs0MCwgMzBdO1xyXG4gICAgfVxyXG5cclxuICAgIENhc3QudGl0bGUgPSBcIkNhc3RcIjtcclxuICAgIENhc3QuZGVzYyA9IFwiQWxsb3dzIHRvIGNvbm5lY3QgZGlmZmVyZW50IHR5cGVzXCI7XHJcblxyXG4gICAgQ2FzdC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuZ2V0SW5wdXREYXRhKDApKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy9jYXN0XCIsIENhc3QpO1xyXG5cclxuICAgIC8vU2hvdyB2YWx1ZSBpbnNpZGUgdGhlIGRlYnVnIGNvbnNvbGVcclxuICAgIGZ1bmN0aW9uIENvbnNvbGUoKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlID0gTGl0ZUdyYXBoLk9OX0VWRU5UO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgMzBdO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJtc2dcIiwgXCJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImxvZ1wiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJtc2dcIiwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgQ29uc29sZS50aXRsZSA9IFwiQ29uc29sZVwiO1xyXG4gICAgQ29uc29sZS5kZXNjID0gXCJTaG93IHZhbHVlIGluc2lkZSB0aGUgY29uc29sZVwiO1xyXG5cclxuICAgIENvbnNvbGUucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xyXG4gICAgICAgIC8vIHBhcmFtIGlzIHRoZSBhY3Rpb25cclxuICAgICAgICB2YXIgbXNnID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7IC8vZ2V0SW5wdXREYXRhQnlOYW1lKFwibXNnXCIpO1xyXG4gICAgICAgIC8vaWYgKG1zZyA9PSBudWxsIHx8IHR5cGVvZiBtc2cgPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xyXG4gICAgICAgIGlmICghbXNnKSBtc2cgPSB0aGlzLnByb3BlcnRpZXMubXNnO1xyXG4gICAgICAgIGlmICghbXNnKSBtc2cgPSBcIkV2ZW50OiBcIitwYXJhbTsgLy8gbXNnIGlzIHVuZGVmaW5lZCBpZiB0aGUgc2xvdCBpcyBsb3N0P1xyXG4gICAgICAgIGlmIChhY3Rpb24gPT0gXCJsb2dcIikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtc2cpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09IFwid2FyblwiKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09IFwiZXJyb3JcIikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBDb25zb2xlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgbXNnID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7IC8vZ2V0SW5wdXREYXRhQnlOYW1lKFwibXNnXCIpO1xyXG4gICAgICAgIGlmICghbXNnKSBtc2cgPSB0aGlzLnByb3BlcnRpZXMubXNnO1xyXG4gICAgICAgIGlmIChtc2cgIT0gbnVsbCAmJiB0eXBlb2YgbXNnICE9IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1zZyA9IG1zZztcclxuICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIENvbnNvbGUucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgW1wibG9nXCIsIExpdGVHcmFwaC5BQ1RJT05dLFxyXG4gICAgICAgICAgICBbXCJ3YXJuXCIsIExpdGVHcmFwaC5BQ1RJT05dLFxyXG4gICAgICAgICAgICBbXCJlcnJvclwiLCBMaXRlR3JhcGguQUNUSU9OXVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYmFzaWMvY29uc29sZVwiLCBDb25zb2xlKTtcclxuXHJcbiAgICAvL1Nob3cgdmFsdWUgaW5zaWRlIHRoZSBkZWJ1ZyBjb25zb2xlXHJcbiAgICBmdW5jdGlvbiBBbGVydCgpIHtcclxuICAgICAgICB0aGlzLm1vZGUgPSBMaXRlR3JhcGguT05fRVZFTlQ7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIm1zZ1wiLCBcIlwiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMud2lkZ2V0ID0gdGhpcy5hZGRXaWRnZXQoXCJ0ZXh0XCIsIFwiVGV4dFwiLCBcIlwiLCBcIm1zZ1wiKTtcclxuICAgICAgICB0aGlzLndpZGdldHNfdXAgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFsyMDAsIDMwXTtcclxuICAgIH1cclxuXHJcbiAgICBBbGVydC50aXRsZSA9IFwiQWxlcnRcIjtcclxuICAgIEFsZXJ0LmRlc2MgPSBcIlNob3cgYW4gYWxlcnQgd2luZG93XCI7XHJcbiAgICBBbGVydC5jb2xvciA9IFwiIzUxMFwiO1xyXG5cclxuICAgIEFsZXJ0LnByb3RvdHlwZS5vbkNvbmZpZ3VyZSA9IGZ1bmN0aW9uKG8pIHtcclxuICAgICAgICB0aGlzLndpZGdldC52YWx1ZSA9IG8ucHJvcGVydGllcy5tc2c7XHJcbiAgICB9O1xyXG5cclxuICAgIEFsZXJ0LnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0pIHtcclxuICAgICAgICB2YXIgbXNnID0gdGhpcy5wcm9wZXJ0aWVzLm1zZztcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBhbGVydChtc2cpO1xyXG4gICAgICAgIH0sIDEwKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy9hbGVydFwiLCBBbGVydCk7XHJcblxyXG4gICAgLy9FeGVjaXRlcyBzaW1wbGUgY29kZVxyXG4gICAgZnVuY3Rpb24gTm9kZVNjcmlwdCgpIHtcclxuICAgICAgICB0aGlzLnNpemUgPSBbNjAsIDMwXTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwib25FeGVjdXRlXCIsIFwicmV0dXJuIEE7XCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJBXCIsIDApO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJCXCIsIDApO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIDApO1xyXG5cclxuICAgICAgICB0aGlzLl9mdW5jID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICBOb2RlU2NyaXB0LnByb3RvdHlwZS5vbkNvbmZpZ3VyZSA9IGZ1bmN0aW9uKG8pIHtcclxuICAgICAgICBpZiAoby5wcm9wZXJ0aWVzLm9uRXhlY3V0ZSAmJiBMaXRlR3JhcGguYWxsb3dfc2NyaXB0cylcclxuICAgICAgICAgICAgdGhpcy5jb21waWxlQ29kZShvLnByb3BlcnRpZXMub25FeGVjdXRlKTtcclxuXHRcdGVsc2VcclxuXHRcdFx0Y29uc29sZS53YXJuKFwiU2NyaXB0IG5vdCBjb21waWxlZCwgTGl0ZUdyYXBoLmFsbG93X3NjcmlwdHMgaXMgZmFsc2VcIik7XHJcbiAgICB9O1xyXG5cclxuICAgIE5vZGVTY3JpcHQudGl0bGUgPSBcIlNjcmlwdFwiO1xyXG4gICAgTm9kZVNjcmlwdC5kZXNjID0gXCJleGVjdXRlcyBhIGNvZGUgKG1heCAyNTYgY2hhcmFjdGVycylcIjtcclxuXHJcbiAgICBOb2RlU2NyaXB0LndpZGdldHNfaW5mbyA9IHtcclxuICAgICAgICBvbkV4ZWN1dGU6IHsgdHlwZTogXCJjb2RlXCIgfVxyXG4gICAgfTtcclxuXHJcbiAgICBOb2RlU2NyaXB0LnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJvbkV4ZWN1dGVcIiAmJiBMaXRlR3JhcGguYWxsb3dfc2NyaXB0cylcclxuICAgICAgICAgICAgdGhpcy5jb21waWxlQ29kZSh2YWx1ZSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdGNvbnNvbGUud2FybihcIlNjcmlwdCBub3QgY29tcGlsZWQsIExpdGVHcmFwaC5hbGxvd19zY3JpcHRzIGlzIGZhbHNlXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBOb2RlU2NyaXB0LnByb3RvdHlwZS5jb21waWxlQ29kZSA9IGZ1bmN0aW9uKGNvZGUpIHtcclxuICAgICAgICB0aGlzLl9mdW5jID0gbnVsbDtcclxuICAgICAgICBpZiAoY29kZS5sZW5ndGggPiAyNTYpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU2NyaXB0IHRvbyBsb25nLCBtYXggMjU2IGNoYXJzXCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBjb2RlX2xvdyA9IGNvZGUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgdmFyIGZvcmJpZGRlbl93b3JkcyA9IFtcclxuICAgICAgICAgICAgICAgIFwic2NyaXB0XCIsXHJcbiAgICAgICAgICAgICAgICBcImJvZHlcIixcclxuICAgICAgICAgICAgICAgIFwiZG9jdW1lbnRcIixcclxuICAgICAgICAgICAgICAgIFwiZXZhbFwiLFxyXG4gICAgICAgICAgICAgICAgXCJub2Rlc2NyaXB0XCIsXHJcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCJcclxuICAgICAgICAgICAgXTsgLy9iYWQgc2VjdXJpdHkgc29sdXRpb25cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JiaWRkZW5fd29yZHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb2RlX2xvdy5pbmRleE9mKGZvcmJpZGRlbl93b3Jkc1tpXSkgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJpbnZhbGlkIHNjcmlwdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bmMgPSBuZXcgRnVuY3Rpb24oXCJBXCIsIFwiQlwiLCBcIkNcIiwgXCJEQVRBXCIsIFwibm9kZVwiLCBjb2RlKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcGFyc2luZyBzY3JpcHRcIik7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIE5vZGVTY3JpcHQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZnVuYykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgQSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgICAgICB2YXIgQiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgICAgICB2YXIgQyA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fZnVuYyhBLCBCLCBDLCB0aGlzLmRhdGEsIHRoaXMpKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHNjcmlwdFwiKTtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTm9kZVNjcmlwdC5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtbXCJDXCIsIFwiXCJdXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy9zY3JpcHRcIiwgTm9kZVNjcmlwdCk7XHJcbiAgICBcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gR2VuZXJpY0NvbXBhcmUoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkFcIiwgMCk7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkJcIiwgMCk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ0cnVlXCIsIFwiYm9vbGVhblwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcImZhbHNlXCIsIFwiYm9vbGVhblwiKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiQVwiLCAxKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiQlwiLCAxKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiT1BcIiwgXCI9PVwiLCBcImVudW1cIiwgeyB2YWx1ZXM6IEdlbmVyaWNDb21wYXJlLnZhbHVlcyB9KTtcclxuXHRcdHRoaXMuYWRkV2lkZ2V0KFwiY29tYm9cIixcIk9wLlwiLHRoaXMucHJvcGVydGllcy5PUCx7IHByb3BlcnR5OiBcIk9QXCIsIHZhbHVlczogR2VuZXJpY0NvbXBhcmUudmFsdWVzIH0gKTtcclxuXHJcbiAgICAgICAgdGhpcy5zaXplID0gWzgwLCA2MF07XHJcbiAgICB9XHJcblxyXG4gICAgR2VuZXJpY0NvbXBhcmUudmFsdWVzID0gW1wiPT1cIiwgXCIhPVwiXTsgLy9bXCI+XCIsIFwiPFwiLCBcIj09XCIsIFwiIT1cIiwgXCI8PVwiLCBcIj49XCIsIFwifHxcIiwgXCImJlwiIF07XHJcbiAgICBHZW5lcmljQ29tcGFyZVtcIkBPUFwiXSA9IHtcclxuICAgICAgICB0eXBlOiBcImVudW1cIixcclxuICAgICAgICB0aXRsZTogXCJvcGVyYXRpb25cIixcclxuICAgICAgICB2YWx1ZXM6IEdlbmVyaWNDb21wYXJlLnZhbHVlc1xyXG4gICAgfTtcclxuXHJcbiAgICBHZW5lcmljQ29tcGFyZS50aXRsZSA9IFwiQ29tcGFyZSAqXCI7XHJcbiAgICBHZW5lcmljQ29tcGFyZS5kZXNjID0gXCJldmFsdWF0ZXMgY29uZGl0aW9uIGJldHdlZW4gQSBhbmQgQlwiO1xyXG5cclxuICAgIEdlbmVyaWNDb21wYXJlLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBcIipBIFwiICsgdGhpcy5wcm9wZXJ0aWVzLk9QICsgXCIgKkJcIjtcclxuICAgIH07XHJcblxyXG4gICAgR2VuZXJpY0NvbXBhcmUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBBID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKEEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBBID0gdGhpcy5wcm9wZXJ0aWVzLkE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLkEgPSBBO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAoQiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIEIgPSB0aGlzLnByb3BlcnRpZXMuQjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuQiA9IEI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBBID09IHR5cGVvZiBCKXtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnByb3BlcnRpZXMuT1ApIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCI9PVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIiE9XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhdmVyc2UgYm90aCBvYmplY3RzLi4gY29uc2lkZXIgdGhhdCB0aGlzIGlzIG5vdCBhIHRydWUgZGVlcCBjaGVjayEgY29uc2lkZXIgdW5kZXJzY29yZSBvciBvdGhlciBsaWJyYXJ5IGZvciB0aGF0aCA6OiBfaXNFcXVhbCgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2godHlwZW9mIEEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYVByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoQSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYlByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoQik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYVByb3BzLmxlbmd0aCAhPSBiUHJvcHMubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYVByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gYVByb3BzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBW3Byb3BOYW1lXSAhPT0gQltwcm9wTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBBID09IEI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuT1AgPT0gXCIhPVwiKSByZXN1bHQgPSAhcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgLypjYXNlIFwiPlwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEEgPiBCO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIjxcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBBIDwgQjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCI8PVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEEgPD0gQjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCI+PVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEEgPj0gQjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ8fFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEEgfHwgQjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCImJlwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEEgJiYgQjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCByZXN1bHQpO1xyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgxLCAhcmVzdWx0KTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy9Db21wYXJlVmFsdWVzXCIsIEdlbmVyaWNDb21wYXJlKTtcclxuICAgIFxyXG59KSh0aGlzKTtcclxuXG4vL2V2ZW50IHJlbGF0ZWQgbm9kZXNcclxuKGZ1bmN0aW9uKGdsb2JhbCkge1xyXG4gICAgdmFyIExpdGVHcmFwaCA9IGdsb2JhbC5MaXRlR3JhcGg7XHJcblxyXG4gICAgLy9TaG93IHZhbHVlIGluc2lkZSB0aGUgZGVidWcgY29uc29sZVxyXG4gICAgZnVuY3Rpb24gTG9nRXZlbnQoKSB7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzYwLCAzMF07XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImV2ZW50XCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgfVxyXG5cclxuICAgIExvZ0V2ZW50LnRpdGxlID0gXCJMb2cgRXZlbnRcIjtcclxuICAgIExvZ0V2ZW50LmRlc2MgPSBcIkxvZyBldmVudCBpbiBjb25zb2xlXCI7XHJcblxyXG4gICAgTG9nRXZlbnQucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGFjdGlvbiwgcGFyYW0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImV2ZW50cy9sb2dcIiwgTG9nRXZlbnQpO1xyXG5cclxuICAgIC8vY29udmVydCB0byBFdmVudCBpZiB0aGUgdmFsdWUgaXMgdHJ1ZVxyXG4gICAgZnVuY3Rpb24gVHJpZ2dlckV2ZW50KCkge1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs2MCwgMzBdO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpZlwiLCBcIlwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInRydWVcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcImNoYW5nZVwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiZmFsc2VcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgb25seV9vbl9jaGFuZ2U6IHRydWUgfTtcclxuXHRcdHRoaXMucHJldiA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgVHJpZ2dlckV2ZW50LnRpdGxlID0gXCJUcmlnZ2VyRXZlbnRcIjtcclxuICAgIFRyaWdnZXJFdmVudC5kZXNjID0gXCJUcmlnZ2VycyBldmVudCBpZiBpbnB1dCBldmFsdWF0ZXMgdG8gdHJ1ZVwiO1xyXG5cclxuICAgIFRyaWdnZXJFdmVudC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oIHBhcmFtLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0dmFyIGNoYW5nZWQgPSAodiAhPSB0aGlzLnByZXYpO1xyXG5cdFx0aWYodGhpcy5wcmV2ID09PSAwKVxyXG5cdFx0XHRjaGFuZ2VkID0gZmFsc2U7XHJcblx0XHR2YXIgbXVzdF9yZXNlbmQgPSAoY2hhbmdlZCAmJiB0aGlzLnByb3BlcnRpZXMub25seV9vbl9jaGFuZ2UpIHx8ICghY2hhbmdlZCAmJiAhdGhpcy5wcm9wZXJ0aWVzLm9ubHlfb25fY2hhbmdlKTtcclxuXHRcdGlmKHYgJiYgbXVzdF9yZXNlbmQgKVxyXG5cdCAgICAgICAgdGhpcy50cmlnZ2VyU2xvdCgwLCBwYXJhbSwgbnVsbCwgb3B0aW9ucyk7XHJcblx0XHRpZighdiAmJiBtdXN0X3Jlc2VuZClcclxuXHQgICAgICAgIHRoaXMudHJpZ2dlclNsb3QoMiwgcGFyYW0sIG51bGwsIG9wdGlvbnMpO1xyXG5cdFx0aWYoY2hhbmdlZClcclxuXHQgICAgICAgIHRoaXMudHJpZ2dlclNsb3QoMSwgcGFyYW0sIG51bGwsIG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5wcmV2ID0gdjtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJldmVudHMvdHJpZ2dlclwiLCBUcmlnZ2VyRXZlbnQpO1xyXG5cclxuICAgIC8vU2VxdWVuY2Ugb2YgZXZlbnRzXHJcbiAgICBmdW5jdGlvbiBTZXF1ZW5jZSgpIHtcclxuXHRcdHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZFdpZGdldChcImJ1dHRvblwiLFwiK1wiLG51bGwsZnVuY3Rpb24oKXtcclxuXHQgICAgICAgIHRoYXQuYWRkSW5wdXQoXCJcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcblx0ICAgICAgICB0aGF0LmFkZE91dHB1dChcIlwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs5MCwgNzBdO1xyXG4gICAgICAgIHRoaXMuZmxhZ3MgPSB7IGhvcml6b250YWw6IHRydWUsIHJlbmRlcl9ib3g6IGZhbHNlIH07XHJcbiAgICB9XHJcblxyXG4gICAgU2VxdWVuY2UudGl0bGUgPSBcIlNlcXVlbmNlXCI7XHJcbiAgICBTZXF1ZW5jZS5kZXNjID0gXCJUcmlnZ2VycyBhIHNlcXVlbmNlIG9mIGV2ZW50cyB3aGVuIGFuIGV2ZW50IGFycml2ZXNcIjtcclxuXHJcbiAgICBTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH07XHJcblxyXG4gICAgU2VxdWVuY2UucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmICh0aGlzLm91dHB1dHMpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdFx0dmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tpXTtcclxuXHRcdFx0XHQvL25lZWRzIG1vcmUgaW5mbyBhYm91dCB0aGlzLi4uXHJcblx0XHRcdFx0aWYoIG9wdGlvbnMuYWN0aW9uX2NhbGwgKSAvLyBDUkVBVEUgQSBORVcgSUQgRk9SIFRIRSBBQ1RJT05cclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5hY3Rpb25fY2FsbCA9IG9wdGlvbnMuYWN0aW9uX2NhbGwgKyBcIl9zZXFfXCIgKyBpO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdG9wdGlvbnMuYWN0aW9uX2NhbGwgPSB0aGlzLmlkICsgXCJfXCIgKyAoYWN0aW9uID8gYWN0aW9uIDogXCJhY3Rpb25cIikrXCJfc2VxX1wiK2krXCJfXCIrTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjk5OTkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyU2xvdChpLCBwYXJhbSwgbnVsbCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZXZlbnRzL3NlcXVlbmNlXCIsIFNlcXVlbmNlKTtcclxuXHJcblxyXG4gICAvL1NlcXVlbmNlIG9mIGV2ZW50c1xyXG4gICBmdW5jdGlvbiBXYWl0QWxsKCkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdGhpcy5hZGRJbnB1dChcIlwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgIHRoaXMuYWRkSW5wdXQoXCJcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgdGhpcy5hZGRXaWRnZXQoXCJidXR0b25cIixcIitcIixudWxsLGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhhdC5hZGRJbnB1dChcIlwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGF0LnNpemVbMF0gPSA5MDtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5zaXplID0gWzkwLCA3MF07XHJcbiAgICB0aGlzLnJlYWR5ID0gW107XHJcbn1cclxuXHJcbldhaXRBbGwudGl0bGUgPSBcIldhaXRBbGxcIjtcclxuV2FpdEFsbC5kZXNjID0gXCJXYWl0IHVudGlsIGFsbCBpbnB1dCBldmVudHMgYXJyaXZlIHRoZW4gdHJpZ2dlcnMgb3V0cHV0XCI7XHJcblxyXG5XYWl0QWxsLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFwiXCI7XHJcbn07XHJcblxyXG5XYWl0QWxsLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KVxyXG57XHJcbiAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHkgPSBpICogTGl0ZUdyYXBoLk5PREVfU0xPVF9IRUlHSFQgKyAxMDtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5yZWFkeVtpXSA/IFwiI0FGQlwiIDogXCIjMDAwXCI7XHJcbiAgICAgICAgY3R4LmZpbGxSZWN0KDIwLCB5LCAxMCwgMTApO1xyXG4gICAgfVxyXG59XHJcblxyXG5XYWl0QWxsLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0sIG9wdGlvbnMsIHNsb3RfaW5kZXgpIHtcclxuICAgIGlmKHNsb3RfaW5kZXggPT0gbnVsbClcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgLy9jaGVjayBhbGxcclxuICAgIHRoaXMucmVhZHkubGVuZ3RoID0gdGhpcy5vdXRwdXRzLmxlbmd0aDtcclxuICAgIHRoaXMucmVhZHlbc2xvdF9pbmRleF0gPSB0cnVlO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMucmVhZHkubGVuZ3RoOysraSlcclxuICAgICAgICBpZighdGhpcy5yZWFkeVtpXSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgLy9wYXNzXHJcbiAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICB0aGlzLnRyaWdnZXJTbG90KDApO1xyXG59O1xyXG5cclxuV2FpdEFsbC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpXHJcbntcclxuICAgIHRoaXMucmVhZHkubGVuZ3RoID0gMDtcclxufVxyXG5cclxuTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJldmVudHMvd2FpdEFsbFwiLCBXYWl0QWxsKTsgICAgXHJcblxyXG5cclxuICAgIC8vU2VxdWVuY2VyIGZvciBldmVudHNcclxuICAgIGZ1bmN0aW9uIFN0ZXBwZXIoKSB7XHJcblx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IGluZGV4OiAwIH07XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluZGV4XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJzdGVwXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJyZXNldFwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcImluZGV4XCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBMaXRlR3JhcGguRVZFTlQse3JlbW92YWJsZTp0cnVlfSk7XHJcbiAgICAgICAgdGhpcy5hZGRXaWRnZXQoXCJidXR0b25cIixcIitcIixudWxsLGZ1bmN0aW9uKCl7XHJcblx0ICAgICAgICB0aGF0LmFkZE91dHB1dChcIlwiLCBMaXRlR3JhcGguRVZFTlQsIHtyZW1vdmFibGU6dHJ1ZX0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxMjAsIDEyMF07XHJcbiAgICAgICAgdGhpcy5mbGFncyA9IHsgcmVuZGVyX2JveDogZmFsc2UgfTtcclxuICAgIH1cclxuXHJcbiAgICBTdGVwcGVyLnRpdGxlID0gXCJTdGVwcGVyXCI7XHJcbiAgICBTdGVwcGVyLmRlc2MgPSBcIlRyaWdnZXIgZXZlbnRzIHNlcXVlbnRpYWxseSB3aGVuIGFuIHRpY2sgYXJyaXZlc1wiO1xyXG5cclxuXHRTdGVwcGVyLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KVxyXG5cdHtcclxuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHRcdHZhciBpbmRleCA9IHRoaXMucHJvcGVydGllcy5pbmRleCB8fCAwO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNBRkJcIjtcclxuXHRcdHZhciB3ID0gdGhpcy5zaXplWzBdO1xyXG4gICAgICAgIHZhciB5ID0gKGluZGV4ICsgMSkqIExpdGVHcmFwaC5OT0RFX1NMT1RfSEVJR0hUICsgNDtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4Lm1vdmVUbyh3IC0gMzAsIHkpO1xyXG4gICAgICAgIGN0eC5saW5lVG8odyAtIDMwLCB5ICsgTGl0ZUdyYXBoLk5PREVfU0xPVF9IRUlHSFQpO1xyXG4gICAgICAgIGN0eC5saW5lVG8odyAtIDE1LCB5ICsgTGl0ZUdyYXBoLk5PREVfU0xPVF9IRUlHSFQgKiAwLjUpO1xyXG4gICAgICAgIGN0eC5maWxsKCk7XHJcblx0fVxyXG5cclxuXHRTdGVwcGVyLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0dmFyIGluZGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRpZihpbmRleCAhPSBudWxsKVxyXG5cdFx0e1xyXG5cdFx0XHRpbmRleCA9IE1hdGguZmxvb3IoaW5kZXgpO1xyXG5cdFx0XHRpbmRleCA9IGNsYW1wKCBpbmRleCwgMCwgdGhpcy5vdXRwdXRzID8gKHRoaXMub3V0cHV0cy5sZW5ndGggLSAyKSA6IDAgKTtcclxuXHRcdFx0aWYoIGluZGV4ICE9IHRoaXMucHJvcGVydGllcy5pbmRleCApXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aGlzLnByb3BlcnRpZXMuaW5kZXggPSBpbmRleDtcclxuXHRcdFx0ICAgIHRoaXMudHJpZ2dlclNsb3QoIGluZGV4KzEgKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLnByb3BlcnRpZXMuaW5kZXggKTtcclxuXHR9XHJcblxyXG4gICAgU3RlcHBlci5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XHJcblx0XHRpZihhY3Rpb24gPT0gXCJyZXNldFwiKVxyXG5cdFx0XHR0aGlzLnByb3BlcnRpZXMuaW5kZXggPSAwO1xyXG5cdFx0ZWxzZSBpZihhY3Rpb24gPT0gXCJzdGVwXCIpXHJcblx0XHR7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlclNsb3QodGhpcy5wcm9wZXJ0aWVzLmluZGV4KzEsIHBhcmFtKTtcclxuXHRcdFx0dmFyIG4gPSB0aGlzLm91dHB1dHMgPyB0aGlzLm91dHB1dHMubGVuZ3RoIC0gMSA6IDA7XHJcblx0XHRcdHRoaXMucHJvcGVydGllcy5pbmRleCA9ICh0aGlzLnByb3BlcnRpZXMuaW5kZXggKyAxKSAlIG47XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImV2ZW50cy9zdGVwcGVyXCIsIFN0ZXBwZXIpO1xyXG5cclxuICAgIC8vRmlsdGVyIGV2ZW50c1xyXG4gICAgZnVuY3Rpb24gRmlsdGVyRXZlbnQoKSB7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzYwLCAzMF07XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImV2ZW50XCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiZXZlbnRcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIGVxdWFsX3RvOiBcIlwiLFxyXG4gICAgICAgICAgICBoYXNfcHJvcGVydHk6IFwiXCIsXHJcbiAgICAgICAgICAgIHByb3BlcnR5X2VxdWFsX3RvOiBcIlwiXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBGaWx0ZXJFdmVudC50aXRsZSA9IFwiRmlsdGVyIEV2ZW50XCI7XHJcbiAgICBGaWx0ZXJFdmVudC5kZXNjID0gXCJCbG9ja3MgZXZlbnRzIHRoYXQgZG8gbm90IG1hdGNoIHRoZSBmaWx0ZXJcIjtcclxuXHJcbiAgICBGaWx0ZXJFdmVudC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5lcXVhbF90byAmJiB0aGlzLnByb3BlcnRpZXMuZXF1YWxfdG8gIT0gcGFyYW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5oYXNfcHJvcGVydHkpIHtcclxuICAgICAgICAgICAgdmFyIHByb3AgPSBwYXJhbVt0aGlzLnByb3BlcnRpZXMuaGFzX3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgaWYgKHByb3AgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMucHJvcGVydHlfZXF1YWxfdG8gJiZcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5wcm9wZXJ0eV9lcXVhbF90byAhPSBwcm9wXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnRyaWdnZXJTbG90KDAsIHBhcmFtLCBudWxsLCBvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJldmVudHMvZmlsdGVyXCIsIEZpbHRlckV2ZW50KTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gRXZlbnRCcmFuY2goKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJjb25kXCIsIFwiYm9vbGVhblwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInRydWVcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcImZhbHNlXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzEyMCwgNjBdO1xyXG5cdFx0dGhpcy5fdmFsdWUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBFdmVudEJyYW5jaC50aXRsZSA9IFwiQnJhbmNoXCI7XHJcbiAgICBFdmVudEJyYW5jaC5kZXNjID0gXCJJZiBjb25kaXRpb24gaXMgdHJ1ZSwgb3V0cHV0cyB0cmlnZ2VycyB0cnVlLCBvdGhlcndpc2UgZmFsc2VcIjtcclxuXHJcbiAgICBFdmVudEJyYW5jaC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLl92YWx1ZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG5cdH1cclxuXHJcbiAgICBFdmVudEJyYW5jaC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuXHRcdHRoaXMudHJpZ2dlclNsb3QodGhpcy5fdmFsdWUgPyAwIDogMSwgcGFyYW0sIG51bGwsIG9wdGlvbnMpO1xyXG5cdH1cclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImV2ZW50cy9icmFuY2hcIiwgRXZlbnRCcmFuY2gpO1xyXG5cclxuICAgIC8vU2hvdyB2YWx1ZSBpbnNpZGUgdGhlIGRlYnVnIGNvbnNvbGVcclxuICAgIGZ1bmN0aW9uIEV2ZW50Q291bnRlcigpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5jXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJkZWNcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInJlc2V0XCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiY2hhbmdlXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJudW1cIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcImRvQ291bnRFeGVjdXRpb25cIiwgZmFsc2UsIFwiYm9vbGVhblwiLCB7bmFtZTogXCJDb3VudCBFeGVjdXRpb25zXCJ9KTtcclxuICAgICAgICB0aGlzLmFkZFdpZGdldChcInRvZ2dsZVwiLFwiQ291bnQgRXhlYy5cIix0aGlzLnByb3BlcnRpZXMuZG9Db3VudEV4ZWN1dGlvbixcImRvQ291bnRFeGVjdXRpb25cIik7XHJcbiAgICAgICAgdGhpcy5udW0gPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIEV2ZW50Q291bnRlci50aXRsZSA9IFwiQ291bnRlclwiO1xyXG4gICAgRXZlbnRDb3VudGVyLmRlc2MgPSBcIkNvdW50cyBldmVudHNcIjtcclxuXHJcbiAgICBFdmVudENvdW50ZXIucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodGhpcy5udW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50aXRsZTtcclxuICAgIH07XHJcblxyXG4gICAgRXZlbnRDb3VudGVyLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0sIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMubnVtO1xyXG4gICAgICAgIGlmIChhY3Rpb24gPT0gXCJpbmNcIikge1xyXG4gICAgICAgICAgICB0aGlzLm51bSArPSAxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09IFwiZGVjXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5udW0gLT0gMTtcclxuICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PSBcInJlc2V0XCIpIHtcclxuICAgICAgICAgICAgdGhpcy5udW0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5udW0gIT0gdikge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJjaGFuZ2VcIiwgdGhpcy5udW0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgRXZlbnRDb3VudGVyLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI0FBQVwiO1xyXG4gICAgICAgIGN0eC5mb250ID0gXCIyMHB4IEFyaWFsXCI7XHJcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMubnVtLCB0aGlzLnNpemVbMF0gKiAwLjUsIHRoaXMuc2l6ZVsxXSAqIDAuNSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEV2ZW50Q291bnRlci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYodGhpcy5wcm9wZXJ0aWVzLmRvQ291bnRFeGVjdXRpb24pe1xyXG4gICAgICAgICAgICB0aGlzLm51bSArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMSwgdGhpcy5udW0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImV2ZW50cy9jb3VudGVyXCIsIEV2ZW50Q291bnRlcik7XHJcblxyXG4gICAgLy9TaG93IHZhbHVlIGluc2lkZSB0aGUgZGVidWcgY29uc29sZVxyXG4gICAgZnVuY3Rpb24gRGVsYXlFdmVudCgpIHtcclxuICAgICAgICB0aGlzLnNpemUgPSBbNjAsIDMwXTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwidGltZV9pbl9tc1wiLCAxMDAwKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiZXZlbnRcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvbl90aW1lXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcblxyXG4gICAgICAgIHRoaXMuX3BlbmRpbmcgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBEZWxheUV2ZW50LnRpdGxlID0gXCJEZWxheVwiO1xyXG4gICAgRGVsYXlFdmVudC5kZXNjID0gXCJEZWxheXMgb25lIGV2ZW50XCI7XHJcblxyXG4gICAgRGVsYXlFdmVudC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHRpbWUgPSB0aGlzLnByb3BlcnRpZXMudGltZV9pbl9tcztcclxuICAgICAgICBpZiAodGltZSA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihudWxsLCBwYXJhbSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcGVuZGluZy5wdXNoKFt0aW1lLCBwYXJhbV0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgRGVsYXlFdmVudC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24ocGFyYW0sIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZHQgPSB0aGlzLmdyYXBoLmVsYXBzZWRfdGltZSAqIDEwMDA7IC8vaW4gbXNcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNJbnB1dENvbm5lY3RlZCgxKSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudGltZV9pbl9tcyA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wZW5kaW5nLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpb25QYXNzID0gdGhpcy5fcGVuZGluZ1tpXTtcclxuICAgICAgICAgICAgYWN0aW9uUGFzc1swXSAtPSBkdDtcclxuICAgICAgICAgICAgaWYgKGFjdGlvblBhc3NbMF0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9yZW1vdmVcclxuICAgICAgICAgICAgdGhpcy5fcGVuZGluZy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgIC0taTtcclxuXHJcbiAgICAgICAgICAgIC8vdHJpZ2dlclxyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobnVsbCwgYWN0aW9uUGFzc1sxXSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBEZWxheUV2ZW50LnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wiZXZlbnRcIiwgTGl0ZUdyYXBoLkFDVElPTl0sIFtcInRpbWVfaW5fbXNcIiwgXCJudW1iZXJcIl1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImV2ZW50cy9kZWxheVwiLCBEZWxheUV2ZW50KTtcclxuXHJcbiAgICAvL1Nob3cgdmFsdWUgaW5zaWRlIHRoZSBkZWJ1ZyBjb25zb2xlXHJcbiAgICBmdW5jdGlvbiBUaW1lckV2ZW50KCkge1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJpbnRlcnZhbFwiLCAxMDAwKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiZXZlbnRcIiwgXCJ0aWNrXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib25fdGlja1wiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMudGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5sYXN0X2ludGVydmFsID0gMTAwMDtcclxuICAgICAgICB0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIFRpbWVyRXZlbnQudGl0bGUgPSBcIlRpbWVyXCI7XHJcbiAgICBUaW1lckV2ZW50LmRlc2MgPSBcIlNlbmRzIGFuIGV2ZW50IGV2ZXJ5IE4gbWlsbGlzZWNvbmRzXCI7XHJcblxyXG4gICAgVGltZXJFdmVudC5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMudGltZSA9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIFRpbWVyRXZlbnQucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiVGltZXI6IFwiICsgdGhpcy5sYXN0X2ludGVydmFsLnRvU3RyaW5nKCkgKyBcIm1zXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIFRpbWVyRXZlbnQub25fY29sb3IgPSBcIiNBQUFcIjtcclxuICAgIFRpbWVyRXZlbnQub2ZmX2NvbG9yID0gXCIjMjIyXCI7XHJcblxyXG4gICAgVGltZXJFdmVudC5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYm94Y29sb3IgPSB0aGlzLnRyaWdnZXJlZFxyXG4gICAgICAgICAgICA/IFRpbWVyRXZlbnQub25fY29sb3JcclxuICAgICAgICAgICAgOiBUaW1lckV2ZW50Lm9mZl9jb2xvcjtcclxuICAgICAgICB0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBUaW1lckV2ZW50LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgZHQgPSB0aGlzLmdyYXBoLmVsYXBzZWRfdGltZSAqIDEwMDA7IC8vaW4gbXNcclxuXHJcbiAgICAgICAgdmFyIHRyaWdnZXIgPSB0aGlzLnRpbWUgPT0gMDtcclxuXHJcbiAgICAgICAgdGhpcy50aW1lICs9IGR0O1xyXG4gICAgICAgIHRoaXMubGFzdF9pbnRlcnZhbCA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICAxLFxyXG4gICAgICAgICAgICB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcImludGVydmFsXCIpIHwgMFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgIXRyaWdnZXIgJiZcclxuICAgICAgICAgICAgKHRoaXMudGltZSA8IHRoaXMubGFzdF9pbnRlcnZhbCB8fCBpc05hTih0aGlzLmxhc3RfaW50ZXJ2YWwpKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dHMgJiYgdGhpcy5pbnB1dHMubGVuZ3RoID4gMSAmJiB0aGlzLmlucHV0c1sxXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDEsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnRyaWdnZXJlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50aW1lID0gdGhpcy50aW1lICUgdGhpcy5sYXN0X2ludGVydmFsO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcihcIm9uX3RpY2tcIiwgdGhpcy5wcm9wZXJ0aWVzLmV2ZW50KTtcclxuICAgICAgICBpZiAodGhpcy5pbnB1dHMgJiYgdGhpcy5pbnB1dHMubGVuZ3RoID4gMSAmJiB0aGlzLmlucHV0c1sxXSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBUaW1lckV2ZW50LnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wiaW50ZXJ2YWxcIiwgXCJudW1iZXJcIl1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBUaW1lckV2ZW50LnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcInRpY2tcIiwgXCJib29sZWFuXCJdXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJldmVudHMvdGltZXJcIiwgVGltZXJFdmVudCk7XHJcblxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBTZW1hcGhvcmVFdmVudCgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiZ29cIiwgTGl0ZUdyYXBoLkFDVElPTiApO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJncmVlblwiLCBMaXRlR3JhcGguQUNUSU9OICk7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInJlZFwiLCBMaXRlR3JhcGguQUNUSU9OICk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJjb250aW51ZVwiLCBMaXRlR3JhcGguRVZFTlQgKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcImJsb2NrZWRcIiwgTGl0ZUdyYXBoLkVWRU5UICk7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJpc19ncmVlblwiLCBcImJvb2xlYW5cIiApO1xyXG5cdFx0dGhpcy5fcmVhZHkgPSBmYWxzZTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHt9O1xyXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJidXR0b25cIixcInJlc2V0XCIsXCJcIixmdW5jdGlvbigpe1xyXG5cdFx0XHR0aGF0Ll9yZWFkeSA9IGZhbHNlO1xyXG5cdFx0fSk7XHJcbiAgICB9XHJcblxyXG4gICAgU2VtYXBob3JlRXZlbnQudGl0bGUgPSBcIlNlbWFwaG9yZSBFdmVudFwiO1xyXG4gICAgU2VtYXBob3JlRXZlbnQuZGVzYyA9IFwiVW50aWwgYm90aCBldmVudHMgYXJlIG5vdCB0cmlnZ2VyZWQsIGl0IGRvZXNudCBjb250aW51ZS5cIjtcclxuXHJcblx0U2VtYXBob3JlRXZlbnQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMSx0aGlzLl9yZWFkeSk7XHJcblx0XHR0aGlzLmJveGNvbG9yID0gdGhpcy5fcmVhZHkgPyBcIiM5RjlcIiA6IFwiI0ZBNVwiO1xyXG5cdH1cclxuXHJcbiAgICBTZW1hcGhvcmVFdmVudC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XHJcblx0XHRpZiggYWN0aW9uID09IFwiZ29cIiApXHJcblx0XHRcdHRoaXMudHJpZ2dlclNsb3QoIHRoaXMuX3JlYWR5ID8gMCA6IDEgKTtcclxuXHRcdGVsc2UgaWYoIGFjdGlvbiA9PSBcImdyZWVuXCIgKVxyXG5cdFx0XHR0aGlzLl9yZWFkeSA9IHRydWU7XHJcblx0XHRlbHNlIGlmKCBhY3Rpb24gPT0gXCJyZWRcIiApXHJcblx0XHRcdHRoaXMuX3JlYWR5ID0gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZXZlbnRzL3NlbWFwaG9yZVwiLCBTZW1hcGhvcmVFdmVudCk7XHJcblxyXG4gICAgZnVuY3Rpb24gT25jZUV2ZW50KCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBMaXRlR3JhcGguQUNUSU9OICk7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInJlc2V0XCIsIExpdGVHcmFwaC5BQ1RJT04gKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBMaXRlR3JhcGguRVZFTlQgKTtcclxuXHRcdHRoaXMuX29uY2UgPSBmYWxzZTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHt9O1xyXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJidXR0b25cIixcInJlc2V0XCIsXCJcIixmdW5jdGlvbigpe1xyXG5cdFx0XHR0aGF0Ll9vbmNlID0gZmFsc2U7XHJcblx0XHR9KTtcclxuICAgIH1cclxuXHJcbiAgICBPbmNlRXZlbnQudGl0bGUgPSBcIk9uY2VcIjtcclxuICAgIE9uY2VFdmVudC5kZXNjID0gXCJPbmx5IHBhc3NlcyBhbiBldmVudCBvbmNlLCB0aGVuIGdldHMgbG9ja2VkXCI7XHJcblxyXG4gICAgT25jZUV2ZW50LnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0pIHtcclxuXHRcdGlmKCBhY3Rpb24gPT0gXCJpblwiICYmICF0aGlzLl9vbmNlIClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5fb25jZSA9IHRydWU7XHJcblx0XHRcdHRoaXMudHJpZ2dlclNsb3QoIDAsIHBhcmFtICk7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKCBhY3Rpb24gPT0gXCJyZXNldFwiIClcclxuXHRcdFx0dGhpcy5fb25jZSA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImV2ZW50cy9vbmNlXCIsIE9uY2VFdmVudCk7XHJcblxyXG4gICAgZnVuY3Rpb24gRGF0YVN0b3JlKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJkYXRhXCIsIDApO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJhc3NpZ25cIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJkYXRhXCIsIDApO1xyXG5cdFx0dGhpcy5fbGFzdF92YWx1ZSA9IG51bGw7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IGRhdGE6IG51bGwsIHNlcmlhbGl6ZTogdHJ1ZSB9O1xyXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJidXR0b25cIixcInN0b3JlXCIsXCJcIixmdW5jdGlvbigpe1xyXG5cdFx0XHR0aGF0LnByb3BlcnRpZXMuZGF0YSA9IHRoYXQuX2xhc3RfdmFsdWU7XHJcblx0XHR9KTtcclxuICAgIH1cclxuXHJcbiAgICBEYXRhU3RvcmUudGl0bGUgPSBcIkRhdGEgU3RvcmVcIjtcclxuICAgIERhdGFTdG9yZS5kZXNjID0gXCJTdG9yZXMgZGF0YSBhbmQgb25seSBjaGFuZ2VzIHdoZW4gZXZlbnQgaXMgcmVjZWl2ZWRcIjtcclxuXHJcblx0RGF0YVN0b3JlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0dGhpcy5fbGFzdF92YWx1ZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMucHJvcGVydGllcy5kYXRhICk7XHJcblx0fVxyXG5cclxuICAgIERhdGFTdG9yZS5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtLCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMuZGF0YSA9IHRoaXMuX2xhc3RfdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuXHREYXRhU3RvcmUucHJvdG90eXBlLm9uU2VyaWFsaXplID0gZnVuY3Rpb24obylcclxuXHR7XHJcblx0XHRpZihvLmRhdGEgPT0gbnVsbClcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0aWYodGhpcy5wcm9wZXJ0aWVzLnNlcmlhbGl6ZSA9PSBmYWxzZSB8fCAoby5kYXRhLmNvbnN0cnVjdG9yICE9PSBTdHJpbmcgJiYgby5kYXRhLmNvbnN0cnVjdG9yICE9PSBOdW1iZXIgJiYgby5kYXRhLmNvbnN0cnVjdG9yICE9PSBCb29sZWFuICYmIG8uZGF0YS5jb25zdHJ1Y3RvciAhPT0gQXJyYXkgJiYgby5kYXRhLmNvbnN0cnVjdG9yICE9PSBPYmplY3QgKSlcclxuXHRcdFx0by5kYXRhID0gbnVsbDtcclxuXHR9XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJiYXNpYy9kYXRhX3N0b3JlXCIsIERhdGFTdG9yZSk7XHJcblxyXG5cclxuXHJcbn0pKHRoaXMpO1xyXG5cbi8vd2lkZ2V0c1xuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAgIHZhciBMaXRlR3JhcGggPSBnbG9iYWwuTGl0ZUdyYXBoO1xuXG4gICAgLyogQnV0dG9uICoqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBXaWRnZXRCdXR0b24oKSB7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIExpdGVHcmFwaC5FVkVOVCk7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwiYm9vbGVhblwiKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInRleHRcIiwgXCJjbGljayBtZVwiKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcImZvbnRfc2l6ZVwiLCAzMCk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJtZXNzYWdlXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLnNpemUgPSBbMTY0LCA4NF07XG4gICAgICAgIHRoaXMuY2xpY2tlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIFdpZGdldEJ1dHRvbi50aXRsZSA9IFwiQnV0dG9uXCI7XG4gICAgV2lkZ2V0QnV0dG9uLmRlc2MgPSBcIlRyaWdnZXJzIGFuIGV2ZW50XCI7XG5cbiAgICBXaWRnZXRCdXR0b24uZm9udCA9IFwiQXJpYWxcIjtcbiAgICBXaWRnZXRCdXR0b24ucHJvdG90eXBlLm9uRHJhd0ZvcmVncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmdpbiA9IDEwO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICBtYXJnaW4gKyAxLFxuICAgICAgICAgICAgbWFyZ2luICsgMSxcbiAgICAgICAgICAgIHRoaXMuc2l6ZVswXSAtIG1hcmdpbiAqIDIsXG4gICAgICAgICAgICB0aGlzLnNpemVbMV0gLSBtYXJnaW4gKiAyXG4gICAgICAgICk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNBQUZcIjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgbWFyZ2luIC0gMSxcbiAgICAgICAgICAgIG1hcmdpbiAtIDEsXG4gICAgICAgICAgICB0aGlzLnNpemVbMF0gLSBtYXJnaW4gKiAyLFxuICAgICAgICAgICAgdGhpcy5zaXplWzFdIC0gbWFyZ2luICogMlxuICAgICAgICApO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jbGlja2VkXG4gICAgICAgICAgICA/IFwid2hpdGVcIlxuICAgICAgICAgICAgOiB0aGlzLm1vdXNlT3ZlclxuICAgICAgICAgICAgPyBcIiM2NjhcIlxuICAgICAgICAgICAgOiBcIiMzMzRcIjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgbWFyZ2luLFxuICAgICAgICAgICAgbWFyZ2luLFxuICAgICAgICAgICAgdGhpcy5zaXplWzBdIC0gbWFyZ2luICogMixcbiAgICAgICAgICAgIHRoaXMuc2l6ZVsxXSAtIG1hcmdpbiAqIDJcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnRleHQgfHwgdGhpcy5wcm9wZXJ0aWVzLnRleHQgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBmb250X3NpemUgPSB0aGlzLnByb3BlcnRpZXMuZm9udF9zaXplIHx8IDMwO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jbGlja2VkID8gXCJibGFja1wiIDogXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250X3NpemUgKyBcInB4IFwiICsgV2lkZ2V0QnV0dG9uLmZvbnQ7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnRleHQsXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplWzBdICogMC41LFxuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZVsxXSAqIDAuNSArIGZvbnRfc2l6ZSAqIDAuM1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBXaWRnZXRCdXR0b24ucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24oZSwgbG9jYWxfcG9zKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGxvY2FsX3Bvc1swXSA+IDEgJiZcbiAgICAgICAgICAgIGxvY2FsX3Bvc1sxXSA+IDEgJiZcbiAgICAgICAgICAgIGxvY2FsX3Bvc1swXSA8IHRoaXMuc2l6ZVswXSAtIDIgJiZcbiAgICAgICAgICAgIGxvY2FsX3Bvc1sxXSA8IHRoaXMuc2l6ZVsxXSAtIDJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDEsIHRoaXMuY2xpY2tlZCk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJTbG90KDAsIHRoaXMucHJvcGVydGllcy5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFdpZGdldEJ1dHRvbi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgxLCB0aGlzLmNsaWNrZWQpO1xuICAgIH07XG5cbiAgICBXaWRnZXRCdXR0b24ucHJvdG90eXBlLm9uTW91c2VVcCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5jbGlja2VkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwid2lkZ2V0L2J1dHRvblwiLCBXaWRnZXRCdXR0b24pO1xuXG4gICAgZnVuY3Rpb24gV2lkZ2V0VG9nZ2xlKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiXCIsIFwiYm9vbGVhblwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImVcIiwgTGl0ZUdyYXBoLkFDVElPTik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwidlwiLCBcImJvb2xlYW5cIik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiZVwiLCBMaXRlR3JhcGguRVZFTlQpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IGZvbnQ6IFwiXCIsIHZhbHVlOiBmYWxzZSB9O1xuICAgICAgICB0aGlzLnNpemUgPSBbMTYwLCA0NF07XG4gICAgfVxuXG4gICAgV2lkZ2V0VG9nZ2xlLnRpdGxlID0gXCJUb2dnbGVcIjtcbiAgICBXaWRnZXRUb2dnbGUuZGVzYyA9IFwiVG9nZ2xlcyBiZXR3ZWVuIHRydWUgb3IgZmFsc2VcIjtcblxuICAgIFdpZGdldFRvZ2dsZS5wcm90b3R5cGUub25EcmF3Rm9yZWdyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaXplID0gdGhpcy5zaXplWzFdICogMC41O1xuICAgICAgICB2YXIgbWFyZ2luID0gMC4yNTtcbiAgICAgICAgdmFyIGggPSB0aGlzLnNpemVbMV0gKiAwLjg7XG4gICAgICAgIGN0eC5mb250ID0gdGhpcy5wcm9wZXJ0aWVzLmZvbnQgfHwgKHNpemUgKiAwLjgpLnRvRml4ZWQoMCkgKyBcInB4IEFyaWFsXCI7XG4gICAgICAgIHZhciB3ID0gY3R4Lm1lYXN1cmVUZXh0KHRoaXMudGl0bGUpLndpZHRoO1xuICAgICAgICB2YXIgeCA9ICh0aGlzLnNpemVbMF0gLSAodyArIHNpemUpKSAqIDAuNTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjQUFBXCI7XG4gICAgICAgIGN0eC5maWxsUmVjdCh4LCBoIC0gc2l6ZSwgc2l6ZSwgc2l6ZSk7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMucHJvcGVydGllcy52YWx1ZSA/IFwiI0FFRlwiIDogXCIjMDAwXCI7XG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgIHggKyBzaXplICogbWFyZ2luLFxuICAgICAgICAgICAgaCAtIHNpemUgKyBzaXplICogbWFyZ2luLFxuICAgICAgICAgICAgc2l6ZSAqICgxIC0gbWFyZ2luICogMiksXG4gICAgICAgICAgICBzaXplICogKDEgLSBtYXJnaW4gKiAyKVxuICAgICAgICApO1xuXG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI0FBQVwiO1xuICAgICAgICBjdHguZmlsbFRleHQodGhpcy50aXRsZSwgc2l6ZSAqIDEuMiArIHgsIGggKiAwLjg1KTtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgIH07XG5cbiAgICBXaWRnZXRUb2dnbGUucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSA9ICF0aGlzLnByb3BlcnRpZXMudmFsdWU7XG4gICAgICAgIHRoaXMudHJpZ2dlcihcImVcIiwgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0VG9nZ2xlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0VG9nZ2xlLnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKGUsIGxvY2FsX3Bvcykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBsb2NhbF9wb3NbMF0gPiAxICYmXG4gICAgICAgICAgICBsb2NhbF9wb3NbMV0gPiAxICYmXG4gICAgICAgICAgICBsb2NhbF9wb3NbMF0gPCB0aGlzLnNpemVbMF0gLSAyICYmXG4gICAgICAgICAgICBsb2NhbF9wb3NbMV0gPCB0aGlzLnNpemVbMV0gLSAyXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlID0gIXRoaXMucHJvcGVydGllcy52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcImVcIiwgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwid2lkZ2V0L3RvZ2dsZVwiLCBXaWRnZXRUb2dnbGUpO1xuXG4gICAgLyogTnVtYmVyICoqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBXaWRnZXROdW1iZXIoKSB7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLnNpemUgPSBbODAsIDYwXTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBtaW46IC0xMDAwLCBtYXg6IDEwMDAsIHZhbHVlOiAxLCBzdGVwOiAxIH07XG4gICAgICAgIHRoaXMub2xkX3kgPSAtMTtcbiAgICAgICAgdGhpcy5fcmVtYWluZGVyID0gMDtcbiAgICAgICAgdGhpcy5fcHJlY2lzaW9uID0gMDtcbiAgICAgICAgdGhpcy5tb3VzZV9jYXB0dXJlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIFdpZGdldE51bWJlci50aXRsZSA9IFwiTnVtYmVyXCI7XG4gICAgV2lkZ2V0TnVtYmVyLmRlc2MgPSBcIldpZGdldCB0byBzZWxlY3QgbnVtYmVyIHZhbHVlXCI7XG5cbiAgICBXaWRnZXROdW1iZXIucGl4ZWxzX3RocmVzaG9sZCA9IDEwO1xuICAgIFdpZGdldE51bWJlci5tYXJrZXJzX2NvbG9yID0gXCIjNjY2XCI7XG5cbiAgICBXaWRnZXROdW1iZXIucHJvdG90eXBlLm9uRHJhd0ZvcmVncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLnNpemVbMF0gKiAwLjU7XG4gICAgICAgIHZhciBoID0gdGhpcy5zaXplWzFdO1xuICAgICAgICBpZiAoaCA+IDMwKSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gV2lkZ2V0TnVtYmVyLm1hcmtlcnNfY29sb3I7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIGggKiAwLjEpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgaCAqIDAuMSwgaCAqIDAuMik7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBoICogLTAuMSwgaCAqIDAuMik7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCBoICogMC45KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGggKiAwLjEsIGggKiAwLjgpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgaCAqIC0wLjEsIGggKiAwLjgpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIGN0eC5mb250ID0gKGggKiAwLjcpLnRvRml4ZWQoMSkgKyBcInB4IEFyaWFsXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguZm9udCA9IChoICogMC44KS50b0ZpeGVkKDEpICsgXCJweCBBcmlhbFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIGN0eC5mb250ID0gKGggKiAwLjcpLnRvRml4ZWQoMSkgKyBcInB4IEFyaWFsXCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNFRUVcIjtcbiAgICAgICAgY3R4LmZpbGxUZXh0KFxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlLnRvRml4ZWQodGhpcy5fcHJlY2lzaW9uKSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICBoICogMC43NVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBXaWRnZXROdW1iZXIucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0TnVtYmVyLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciB0ID0gKHRoaXMucHJvcGVydGllcy5zdGVwICsgXCJcIikuc3BsaXQoXCIuXCIpO1xuICAgICAgICB0aGlzLl9wcmVjaXNpb24gPSB0Lmxlbmd0aCA+IDEgPyB0WzFdLmxlbmd0aCA6IDA7XG4gICAgfTtcblxuICAgIFdpZGdldE51bWJlci5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbihlLCBwb3MpIHtcbiAgICAgICAgaWYgKHBvc1sxXSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub2xkX3kgPSBlLmNhbnZhc1k7XG4gICAgICAgIHRoaXMuY2FwdHVyZUlucHV0KHRydWUpO1xuICAgICAgICB0aGlzLm1vdXNlX2NhcHR1cmVkID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0TnVtYmVyLnByb3RvdHlwZS5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vdXNlX2NhcHR1cmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVsdGEgPSB0aGlzLm9sZF95IC0gZS5jYW52YXNZO1xuICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgZGVsdGEgKj0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUubWV0YUtleSB8fCBlLmFsdEtleSkge1xuICAgICAgICAgICAgZGVsdGEgKj0gMC4xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2xkX3kgPSBlLmNhbnZhc1k7XG5cbiAgICAgICAgdmFyIHN0ZXBzID0gdGhpcy5fcmVtYWluZGVyICsgZGVsdGEgLyBXaWRnZXROdW1iZXIucGl4ZWxzX3RocmVzaG9sZDtcbiAgICAgICAgdGhpcy5fcmVtYWluZGVyID0gc3RlcHMgJSAxO1xuICAgICAgICBzdGVwcyA9IHN0ZXBzIHwgMDtcblxuICAgICAgICB2YXIgdiA9IGNsYW1wKFxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlICsgc3RlcHMgKiB0aGlzLnByb3BlcnRpZXMuc3RlcCxcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5taW4sXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWF4XG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSA9IHY7XG4gICAgICAgIHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlKTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0TnVtYmVyLnByb3RvdHlwZS5vbk1vdXNlVXAgPSBmdW5jdGlvbihlLCBwb3MpIHtcbiAgICAgICAgaWYgKGUuY2xpY2tfdGltZSA8IDIwMCkge1xuICAgICAgICAgICAgdmFyIHN0ZXBzID0gcG9zWzFdID4gdGhpcy5zaXplWzFdICogMC41ID8gLTEgOiAxO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlID0gY2xhbXAoXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlICsgc3RlcHMgKiB0aGlzLnByb3BlcnRpZXMuc3RlcCxcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWluLFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5tYXhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmdyYXBoLl92ZXJzaW9uKys7XG4gICAgICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubW91c2VfY2FwdHVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW91c2VfY2FwdHVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZUlucHV0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIndpZGdldC9udW1iZXJcIiwgV2lkZ2V0TnVtYmVyKTtcblxuXG4gICAgLyogQ29tYm8gKioqKioqKioqKioqKioqKi9cblxuICAgIGZ1bmN0aW9uIFdpZGdldENvbWJvKCkge1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcInN0cmluZ1wiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJjaGFuZ2VcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcbiAgICAgICAgdGhpcy5zaXplID0gWzgwLCA2MF07XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgdmFsdWU6IFwiQVwiLCB2YWx1ZXM6XCJBO0I7Q1wiIH07XG4gICAgICAgIHRoaXMub2xkX3kgPSAtMTtcbiAgICAgICAgdGhpcy5tb3VzZV9jYXB0dXJlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3ZhbHVlcyA9IHRoaXMucHJvcGVydGllcy52YWx1ZXMuc3BsaXQoXCI7XCIpO1xuXHRcdHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhpcy53aWRnZXRzX3VwID0gdHJ1ZTtcblx0XHR0aGlzLndpZGdldCA9IHRoaXMuYWRkV2lkZ2V0KFwiY29tYm9cIixcIlwiLCB0aGlzLnByb3BlcnRpZXMudmFsdWUsIGZ1bmN0aW9uKHYpe1xuXHRcdFx0dGhhdC5wcm9wZXJ0aWVzLnZhbHVlID0gdjtcbiAgICAgICAgICAgIHRoYXQudHJpZ2dlclNsb3QoMSwgdik7XG5cdFx0fSwgeyBwcm9wZXJ0eTogXCJ2YWx1ZVwiLCB2YWx1ZXM6IHRoaXMuX3ZhbHVlcyB9ICk7XG4gICAgfVxuXG4gICAgV2lkZ2V0Q29tYm8udGl0bGUgPSBcIkNvbWJvXCI7XG4gICAgV2lkZ2V0Q29tYm8uZGVzYyA9IFwiV2lkZ2V0IHRvIHNlbGVjdCBmcm9tIGEgbGlzdFwiO1xuXG4gICAgV2lkZ2V0Q29tYm8ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoIDAsIHRoaXMucHJvcGVydGllcy52YWx1ZSApO1xuICAgIH07XG5cbiAgICBXaWRnZXRDb21iby5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuXHRcdGlmKG5hbWUgPT0gXCJ2YWx1ZXNcIilcblx0XHR7XG5cdFx0XHR0aGlzLl92YWx1ZXMgPSB2YWx1ZS5zcGxpdChcIjtcIik7XG5cdFx0XHR0aGlzLndpZGdldC5vcHRpb25zLnZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcblx0XHR9XG5cdFx0ZWxzZSBpZihuYW1lID09IFwidmFsdWVcIilcblx0XHR7XG5cdFx0XHR0aGlzLndpZGdldC52YWx1ZSA9IHZhbHVlO1xuXHRcdH1cblx0fTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwid2lkZ2V0L2NvbWJvXCIsIFdpZGdldENvbWJvKTtcblxuXG4gICAgLyogS25vYiAqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gV2lkZ2V0S25vYigpIHtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFs2NCwgODRdO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IDEsXG4gICAgICAgICAgICB2YWx1ZTogMC41LFxuICAgICAgICAgICAgY29sb3I6IFwiIzdBRlwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiAyXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudmFsdWUgPSAtMTtcbiAgICB9XG5cbiAgICBXaWRnZXRLbm9iLnRpdGxlID0gXCJLbm9iXCI7XG4gICAgV2lkZ2V0S25vYi5kZXNjID0gXCJDaXJjdWxhciBjb250cm9sbGVyXCI7XG4gICAgV2lkZ2V0S25vYi5zaXplID0gWzgwLCAxMDBdO1xuXG4gICAgV2lkZ2V0S25vYi5wcm90b3R5cGUub25EcmF3Rm9yZWdyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID1cbiAgICAgICAgICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLnZhbHVlIC0gdGhpcy5wcm9wZXJ0aWVzLm1pbikgL1xuICAgICAgICAgICAgICAgICh0aGlzLnByb3BlcnRpZXMubWF4IC0gdGhpcy5wcm9wZXJ0aWVzLm1pbik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2VudGVyX3ggPSB0aGlzLnNpemVbMF0gKiAwLjU7XG4gICAgICAgIHZhciBjZW50ZXJfeSA9IHRoaXMuc2l6ZVsxXSAqIDAuNTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGgubWluKHRoaXMuc2l6ZVswXSwgdGhpcy5zaXplWzFdKSAqIDAuNSAtIDU7XG4gICAgICAgIHZhciB3ID0gTWF0aC5mbG9vcihyYWRpdXMgKiAwLjA1KTtcblxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKGNlbnRlcl94LCBjZW50ZXJfeSk7XG4gICAgICAgIGN0eC5yb3RhdGUoTWF0aC5QSSAqIDAuNzUpO1xuXG4gICAgICAgIC8vYmdcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYSgwLDAsMCwwLjUpXCI7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgY3R4LmFyYygwLCAwLCByYWRpdXMsIDAsIE1hdGguUEkgKiAxLjUpO1xuICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgIC8vdmFsdWVcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5wcm9wZXJ0aWVzLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgICBjdHguYXJjKFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICByYWRpdXMgLSA0LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIE1hdGguUEkgKiAxLjUgKiBNYXRoLm1heCgwLjAxLCB0aGlzLnZhbHVlKVxuICAgICAgICApO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIC8vY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAvL2lubmVyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyhjZW50ZXJfeCwgY2VudGVyX3ksIHJhZGl1cyAqIDAuNzUsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAvL21pbmliYWxsXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLm1vdXNlT3ZlciA/IFwid2hpdGVcIiA6IHRoaXMucHJvcGVydGllcy5jb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLnZhbHVlICogTWF0aC5QSSAqIDEuNSArIE1hdGguUEkgKiAwLjc1O1xuICAgICAgICBjdHguYXJjKFxuICAgICAgICAgICAgY2VudGVyX3ggKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMgKiAwLjY1LFxuICAgICAgICAgICAgY2VudGVyX3kgKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMgKiAwLjY1LFxuICAgICAgICAgICAgcmFkaXVzICogMC4wNSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBNYXRoLlBJICogMixcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAvL3RleHRcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubW91c2VPdmVyID8gXCJ3aGl0ZVwiIDogXCIjQUFBXCI7XG4gICAgICAgIGN0eC5mb250ID0gTWF0aC5mbG9vcihyYWRpdXMgKiAwLjUpICsgXCJweCBBcmlhbFwiO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgY3R4LmZpbGxUZXh0KFxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlLnRvRml4ZWQodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiksXG4gICAgICAgICAgICBjZW50ZXJfeCxcbiAgICAgICAgICAgIGNlbnRlcl95ICsgcmFkaXVzICogMC4xNVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBXaWRnZXRLbm9iLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMucHJvcGVydGllcy52YWx1ZSk7XG4gICAgICAgIHRoaXMuYm94Y29sb3IgPSBMaXRlR3JhcGguY29sb3JUb1N0cmluZyhbXG4gICAgICAgICAgICB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIHRoaXMudmFsdWVcbiAgICAgICAgXSk7XG4gICAgfTtcblxuICAgIFdpZGdldEtub2IucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmNlbnRlciA9IFt0aGlzLnNpemVbMF0gKiAwLjUsIHRoaXMuc2l6ZVsxXSAqIDAuNSArIDIwXTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSB0aGlzLnNpemVbMF0gKiAwLjU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGUuY2FudmFzWSAtIHRoaXMucG9zWzFdIDwgMjAgfHxcbiAgICAgICAgICAgIExpdGVHcmFwaC5kaXN0YW5jZShcbiAgICAgICAgICAgICAgICBbZS5jYW52YXNYLCBlLmNhbnZhc1ldLFxuICAgICAgICAgICAgICAgIFt0aGlzLnBvc1swXSArIHRoaXMuY2VudGVyWzBdLCB0aGlzLnBvc1sxXSArIHRoaXMuY2VudGVyWzFdXVxuICAgICAgICAgICAgKSA+IHRoaXMucmFkaXVzXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2xkbW91c2UgPSBbZS5jYW52YXNYIC0gdGhpcy5wb3NbMF0sIGUuY2FudmFzWSAtIHRoaXMucG9zWzFdXTtcbiAgICAgICAgdGhpcy5jYXB0dXJlSW5wdXQodHJ1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBXaWRnZXRLbm9iLnByb3RvdHlwZS5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9sZG1vdXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbSA9IFtlLmNhbnZhc1ggLSB0aGlzLnBvc1swXSwgZS5jYW52YXNZIC0gdGhpcy5wb3NbMV1dO1xuXG4gICAgICAgIHZhciB2ID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdiAtPSAobVsxXSAtIHRoaXMub2xkbW91c2VbMV0pICogMC4wMTtcbiAgICAgICAgaWYgKHYgPiAxLjApIHtcbiAgICAgICAgICAgIHYgPSAxLjA7XG4gICAgICAgIH0gZWxzZSBpZiAodiA8IDAuMCkge1xuICAgICAgICAgICAgdiA9IDAuMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdjtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlID1cbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5taW4gK1xuICAgICAgICAgICAgKHRoaXMucHJvcGVydGllcy5tYXggLSB0aGlzLnByb3BlcnRpZXMubWluKSAqIHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMub2xkbW91c2UgPSBtO1xuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUpO1xuICAgIH07XG5cbiAgICBXaWRnZXRLbm9iLnByb3RvdHlwZS5vbk1vdXNlVXAgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0aGlzLm9sZG1vdXNlKSB7XG4gICAgICAgICAgICB0aGlzLm9sZG1vdXNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZUlucHV0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBXaWRnZXRLbm9iLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChuYW1lID09IFwibWluXCIgfHwgbmFtZSA9PSBcIm1heFwiIHx8IG5hbWUgPT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbbmFtZV0gPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvL2Jsb2NrXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ3aWRnZXQva25vYlwiLCBXaWRnZXRLbm9iKTtcblxuICAgIC8vU2hvdyB2YWx1ZSBpbnNpZGUgdGhlIGRlYnVnIGNvbnNvbGVcbiAgICBmdW5jdGlvbiBXaWRnZXRTbGlkZXJHVUkoKSB7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICB2YWx1ZTogMC41LFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiAxLFxuICAgICAgICAgICAgdGV4dDogXCJWXCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLnNpemUgPSBbMTQwLCA0MF07XG4gICAgICAgIHRoaXMuc2xpZGVyID0gdGhpcy5hZGRXaWRnZXQoXG4gICAgICAgICAgICBcInNsaWRlclwiLFxuICAgICAgICAgICAgXCJWXCIsXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUsXG4gICAgICAgICAgICBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgdGhhdC5wcm9wZXJ0aWVzLnZhbHVlID0gdjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy53aWRnZXRzX3VwID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBXaWRnZXRTbGlkZXJHVUkudGl0bGUgPSBcIklubmVyIFNsaWRlclwiO1xuXG4gICAgV2lkZ2V0U2xpZGVyR1VJLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChuYW1lID09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgdGhpcy5zbGlkZXIudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBXaWRnZXRTbGlkZXJHVUkucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ3aWRnZXQvaW50ZXJuYWxfc2xpZGVyXCIsIFdpZGdldFNsaWRlckdVSSk7XG5cbiAgICAvL1dpZGdldCBIIFNMSURFUlxuICAgIGZ1bmN0aW9uIFdpZGdldEhTbGlkZXIoKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxNjAsIDI2XTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgY29sb3I6IFwiIzdBRlwiLCBtaW46IDAsIG1heDogMSwgdmFsdWU6IDAuNSB9O1xuICAgICAgICB0aGlzLnZhbHVlID0gLTE7XG4gICAgfVxuXG4gICAgV2lkZ2V0SFNsaWRlci50aXRsZSA9IFwiSC5TbGlkZXJcIjtcbiAgICBXaWRnZXRIU2xpZGVyLmRlc2MgPSBcIkxpbmVhciBzbGlkZXIgY29udHJvbGxlclwiO1xuXG4gICAgV2lkZ2V0SFNsaWRlci5wcm90b3R5cGUub25EcmF3Rm9yZWdyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9XG4gICAgICAgICAgICAgICAgKHRoaXMucHJvcGVydGllcy52YWx1ZSAtIHRoaXMucHJvcGVydGllcy5taW4pIC9cbiAgICAgICAgICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLm1heCAtIHRoaXMucHJvcGVydGllcy5taW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9ib3JkZXJcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiMwMDBcIjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDIsIDIsIHRoaXMuc2l6ZVswXSAtIDQsIHRoaXMuc2l6ZVsxXSAtIDQpO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnByb3BlcnRpZXMuY29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnJlY3QoNCwgNCwgKHRoaXMuc2l6ZVswXSAtIDgpICogdGhpcy52YWx1ZSwgdGhpcy5zaXplWzFdIC0gOCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfTtcblxuICAgIFdpZGdldEhTbGlkZXIucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUgPVxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1pbiArXG4gICAgICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLm1heCAtIHRoaXMucHJvcGVydGllcy5taW4pICogdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMucHJvcGVydGllcy52YWx1ZSk7XG4gICAgICAgIHRoaXMuYm94Y29sb3IgPSBMaXRlR3JhcGguY29sb3JUb1N0cmluZyhbXG4gICAgICAgICAgICB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIHRoaXMudmFsdWVcbiAgICAgICAgXSk7XG4gICAgfTtcblxuICAgIFdpZGdldEhTbGlkZXIucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5jYW52YXNZIC0gdGhpcy5wb3NbMV0gPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9sZG1vdXNlID0gW2UuY2FudmFzWCAtIHRoaXMucG9zWzBdLCBlLmNhbnZhc1kgLSB0aGlzLnBvc1sxXV07XG4gICAgICAgIHRoaXMuY2FwdHVyZUlucHV0KHRydWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0SFNsaWRlci5wcm90b3R5cGUub25Nb3VzZU1vdmUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5vbGRtb3VzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG0gPSBbZS5jYW52YXNYIC0gdGhpcy5wb3NbMF0sIGUuY2FudmFzWSAtIHRoaXMucG9zWzFdXTtcblxuICAgICAgICB2YXIgdiA9IHRoaXMudmFsdWU7XG4gICAgICAgIHZhciBkZWx0YSA9IG1bMF0gLSB0aGlzLm9sZG1vdXNlWzBdO1xuICAgICAgICB2ICs9IGRlbHRhIC8gdGhpcy5zaXplWzBdO1xuICAgICAgICBpZiAodiA+IDEuMCkge1xuICAgICAgICAgICAgdiA9IDEuMDtcbiAgICAgICAgfSBlbHNlIGlmICh2IDwgMC4wKSB7XG4gICAgICAgICAgICB2ID0gMC4wO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IHY7XG5cbiAgICAgICAgdGhpcy5vbGRtb3VzZSA9IG07XG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgfTtcblxuICAgIFdpZGdldEhTbGlkZXIucHJvdG90eXBlLm9uTW91c2VVcCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5vbGRtb3VzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FwdHVyZUlucHV0KGZhbHNlKTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0SFNsaWRlci5wcm90b3R5cGUub25Nb3VzZUxlYXZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAvL3RoaXMub2xkbW91c2UgPSBudWxsO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIndpZGdldC9oc2xpZGVyXCIsIFdpZGdldEhTbGlkZXIpO1xuXG4gICAgZnVuY3Rpb24gV2lkZ2V0UHJvZ3Jlc3MoKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFsxNjAsIDI2XTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBtaW46IDAsIG1heDogMSwgdmFsdWU6IDAsIGNvbG9yOiBcIiNBQUZcIiB9O1xuICAgIH1cblxuICAgIFdpZGdldFByb2dyZXNzLnRpdGxlID0gXCJQcm9ncmVzc1wiO1xuICAgIFdpZGdldFByb2dyZXNzLmRlc2MgPSBcIlNob3dzIGRhdGEgaW4gbGluZWFyIHByb2dyZXNzXCI7XG5cbiAgICBXaWRnZXRQcm9ncmVzcy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmICh2ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW1widmFsdWVcIl0gPSB2O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFdpZGdldFByb2dyZXNzLnByb3RvdHlwZS5vbkRyYXdGb3JlZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIC8vYm9yZGVyXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5wcm9wZXJ0aWVzLmNvbG9yO1xuICAgICAgICB2YXIgdiA9XG4gICAgICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLnZhbHVlIC0gdGhpcy5wcm9wZXJ0aWVzLm1pbikgL1xuICAgICAgICAgICAgKHRoaXMucHJvcGVydGllcy5tYXggLSB0aGlzLnByb3BlcnRpZXMubWluKTtcbiAgICAgICAgdiA9IE1hdGgubWluKDEsIHYpO1xuICAgICAgICB2ID0gTWF0aC5tYXgoMCwgdik7XG4gICAgICAgIGN0eC5maWxsUmVjdCgyLCAyLCAodGhpcy5zaXplWzBdIC0gNCkgKiB2LCB0aGlzLnNpemVbMV0gLSA0KTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ3aWRnZXQvcHJvZ3Jlc3NcIiwgV2lkZ2V0UHJvZ3Jlc3MpO1xuXG4gICAgZnVuY3Rpb24gV2lkZ2V0VGV4dCgpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dHMoXCJcIiwgMCk7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBcIi4uLlwiLFxuICAgICAgICAgICAgZm9udDogXCJBcmlhbFwiLFxuICAgICAgICAgICAgZm9udHNpemU6IDE4LFxuICAgICAgICAgICAgY29sb3I6IFwiI0FBQVwiLFxuICAgICAgICAgICAgYWxpZ246IFwibGVmdFwiLFxuICAgICAgICAgICAgZ2xvd1NpemU6IDAsXG4gICAgICAgICAgICBkZWNpbWFsczogMVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIFdpZGdldFRleHQudGl0bGUgPSBcIlRleHRcIjtcbiAgICBXaWRnZXRUZXh0LmRlc2MgPSBcIlNob3dzIHRoZSBpbnB1dCB2YWx1ZVwiO1xuICAgIFdpZGdldFRleHQud2lkZ2V0cyA9IFtcbiAgICAgICAgeyBuYW1lOiBcInJlc2l6ZVwiLCB0ZXh0OiBcIlJlc2l6ZSBib3hcIiwgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICB7IG5hbWU6IFwibGVkX3RleHRcIiwgdGV4dDogXCJMRURcIiwgdHlwZTogXCJtaW5pYnV0dG9uXCIgfSxcbiAgICAgICAgeyBuYW1lOiBcIm5vcm1hbF90ZXh0XCIsIHRleHQ6IFwiTm9ybWFsXCIsIHR5cGU6IFwibWluaWJ1dHRvblwiIH1cbiAgICBdO1xuXG4gICAgV2lkZ2V0VGV4dC5wcm90b3R5cGUub25EcmF3Rm9yZWdyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAvL2N0eC5maWxsU3R5bGU9XCIjMDAwXCI7XG4gICAgICAgIC8vY3R4LmZpbGxSZWN0KDAsMCwxMDAsNjApO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5wcm9wZXJ0aWVzW1wiY29sb3JcIl07XG4gICAgICAgIHZhciB2ID0gdGhpcy5wcm9wZXJ0aWVzW1widmFsdWVcIl07XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllc1tcImdsb3dTaXplXCJdKSB7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB0aGlzLnByb3BlcnRpZXMuY29sb3I7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHRoaXMucHJvcGVydGllc1tcImdsb3dTaXplXCJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZvbnRzaXplID0gdGhpcy5wcm9wZXJ0aWVzW1wiZm9udHNpemVcIl07XG5cbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRoaXMucHJvcGVydGllc1tcImFsaWduXCJdO1xuICAgICAgICBjdHguZm9udCA9IGZvbnRzaXplLnRvU3RyaW5nKCkgKyBcInB4IFwiICsgdGhpcy5wcm9wZXJ0aWVzW1wiZm9udFwiXTtcbiAgICAgICAgdGhpcy5zdHIgPVxuICAgICAgICAgICAgdHlwZW9mIHYgPT0gXCJudW1iZXJcIiA/IHYudG9GaXhlZCh0aGlzLnByb3BlcnRpZXNbXCJkZWNpbWFsc1wiXSkgOiB2O1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdHIgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5zdHIucmVwbGFjZSgvW1xcclxcbl0vZywgXCJcXFxcblwiKS5zcGxpdChcIlxcXFxuXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzW2ldLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbXCJhbGlnblwiXSA9PSBcImxlZnRcIiA/IDE1IDogdGhpcy5zaXplWzBdIC0gMTUsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRzaXplICogLTAuMTUgKyBmb250c2l6ZSAqIChwYXJzZUludChpKSArIDEpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgdGhpcy5sYXN0X2N0eCA9IGN0eDtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgIH07XG5cbiAgICBXaWRnZXRUZXh0LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW1widmFsdWVcIl0gPSB2O1xuICAgICAgICB9XG4gICAgICAgIC8vdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlKTtcbiAgICB9O1xuXG4gICAgV2lkZ2V0VGV4dC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5sYXN0X2N0eCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5zdHIuc3BsaXQoXCJcXFxcblwiKTtcbiAgICAgICAgdGhpcy5sYXN0X2N0eC5mb250ID1cbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tcImZvbnRzaXplXCJdICsgXCJweCBcIiArIHRoaXMucHJvcGVydGllc1tcImZvbnRcIl07XG4gICAgICAgIHZhciBtYXggPSAwO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHcgPSB0aGlzLmxhc3RfY3R4Lm1lYXN1cmVUZXh0KGxpbmVzW2ldKS53aWR0aDtcbiAgICAgICAgICAgIGlmIChtYXggPCB3KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemVbMF0gPSBtYXggKyAyMDtcbiAgICAgICAgdGhpcy5zaXplWzFdID0gNCArIGxpbmVzLmxlbmd0aCAqIHRoaXMucHJvcGVydGllc1tcImZvbnRzaXplXCJdO1xuXG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgfTtcblxuICAgIFdpZGdldFRleHQucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc3RyID0gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyB2YWx1ZS50b0ZpeGVkKDMpIDogdmFsdWU7XG4gICAgICAgIC8vdGhpcy5yZXNpemUoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwid2lkZ2V0L3RleHRcIiwgV2lkZ2V0VGV4dCk7XG5cbiAgICBmdW5jdGlvbiBXaWRnZXRQYW5lbCgpIHtcbiAgICAgICAgdGhpcy5zaXplID0gWzIwMCwgMTAwXTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiI2ZmZmZmZlwiLFxuICAgICAgICAgICAgYmdjb2xvclRvcDogXCIjZjBmMGYwXCIsXG4gICAgICAgICAgICBiZ2NvbG9yQm90dG9tOiBcIiNlMGUwZTBcIixcbiAgICAgICAgICAgIHNoYWRvd1NpemU6IDIsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBXaWRnZXRQYW5lbC50aXRsZSA9IFwiUGFuZWxcIjtcbiAgICBXaWRnZXRQYW5lbC5kZXNjID0gXCJOb24gaW50ZXJhY3RpdmUgcGFuZWxcIjtcbiAgICBXaWRnZXRQYW5lbC53aWRnZXRzID0gW3sgbmFtZTogXCJ1cGRhdGVcIiwgdGV4dDogXCJVcGRhdGVcIiwgdHlwZTogXCJidXR0b25cIiB9XTtcblxuICAgIFdpZGdldFBhbmVsLnByb3RvdHlwZS5jcmVhdGVHcmFkaWVudCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbXCJiZ2NvbG9yVG9wXCJdID09IFwiXCIgfHxcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tcImJnY29sb3JCb3R0b21cIl0gPT0gXCJcIlxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMubGluZWFyZ3JhZGllbnQgPSAwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5saW5lYXJncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCB0aGlzLnNpemVbMV0pO1xuICAgICAgICB0aGlzLmxpbmVhcmdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCB0aGlzLnByb3BlcnRpZXNbXCJiZ2NvbG9yVG9wXCJdKTtcbiAgICAgICAgdGhpcy5saW5lYXJncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgdGhpcy5wcm9wZXJ0aWVzW1wiYmdjb2xvckJvdHRvbVwiXSk7XG4gICAgfTtcblxuICAgIFdpZGdldFBhbmVsLnByb3RvdHlwZS5vbkRyYXdGb3JlZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGluZWFyZ3JhZGllbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVHcmFkaWVudChjdHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmxpbmVhcmdyYWRpZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5wcm9wZXJ0aWVzW1wiYm9yZGVyQ29sb3JcIl07XG4gICAgICAgIC8vY3R4LmZpbGxTdHlsZSA9IFwiI2ViZWJlYlwiO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5saW5lYXJncmFkaWVudDtcblxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzW1wic2hhZG93U2l6ZVwiXSkge1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCIjMDAwXCI7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHRoaXMucHJvcGVydGllc1tcInNoYWRvd1NpemVcIl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgucm91bmRSZWN0KFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB0aGlzLnNpemVbMF0gLSAxLFxuICAgICAgICAgICAgdGhpcy5zaXplWzFdIC0gMSxcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tcInNoYWRvd1NpemVcIl1cbiAgICAgICAgKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwid2lkZ2V0L3BhbmVsXCIsIFdpZGdldFBhbmVsKTtcbn0pKHRoaXMpO1xuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcclxuXHJcbiAgICBmdW5jdGlvbiBHYW1lcGFkSW5wdXQoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJsZWZ0X3hfYXhpc1wiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcImxlZnRfeV9heGlzXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiYnV0dG9uX3ByZXNzZWRcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IGdhbWVwYWRfaW5kZXg6IDAsIHRocmVzaG9sZDogMC4xIH07XHJcblxyXG4gICAgICAgIHRoaXMuX2xlZnRfYXhpcyA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbiAgICAgICAgdGhpcy5fcmlnaHRfYXhpcyA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbiAgICAgICAgdGhpcy5fdHJpZ2dlcnMgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xyXG4gICAgICAgIHRoaXMuX3ByZXZpb3VzX2J1dHRvbnMgPSBuZXcgVWludDhBcnJheSgxNyk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudF9idXR0b25zID0gbmV3IFVpbnQ4QXJyYXkoMTcpO1xyXG4gICAgfVxyXG5cclxuICAgIEdhbWVwYWRJbnB1dC50aXRsZSA9IFwiR2FtZXBhZFwiO1xyXG4gICAgR2FtZXBhZElucHV0LmRlc2MgPSBcImdldHMgdGhlIGlucHV0IG9mIHRoZSBnYW1lcGFkXCI7XHJcblxyXG4gICAgR2FtZXBhZElucHV0LkNFTlRFUiA9IDA7XHJcbiAgICBHYW1lcGFkSW5wdXQuTEVGVCA9IDE7XHJcbiAgICBHYW1lcGFkSW5wdXQuUklHSFQgPSAyO1xyXG4gICAgR2FtZXBhZElucHV0LlVQID0gNDtcclxuICAgIEdhbWVwYWRJbnB1dC5ET1dOID0gODtcclxuXHJcbiAgICBHYW1lcGFkSW5wdXQuemVybyA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbiAgICBHYW1lcGFkSW5wdXQuYnV0dG9ucyA9IFtcclxuICAgICAgICBcImFcIixcclxuICAgICAgICBcImJcIixcclxuICAgICAgICBcInhcIixcclxuICAgICAgICBcInlcIixcclxuICAgICAgICBcImxiXCIsXHJcbiAgICAgICAgXCJyYlwiLFxyXG4gICAgICAgIFwibHRcIixcclxuICAgICAgICBcInJ0XCIsXHJcbiAgICAgICAgXCJiYWNrXCIsXHJcbiAgICAgICAgXCJzdGFydFwiLFxyXG4gICAgICAgIFwibHNcIixcclxuICAgICAgICBcInJzXCIsXHJcbiAgICAgICAgXCJob21lXCJcclxuICAgIF07XHJcblxyXG4gICAgR2FtZXBhZElucHV0LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvL2dldCBnYW1lcGFkXHJcbiAgICAgICAgdmFyIGdhbWVwYWQgPSB0aGlzLmdldEdhbWVwYWQoKTtcclxuICAgICAgICB2YXIgdGhyZXNob2xkID0gdGhpcy5wcm9wZXJ0aWVzLnRocmVzaG9sZCB8fCAwLjA7XHJcblxyXG4gICAgICAgIGlmIChnYW1lcGFkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlZnRfYXhpc1swXSA9XHJcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhnYW1lcGFkLnhib3guYXhlc1tcImx4XCJdKSA+IHRocmVzaG9sZFxyXG4gICAgICAgICAgICAgICAgICAgID8gZ2FtZXBhZC54Ym94LmF4ZXNbXCJseFwiXVxyXG4gICAgICAgICAgICAgICAgICAgIDogMDtcclxuICAgICAgICAgICAgdGhpcy5fbGVmdF9heGlzWzFdID1cclxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGdhbWVwYWQueGJveC5heGVzW1wibHlcIl0pID4gdGhyZXNob2xkXHJcbiAgICAgICAgICAgICAgICAgICAgPyBnYW1lcGFkLnhib3guYXhlc1tcImx5XCJdXHJcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgICAgICAgICB0aGlzLl9yaWdodF9heGlzWzBdID1cclxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGdhbWVwYWQueGJveC5heGVzW1wicnhcIl0pID4gdGhyZXNob2xkXHJcbiAgICAgICAgICAgICAgICAgICAgPyBnYW1lcGFkLnhib3guYXhlc1tcInJ4XCJdXHJcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgICAgICAgICB0aGlzLl9yaWdodF9heGlzWzFdID1cclxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGdhbWVwYWQueGJveC5heGVzW1wicnlcIl0pID4gdGhyZXNob2xkXHJcbiAgICAgICAgICAgICAgICAgICAgPyBnYW1lcGFkLnhib3guYXhlc1tcInJ5XCJdXHJcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2Vyc1swXSA9XHJcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhnYW1lcGFkLnhib3guYXhlc1tcImx0cmlnZ2VyXCJdKSA+IHRocmVzaG9sZFxyXG4gICAgICAgICAgICAgICAgICAgID8gZ2FtZXBhZC54Ym94LmF4ZXNbXCJsdHJpZ2dlclwiXVxyXG4gICAgICAgICAgICAgICAgICAgIDogMDtcclxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcnNbMV0gPVxyXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoZ2FtZXBhZC54Ym94LmF4ZXNbXCJydHJpZ2dlclwiXSkgPiB0aHJlc2hvbGRcclxuICAgICAgICAgICAgICAgICAgICA/IGdhbWVwYWQueGJveC5heGVzW1wicnRyaWdnZXJcIl1cclxuICAgICAgICAgICAgICAgICAgICA6IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5vdXRwdXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvdXRwdXQubGlua3MgfHwgIW91dHB1dC5saW5rcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB2ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZ2FtZXBhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAob3V0cHV0Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxlZnRfYXhpc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuX2xlZnRfYXhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRfYXhpc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuX3JpZ2h0X2F4aXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxlZnRfeF9heGlzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5fbGVmdF9heGlzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsZWZ0X3lfYXhpc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuX2xlZnRfYXhpc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRfeF9heGlzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5fcmlnaHRfYXhpc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRfeV9heGlzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5fcmlnaHRfYXhpc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidHJpZ2dlcl9sZWZ0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5fdHJpZ2dlcnNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRyaWdnZXJfcmlnaHRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB0aGlzLl90cmlnZ2Vyc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYV9idXR0b25cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guYnV0dG9uc1tcImFcIl0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYl9idXR0b25cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guYnV0dG9uc1tcImJcIl0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwieF9idXR0b25cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guYnV0dG9uc1tcInhcIl0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwieV9idXR0b25cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guYnV0dG9uc1tcInlcIl0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibGJfYnV0dG9uXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2FtZXBhZC54Ym94LmJ1dHRvbnNbXCJsYlwiXSA/IDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyYl9idXR0b25cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guYnV0dG9uc1tcInJiXCJdID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxzX2J1dHRvblwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGdhbWVwYWQueGJveC5idXR0b25zW1wibHNcIl0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicnNfYnV0dG9uXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2FtZXBhZC54Ym94LmJ1dHRvbnNbXCJyc1wiXSA/IDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJoYXRfbGVmdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGdhbWVwYWQueGJveC5oYXRtYXAgJiBHYW1lcGFkSW5wdXQuTEVGVDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaGF0X3JpZ2h0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2FtZXBhZC54Ym94LmhhdG1hcCAmIEdhbWVwYWRJbnB1dC5SSUdIVDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaGF0X3VwXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2FtZXBhZC54Ym94LmhhdG1hcCAmIEdhbWVwYWRJbnB1dC5VUDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaGF0X2Rvd25cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guaGF0bWFwICYgR2FtZXBhZElucHV0LkRPV047XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImhhdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGdhbWVwYWQueGJveC5oYXRtYXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0YXJ0X2J1dHRvblwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGdhbWVwYWQueGJveC5idXR0b25zW1wic3RhcnRcIl0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYmFja19idXR0b25cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnYW1lcGFkLnhib3guYnV0dG9uc1tcImJhY2tcIl0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYnV0dG9uX3ByZXNzZWRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPCB0aGlzLl9jdXJyZW50X2J1dHRvbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsralxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50X2J1dHRvbnNbal0gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX3ByZXZpb3VzX2J1dHRvbnNbal1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyU2xvdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHYW1lcGFkSW5wdXQuYnV0dG9uc1tqXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2lmIG5vIGdhbWVwYWQgaXMgY29ubmVjdGVkLCBvdXRwdXQgMFxyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAob3V0cHV0Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJ1dHRvbl9wcmVzc2VkXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxlZnRfYXhpc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRfYXhpc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IEdhbWVwYWRJbnB1dC56ZXJvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoaSwgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHRHYW1lcGFkSW5wdXQubWFwcGluZyA9IHthOjAsYjoxLHg6Mix5OjMsbGI6NCxyYjo1LGx0OjYscnQ6NyxiYWNrOjgsc3RhcnQ6OSxsczoxMCxyczoxMSB9O1xyXG5cdEdhbWVwYWRJbnB1dC5tYXBwaW5nX2FycmF5ID0gW1wiYVwiLFwiYlwiLFwieFwiLFwieVwiLFwibGJcIixcInJiXCIsXCJsdFwiLFwicnRcIixcImJhY2tcIixcInN0YXJ0XCIsXCJsc1wiLFwicnNcIl07XHJcblxyXG4gICAgR2FtZXBhZElucHV0LnByb3RvdHlwZS5nZXRHYW1lcGFkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGdldEdhbWVwYWRzID1cclxuICAgICAgICAgICAgbmF2aWdhdG9yLmdldEdhbWVwYWRzIHx8XHJcbiAgICAgICAgICAgIG5hdmlnYXRvci53ZWJraXRHZXRHYW1lcGFkcyB8fFxyXG4gICAgICAgICAgICBuYXZpZ2F0b3IubW96R2V0R2FtZXBhZHM7XHJcbiAgICAgICAgaWYgKCFnZXRHYW1lcGFkcykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGdhbWVwYWRzID0gZ2V0R2FtZXBhZHMuY2FsbChuYXZpZ2F0b3IpO1xyXG4gICAgICAgIHZhciBnYW1lcGFkID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5fcHJldmlvdXNfYnV0dG9ucy5zZXQodGhpcy5fY3VycmVudF9idXR0b25zKTtcclxuXHJcbiAgICAgICAgLy9waWNrIHRoZSBmaXJzdCBjb25uZWN0ZWRcclxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5wcm9wZXJ0aWVzLmdhbWVwYWRfaW5kZXg7IGkgPCA0OyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCFnYW1lcGFkc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2FtZXBhZCA9IGdhbWVwYWRzW2ldO1xyXG5cclxuICAgICAgICAgICAgLy94Ym94IGNvbnRyb2xsZXIgbWFwcGluZ1xyXG4gICAgICAgICAgICB2YXIgeGJveCA9IHRoaXMueGJveF9tYXBwaW5nO1xyXG4gICAgICAgICAgICBpZiAoIXhib3gpIHtcclxuICAgICAgICAgICAgICAgIHhib3ggPSB0aGlzLnhib3hfbWFwcGluZyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBheGVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBidXR0b25zOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBoYXQ6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgaGF0bWFwOiBHYW1lcGFkSW5wdXQuQ0VOVEVSXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB4Ym94LmF4ZXNbXCJseFwiXSA9IGdhbWVwYWQuYXhlc1swXTtcclxuICAgICAgICAgICAgeGJveC5heGVzW1wibHlcIl0gPSBnYW1lcGFkLmF4ZXNbMV07XHJcbiAgICAgICAgICAgIHhib3guYXhlc1tcInJ4XCJdID0gZ2FtZXBhZC5heGVzWzJdO1xyXG4gICAgICAgICAgICB4Ym94LmF4ZXNbXCJyeVwiXSA9IGdhbWVwYWQuYXhlc1szXTtcclxuICAgICAgICAgICAgeGJveC5heGVzW1wibHRyaWdnZXJcIl0gPSBnYW1lcGFkLmJ1dHRvbnNbNl0udmFsdWU7XHJcbiAgICAgICAgICAgIHhib3guYXhlc1tcInJ0cmlnZ2VyXCJdID0gZ2FtZXBhZC5idXR0b25zWzddLnZhbHVlO1xyXG4gICAgICAgICAgICB4Ym94LmhhdCA9IFwiXCI7XHJcbiAgICAgICAgICAgIHhib3guaGF0bWFwID0gR2FtZXBhZElucHV0LkNFTlRFUjtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2FtZXBhZC5idXR0b25zLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50X2J1dHRvbnNbal0gPSBnYW1lcGFkLmJ1dHRvbnNbal0ucHJlc3NlZDtcclxuXHJcblx0XHRcdFx0aWYoaiA8IDEyKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHhib3guYnV0dG9uc1sgR2FtZXBhZElucHV0Lm1hcHBpbmdfYXJyYXlbal0gXSA9IGdhbWVwYWQuYnV0dG9uc1tqXS5wcmVzc2VkO1xyXG5cdFx0XHRcdFx0aWYoZ2FtZXBhZC5idXR0b25zW2pdLndhc19wcmVzc2VkKVxyXG5cdFx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoIEdhbWVwYWRJbnB1dC5tYXBwaW5nX2FycmF5W2pdICsgXCJfYnV0dG9uX2V2ZW50XCIgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSAvL21hcHBpbmcgb2YgWEJPWFxyXG5cdFx0XHRcdFx0c3dpdGNoICggaiApIC8vSSB1c2UgYSBzd2l0Y2ggdG8gZW5zdXJlIHRoYXQgYSBwbGF5ZXIgd2l0aCBhbm90aGVyIGdhbWVwYWQgY291bGQgcGxheVxyXG5cdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRjYXNlIDEyOlxyXG5cdFx0XHRcdFx0XHRcdGlmIChnYW1lcGFkLmJ1dHRvbnNbal0ucHJlc3NlZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0eGJveC5oYXQgKz0gXCJ1cFwiO1xyXG5cdFx0XHRcdFx0XHRcdFx0eGJveC5oYXRtYXAgfD0gR2FtZXBhZElucHV0LlVQO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAxMzpcclxuXHRcdFx0XHRcdFx0XHRpZiAoZ2FtZXBhZC5idXR0b25zW2pdLnByZXNzZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHhib3guaGF0ICs9IFwiZG93blwiO1xyXG5cdFx0XHRcdFx0XHRcdFx0eGJveC5oYXRtYXAgfD0gR2FtZXBhZElucHV0LkRPV047XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlIDE0OlxyXG5cdFx0XHRcdFx0XHRcdGlmIChnYW1lcGFkLmJ1dHRvbnNbal0ucHJlc3NlZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0eGJveC5oYXQgKz0gXCJsZWZ0XCI7XHJcblx0XHRcdFx0XHRcdFx0XHR4Ym94LmhhdG1hcCB8PSBHYW1lcGFkSW5wdXQuTEVGVDtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgMTU6XHJcblx0XHRcdFx0XHRcdFx0aWYgKGdhbWVwYWQuYnV0dG9uc1tqXS5wcmVzc2VkKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR4Ym94LmhhdCArPSBcInJpZ2h0XCI7XHJcblx0XHRcdFx0XHRcdFx0XHR4Ym94LmhhdG1hcCB8PSBHYW1lcGFkSW5wdXQuUklHSFQ7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlIDE2OlxyXG5cdFx0XHRcdFx0XHRcdHhib3guYnV0dG9uc1tcImhvbWVcIl0gPSBnYW1lcGFkLmJ1dHRvbnNbal0ucHJlc3NlZDtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnYW1lcGFkLnhib3ggPSB4Ym94O1xyXG4gICAgICAgICAgICByZXR1cm4gZ2FtZXBhZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEdhbWVwYWRJbnB1dC5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3JlbmRlciBnYW1lcGFkIHN0YXRlP1xyXG4gICAgICAgIHZhciBsYSA9IHRoaXMuX2xlZnRfYXhpcztcclxuICAgICAgICB2YXIgcmEgPSB0aGlzLl9yaWdodF9heGlzO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiIzg4QVwiO1xyXG4gICAgICAgIGN0eC5zdHJva2VSZWN0KFxyXG4gICAgICAgICAgICAobGFbMF0gKyAxKSAqIDAuNSAqIHRoaXMuc2l6ZVswXSAtIDQsXHJcbiAgICAgICAgICAgIChsYVsxXSArIDEpICogMC41ICogdGhpcy5zaXplWzFdIC0gNCxcclxuICAgICAgICAgICAgOCxcclxuICAgICAgICAgICAgOFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCIjOEE4XCI7XHJcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QoXHJcbiAgICAgICAgICAgIChyYVswXSArIDEpICogMC41ICogdGhpcy5zaXplWzBdIC0gNCxcclxuICAgICAgICAgICAgKHJhWzFdICsgMSkgKiAwLjUgKiB0aGlzLnNpemVbMV0gLSA0LFxyXG4gICAgICAgICAgICA4LFxyXG4gICAgICAgICAgICA4XHJcbiAgICAgICAgKTtcclxuICAgICAgICB2YXIgaCA9IHRoaXMuc2l6ZVsxXSAvIHRoaXMuX2N1cnJlbnRfYnV0dG9ucy5sZW5ndGg7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI0FFQlwiO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY3VycmVudF9idXR0b25zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50X2J1dHRvbnNbaV0pIHtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCBoICogaSwgNiwgaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEdhbWVwYWRJbnB1dC5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgW1wibGVmdF9heGlzXCIsIFwidmVjMlwiXSxcclxuICAgICAgICAgICAgW1wicmlnaHRfYXhpc1wiLCBcInZlYzJcIl0sXHJcbiAgICAgICAgICAgIFtcImxlZnRfeF9heGlzXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJsZWZ0X3lfYXhpc1wiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wicmlnaHRfeF9heGlzXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJyaWdodF95X2F4aXNcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInRyaWdnZXJfbGVmdFwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1widHJpZ2dlcl9yaWdodFwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiYV9idXR0b25cIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImJfYnV0dG9uXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJ4X2J1dHRvblwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wieV9idXR0b25cIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImxiX2J1dHRvblwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wicmJfYnV0dG9uXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJsc19idXR0b25cIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInJzX2J1dHRvblwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wic3RhcnRfYnV0dG9uXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJiYWNrX2J1dHRvblwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiYV9idXR0b25fZXZlbnRcIiwgTGl0ZUdyYXBoLkVWRU5UIF0sXHJcbiAgICAgICAgICAgIFtcImJfYnV0dG9uX2V2ZW50XCIsIExpdGVHcmFwaC5FVkVOVCBdLFxyXG4gICAgICAgICAgICBbXCJ4X2J1dHRvbl9ldmVudFwiLCBMaXRlR3JhcGguRVZFTlQgXSxcclxuICAgICAgICAgICAgW1wieV9idXR0b25fZXZlbnRcIiwgTGl0ZUdyYXBoLkVWRU5UIF0sXHJcbiAgICAgICAgICAgIFtcImxiX2J1dHRvbl9ldmVudFwiLCBMaXRlR3JhcGguRVZFTlQgXSxcclxuICAgICAgICAgICAgW1wicmJfYnV0dG9uX2V2ZW50XCIsIExpdGVHcmFwaC5FVkVOVCBdLFxyXG4gICAgICAgICAgICBbXCJsc19idXR0b25fZXZlbnRcIiwgTGl0ZUdyYXBoLkVWRU5UIF0sXHJcbiAgICAgICAgICAgIFtcInJzX2J1dHRvbl9ldmVudFwiLCBMaXRlR3JhcGguRVZFTlQgXSxcclxuICAgICAgICAgICAgW1wic3RhcnRfYnV0dG9uX2V2ZW50XCIsIExpdGVHcmFwaC5FVkVOVCBdLFxyXG4gICAgICAgICAgICBbXCJiYWNrX2J1dHRvbl9ldmVudFwiLCBMaXRlR3JhcGguRVZFTlQgXSxcclxuICAgICAgICAgICAgW1wiaGF0X2xlZnRcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImhhdF9yaWdodFwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiaGF0X3VwXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJoYXRfZG93blwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiaGF0XCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJidXR0b25fcHJlc3NlZFwiLCBMaXRlR3JhcGguRVZFTlRdXHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJpbnB1dC9nYW1lcGFkXCIsIEdhbWVwYWRJbnB1dCk7XHJcblxyXG59KSh0aGlzKTtcclxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICAgdmFyIExpdGVHcmFwaCA9IGdsb2JhbC5MaXRlR3JhcGg7XG5cbiAgICAvL0NvbnZlcnRlclxuICAgIGZ1bmN0aW9uIENvbnZlcnRlcigpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIDApO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIDApO1xuICAgICAgICB0aGlzLnNpemUgPSBbODAsIDMwXTtcbiAgICB9XG5cbiAgICBDb252ZXJ0ZXIudGl0bGUgPSBcIkNvbnZlcnRlclwiO1xuICAgIENvbnZlcnRlci5kZXNjID0gXCJ0eXBlIEEgdG8gdHlwZSBCXCI7XG5cbiAgICBDb252ZXJ0ZXIucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vdXRwdXRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFvdXRwdXQubGlua3MgfHwgIW91dHB1dC5saW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvdXRwdXQubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB2Lmxlbmd0aCA/IHZbMF0gOiBwYXJzZUZsb2F0KHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2ZWMyXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2ZWMzXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2ZWM0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG91dHB1dC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInZlYzJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidmVjM1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2ZWM0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA8IHYubGVuZ3RoICYmIGogPCByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2pdID0gdltqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFswXSA9IHBhcnNlRmxvYXQodik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKGksIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29udmVydGVyLnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFtcIm51bWJlclwiLCBcIm51bWJlclwiXSxcbiAgICAgICAgICAgIFtcInZlYzJcIiwgXCJ2ZWMyXCJdLFxuICAgICAgICAgICAgW1widmVjM1wiLCBcInZlYzNcIl0sXG4gICAgICAgICAgICBbXCJ2ZWM0XCIsIFwidmVjNFwiXVxuICAgICAgICBdO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvY29udmVydGVyXCIsIENvbnZlcnRlcik7XG5cbiAgICAvL0J5cGFzc1xuICAgIGZ1bmN0aW9uIEJ5cGFzcygpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiKTtcbiAgICAgICAgdGhpcy5zaXplID0gWzgwLCAzMF07XG4gICAgfVxuXG4gICAgQnlwYXNzLnRpdGxlID0gXCJCeXBhc3NcIjtcbiAgICBCeXBhc3MuZGVzYyA9IFwicmVtb3ZlcyB0aGUgdHlwZVwiO1xuXG4gICAgQnlwYXNzLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHYpO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvYnlwYXNzXCIsIEJ5cGFzcyk7XG5cbiAgICBmdW5jdGlvbiBUb051bWJlcigpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiKTtcbiAgICB9XG5cbiAgICBUb051bWJlci50aXRsZSA9IFwidG8gTnVtYmVyXCI7XG4gICAgVG9OdW1iZXIuZGVzYyA9IFwiQ2FzdCB0byBudW1iZXJcIjtcblxuICAgIFRvTnVtYmVyLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIE51bWJlcih2KSk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC90b19udW1iZXJcIiwgVG9OdW1iZXIpO1xuXG4gICAgZnVuY3Rpb24gTWF0aFJhbmdlKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJudW1iZXJcIiwgeyBsb2NrZWQ6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibnVtYmVyXCIsIHsgbG9ja2VkOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcImNsYW1wZWRcIiwgXCJudW1iZXJcIiwgeyBsb2NrZWQ6IHRydWUgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcImluXCIsIDApO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiaW5fbWluXCIsIDApO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiaW5fbWF4XCIsIDEpO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwib3V0X21pblwiLCAwKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIm91dF9tYXhcIiwgMSk7XG5cbiAgICAgICAgdGhpcy5zaXplID0gWzEyMCwgNTBdO1xuICAgIH1cblxuICAgIE1hdGhSYW5nZS50aXRsZSA9IFwiUmFuZ2VcIjtcbiAgICBNYXRoUmFuZ2UuZGVzYyA9IFwiQ29udmVydCBhIG51bWJlciBmcm9tIG9uZSByYW5nZSB0byBhbm90aGVyXCI7XG5cbiAgICBNYXRoUmFuZ2UucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9sYXN0X3YgfHwgMCkudG9GaXhlZCgyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50aXRsZTtcbiAgICB9O1xuXG4gICAgTWF0aFJhbmdlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbaW5wdXQubmFtZV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHYgPSB0aGlzLnByb3BlcnRpZXNbXCJpblwiXTtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsIHx8IHYuY29uc3RydWN0b3IgIT09IE51bWJlcikge1xuICAgICAgICAgICAgdiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5fbWluID0gdGhpcy5wcm9wZXJ0aWVzLmluX21pbjtcbiAgICAgICAgdmFyIGluX21heCA9IHRoaXMucHJvcGVydGllcy5pbl9tYXg7XG4gICAgICAgIHZhciBvdXRfbWluID0gdGhpcy5wcm9wZXJ0aWVzLm91dF9taW47XG4gICAgICAgIHZhciBvdXRfbWF4ID0gdGhpcy5wcm9wZXJ0aWVzLm91dF9tYXg7XG5cdFx0Lypcblx0XHRpZiggaW5fbWluID4gaW5fbWF4IClcblx0XHR7XG5cdFx0XHRpbl9taW4gPSBpbl9tYXg7XG5cdFx0XHRpbl9tYXggPSB0aGlzLnByb3BlcnRpZXMuaW5fbWluO1xuXHRcdH1cblx0XHRpZiggb3V0X21pbiA+IG91dF9tYXggKVxuXHRcdHtcblx0XHRcdG91dF9taW4gPSBvdXRfbWF4O1xuXHRcdFx0b3V0X21heCA9IHRoaXMucHJvcGVydGllcy5vdXRfbWluO1xuXHRcdH1cblx0XHQqL1xuXG4gICAgICAgIHRoaXMuX2xhc3RfdiA9ICgodiAtIGluX21pbikgLyAoaW5fbWF4IC0gaW5fbWluKSkgKiAob3V0X21heCAtIG91dF9taW4pICsgb3V0X21pbjtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX2xhc3Rfdik7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgxLCBjbGFtcCggdGhpcy5fbGFzdF92LCBvdXRfbWluLCBvdXRfbWF4ICkpO1xuICAgIH07XG5cbiAgICBNYXRoUmFuZ2UucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgLy9zaG93IHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgIGlmICh0aGlzLl9sYXN0X3YpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0c1swXS5sYWJlbCA9IHRoaXMuX2xhc3Rfdi50b0ZpeGVkKDMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRzWzBdLmxhYmVsID0gXCI/XCI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTWF0aFJhbmdlLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgW1wiaW5fbWluXCIsIFwibnVtYmVyXCJdLFxuICAgICAgICAgICAgW1wiaW5fbWF4XCIsIFwibnVtYmVyXCJdLFxuICAgICAgICAgICAgW1wib3V0X21pblwiLCBcIm51bWJlclwiXSxcbiAgICAgICAgICAgIFtcIm91dF9tYXhcIiwgXCJudW1iZXJcIl1cbiAgICAgICAgXTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL3JhbmdlXCIsIE1hdGhSYW5nZSk7XG5cbiAgICBmdW5jdGlvbiBNYXRoUmFuZCgpIHtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ2YWx1ZVwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIm1pblwiLCAwKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIm1heFwiLCAxKTtcbiAgICAgICAgdGhpcy5zaXplID0gWzgwLCAzMF07XG4gICAgfVxuXG4gICAgTWF0aFJhbmQudGl0bGUgPSBcIlJhbmRcIjtcbiAgICBNYXRoUmFuZC5kZXNjID0gXCJSYW5kb20gbnVtYmVyXCI7XG5cbiAgICBNYXRoUmFuZC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmlucHV0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW2lucHV0Lm5hbWVdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW4gPSB0aGlzLnByb3BlcnRpZXMubWluO1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy5wcm9wZXJ0aWVzLm1heDtcbiAgICAgICAgdGhpcy5fbGFzdF92ID0gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fbGFzdF92KTtcbiAgICB9O1xuXG4gICAgTWF0aFJhbmQucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgLy9zaG93IHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgIHRoaXMub3V0cHV0c1swXS5sYWJlbCA9ICh0aGlzLl9sYXN0X3YgfHwgMCkudG9GaXhlZCgzKTtcbiAgICB9O1xuXG4gICAgTWF0aFJhbmQucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbW1wibWluXCIsIFwibnVtYmVyXCJdLCBbXCJtYXhcIiwgXCJudW1iZXJcIl1dO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvcmFuZFwiLCBNYXRoUmFuZCk7XG5cbiAgICAvL2Jhc2ljIGNvbnRpbnVvdXMgbm9pc2VcbiAgICBmdW5jdGlvbiBNYXRoTm9pc2UoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJtaW5cIiwgMCk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJtYXhcIiwgMSk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJzbW9vdGhcIiwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJzZWVkXCIsIDApO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwib2N0YXZlc1wiLCAxKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInBlcnNpc3RlbmNlXCIsIDAuOCk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJzcGVlZFwiLCAxKTtcbiAgICAgICAgdGhpcy5zaXplID0gWzkwLCAzMF07XG4gICAgfVxuXG4gICAgTWF0aE5vaXNlLnRpdGxlID0gXCJOb2lzZVwiO1xuICAgIE1hdGhOb2lzZS5kZXNjID0gXCJSYW5kb20gbnVtYmVyIHdpdGggdGVtcG9yYWwgY29udGludWl0eVwiO1xuICAgIE1hdGhOb2lzZS5kYXRhID0gbnVsbDtcblxuICAgIE1hdGhOb2lzZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKGYsIHNtb290aCkge1xuICAgICAgICBpZiAoIU1hdGhOb2lzZS5kYXRhKSB7XG4gICAgICAgICAgICBNYXRoTm9pc2UuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMTAyNCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGhOb2lzZS5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgTWF0aE5vaXNlLmRhdGFbaV0gPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGYgPSBmICUgMTAyNDtcbiAgICAgICAgaWYgKGYgPCAwKSB7XG4gICAgICAgICAgICBmICs9IDEwMjQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZfbWluID0gTWF0aC5mbG9vcihmKTtcbiAgICAgICAgdmFyIGYgPSBmIC0gZl9taW47XG4gICAgICAgIHZhciByMSA9IE1hdGhOb2lzZS5kYXRhW2ZfbWluXTtcbiAgICAgICAgdmFyIHIyID0gTWF0aE5vaXNlLmRhdGFbZl9taW4gPT0gMTAyMyA/IDAgOiBmX21pbiArIDFdO1xuICAgICAgICBpZiAoc21vb3RoKSB7XG4gICAgICAgICAgICBmID0gZiAqIGYgKiBmICogKGYgKiAoZiAqIDYuMCAtIDE1LjApICsgMTAuMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHIxICogKDEgLSBmKSArIHIyICogZjtcbiAgICB9O1xuXG4gICAgTWF0aE5vaXNlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLmdldElucHV0RGF0YSgwKSB8fCAwO1xuXHRcdHZhciBpdGVyYXRpb25zID0gdGhpcy5wcm9wZXJ0aWVzLm9jdGF2ZXMgfHwgMTtcblx0XHR2YXIgciA9IDA7XG5cdFx0dmFyIGFtcCA9IDE7XG5cdFx0dmFyIHNlZWQgPSB0aGlzLnByb3BlcnRpZXMuc2VlZCB8fCAwO1xuXHRcdGYgKz0gc2VlZDtcblx0XHR2YXIgc3BlZWQgPSB0aGlzLnByb3BlcnRpZXMuc3BlZWQgfHwgMTtcblx0XHR2YXIgdG90YWxfYW1wID0gMDtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgKytpKVxuXHRcdHtcblx0XHRcdHIgKz0gTWF0aE5vaXNlLmdldFZhbHVlKGYgKiAoMStpKSAqIHNwZWVkLCB0aGlzLnByb3BlcnRpZXMuc21vb3RoKSAqIGFtcDtcblx0XHRcdHRvdGFsX2FtcCArPSBhbXA7XG5cdFx0XHRhbXAgKj0gdGhpcy5wcm9wZXJ0aWVzLnBlcnNpc3RlbmNlO1xuXHRcdFx0aWYoYW1wIDwgMC4wMDEpXG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRyIC89IHRvdGFsX2FtcDtcbiAgICAgICAgdmFyIG1pbiA9IHRoaXMucHJvcGVydGllcy5taW47XG4gICAgICAgIHZhciBtYXggPSB0aGlzLnByb3BlcnRpZXMubWF4O1xuICAgICAgICB0aGlzLl9sYXN0X3YgPSByICogKG1heCAtIG1pbikgKyBtaW47XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl9sYXN0X3YpO1xuICAgIH07XG5cbiAgICBNYXRoTm9pc2UucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgLy9zaG93IHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgIHRoaXMub3V0cHV0c1swXS5sYWJlbCA9ICh0aGlzLl9sYXN0X3YgfHwgMCkudG9GaXhlZCgzKTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL25vaXNlXCIsIE1hdGhOb2lzZSk7XG5cbiAgICAvL2dlbmVyYXRlcyBzcGlrZXMgZXZlcnkgcmFuZG9tIHRpbWVcbiAgICBmdW5jdGlvbiBNYXRoU3Bpa2VzKCkge1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIm1pbl90aW1lXCIsIDEpO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwibWF4X3RpbWVcIiwgMik7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJkdXJhdGlvblwiLCAwLjIpO1xuICAgICAgICB0aGlzLnNpemUgPSBbOTAsIDMwXTtcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nX3RpbWUgPSAwO1xuICAgICAgICB0aGlzLl9ibGlua190aW1lID0gMDtcbiAgICB9XG5cbiAgICBNYXRoU3Bpa2VzLnRpdGxlID0gXCJTcGlrZXNcIjtcbiAgICBNYXRoU3Bpa2VzLmRlc2MgPSBcInNwaWtlIGV2ZXJ5IHJhbmRvbSB0aW1lXCI7XG5cbiAgICBNYXRoU3Bpa2VzLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGR0ID0gdGhpcy5ncmFwaC5lbGFwc2VkX3RpbWU7IC8vaW4gc2Vjc1xuXG4gICAgICAgIHRoaXMuX3JlbWFpbmluZ190aW1lIC09IGR0O1xuICAgICAgICB0aGlzLl9ibGlua190aW1lIC09IGR0O1xuXG4gICAgICAgIHZhciB2ID0gMDtcbiAgICAgICAgaWYgKHRoaXMuX2JsaW5rX3RpbWUgPiAwKSB7XG4gICAgICAgICAgICB2YXIgZiA9IHRoaXMuX2JsaW5rX3RpbWUgLyB0aGlzLnByb3BlcnRpZXMuZHVyYXRpb247XG4gICAgICAgICAgICB2ID0gMSAvIChNYXRoLnBvdyhmICogOCAtIDQsIDQpICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nX3RpbWUgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1haW5pbmdfdGltZSA9XG4gICAgICAgICAgICAgICAgTWF0aC5yYW5kb20oKSAqXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnByb3BlcnRpZXMubWF4X3RpbWUgLSB0aGlzLnByb3BlcnRpZXMubWluX3RpbWUpICtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWluX3RpbWU7XG4gICAgICAgICAgICB0aGlzLl9ibGlua190aW1lID0gdGhpcy5wcm9wZXJ0aWVzLmR1cmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiI0ZGRlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiIzAwMFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB2KTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL3NwaWtlc1wiLCBNYXRoU3Bpa2VzKTtcblxuICAgIC8vTWF0aCBjbGFtcFxuICAgIGZ1bmN0aW9uIE1hdGhDbGFtcCgpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5zaXplID0gWzgwLCAzMF07XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJtaW5cIiwgMCk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJtYXhcIiwgMSk7XG4gICAgfVxuXG4gICAgTWF0aENsYW1wLnRpdGxlID0gXCJDbGFtcFwiO1xuICAgIE1hdGhDbGFtcC5kZXNjID0gXCJDbGFtcCBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heFwiO1xuICAgIC8vTWF0aENsYW1wLmZpbHRlciA9IFwic2hhZGVyXCI7XG5cbiAgICBNYXRoQ2xhbXAucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdiA9IE1hdGgubWF4KHRoaXMucHJvcGVydGllcy5taW4sIHYpO1xuICAgICAgICB2ID0gTWF0aC5taW4odGhpcy5wcm9wZXJ0aWVzLm1heCwgdik7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB2KTtcbiAgICB9O1xuXG4gICAgTWF0aENsYW1wLnByb3RvdHlwZS5nZXRDb2RlID0gZnVuY3Rpb24obGFuZykge1xuICAgICAgICB2YXIgY29kZSA9IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLmlzSW5wdXRDb25uZWN0ZWQoMCkpIHtcbiAgICAgICAgICAgIGNvZGUgKz1cbiAgICAgICAgICAgICAgICBcImNsYW1wKHt7MH19LFwiICtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWluICtcbiAgICAgICAgICAgICAgICBcIixcIiArXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1heCArXG4gICAgICAgICAgICAgICAgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9jbGFtcFwiLCBNYXRoQ2xhbXApO1xuXG4gICAgLy9NYXRoIEFCU1xuICAgIGZ1bmN0aW9uIE1hdGhMZXJwKCkge1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IGY6IDAuNSB9O1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiQVwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkJcIiwgXCJudW1iZXJcIik7XG5cbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJudW1iZXJcIik7XG4gICAgfVxuXG4gICAgTWF0aExlcnAudGl0bGUgPSBcIkxlcnBcIjtcbiAgICBNYXRoTGVycC5kZXNjID0gXCJMaW5lYXIgSW50ZXJwb2xhdGlvblwiO1xuXG4gICAgTWF0aExlcnAucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdjEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgaWYgKHYxID09IG51bGwpIHtcbiAgICAgICAgICAgIHYxID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdjIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcbiAgICAgICAgaWYgKHYyID09IG51bGwpIHtcbiAgICAgICAgICAgIHYyID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmID0gdGhpcy5wcm9wZXJ0aWVzLmY7XG5cbiAgICAgICAgdmFyIF9mID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XG4gICAgICAgIGlmIChfZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmID0gX2Y7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdjEgKiAoMSAtIGYpICsgdjIgKiBmKTtcbiAgICB9O1xuXG4gICAgTWF0aExlcnAucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbW1wiZlwiLCBcIm51bWJlclwiXV07XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9sZXJwXCIsIE1hdGhMZXJwKTtcblxuICAgIC8vTWF0aCBBQlNcbiAgICBmdW5jdGlvbiBNYXRoQWJzKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLnNpemUgPSBbODAsIDMwXTtcbiAgICB9XG5cbiAgICBNYXRoQWJzLnRpdGxlID0gXCJBYnNcIjtcbiAgICBNYXRoQWJzLmRlc2MgPSBcIkFic29sdXRlXCI7XG5cbiAgICBNYXRoQWJzLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBNYXRoLmFicyh2KSk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9hYnNcIiwgTWF0aEFicyk7XG5cbiAgICAvL01hdGggRmxvb3JcbiAgICBmdW5jdGlvbiBNYXRoRmxvb3IoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgMzBdO1xuICAgIH1cblxuICAgIE1hdGhGbG9vci50aXRsZSA9IFwiRmxvb3JcIjtcbiAgICBNYXRoRmxvb3IuZGVzYyA9IFwiRmxvb3IgbnVtYmVyIHRvIHJlbW92ZSBmcmFjdGlvbmFsIHBhcnRcIjtcblxuICAgIE1hdGhGbG9vci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgTWF0aC5mbG9vcih2KSk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9mbG9vclwiLCBNYXRoRmxvb3IpO1xuXG4gICAgLy9NYXRoIGZyYWNcbiAgICBmdW5jdGlvbiBNYXRoRnJhYygpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5zaXplID0gWzgwLCAzMF07XG4gICAgfVxuXG4gICAgTWF0aEZyYWMudGl0bGUgPSBcIkZyYWNcIjtcbiAgICBNYXRoRnJhYy5kZXNjID0gXCJSZXR1cm5zIGZyYWN0aW9uYWwgcGFydFwiO1xuXG4gICAgTWF0aEZyYWMucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHYgJSAxKTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL2ZyYWNcIiwgTWF0aEZyYWMpO1xuXG4gICAgLy9NYXRoIEZsb29yXG4gICAgZnVuY3Rpb24gTWF0aFNtb290aFN0ZXAoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgMzBdO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IEE6IDAsIEI6IDEgfTtcbiAgICB9XG5cbiAgICBNYXRoU21vb3RoU3RlcC50aXRsZSA9IFwiU21vb3Roc3RlcFwiO1xuICAgIE1hdGhTbW9vdGhTdGVwLmRlc2MgPSBcIlNtb290aHN0ZXBcIjtcblxuICAgIE1hdGhTbW9vdGhTdGVwLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkZ2UwID0gdGhpcy5wcm9wZXJ0aWVzLkE7XG4gICAgICAgIHZhciBlZGdlMSA9IHRoaXMucHJvcGVydGllcy5CO1xuXG4gICAgICAgIC8vIFNjYWxlLCBiaWFzIGFuZCBzYXR1cmF0ZSB4IHRvIDAuLjEgcmFuZ2VcbiAgICAgICAgdiA9IGNsYW1wKCh2IC0gZWRnZTApIC8gKGVkZ2UxIC0gZWRnZTApLCAwLjAsIDEuMCk7XG4gICAgICAgIC8vIEV2YWx1YXRlIHBvbHlub21pYWxcbiAgICAgICAgdiA9IHYgKiB2ICogKDMgLSAyICogdik7XG5cbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHYpO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgvc21vb3Roc3RlcFwiLCBNYXRoU21vb3RoU3RlcCk7XG5cbiAgICAvL01hdGggc2NhbGVcbiAgICBmdW5jdGlvbiBNYXRoU2NhbGUoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIm51bWJlclwiLCB7IGxhYmVsOiBcIlwiIH0pO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIm51bWJlclwiLCB7IGxhYmVsOiBcIlwiIH0pO1xuICAgICAgICB0aGlzLnNpemUgPSBbODAsIDMwXTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcImZhY3RvclwiLCAxKTtcbiAgICB9XG5cbiAgICBNYXRoU2NhbGUudGl0bGUgPSBcIlNjYWxlXCI7XG4gICAgTWF0aFNjYWxlLmRlc2MgPSBcInYgKiBmYWN0b3JcIjtcblxuICAgIE1hdGhTY2FsZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHZhbHVlICogdGhpcy5wcm9wZXJ0aWVzLmZhY3Rvcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL3NjYWxlXCIsIE1hdGhTY2FsZSk7XG5cblx0Ly9HYXRlXG5cdGZ1bmN0aW9uIEdhdGUoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcInZcIixcImJvb2xlYW5cIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIkFcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIkJcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIik7XG5cdH1cblxuXHRHYXRlLnRpdGxlID0gXCJHYXRlXCI7XG5cdEdhdGUuZGVzYyA9IFwiaWYgdiBpcyB0cnVlLCB0aGVuIG91dHB1dHMgQSwgb3RoZXJ3aXNlIEJcIjtcblxuXHRHYXRlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLmdldElucHV0RGF0YSggdiA/IDEgOiAyICkpO1xuXHR9O1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9nYXRlXCIsIEdhdGUpO1xuXG5cbiAgICAvL01hdGggQXZlcmFnZVxuICAgIGZ1bmN0aW9uIE1hdGhBdmVyYWdlRmlsdGVyKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLnNpemUgPSBbODAsIDMwXTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInNhbXBsZXNcIiwgMTApO1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KDEwKTtcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IDA7XG4gICAgfVxuXG4gICAgTWF0aEF2ZXJhZ2VGaWx0ZXIudGl0bGUgPSBcIkF2ZXJhZ2VcIjtcbiAgICBNYXRoQXZlcmFnZUZpbHRlci5kZXNjID0gXCJBdmVyYWdlIEZpbHRlclwiO1xuXG4gICAgTWF0aEF2ZXJhZ2VGaWx0ZXIucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICB2ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBudW1fc2FtcGxlcyA9IHRoaXMuX3ZhbHVlcy5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5fdmFsdWVzW3RoaXMuX2N1cnJlbnQgJSBudW1fc2FtcGxlc10gPSB2O1xuICAgICAgICB0aGlzLl9jdXJyZW50ICs9IDE7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50ID4gbnVtX3NhbXBsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF2ciA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX3NhbXBsZXM7ICsraSkge1xuICAgICAgICAgICAgYXZyICs9IHRoaXMuX3ZhbHVlc1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBhdnIgLyBudW1fc2FtcGxlcyk7XG4gICAgfTtcblxuICAgIE1hdGhBdmVyYWdlRmlsdGVyLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDEpIHtcbiAgICAgICAgICAgIHZhbHVlID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3BlcnRpZXMuc2FtcGxlcyA9IE1hdGgucm91bmQodmFsdWUpO1xuICAgICAgICB2YXIgb2xkID0gdGhpcy5fdmFsdWVzO1xuXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5wcm9wZXJ0aWVzLnNhbXBsZXMpO1xuICAgICAgICBpZiAob2xkLmxlbmd0aCA8PSB0aGlzLl92YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXMuc2V0KG9sZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXMuc2V0KG9sZC5zdWJhcnJheSgwLCB0aGlzLl92YWx1ZXMubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL2F2ZXJhZ2VcIiwgTWF0aEF2ZXJhZ2VGaWx0ZXIpO1xuXG4gICAgLy9NYXRoXG4gICAgZnVuY3Rpb24gTWF0aFRlbmRUbygpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcImZhY3RvclwiLCAwLjEpO1xuICAgICAgICB0aGlzLnNpemUgPSBbODAsIDMwXTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgIH1cblxuICAgIE1hdGhUZW5kVG8udGl0bGUgPSBcIlRlbmRUb1wiO1xuICAgIE1hdGhUZW5kVG8uZGVzYyA9IFwibW92ZXMgdGhlIG91dHB1dCB2YWx1ZSBhbHdheXMgY2xvc2VyIHRvIHRoZSBpbnB1dFwiO1xuXG4gICAgTWF0aFRlbmRUby5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmID0gdGhpcy5wcm9wZXJ0aWVzLmZhY3RvcjtcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5fdmFsdWUgKiAoMSAtIGYpICsgdiAqIGY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3ZhbHVlKTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL3RlbmRUb1wiLCBNYXRoVGVuZFRvKTtcblxuICAgIC8vTWF0aCBvcGVyYXRpb25cbiAgICBmdW5jdGlvbiBNYXRoT3BlcmF0aW9uKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiQVwiLCBcIm51bWJlcixhcnJheSxvYmplY3RcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJCXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIj1cIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJBXCIsIDEpO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiQlwiLCAxKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIk9QXCIsIFwiK1wiLCBcImVudW1cIiwgeyB2YWx1ZXM6IE1hdGhPcGVyYXRpb24udmFsdWVzIH0pO1xuXHRcdHRoaXMuX2Z1bmMgPSBNYXRoT3BlcmF0aW9uLmZ1bmNzW3RoaXMucHJvcGVydGllcy5PUF07XG5cdFx0dGhpcy5fcmVzdWx0ID0gW107IC8vb25seSB1c2VkIGZvciBhcnJheXNcbiAgICB9XG5cbiAgICBNYXRoT3BlcmF0aW9uLnZhbHVlcyA9IFtcIitcIiwgXCItXCIsIFwiKlwiLCBcIi9cIiwgXCIlXCIsIFwiXlwiLCBcIm1heFwiLCBcIm1pblwiXTtcbiAgICBNYXRoT3BlcmF0aW9uLmZ1bmNzID0ge1xuICAgICAgICBcIitcIjogZnVuY3Rpb24oQSxCKSB7IHJldHVybiBBICsgQjsgfSxcbiAgICAgICAgXCItXCI6IGZ1bmN0aW9uKEEsQikgeyByZXR1cm4gQSAtIEI7IH0sXG4gICAgICAgIFwieFwiOiBmdW5jdGlvbihBLEIpIHsgcmV0dXJuIEEgKiBCOyB9LFxuICAgICAgICBcIlhcIjogZnVuY3Rpb24oQSxCKSB7IHJldHVybiBBICogQjsgfSxcbiAgICAgICAgXCIqXCI6IGZ1bmN0aW9uKEEsQikgeyByZXR1cm4gQSAqIEI7IH0sXG4gICAgICAgIFwiL1wiOiBmdW5jdGlvbihBLEIpIHsgcmV0dXJuIEEgLyBCOyB9LFxuICAgICAgICBcIiVcIjogZnVuY3Rpb24oQSxCKSB7IHJldHVybiBBICUgQjsgfSxcbiAgICAgICAgXCJeXCI6IGZ1bmN0aW9uKEEsQikgeyByZXR1cm4gTWF0aC5wb3coQSwgQik7IH0sXG4gICAgICAgIFwibWF4XCI6IGZ1bmN0aW9uKEEsQikgeyByZXR1cm4gTWF0aC5tYXgoQSwgQik7IH0sXG4gICAgICAgIFwibWluXCI6IGZ1bmN0aW9uKEEsQikgeyByZXR1cm4gTWF0aC5taW4oQSwgQik7IH1cbiAgICB9O1xuXG5cdE1hdGhPcGVyYXRpb24udGl0bGUgPSBcIk9wZXJhdGlvblwiO1xuICAgIE1hdGhPcGVyYXRpb24uZGVzYyA9IFwiRWFzeSBtYXRoIG9wZXJhdG9yc1wiO1xuICAgIE1hdGhPcGVyYXRpb25bXCJAT1BcIl0gPSB7XG4gICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICB0aXRsZTogXCJvcGVyYXRpb25cIixcbiAgICAgICAgdmFsdWVzOiBNYXRoT3BlcmF0aW9uLnZhbHVlc1xuICAgIH07XG4gICAgTWF0aE9wZXJhdGlvbi5zaXplID0gWzEwMCwgNjBdO1xuXG4gICAgTWF0aE9wZXJhdGlvbi5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZih0aGlzLnByb3BlcnRpZXMuT1AgPT0gXCJtYXhcIiB8fCB0aGlzLnByb3BlcnRpZXMuT1AgPT0gXCJtaW5cIilcblx0XHRcdHJldHVybiB0aGlzLnByb3BlcnRpZXMuT1AgKyBcIihBLEIpXCI7XG4gICAgICAgIHJldHVybiBcIkEgXCIgKyB0aGlzLnByb3BlcnRpZXMuT1AgKyBcIiBCXCI7XG4gICAgfTtcblxuICAgIE1hdGhPcGVyYXRpb24ucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24odikge1xuICAgICAgICBpZiAodHlwZW9mIHYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdiA9IHBhcnNlRmxvYXQodik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW1widmFsdWVcIl0gPSB2O1xuICAgIH07XG5cbiAgICBNYXRoT3BlcmF0aW9uLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKVxuXHR7XG5cdFx0aWYgKG5hbWUgIT0gXCJPUFwiKVxuXHRcdFx0cmV0dXJuO1xuICAgICAgICB0aGlzLl9mdW5jID0gTWF0aE9wZXJhdGlvbi5mdW5jc1t0aGlzLnByb3BlcnRpZXMuT1BdO1xuICAgICAgICBpZighdGhpcy5fZnVuYylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biBvcGVyYXRpb246IFwiICsgdGhpcy5wcm9wZXJ0aWVzLk9QKTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bmMgPSBmdW5jdGlvbihBKSB7IHJldHVybiBBOyB9O1xuICAgICAgICB9XG5cdH1cblxuICAgIE1hdGhPcGVyYXRpb24ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgQSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICB2YXIgQiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuICAgICAgICBpZiAoIEEgIT0gbnVsbCApIHtcblx0XHRcdGlmKCBBLmNvbnN0cnVjdG9yID09PSBOdW1iZXIgKVxuXHQgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbXCJBXCJdID0gQTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEEgPSB0aGlzLnByb3BlcnRpZXNbXCJBXCJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEIgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW1wiQlwiXSA9IEI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBCID0gdGhpcy5wcm9wZXJ0aWVzW1wiQlwiXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmdW5jID0gTWF0aE9wZXJhdGlvbi5mdW5jc1t0aGlzLnByb3BlcnRpZXMuT1BdO1xuXG5cdFx0dmFyIHJlc3VsdDtcblx0XHRpZihBLmNvbnN0cnVjdG9yID09PSBOdW1iZXIpXG5cdFx0e1xuXHQgICAgICAgIHJlc3VsdCA9IDA7XG5cdFx0XHRyZXN1bHQgPSBmdW5jKEEsQik7XG5cdFx0fVxuXHRcdGVsc2UgaWYoQS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpXG5cdFx0e1xuXHRcdFx0cmVzdWx0ID0gdGhpcy5fcmVzdWx0O1xuXHRcdFx0cmVzdWx0Lmxlbmd0aCA9IEEubGVuZ3RoO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IEEubGVuZ3RoOyArK2kpXG5cdFx0XHRcdHJlc3VsdFtpXSA9IGZ1bmMoQVtpXSxCKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHJlc3VsdCA9IHt9O1xuXHRcdFx0Zm9yKHZhciBpIGluIEEpXG5cdFx0XHRcdHJlc3VsdFtpXSA9IGZ1bmMoQVtpXSxCKTtcblx0XHR9XG5cdCAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgcmVzdWx0KTtcbiAgICB9O1xuXG4gICAgTWF0aE9wZXJhdGlvbi5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5mb250ID0gXCI0MHB4IEFyaWFsXCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiM2NjZcIjtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIGN0eC5maWxsVGV4dChcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5PUCxcbiAgICAgICAgICAgIHRoaXMuc2l6ZVswXSAqIDAuNSxcbiAgICAgICAgICAgICh0aGlzLnNpemVbMV0gKyBMaXRlR3JhcGguTk9ERV9USVRMRV9IRUlHSFQpICogMC41XG4gICAgICAgICk7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL29wZXJhdGlvblwiLCBNYXRoT3BlcmF0aW9uKTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3RlclNlYXJjaGJveEV4dHJhKFwibWF0aC9vcGVyYXRpb25cIiwgXCJNQVhcIiwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7T1A6XCJtYXhcIn0sXG4gICAgICAgIHRpdGxlOiBcIk1BWCgpXCJcbiAgICB9KTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3RlclNlYXJjaGJveEV4dHJhKFwibWF0aC9vcGVyYXRpb25cIiwgXCJNSU5cIiwge1xuICAgICAgICBwcm9wZXJ0aWVzOiB7T1A6XCJtaW5cIn0sXG4gICAgICAgIHRpdGxlOiBcIk1JTigpXCJcbiAgICB9KTtcblxuXG4gICAgLy9NYXRoIGNvbXBhcmVcbiAgICBmdW5jdGlvbiBNYXRoQ29tcGFyZSgpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkFcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJCXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIkE9PUJcIiwgXCJib29sZWFuXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIkEhPUJcIiwgXCJib29sZWFuXCIpO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiQVwiLCAwKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIkJcIiwgMCk7XG4gICAgfVxuXG4gICAgTWF0aENvbXBhcmUudGl0bGUgPSBcIkNvbXBhcmVcIjtcbiAgICBNYXRoQ29tcGFyZS5kZXNjID0gXCJjb21wYXJlcyBiZXR3ZWVuIHR3byB2YWx1ZXNcIjtcblxuICAgIE1hdGhDb21wYXJlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIEEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgdmFyIEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcbiAgICAgICAgaWYgKEEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW1wiQVwiXSA9IEE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBID0gdGhpcy5wcm9wZXJ0aWVzW1wiQVwiXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChCICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tcIkJcIl0gPSBCO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQiA9IHRoaXMucHJvcGVydGllc1tcIkJcIl07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMub3V0cHV0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaV07XG4gICAgICAgICAgICBpZiAoIW91dHB1dC5saW5rcyB8fCAhb3V0cHV0LmxpbmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChvdXRwdXQubmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBPT1CXCI6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQSA9PSBCO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiQSE9QlwiOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEEgIT0gQjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkE+QlwiOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEEgPiBCO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiQTxCXCI6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQSA8IEI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBPD1CXCI6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQSA8PSBCO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiQT49QlwiOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEEgPj0gQjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoaSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIE1hdGhDb21wYXJlLnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFtcIkE9PUJcIiwgXCJib29sZWFuXCJdLFxuICAgICAgICAgICAgW1wiQSE9QlwiLCBcImJvb2xlYW5cIl0sXG4gICAgICAgICAgICBbXCJBPkJcIiwgXCJib29sZWFuXCJdLFxuICAgICAgICAgICAgW1wiQTxCXCIsIFwiYm9vbGVhblwiXSxcbiAgICAgICAgICAgIFtcIkE+PUJcIiwgXCJib29sZWFuXCJdLFxuICAgICAgICAgICAgW1wiQTw9QlwiLCBcImJvb2xlYW5cIl1cbiAgICAgICAgXTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL2NvbXBhcmVcIiwgTWF0aENvbXBhcmUpO1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyU2VhcmNoYm94RXh0cmEoXCJtYXRoL2NvbXBhcmVcIiwgXCI9PVwiLCB7XG4gICAgICAgIG91dHB1dHM6IFtbXCJBPT1CXCIsIFwiYm9vbGVhblwiXV0sXG4gICAgICAgIHRpdGxlOiBcIkE9PUJcIlxuICAgIH0pO1xuICAgIExpdGVHcmFwaC5yZWdpc3RlclNlYXJjaGJveEV4dHJhKFwibWF0aC9jb21wYXJlXCIsIFwiIT1cIiwge1xuICAgICAgICBvdXRwdXRzOiBbW1wiQSE9QlwiLCBcImJvb2xlYW5cIl1dLFxuICAgICAgICB0aXRsZTogXCJBIT1CXCJcbiAgICB9KTtcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJTZWFyY2hib3hFeHRyYShcIm1hdGgvY29tcGFyZVwiLCBcIj5cIiwge1xuICAgICAgICBvdXRwdXRzOiBbW1wiQT5CXCIsIFwiYm9vbGVhblwiXV0sXG4gICAgICAgIHRpdGxlOiBcIkE+QlwiXG4gICAgfSk7XG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyU2VhcmNoYm94RXh0cmEoXCJtYXRoL2NvbXBhcmVcIiwgXCI8XCIsIHtcbiAgICAgICAgb3V0cHV0czogW1tcIkE8QlwiLCBcImJvb2xlYW5cIl1dLFxuICAgICAgICB0aXRsZTogXCJBPEJcIlxuICAgIH0pO1xuICAgIExpdGVHcmFwaC5yZWdpc3RlclNlYXJjaGJveEV4dHJhKFwibWF0aC9jb21wYXJlXCIsIFwiPj1cIiwge1xuICAgICAgICBvdXRwdXRzOiBbW1wiQT49QlwiLCBcImJvb2xlYW5cIl1dLFxuICAgICAgICB0aXRsZTogXCJBPj1CXCJcbiAgICB9KTtcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJTZWFyY2hib3hFeHRyYShcIm1hdGgvY29tcGFyZVwiLCBcIjw9XCIsIHtcbiAgICAgICAgb3V0cHV0czogW1tcIkE8PUJcIiwgXCJib29sZWFuXCJdXSxcbiAgICAgICAgdGl0bGU6IFwiQTw9QlwiXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBNYXRoQ29uZGl0aW9uKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiQVwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkJcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwidHJ1ZVwiLCBcImJvb2xlYW5cIik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiZmFsc2VcIiwgXCJib29sZWFuXCIpO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiQVwiLCAxKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcIkJcIiwgMSk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJPUFwiLCBcIj5cIiwgXCJlbnVtXCIsIHsgdmFsdWVzOiBNYXRoQ29uZGl0aW9uLnZhbHVlcyB9KTtcblx0XHR0aGlzLmFkZFdpZGdldChcImNvbWJvXCIsXCJDb25kLlwiLHRoaXMucHJvcGVydGllcy5PUCx7IHByb3BlcnR5OiBcIk9QXCIsIHZhbHVlczogTWF0aENvbmRpdGlvbi52YWx1ZXMgfSApO1xuXG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgNjBdO1xuICAgIH1cblxuICAgIE1hdGhDb25kaXRpb24udmFsdWVzID0gW1wiPlwiLCBcIjxcIiwgXCI9PVwiLCBcIiE9XCIsIFwiPD1cIiwgXCI+PVwiLCBcInx8XCIsIFwiJiZcIiBdO1xuICAgIE1hdGhDb25kaXRpb25bXCJAT1BcIl0gPSB7XG4gICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICB0aXRsZTogXCJvcGVyYXRpb25cIixcbiAgICAgICAgdmFsdWVzOiBNYXRoQ29uZGl0aW9uLnZhbHVlc1xuICAgIH07XG5cbiAgICBNYXRoQ29uZGl0aW9uLnRpdGxlID0gXCJDb25kaXRpb25cIjtcbiAgICBNYXRoQ29uZGl0aW9uLmRlc2MgPSBcImV2YWx1YXRlcyBjb25kaXRpb24gYmV0d2VlbiBBIGFuZCBCXCI7XG5cbiAgICBNYXRoQ29uZGl0aW9uLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCJBIFwiICsgdGhpcy5wcm9wZXJ0aWVzLk9QICsgXCIgQlwiO1xuICAgIH07XG5cbiAgICBNYXRoQ29uZGl0aW9uLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIEEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgaWYgKEEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgQSA9IHRoaXMucHJvcGVydGllcy5BO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLkEgPSBBO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcbiAgICAgICAgaWYgKEIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgQiA9IHRoaXMucHJvcGVydGllcy5CO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLkIgPSBCO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wcm9wZXJ0aWVzLk9QKSB7XG4gICAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEEgPiBCO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBBIDwgQjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI9PVwiOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEEgPT0gQjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCIhPVwiOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEEgIT0gQjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEEgPD0gQjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI+PVwiOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEEgPj0gQjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ8fFwiOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEEgfHwgQjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCImJlwiOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEEgJiYgQjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCByZXN1bHQpO1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMSwgIXJlc3VsdCk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9jb25kaXRpb25cIiwgTWF0aENvbmRpdGlvbik7XG5cblxuICAgIGZ1bmN0aW9uIE1hdGhCcmFuY2goKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCAwKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImNvbmRcIiwgXCJib29sZWFuXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcInRydWVcIiwgMCk7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiZmFsc2VcIiwgMCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFs4MCwgNjBdO1xuICAgIH1cblxuICAgIE1hdGhCcmFuY2gudGl0bGUgPSBcIkJyYW5jaFwiO1xuICAgIE1hdGhCcmFuY2guZGVzYyA9IFwiSWYgY29uZGl0aW9uIGlzIHRydWUsIG91dHB1dHMgSU4gaW4gdHJ1ZSwgb3RoZXJ3aXNlIGluIGZhbHNlXCI7XG5cbiAgICBNYXRoQnJhbmNoLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIFYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgdmFyIGNvbmQgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcblxuXHRcdGlmKGNvbmQpXG5cdFx0e1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIFYpO1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDEsIG51bGwpO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIG51bGwpO1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDEsIFYpO1xuXHRcdH1cblx0fVxuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL2JyYW5jaFwiLCBNYXRoQnJhbmNoKTtcblxuXG4gICAgZnVuY3Rpb24gTWF0aEFjY3VtdWxhdGUoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpbmNcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwidG90YWxcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJpbmNyZW1lbnRcIiwgMSk7XG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJ2YWx1ZVwiLCAwKTtcbiAgICB9XG5cbiAgICBNYXRoQWNjdW11bGF0ZS50aXRsZSA9IFwiQWNjdW11bGF0ZVwiO1xuICAgIE1hdGhBY2N1bXVsYXRlLmRlc2MgPSBcIkluY3JlbWVudHMgYSB2YWx1ZSBldmVyeSB0aW1lXCI7XG5cbiAgICBNYXRoQWNjdW11bGF0ZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5jID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmIChpbmMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZSArPSBpbmM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUgKz0gdGhpcy5wcm9wZXJ0aWVzLmluY3JlbWVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL2FjY3VtdWxhdGVcIiwgTWF0aEFjY3VtdWxhdGUpO1xuXG4gICAgLy9NYXRoIFRyaWdvbm9tZXRyeVxuICAgIGZ1bmN0aW9uIE1hdGhUcmlnb25vbWV0cnkoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ2XCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcInNpblwiLCBcIm51bWJlclwiKTtcblxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiYW1wbGl0dWRlXCIsIDEpO1xuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwib2Zmc2V0XCIsIDApO1xuICAgICAgICB0aGlzLmJnSW1hZ2VVcmwgPSBcIm5vZGVzL2ltZ3MvaWNvbi1zaW4ucG5nXCI7XG4gICAgfVxuXG4gICAgTWF0aFRyaWdvbm9tZXRyeS50aXRsZSA9IFwiVHJpZ29ub21ldHJ5XCI7XG4gICAgTWF0aFRyaWdvbm9tZXRyeS5kZXNjID0gXCJTaW4gQ29zIFRhblwiO1xuICAgIC8vTWF0aFRyaWdvbm9tZXRyeS5maWx0ZXIgPSBcInNoYWRlclwiO1xuXG4gICAgTWF0aFRyaWdvbm9tZXRyeS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbXBsaXR1ZGUgPSB0aGlzLnByb3BlcnRpZXNbXCJhbXBsaXR1ZGVcIl07XG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5maW5kSW5wdXRTbG90KFwiYW1wbGl0dWRlXCIpO1xuICAgICAgICBpZiAoc2xvdCAhPSAtMSkge1xuICAgICAgICAgICAgYW1wbGl0dWRlID0gdGhpcy5nZXRJbnB1dERhdGEoc2xvdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMucHJvcGVydGllc1tcIm9mZnNldFwiXTtcbiAgICAgICAgc2xvdCA9IHRoaXMuZmluZElucHV0U2xvdChcIm9mZnNldFwiKTtcbiAgICAgICAgaWYgKHNsb3QgIT0gLTEpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0SW5wdXREYXRhKHNsb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLm91dHB1dHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChvdXRwdXQubmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzaW5cIjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnNpbih2KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvc1wiOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGguY29zKHYpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidGFuXCI6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC50YW4odik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhc2luXCI6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5hc2luKHYpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiYWNvc1wiOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGguYWNvcyh2KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImF0YW5cIjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmF0YW4odik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKGksIGFtcGxpdHVkZSAqIHZhbHVlICsgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBNYXRoVHJpZ29ub21ldHJ5LnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1tcInZcIiwgXCJudW1iZXJcIl0sIFtcImFtcGxpdHVkZVwiLCBcIm51bWJlclwiXSwgW1wib2Zmc2V0XCIsIFwibnVtYmVyXCJdXTtcbiAgICB9O1xuXG4gICAgTWF0aFRyaWdvbm9tZXRyeS5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbXCJzaW5cIiwgXCJudW1iZXJcIl0sXG4gICAgICAgICAgICBbXCJjb3NcIiwgXCJudW1iZXJcIl0sXG4gICAgICAgICAgICBbXCJ0YW5cIiwgXCJudW1iZXJcIl0sXG4gICAgICAgICAgICBbXCJhc2luXCIsIFwibnVtYmVyXCJdLFxuICAgICAgICAgICAgW1wiYWNvc1wiLCBcIm51bWJlclwiXSxcbiAgICAgICAgICAgIFtcImF0YW5cIiwgXCJudW1iZXJcIl1cbiAgICAgICAgXTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoL3RyaWdvbm9tZXRyeVwiLCBNYXRoVHJpZ29ub21ldHJ5KTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3RlclNlYXJjaGJveEV4dHJhKFwibWF0aC90cmlnb25vbWV0cnlcIiwgXCJTSU4oKVwiLCB7XG4gICAgICAgIG91dHB1dHM6IFtbXCJzaW5cIiwgXCJudW1iZXJcIl1dLFxuICAgICAgICB0aXRsZTogXCJTSU4oKVwiXG4gICAgfSk7XG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyU2VhcmNoYm94RXh0cmEoXCJtYXRoL3RyaWdvbm9tZXRyeVwiLCBcIkNPUygpXCIsIHtcbiAgICAgICAgb3V0cHV0czogW1tcImNvc1wiLCBcIm51bWJlclwiXV0sXG4gICAgICAgIHRpdGxlOiBcIkNPUygpXCJcbiAgICB9KTtcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJTZWFyY2hib3hFeHRyYShcIm1hdGgvdHJpZ29ub21ldHJ5XCIsIFwiVEFOKClcIiwge1xuICAgICAgICBvdXRwdXRzOiBbW1widGFuXCIsIFwibnVtYmVyXCJdXSxcbiAgICAgICAgdGl0bGU6IFwiVEFOKClcIlxuICAgIH0pO1xuXG4gICAgLy9tYXRoIGxpYnJhcnkgZm9yIHNhZmUgbWF0aCBvcGVyYXRpb25zIHdpdGhvdXQgZXZhbFxuICAgIGZ1bmN0aW9uIE1hdGhGb3JtdWxhKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwieFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInlcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHg6IDEuMCwgeTogMS4wLCBmb3JtdWxhOiBcIngreVwiIH07XG4gICAgICAgIHRoaXMuY29kZV93aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcbiAgICAgICAgICAgIFwidGV4dFwiLFxuICAgICAgICAgICAgXCJGKHgseSlcIixcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5mb3JtdWxhLFxuICAgICAgICAgICAgZnVuY3Rpb24odiwgY2FudmFzLCBub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzLmZvcm11bGEgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmFkZFdpZGdldChcInRvZ2dsZVwiLCBcImFsbG93XCIsIExpdGVHcmFwaC5hbGxvd19zY3JpcHRzLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICBMaXRlR3JhcGguYWxsb3dfc2NyaXB0cyA9IHY7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9mdW5jID0gbnVsbDtcbiAgICB9XG5cbiAgICBNYXRoRm9ybXVsYS50aXRsZSA9IFwiRm9ybXVsYVwiO1xuICAgIE1hdGhGb3JtdWxhLmRlc2MgPSBcIkNvbXB1dGUgZm9ybXVsYVwiO1xuICAgIE1hdGhGb3JtdWxhLnNpemUgPSBbMTYwLCAxMDBdO1xuXG4gICAgTWF0aEF2ZXJhZ2VGaWx0ZXIucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJmb3JtdWxhXCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZV93aWRnZXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBNYXRoRm9ybXVsYS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghTGl0ZUdyYXBoLmFsbG93X3NjcmlwdHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG4gICAgICAgIGlmICh4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tcInhcIl0gPSB4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IHRoaXMucHJvcGVydGllc1tcInhcIl07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbXCJ5XCJdID0geTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHkgPSB0aGlzLnByb3BlcnRpZXNbXCJ5XCJdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSB0aGlzLnByb3BlcnRpZXNbXCJmb3JtdWxhXCJdO1xuXG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZnVuYyB8fCB0aGlzLl9mdW5jX2NvZGUgIT0gdGhpcy5wcm9wZXJ0aWVzLmZvcm11bGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdW5jID0gbmV3IEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICBcInhcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiVElNRVwiLFxuICAgICAgICAgICAgICAgICAgICBcInJldHVybiBcIiArIHRoaXMucHJvcGVydGllcy5mb3JtdWxhXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdW5jX2NvZGUgPSB0aGlzLnByb3BlcnRpZXMuZm9ybXVsYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fZnVuYyh4LCB5LCB0aGlzLmdyYXBoLmdsb2JhbHRpbWUpO1xuICAgICAgICAgICAgdGhpcy5ib3hjb2xvciA9IG51bGw7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwicmVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgTWF0aEZvcm11bGEucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mdW5jX2NvZGUgfHwgXCJGb3JtdWxhXCI7XG4gICAgfTtcblxuICAgIE1hdGhGb3JtdWxhLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmID0gdGhpcy5wcm9wZXJ0aWVzW1wiZm9ybXVsYVwiXTtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0cyAmJiB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dHNbMF0ubGFiZWwgPSBmO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aC9mb3JtdWxhXCIsIE1hdGhGb3JtdWxhKTtcblxuICAgIGZ1bmN0aW9uIE1hdGgzRFZlYzJUb1hZKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwidmVjMlwiLCBcInZlYzJcIik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwieFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ5XCIsIFwibnVtYmVyXCIpO1xuICAgIH1cblxuICAgIE1hdGgzRFZlYzJUb1hZLnRpdGxlID0gXCJWZWMyLT5YWVwiO1xuICAgIE1hdGgzRFZlYzJUb1hZLmRlc2MgPSBcInZlY3RvciAyIHRvIGNvbXBvbmVudHNcIjtcblxuICAgIE1hdGgzRFZlYzJUb1hZLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHZbMF0pO1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMSwgdlsxXSk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL3ZlYzItdG8teHlcIiwgTWF0aDNEVmVjMlRvWFkpO1xuXG4gICAgZnVuY3Rpb24gTWF0aDNEWFlUb1ZlYzIoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXRzKFtbXCJ4XCIsIFwibnVtYmVyXCJdLCBbXCJ5XCIsIFwibnVtYmVyXCJdXSk7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwidmVjMlwiLCBcInZlYzJcIik7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICB0aGlzLl9kYXRhID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICB9XG5cbiAgICBNYXRoM0RYWVRvVmVjMi50aXRsZSA9IFwiWFktPlZlYzJcIjtcbiAgICBNYXRoM0RYWVRvVmVjMi5kZXNjID0gXCJjb21wb25lbnRzIHRvIHZlY3RvcjJcIjtcblxuICAgIE1hdGgzRFhZVG9WZWMyLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHRoaXMucHJvcGVydGllcy54O1xuICAgICAgICB9XG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG4gICAgICAgIGlmICh5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHkgPSB0aGlzLnByb3BlcnRpZXMueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgZGF0YVswXSA9IHg7XG4gICAgICAgIGRhdGFbMV0gPSB5O1xuXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBkYXRhKTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2QveHktdG8tdmVjMlwiLCBNYXRoM0RYWVRvVmVjMik7XG5cbiAgICBmdW5jdGlvbiBNYXRoM0RWZWMzVG9YWVooKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ2ZWMzXCIsIFwidmVjM1wiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ4XCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcInlcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwielwiLCBcIm51bWJlclwiKTtcbiAgICB9XG5cbiAgICBNYXRoM0RWZWMzVG9YWVoudGl0bGUgPSBcIlZlYzMtPlhZWlwiO1xuICAgIE1hdGgzRFZlYzNUb1hZWi5kZXNjID0gXCJ2ZWN0b3IgMyB0byBjb21wb25lbnRzXCI7XG5cbiAgICBNYXRoM0RWZWMzVG9YWVoucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdlswXSk7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgxLCB2WzFdKTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDIsIHZbMl0pO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC92ZWMzLXRvLXh5elwiLCBNYXRoM0RWZWMzVG9YWVopO1xuXG4gICAgZnVuY3Rpb24gTWF0aDNEWFlaVG9WZWMzKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0cyhbW1wieFwiLCBcIm51bWJlclwiXSwgW1wieVwiLCBcIm51bWJlclwiXSwgW1wielwiLCBcIm51bWJlclwiXV0pO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcInZlYzNcIiwgXCJ2ZWMzXCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHg6IDAsIHk6IDAsIHo6IDAgfTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgfVxuXG4gICAgTWF0aDNEWFlaVG9WZWMzLnRpdGxlID0gXCJYWVotPlZlYzNcIjtcbiAgICBNYXRoM0RYWVpUb1ZlYzMuZGVzYyA9IFwiY29tcG9uZW50cyB0byB2ZWN0b3IzXCI7XG5cbiAgICBNYXRoM0RYWVpUb1ZlYzMucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAoeCA9PSBudWxsKSB7XG4gICAgICAgICAgICB4ID0gdGhpcy5wcm9wZXJ0aWVzLng7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHkgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcbiAgICAgICAgaWYgKHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgeSA9IHRoaXMucHJvcGVydGllcy55O1xuICAgICAgICB9XG4gICAgICAgIHZhciB6ID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XG4gICAgICAgIGlmICh6ID09IG51bGwpIHtcbiAgICAgICAgICAgIHogPSB0aGlzLnByb3BlcnRpZXMuejtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgZGF0YVswXSA9IHg7XG4gICAgICAgIGRhdGFbMV0gPSB5O1xuICAgICAgICBkYXRhWzJdID0gejtcblxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgZGF0YSk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL3h5ei10by12ZWMzXCIsIE1hdGgzRFhZWlRvVmVjMyk7XG5cbiAgICBmdW5jdGlvbiBNYXRoM0RWZWM0VG9YWVpXKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwidmVjNFwiLCBcInZlYzRcIik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwieFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJ5XCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcInpcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwid1wiLCBcIm51bWJlclwiKTtcbiAgICB9XG5cbiAgICBNYXRoM0RWZWM0VG9YWVpXLnRpdGxlID0gXCJWZWM0LT5YWVpXXCI7XG4gICAgTWF0aDNEVmVjNFRvWFlaVy5kZXNjID0gXCJ2ZWN0b3IgNCB0byBjb21wb25lbnRzXCI7XG5cbiAgICBNYXRoM0RWZWM0VG9YWVpXLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHZbMF0pO1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMSwgdlsxXSk7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgyLCB2WzJdKTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDMsIHZbM10pO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC92ZWM0LXRvLXh5endcIiwgTWF0aDNEVmVjNFRvWFlaVyk7XG5cbiAgICBmdW5jdGlvbiBNYXRoM0RYWVpXVG9WZWM0KCkge1xuICAgICAgICB0aGlzLmFkZElucHV0cyhbXG4gICAgICAgICAgICBbXCJ4XCIsIFwibnVtYmVyXCJdLFxuICAgICAgICAgICAgW1wieVwiLCBcIm51bWJlclwiXSxcbiAgICAgICAgICAgIFtcInpcIiwgXCJudW1iZXJcIl0sXG4gICAgICAgICAgICBbXCJ3XCIsIFwibnVtYmVyXCJdXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcInZlYzRcIiwgXCJ2ZWM0XCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHg6IDAsIHk6IDAsIHo6IDAsIHc6IDAgfTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgfVxuXG4gICAgTWF0aDNEWFlaV1RvVmVjNC50aXRsZSA9IFwiWFlaVy0+VmVjNFwiO1xuICAgIE1hdGgzRFhZWldUb1ZlYzQuZGVzYyA9IFwiY29tcG9uZW50cyB0byB2ZWN0b3I0XCI7XG5cbiAgICBNYXRoM0RYWVpXVG9WZWM0LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcbiAgICAgICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHRoaXMucHJvcGVydGllcy54O1xuICAgICAgICB9XG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG4gICAgICAgIGlmICh5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHkgPSB0aGlzLnByb3BlcnRpZXMueTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeiA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xuICAgICAgICBpZiAoeiA9PSBudWxsKSB7XG4gICAgICAgICAgICB6ID0gdGhpcy5wcm9wZXJ0aWVzLno7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHcgPSB0aGlzLmdldElucHV0RGF0YSgzKTtcbiAgICAgICAgaWYgKHcgPT0gbnVsbCkge1xuICAgICAgICAgICAgdyA9IHRoaXMucHJvcGVydGllcy53O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBkYXRhWzBdID0geDtcbiAgICAgICAgZGF0YVsxXSA9IHk7XG4gICAgICAgIGRhdGFbMl0gPSB6O1xuICAgICAgICBkYXRhWzNdID0gdztcblxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgZGF0YSk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL3h5enctdG8tdmVjNFwiLCBNYXRoM0RYWVpXVG9WZWM0KTtcblxufSkodGhpcyk7XG5cbihmdW5jdGlvbihnbG9iYWwpIHtcclxuICAgIHZhciBMaXRlR3JhcGggPSBnbG9iYWwuTGl0ZUdyYXBoO1xyXG5cclxuXHJcblx0ZnVuY3Rpb24gTWF0aDNETWF0NCgpXHJcblx0e1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJUXCIsIFwidmVjM1wiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiUlwiLCBcInZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlNcIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwibWF0NFwiLCBcIm1hdDRcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XHJcblx0XHRcdFwiVFwiOlswLDAsMF0sXHJcblx0XHRcdFwiUlwiOlswLDAsMF0sXHJcblx0XHRcdFwiU1wiOlsxLDEsMV0sXHJcblx0XHRcdFJfaW5fZGVncmVlczogdHJ1ZVxyXG5cdFx0fTtcclxuXHRcdHRoaXMuX3Jlc3VsdCA9IG1hdDQuY3JlYXRlKCk7XHJcblx0XHR0aGlzLl9tdXN0X3VwZGF0ZSA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRNYXRoM0RNYXQ0LnRpdGxlID0gXCJtYXQ0XCI7XHJcblx0TWF0aDNETWF0NC50ZW1wX3F1YXQgPSBuZXcgRmxvYXQzMkFycmF5KFswLDAsMCwxXSk7XHJcblx0TWF0aDNETWF0NC50ZW1wX21hdDQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcclxuXHRNYXRoM0RNYXQ0LnRlbXBfdmVjMyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XHJcblxyXG5cdE1hdGgzRE1hdDQucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpXHJcblx0e1xyXG5cdFx0dGhpcy5fbXVzdF91cGRhdGUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0TWF0aDNETWF0NC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdHZhciBNID0gdGhpcy5fcmVzdWx0O1xyXG5cdFx0dmFyIFEgPSBNYXRoM0RNYXQ0LnRlbXBfcXVhdDtcclxuXHRcdHZhciB0ZW1wX21hdDQgPSBNYXRoM0RNYXQ0LnRlbXBfbWF0NDtcclxuXHRcdHZhciB0ZW1wX3ZlYzMgPSBNYXRoM0RNYXQ0LnRlbXBfdmVjMztcclxuXHJcblx0XHR2YXIgVCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0dmFyIFIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuXHRcdHZhciBTID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XHJcblxyXG5cdFx0aWYoIHRoaXMuX211c3RfdXBkYXRlIHx8IFQgfHwgUiB8fCBTIClcclxuXHRcdHtcclxuXHRcdFx0VCA9IFQgfHwgdGhpcy5wcm9wZXJ0aWVzLlQ7XHJcblx0XHRcdFIgPSBSIHx8IHRoaXMucHJvcGVydGllcy5SO1xyXG5cdFx0XHRTID0gUyB8fCB0aGlzLnByb3BlcnRpZXMuUztcclxuXHRcdFx0bWF0NC5pZGVudGl0eSggTSApO1xyXG5cdFx0XHRtYXQ0LnRyYW5zbGF0ZSggTSwgTSwgVCApO1xyXG5cdFx0XHRpZih0aGlzLnByb3BlcnRpZXMuUl9pbl9kZWdyZWVzKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGVtcF92ZWMzLnNldCggUiApO1xyXG5cdFx0XHRcdHZlYzMuc2NhbGUodGVtcF92ZWMzLHRlbXBfdmVjMyxERUcyUkFEKTtcclxuXHRcdFx0XHRxdWF0LmZyb21FdWxlciggUSwgdGVtcF92ZWMzICk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHF1YXQuZnJvbUV1bGVyKCBRLCBSICk7XHJcblx0XHRcdG1hdDQuZnJvbVF1YXQoIHRlbXBfbWF0NCwgUSApO1xyXG5cdFx0XHRtYXQ0Lm11bHRpcGx5KCBNLCBNLCB0ZW1wX21hdDQgKTtcclxuXHRcdFx0bWF0NC5zY2FsZSggTSwgTSwgUyApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBNKTtcdFx0XHJcblx0fVxyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL21hdDRcIiwgTWF0aDNETWF0NCk7XHJcblxyXG4gICAgLy9NYXRoIDNEIG9wZXJhdGlvblxyXG4gICAgZnVuY3Rpb24gTWF0aDNET3BlcmF0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJBXCIsIFwibnVtYmVyLHZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkJcIiwgXCJudW1iZXIsdmVjM1wiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIj1cIiwgXCJudW1iZXIsdmVjM1wiKTtcclxuICAgICAgICB0aGlzLmFkZFByb3BlcnR5KFwiT1BcIiwgXCIrXCIsIFwiZW51bVwiLCB7IHZhbHVlczogTWF0aDNET3BlcmF0aW9uLnZhbHVlcyB9KTtcclxuXHRcdHRoaXMuX3Jlc3VsdCA9IHZlYzMuY3JlYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aDNET3BlcmF0aW9uLnZhbHVlcyA9IFtcIitcIiwgXCItXCIsIFwiKlwiLCBcIi9cIiwgXCIlXCIsIFwiXlwiLCBcIm1heFwiLCBcIm1pblwiLFwiZG90XCIsXCJjcm9zc1wiXTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJTZWFyY2hib3hFeHRyYShcIm1hdGgzZC9vcGVyYXRpb25cIiwgXCJDUk9TUygpXCIsIHtcclxuICAgICAgICBwcm9wZXJ0aWVzOiB7XCJPUFwiOlwiY3Jvc3NcIn0sXHJcbiAgICAgICAgdGl0bGU6IFwiQ1JPU1MoKVwiXHJcbiAgICB9KTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJTZWFyY2hib3hFeHRyYShcIm1hdGgzZC9vcGVyYXRpb25cIiwgXCJET1QoKVwiLCB7XHJcbiAgICAgICAgcHJvcGVydGllczoge1wiT1BcIjpcImRvdFwifSxcclxuICAgICAgICB0aXRsZTogXCJET1QoKVwiXHJcbiAgICB9KTtcclxuXHJcblx0TWF0aDNET3BlcmF0aW9uLnRpdGxlID0gXCJPcGVyYXRpb25cIjtcclxuICAgIE1hdGgzRE9wZXJhdGlvbi5kZXNjID0gXCJFYXN5IG1hdGggM0Qgb3BlcmF0b3JzXCI7XHJcbiAgICBNYXRoM0RPcGVyYXRpb25bXCJAT1BcIl0gPSB7XHJcbiAgICAgICAgdHlwZTogXCJlbnVtXCIsXHJcbiAgICAgICAgdGl0bGU6IFwib3BlcmF0aW9uXCIsXHJcbiAgICAgICAgdmFsdWVzOiBNYXRoM0RPcGVyYXRpb24udmFsdWVzXHJcbiAgICB9O1xyXG4gICAgTWF0aDNET3BlcmF0aW9uLnNpemUgPSBbMTAwLCA2MF07XHJcblxyXG4gICAgTWF0aDNET3BlcmF0aW9uLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYodGhpcy5wcm9wZXJ0aWVzLk9QID09IFwibWF4XCIgfHwgdGhpcy5wcm9wZXJ0aWVzLk9QID09IFwibWluXCIgKVxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLk9QICsgXCIoQSxCKVwiO1xyXG4gICAgICAgIHJldHVybiBcIkEgXCIgKyB0aGlzLnByb3BlcnRpZXMuT1AgKyBcIiBCXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGgzRE9wZXJhdGlvbi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIEEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICB2YXIgQiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG5cdFx0aWYoQSA9PSBudWxsIHx8IEIgPT0gbnVsbClcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0aWYoQS5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKVxyXG5cdFx0XHRBID0gW0EsQSxBXTtcclxuXHRcdGlmKEIuY29uc3RydWN0b3IgPT09IE51bWJlcilcclxuXHRcdFx0QiA9IFtCLEIsQl07XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9yZXN1bHQ7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnByb3BlcnRpZXMuT1ApIHtcclxuICAgICAgICAgICAgY2FzZSBcIitcIjpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZlYzMuYWRkKHJlc3VsdCxBLEIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCItXCI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2ZWMzLnN1YihyZXN1bHQsQSxCKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwieFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiWFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiKlwiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmVjMy5tdWwocmVzdWx0LEEsQik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIi9cIjpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZlYzMuZGl2KHJlc3VsdCxBLEIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCIlXCI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbMF0gPSBBWzBdJUJbMF07XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbMV0gPSBBWzFdJUJbMV07XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbMl0gPSBBWzJdJUJbMl07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIl5cIjpcclxuICAgICAgICAgICAgICAgIHJlc3VsdFswXSA9IE1hdGgucG93KEFbMF0sQlswXSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbMV0gPSBNYXRoLnBvdyhBWzFdLEJbMV0pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0WzJdID0gTWF0aC5wb3coQVsyXSxCWzJdKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibWF4XCI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbMF0gPSBNYXRoLm1heChBWzBdLEJbMF0pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0WzFdID0gTWF0aC5tYXgoQVsxXSxCWzFdKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFsyXSA9IE1hdGgubWF4KEFbMl0sQlsyXSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIm1pblwiOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0WzBdID0gTWF0aC5taW4oQVswXSxCWzBdKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFsxXSA9IE1hdGgubWluKEFbMV0sQlsxXSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbMl0gPSBNYXRoLm1pbihBWzJdLEJbMl0pO1xyXG4gICAgICAgICAgICBjYXNlIFwiZG90XCI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2ZWMzLmRvdChBLEIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJjcm9zc1wiOlxyXG4gICAgICAgICAgICAgICAgdmVjMy5jcm9zcyhyZXN1bHQsQSxCKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biBvcGVyYXRpb246IFwiICsgdGhpcy5wcm9wZXJ0aWVzLk9QKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHJlc3VsdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGgzRE9wZXJhdGlvbi5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjdHguZm9udCA9IFwiNDBweCBBcmlhbFwiO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiM2NjZcIjtcclxuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgICBjdHguZmlsbFRleHQoXHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5PUCxcclxuICAgICAgICAgICAgdGhpcy5zaXplWzBdICogMC41LFxyXG4gICAgICAgICAgICAodGhpcy5zaXplWzFdICsgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUKSAqIDAuNVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC9vcGVyYXRpb25cIiwgTWF0aDNET3BlcmF0aW9uKTtcclxuXHJcbiAgICBmdW5jdGlvbiBNYXRoM0RWZWMzU2NhbGUoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwidmVjM1wiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiZlwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcInZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBmOiAxIH07XHJcbiAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aDNEVmVjM1NjYWxlLnRpdGxlID0gXCJ2ZWMzX3NjYWxlXCI7XHJcbiAgICBNYXRoM0RWZWMzU2NhbGUuZGVzYyA9IFwic2NhbGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1wiO1xyXG5cclxuICAgIE1hdGgzRFZlYzNTY2FsZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAodiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGYgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAoZiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGYgPSB0aGlzLnByb3BlcnRpZXMuZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcclxuICAgICAgICBkYXRhWzBdID0gdlswXSAqIGY7XHJcbiAgICAgICAgZGF0YVsxXSA9IHZbMV0gKiBmO1xyXG4gICAgICAgIGRhdGFbMl0gPSB2WzJdICogZjtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgZGF0YSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL3ZlYzMtc2NhbGVcIiwgTWF0aDNEVmVjM1NjYWxlKTtcclxuXHJcbiAgICBmdW5jdGlvbiBNYXRoM0RWZWMzTGVuZ3RoKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcInZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJudW1iZXJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aDNEVmVjM0xlbmd0aC50aXRsZSA9IFwidmVjM19sZW5ndGhcIjtcclxuICAgIE1hdGgzRFZlYzNMZW5ndGguZGVzYyA9IFwicmV0dXJucyB0aGUgbW9kdWxlIG9mIGEgdmVjdG9yXCI7XHJcblxyXG4gICAgTWF0aDNEVmVjM0xlbmd0aC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICBpZiAodiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRpc3QgPSBNYXRoLnNxcnQodlswXSAqIHZbMF0gKyB2WzFdICogdlsxXSArIHZbMl0gKiB2WzJdKTtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgZGlzdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL3ZlYzMtbGVuZ3RoXCIsIE1hdGgzRFZlYzNMZW5ndGgpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1hdGgzRFZlYzNOb3JtYWxpemUoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwidmVjM1wiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcInZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aDNEVmVjM05vcm1hbGl6ZS50aXRsZSA9IFwidmVjM19ub3JtYWxpemVcIjtcclxuICAgIE1hdGgzRFZlYzNOb3JtYWxpemUuZGVzYyA9IFwicmV0dXJucyB0aGUgdmVjdG9yIG5vcm1hbGl6ZWRcIjtcclxuXHJcbiAgICBNYXRoM0RWZWMzTm9ybWFsaXplLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGlzdCA9IE1hdGguc3FydCh2WzBdICogdlswXSArIHZbMV0gKiB2WzFdICsgdlsyXSAqIHZbMl0pO1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcclxuICAgICAgICBkYXRhWzBdID0gdlswXSAvIGRpc3Q7XHJcbiAgICAgICAgZGF0YVsxXSA9IHZbMV0gLyBkaXN0O1xyXG4gICAgICAgIGRhdGFbMl0gPSB2WzJdIC8gZGlzdDtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIGRhdGEpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC92ZWMzLW5vcm1hbGl6ZVwiLCBNYXRoM0RWZWMzTm9ybWFsaXplKTtcclxuXHJcbiAgICBmdW5jdGlvbiBNYXRoM0RWZWMzTGVycCgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiQVwiLCBcInZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkJcIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJmXCIsIFwidmVjM1wiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcInZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBmOiAwLjUgfTtcclxuICAgICAgICB0aGlzLl9kYXRhID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcclxuICAgIH1cclxuXHJcbiAgICBNYXRoM0RWZWMzTGVycC50aXRsZSA9IFwidmVjM19sZXJwXCI7XHJcbiAgICBNYXRoM0RWZWMzTGVycC5kZXNjID0gXCJyZXR1cm5zIHRoZSBpbnRlcnBvbGF0ZWQgdmVjdG9yXCI7XHJcblxyXG4gICAgTWF0aDNEVmVjM0xlcnAucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBBID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKEEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBCID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgaWYgKEIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJmXCIpO1xyXG5cclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XHJcbiAgICAgICAgZGF0YVswXSA9IEFbMF0gKiAoMSAtIGYpICsgQlswXSAqIGY7XHJcbiAgICAgICAgZGF0YVsxXSA9IEFbMV0gKiAoMSAtIGYpICsgQlsxXSAqIGY7XHJcbiAgICAgICAgZGF0YVsyXSA9IEFbMl0gKiAoMSAtIGYpICsgQlsyXSAqIGY7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBkYXRhKTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2QvdmVjMy1sZXJwXCIsIE1hdGgzRFZlYzNMZXJwKTtcclxuXHJcbiAgICBmdW5jdGlvbiBNYXRoM0RWZWMzRG90KCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJBXCIsIFwidmVjM1wiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiQlwiLCBcInZlYzNcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJudW1iZXJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0aDNEVmVjM0RvdC50aXRsZSA9IFwidmVjM19kb3RcIjtcclxuICAgIE1hdGgzRFZlYzNEb3QuZGVzYyA9IFwicmV0dXJucyB0aGUgZG90IHByb2R1Y3RcIjtcclxuXHJcbiAgICBNYXRoM0RWZWMzRG90LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgQSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIGlmIChBID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgQiA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgIGlmIChCID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRvdCA9IEFbMF0gKiBCWzBdICsgQVsxXSAqIEJbMV0gKyBBWzJdICogQlsyXTtcclxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgZG90KTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2QvdmVjMy1kb3RcIiwgTWF0aDNEVmVjM0RvdCk7XHJcblxyXG4gICAgLy9pZiBnbE1hdHJpeCBpcyBpbnN0YWxsZWQuLi5cclxuICAgIGlmIChnbG9iYWwuZ2xNYXRyaXgpIHtcclxuICAgICAgICBmdW5jdGlvbiBNYXRoM0RRdWF0ZXJuaW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZE91dHB1dChcInF1YXRcIiwgXCJxdWF0XCIpO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHg6IDAsIHk6IDAsIHo6IDAsIHc6IDEsIG5vcm1hbGl6ZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBxdWF0LmNyZWF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTWF0aDNEUXVhdGVybmlvbi50aXRsZSA9IFwiUXVhdGVybmlvblwiO1xyXG4gICAgICAgIE1hdGgzRFF1YXRlcm5pb24uZGVzYyA9IFwicXVhdGVybmlvblwiO1xyXG5cclxuICAgICAgICBNYXRoM0RRdWF0ZXJuaW9uLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWVbMF0gPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInhcIik7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlWzFdID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJ5XCIpO1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZVsyXSA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwielwiKTtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWVbM10gPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcIndcIik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMubm9ybWFsaXplKSB7XHJcbiAgICAgICAgICAgICAgICBxdWF0Lm5vcm1hbGl6ZSh0aGlzLl92YWx1ZSwgdGhpcy5fdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl92YWx1ZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgTWF0aDNEUXVhdGVybmlvbi5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIFtcInhcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgICAgICBbXCJ5XCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICAgICAgW1wielwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgICAgIFtcIndcIiwgXCJudW1iZXJcIl1cclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC9xdWF0ZXJuaW9uXCIsIE1hdGgzRFF1YXRlcm5pb24pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBNYXRoM0RSb3RhdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dHMoW1tcImRlZ3JlZXNcIiwgXCJudW1iZXJcIl0sIFtcImF4aXNcIiwgXCJ2ZWMzXCJdXSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0cHV0KFwicXVhdFwiLCBcInF1YXRcIik7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgYW5nbGU6IDkwLjAsIGF4aXM6IHZlYzMuZnJvbVZhbHVlcygwLCAxLCAwKSB9O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBxdWF0LmNyZWF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTWF0aDNEUm90YXRpb24udGl0bGUgPSBcIlJvdGF0aW9uXCI7XHJcbiAgICAgICAgTWF0aDNEUm90YXRpb24uZGVzYyA9IFwicXVhdGVybmlvbiByb3RhdGlvblwiO1xyXG5cclxuICAgICAgICBNYXRoM0RSb3RhdGlvbi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgICAgICBpZiAoYW5nbGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYW5nbGUgPSB0aGlzLnByb3BlcnRpZXMuYW5nbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGF4aXMgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICAgICAgaWYgKGF4aXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYXhpcyA9IHRoaXMucHJvcGVydGllcy5heGlzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgUiA9IHF1YXQuc2V0QXhpc0FuZ2xlKHRoaXMuX3ZhbHVlLCBheGlzLCBhbmdsZSAqIDAuMDE3NDUzMjkyNSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBSKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC9yb3RhdGlvblwiLCBNYXRoM0RSb3RhdGlvbik7XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBNYXRoRXVsZXJUb1F1YXQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQoXCJldWxlclwiLCBcInZlYzNcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0cHV0KFwicXVhdFwiLCBcInF1YXRcIik7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgZXVsZXI6WzAsMCwwXSwgdXNlX3lhd19waXRjaF9yb2xsOiBmYWxzZSB9O1xyXG5cdFx0XHR0aGlzLl9kZWdzID0gdmVjMy5jcmVhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBxdWF0LmNyZWF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTWF0aEV1bGVyVG9RdWF0LnRpdGxlID0gXCJFdWxlci0+UXVhdFwiO1xyXG4gICAgICAgIE1hdGhFdWxlclRvUXVhdC5kZXNjID0gXCJDb252ZXJ0cyBldWxlciBhbmdsZXMgKGluIGRlZ3JlZXMpIHRvIHF1YXRlcm5pb25cIjtcclxuXHJcbiAgICAgICAgTWF0aEV1bGVyVG9RdWF0LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGV1bGVyID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgICAgIGlmIChldWxlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBldWxlciA9IHRoaXMucHJvcGVydGllcy5ldWxlcjtcclxuICAgICAgICAgICAgfVxyXG5cdFx0XHR2ZWMzLnNjYWxlKCB0aGlzLl9kZWdzLCBldWxlciwgREVHMlJBRCApO1xyXG5cdFx0XHRpZih0aGlzLnByb3BlcnRpZXMudXNlX3lhd19waXRjaF9yb2xsKVxyXG5cdFx0XHRcdHRoaXMuX2RlZ3MgPSBbdGhpcy5fZGVnc1syXSx0aGlzLl9kZWdzWzBdLHRoaXMuX2RlZ3NbMV1dO1xyXG4gICAgICAgICAgICB2YXIgUiA9IHF1YXQuZnJvbUV1bGVyKHRoaXMuX3ZhbHVlLCB0aGlzLl9kZWdzKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIFIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWF0aDNkL2V1bGVyX3RvX3F1YXRcIiwgTWF0aEV1bGVyVG9RdWF0KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gTWF0aFF1YXRUb0V1bGVyKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0KFtcInF1YXRcIiwgXCJxdWF0XCJdKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJldWxlclwiLCBcInZlYzNcIik7XHJcblx0XHRcdHRoaXMuX3ZhbHVlID0gdmVjMy5jcmVhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIE1hdGhRdWF0VG9FdWxlci50aXRsZSA9IFwiRXVsZXItPlF1YXRcIjtcclxuICAgICAgICBNYXRoUXVhdFRvRXVsZXIuZGVzYyA9IFwiQ29udmVydHMgcm90WCxyb3RZLHJvdFogaW4gZGVncmVlcyB0byBxdWF0XCI7XHJcblxyXG4gICAgICAgIE1hdGhRdWF0VG9FdWxlci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBxID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRcdGlmKCFxKVxyXG5cdFx0XHRcdHJldHVybjtcclxuICAgICAgICAgICAgdmFyIFIgPSBxdWF0LnRvRXVsZXIodGhpcy5fdmFsdWUsIHEpO1xyXG5cdFx0XHR2ZWMzLnNjYWxlKCB0aGlzLl92YWx1ZSwgdGhpcy5fdmFsdWUsIERFRzJSQUQgKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC9xdWF0X3RvX2V1bGVyXCIsIE1hdGhRdWF0VG9FdWxlcik7XHJcblxyXG5cclxuICAgICAgICAvL01hdGgzRCByb3RhdGUgdmVjM1xyXG4gICAgICAgIGZ1bmN0aW9uIE1hdGgzRFJvdGF0ZVZlYzMoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXRzKFtbXCJ2ZWMzXCIsIFwidmVjM1wiXSwgW1wicXVhdFwiLCBcInF1YXRcIl1dKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJyZXN1bHRcIiwgXCJ2ZWMzXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHZlYzogWzAsIDAsIDFdIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBNYXRoM0RSb3RhdGVWZWMzLnRpdGxlID0gXCJSb3QuIFZlYzNcIjtcclxuICAgICAgICBNYXRoM0RSb3RhdGVWZWMzLmRlc2MgPSBcInJvdGF0ZSBhIHBvaW50XCI7XHJcblxyXG4gICAgICAgIE1hdGgzRFJvdGF0ZVZlYzMucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdmVjID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgICAgIGlmICh2ZWMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmVjID0gdGhpcy5wcm9wZXJ0aWVzLnZlYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcXVhdCA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgICAgICBpZiAocXVhdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEodmVjKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YShcclxuICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHZlYzMudHJhbnNmb3JtUXVhdCh2ZWMzLmNyZWF0ZSgpLCB2ZWMsIHF1YXQpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2Qvcm90YXRlX3ZlYzNcIiwgTWF0aDNEUm90YXRlVmVjMyk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIE1hdGgzRE11bHRRdWF0KCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0cyhbW1wiQVwiLCBcInF1YXRcIl0sIFtcIkJcIiwgXCJxdWF0XCJdXSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiQSpCXCIsIFwicXVhdFwiKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gcXVhdC5jcmVhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIE1hdGgzRE11bHRRdWF0LnRpdGxlID0gXCJNdWx0LiBRdWF0XCI7XHJcbiAgICAgICAgTWF0aDNETXVsdFF1YXQuZGVzYyA9IFwicm90YXRlIHF1YXRlcm5pb25cIjtcclxuXHJcbiAgICAgICAgTWF0aDNETXVsdFF1YXQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgQSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgICAgICBpZiAoQSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICAgICAgaWYgKEIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgUiA9IHF1YXQubXVsdGlwbHkodGhpcy5fdmFsdWUsIEEsIEIpO1xyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgUik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2QvbXVsdC1xdWF0XCIsIE1hdGgzRE11bHRRdWF0KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gTWF0aDNEUXVhdFNsZXJwKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0cyhbXHJcbiAgICAgICAgICAgICAgICBbXCJBXCIsIFwicXVhdFwiXSxcclxuICAgICAgICAgICAgICAgIFtcIkJcIiwgXCJxdWF0XCJdLFxyXG4gICAgICAgICAgICAgICAgW1wiZmFjdG9yXCIsIFwibnVtYmVyXCJdXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB0aGlzLmFkZE91dHB1dChcInNsZXJwXCIsIFwicXVhdFwiKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcImZhY3RvclwiLCAwLjUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBxdWF0LmNyZWF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTWF0aDNEUXVhdFNsZXJwLnRpdGxlID0gXCJRdWF0IFNsZXJwXCI7XHJcbiAgICAgICAgTWF0aDNEUXVhdFNsZXJwLmRlc2MgPSBcInF1YXRlcm5pb24gc3BoZXJpY2FsIGludGVycG9sYXRpb25cIjtcclxuXHJcbiAgICAgICAgTWF0aDNEUXVhdFNsZXJwLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIEEgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICAgICAgaWYgKEEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBCID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgICAgIGlmIChCID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZmFjdG9yID0gdGhpcy5wcm9wZXJ0aWVzLmZhY3RvcjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0SW5wdXREYXRhKDIpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZhY3RvciA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgUiA9IHF1YXQuc2xlcnAodGhpcy5fdmFsdWUsIEEsIEIsIGZhY3Rvcik7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBSKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1hdGgzZC9xdWF0LXNsZXJwXCIsIE1hdGgzRFF1YXRTbGVycCk7XHJcblxyXG5cclxuICAgICAgICAvL01hdGgzRCByb3RhdGUgdmVjM1xyXG4gICAgICAgIGZ1bmN0aW9uIE1hdGgzRFJlbWFwUmFuZ2UoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ2ZWMzXCIsIFwidmVjM1wiKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJyZW1hcFwiLCBcInZlYzNcIik7XHJcblx0XHRcdHRoaXMuYWRkT3V0cHV0KFwiY2xhbXBlZFwiLCBcInZlYzNcIik7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgY2xhbXA6IHRydWUsIHJhbmdlX21pbjogWy0xLCAtMSwgMF0sIHJhbmdlX21heDogWzEsIDEsIDBdLCB0YXJnZXRfbWluOiBbLTEsLTEsMF0sIHRhcmdldF9tYXg6WzEsMSwwXSB9O1xyXG5cdFx0XHR0aGlzLl92YWx1ZSA9IHZlYzMuY3JlYXRlKCk7XHJcblx0XHRcdHRoaXMuX2NsYW1wZWQgPSB2ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTWF0aDNEUmVtYXBSYW5nZS50aXRsZSA9IFwiUmVtYXAgUmFuZ2VcIjtcclxuICAgICAgICBNYXRoM0RSZW1hcFJhbmdlLmRlc2MgPSBcInJlbWFwIGEgM0QgcmFuZ2VcIjtcclxuXHJcbiAgICAgICAgTWF0aDNEUmVtYXBSYW5nZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB2ZWMgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdFx0aWYodmVjKVxyXG5cdFx0XHRcdHRoaXMuX3ZhbHVlLnNldCh2ZWMpO1xyXG5cdFx0XHR2YXIgcmFuZ2VfbWluID0gdGhpcy5wcm9wZXJ0aWVzLnJhbmdlX21pbjtcclxuXHRcdFx0dmFyIHJhbmdlX21heCA9IHRoaXMucHJvcGVydGllcy5yYW5nZV9tYXg7XHJcblx0XHRcdHZhciB0YXJnZXRfbWluID0gdGhpcy5wcm9wZXJ0aWVzLnRhcmdldF9taW47XHJcblx0XHRcdHZhciB0YXJnZXRfbWF4ID0gdGhpcy5wcm9wZXJ0aWVzLnRhcmdldF9tYXg7XHJcblxyXG5cdFx0XHQvL3N3YXAgdG8gYXZvaWQgZXJyb3JzXHJcblx0XHRcdC8qXHJcblx0XHRcdGlmKHJhbmdlX21pbiA+IHJhbmdlX21heClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHJhbmdlX21pbiA9IHJhbmdlX21heDtcclxuXHRcdFx0XHRyYW5nZV9tYXggPSB0aGlzLnByb3BlcnRpZXMucmFuZ2VfbWluO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZih0YXJnZXRfbWluID4gdGFyZ2V0X21heClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRhcmdldF9taW4gPSB0YXJnZXRfbWF4O1xyXG5cdFx0XHRcdHRhcmdldF9tYXggPSB0aGlzLnByb3BlcnRpZXMudGFyZ2V0X21pbjtcclxuXHRcdFx0fVxyXG5cdFx0XHQqL1xyXG5cclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IDM7ICsraSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHZhciByID0gcmFuZ2VfbWF4W2ldIC0gcmFuZ2VfbWluW2ldO1xyXG5cdFx0XHRcdHRoaXMuX2NsYW1wZWRbaV0gPSBjbGFtcCggdGhpcy5fdmFsdWVbaV0sIHJhbmdlX21pbltpXSwgcmFuZ2VfbWF4W2ldICk7XHJcblx0XHRcdFx0aWYociA9PSAwKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHRoaXMuX3ZhbHVlW2ldID0gKHRhcmdldF9taW5baV0gKyB0YXJnZXRfbWF4W2ldKSAqIDAuNTtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIG4gPSAodGhpcy5fdmFsdWVbaV0gLSByYW5nZV9taW5baV0pIC8gcjtcclxuXHRcdFx0XHRpZih0aGlzLnByb3BlcnRpZXMuY2xhbXApXHJcblx0XHRcdFx0XHRuID0gY2xhbXAobiwwLDEpO1xyXG5cdFx0XHRcdHZhciB0ID0gdGFyZ2V0X21heFtpXSAtIHRhcmdldF9taW5baV07XHJcblx0XHRcdFx0dGhpcy5fdmFsdWVbaV0gPSB0YXJnZXRfbWluW2ldICsgbiAqIHQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLHRoaXMuX3ZhbHVlKTtcclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDEsdGhpcy5fY2xhbXBlZCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtYXRoM2QvcmVtYXBfcmFuZ2VcIiwgTWF0aDNEUmVtYXBSYW5nZSk7XHJcblxyXG5cclxuXHJcbiAgICB9IC8vZ2xNYXRyaXhcclxuXHRlbHNlIGlmIChMaXRlR3JhcGguZGVidWcpXHJcblx0XHRjb25zb2xlLndhcm4oXCJObyBnbG1hdHJpeCBmb3VuZCwgc29tZSBNYXRoM0Qgbm9kZXMgbWF5IG5vdCB3b3JrXCIpO1xyXG5cclxufSkodGhpcyk7XHJcblxuLy9iYXNpYyBub2Rlc1xyXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcclxuXHJcbiAgICBmdW5jdGlvbiB0b1N0cmluZyhhKSB7XHJcblx0XHRpZihhICYmIGEuY29uc3RydWN0b3IgPT09IE9iamVjdClcclxuXHRcdHtcclxuXHRcdFx0dHJ5XHJcblx0XHRcdHtcclxuXHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y2F0Y2ggKGVycilcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHJldHVybiBTdHJpbmcoYSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuICAgICAgICByZXR1cm4gU3RyaW5nKGEpO1xyXG4gICAgfVxyXG5cclxuICAgIExpdGVHcmFwaC53cmFwRnVuY3Rpb25Bc05vZGUoXCJzdHJpbmcvdG9TdHJpbmdcIiwgdG9TdHJpbmcsIFtcIlwiXSwgXCJzdHJpbmdcIik7XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEgPT0gYjtcclxuICAgIH1cclxuXHJcbiAgICBMaXRlR3JhcGgud3JhcEZ1bmN0aW9uQXNOb2RlKFxyXG4gICAgICAgIFwic3RyaW5nL2NvbXBhcmVcIixcclxuICAgICAgICBjb21wYXJlLFxyXG4gICAgICAgIFtcInN0cmluZ1wiLCBcInN0cmluZ1wiXSxcclxuICAgICAgICBcImJvb2xlYW5cIlxyXG4gICAgKTtcclxuXHJcbiAgICBmdW5jdGlvbiBjb25jYXRlbmF0ZShhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGEgKyBiO1xyXG4gICAgfVxyXG5cclxuICAgIExpdGVHcmFwaC53cmFwRnVuY3Rpb25Bc05vZGUoXHJcbiAgICAgICAgXCJzdHJpbmcvY29uY2F0ZW5hdGVcIixcclxuICAgICAgICBjb25jYXRlbmF0ZSxcclxuICAgICAgICBbXCJzdHJpbmdcIiwgXCJzdHJpbmdcIl0sXHJcbiAgICAgICAgXCJzdHJpbmdcIlxyXG4gICAgKTtcclxuXHJcbiAgICBmdW5jdGlvbiBjb250YWlucyhhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYS5pbmRleE9mKGIpICE9IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIExpdGVHcmFwaC53cmFwRnVuY3Rpb25Bc05vZGUoXHJcbiAgICAgICAgXCJzdHJpbmcvY29udGFpbnNcIixcclxuICAgICAgICBjb250YWlucyxcclxuICAgICAgICBbXCJzdHJpbmdcIiwgXCJzdHJpbmdcIl0sXHJcbiAgICAgICAgXCJib29sZWFuXCJcclxuICAgICk7XHJcblxyXG4gICAgZnVuY3Rpb24gdG9VcHBlckNhc2UoYSkge1xyXG4gICAgICAgIGlmIChhICE9IG51bGwgJiYgYS5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG5cclxuICAgIExpdGVHcmFwaC53cmFwRnVuY3Rpb25Bc05vZGUoXHJcbiAgICAgICAgXCJzdHJpbmcvdG9VcHBlckNhc2VcIixcclxuICAgICAgICB0b1VwcGVyQ2FzZSxcclxuICAgICAgICBbXCJzdHJpbmdcIl0sXHJcbiAgICAgICAgXCJzdHJpbmdcIlxyXG4gICAgKTtcclxuXHJcbiAgICBmdW5jdGlvbiBzcGxpdChzdHIsIHNlcGFyYXRvcikge1xyXG5cdFx0aWYoc2VwYXJhdG9yID09IG51bGwpXHJcblx0XHRcdHNlcGFyYXRvciA9IHRoaXMucHJvcGVydGllcy5zZXBhcmF0b3I7XHJcbiAgICAgICAgaWYgKHN0ciA9PSBudWxsIClcclxuXHQgICAgICAgIHJldHVybiBbXTtcclxuXHRcdGlmKCBzdHIuY29uc3RydWN0b3IgPT09IFN0cmluZyApXHJcblx0XHRcdHJldHVybiBzdHIuc3BsaXQoc2VwYXJhdG9yIHx8IFwiIFwiKTtcclxuXHRcdGVsc2UgaWYoIHN0ci5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgciA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyW2ldID09IFwic3RyaW5nXCIpXHJcblx0XHRcdFx0ICAgIHJbaV0gPSBzdHJbaV0uc3BsaXQoc2VwYXJhdG9yIHx8IFwiIFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cdFx0XHRyZXR1cm4gcjtcclxuXHRcdH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBMaXRlR3JhcGgud3JhcEZ1bmN0aW9uQXNOb2RlKFxyXG4gICAgICAgIFwic3RyaW5nL3NwbGl0XCIsXHJcbiAgICAgICAgc3BsaXQsXHJcbiAgICAgICAgW1wic3RyaW5nLGFycmF5XCIsIFwic3RyaW5nXCJdLFxyXG4gICAgICAgIFwiYXJyYXlcIixcclxuXHRcdHsgc2VwYXJhdG9yOiBcIixcIiB9XHJcbiAgICApO1xyXG5cclxuICAgIGZ1bmN0aW9uIHRvRml4ZWQoYSkge1xyXG4gICAgICAgIGlmIChhICE9IG51bGwgJiYgYS5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLnRvRml4ZWQodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG5cclxuICAgIExpdGVHcmFwaC53cmFwRnVuY3Rpb25Bc05vZGUoXHJcbiAgICAgICAgXCJzdHJpbmcvdG9GaXhlZFwiLFxyXG4gICAgICAgIHRvRml4ZWQsXHJcbiAgICAgICAgW1wibnVtYmVyXCJdLFxyXG4gICAgICAgIFwic3RyaW5nXCIsXHJcbiAgICAgICAgeyBwcmVjaXNpb246IDAgfVxyXG4gICAgKTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gU3RyaW5nVG9UYWJsZSgpIHtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiXCIsIFwic3RyaW5nXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwidGFibGVcIiwgXCJ0YWJsZVwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInJvd3NcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0eShcInZhbHVlXCIsIFwiXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJzZXBhcmF0b3JcIiwgXCIsXCIpO1xyXG5cdFx0dGhpcy5fdGFibGUgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIFN0cmluZ1RvVGFibGUudGl0bGUgPSBcInRvVGFibGVcIjtcclxuICAgIFN0cmluZ1RvVGFibGUuZGVzYyA9IFwiU3BsaXRzIGEgc3RyaW5nIHRvIHRhYmxlXCI7XHJcblxyXG4gICAgU3RyaW5nVG9UYWJsZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRpZighaW5wdXQpXHJcblx0XHRcdHJldHVybjtcclxuXHRcdHZhciBzZXBhcmF0b3IgPSB0aGlzLnByb3BlcnRpZXMuc2VwYXJhdG9yIHx8IFwiLFwiO1xyXG5cdFx0aWYoaW5wdXQgIT0gdGhpcy5fc3RyIHx8IHNlcGFyYXRvciAhPSB0aGlzLl9sYXN0X3NlcGFyYXRvciApXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuX2xhc3Rfc2VwYXJhdG9yID0gc2VwYXJhdG9yO1xyXG5cdFx0XHR0aGlzLl9zdHIgPSBpbnB1dDtcclxuXHRcdFx0dGhpcy5fdGFibGUgPSBpbnB1dC5zcGxpdChcIlxcblwiKS5tYXAoZnVuY3Rpb24oYSl7IHJldHVybiBhLnRyaW0oKS5zcGxpdChzZXBhcmF0b3IpfSk7XHJcblx0XHR9XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RhYmxlICk7XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDEsIHRoaXMuX3RhYmxlID8gdGhpcy5fdGFibGUubGVuZ3RoIDogMCApO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInN0cmluZy90b1RhYmxlXCIsIFN0cmluZ1RvVGFibGUpO1xyXG5cclxufSkodGhpcyk7XHJcblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAgIHZhciBMaXRlR3JhcGggPSBnbG9iYWwuTGl0ZUdyYXBoO1xuXG4gICAgZnVuY3Rpb24gU2VsZWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJzZWxcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJBXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiQlwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkNcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJEXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiKTtcblxuICAgICAgICB0aGlzLnNlbGVjdGVkID0gMDtcbiAgICB9XG5cbiAgICBTZWxlY3Rvci50aXRsZSA9IFwiU2VsZWN0b3JcIjtcbiAgICBTZWxlY3Rvci5kZXNjID0gXCJzZWxlY3RzIGFuIG91dHB1dFwiO1xuXG4gICAgU2VsZWN0b3IucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI0FGQlwiO1xuICAgICAgICB2YXIgeSA9ICh0aGlzLnNlbGVjdGVkICsgMSkgKiBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCArIDY7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyg1MCwgeSk7XG4gICAgICAgIGN0eC5saW5lVG8oNTAsIHkgKyBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCk7XG4gICAgICAgIGN0eC5saW5lVG8oMzQsIHkgKyBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCAqIDAuNSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfTtcblxuICAgIFNlbGVjdG9yLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAoc2VsID09IG51bGwgfHwgc2VsLmNvbnN0cnVjdG9yICE9PSBOdW1iZXIpXG4gICAgICAgICAgICBzZWwgPSAwO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gc2VsID0gTWF0aC5yb3VuZChzZWwpICUgKHRoaXMuaW5wdXRzLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKHNlbCArIDEpO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2VsZWN0b3IucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbW1wiRVwiLCAwXSwgW1wiRlwiLCAwXSwgW1wiR1wiLCAwXSwgW1wiSFwiLCAwXV07XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibG9naWMvc2VsZWN0b3JcIiwgU2VsZWN0b3IpO1xuXG4gICAgZnVuY3Rpb24gU2VxdWVuY2UoKSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIHNlcXVlbmNlOiBcIkEsQixDXCJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluZGV4XCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwic2VxXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiKTtcblxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB0aGlzLnByb3BlcnRpZXMuc2VxdWVuY2Uuc3BsaXQoXCIsXCIpO1xuICAgIH1cblxuICAgIFNlcXVlbmNlLnRpdGxlID0gXCJTZXF1ZW5jZVwiO1xuICAgIFNlcXVlbmNlLmRlc2MgPSBcInNlbGVjdCBvbmUgZWxlbWVudCBmcm9tIGEgc2VxdWVuY2UgZnJvbSBhIHN0cmluZ1wiO1xuXG4gICAgU2VxdWVuY2UucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJzZXF1ZW5jZVwiKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTZXF1ZW5jZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXEgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcbiAgICAgICAgaWYgKHNlcSAmJiBzZXEgIT0gdGhpcy5jdXJyZW50X3NlcXVlbmNlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcyA9IHNlcS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfc2VxdWVuY2UgPSBzZXE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4ID0gTWF0aC5yb3VuZChpbmRleCkgJSB0aGlzLnZhbHVlcy5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMudmFsdWVzW2luZGV4XSk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibG9naWMvc2VxdWVuY2VcIiwgU2VxdWVuY2UpO1xuXHRcbiAgICBcbiAgICBmdW5jdGlvbiBsb2dpY0FuZCgpe1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IH07XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJhXCIsIFwiYm9vbGVhblwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImJcIiwgXCJib29sZWFuXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImJvb2xlYW5cIik7XG4gICAgfVxuICAgIGxvZ2ljQW5kLnRpdGxlID0gXCJBTkRcIjtcbiAgICBsb2dpY0FuZC5kZXNjID0gXCJSZXR1cm4gdHJ1ZSBpZiBhbGwgaW5wdXRzIGFyZSB0cnVlXCI7XG4gICAgbG9naWNBbmQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmV0ID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaW5YIGluIHRoaXMuaW5wdXRzKXtcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRJbnB1dERhdGEoaW5YKSl7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCByZXQpO1xuICAgIH07XG4gICAgbG9naWNBbmQucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbXCJhbmRcIiwgXCJib29sZWFuXCJdXG4gICAgICAgIF07XG4gICAgfTtcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImxvZ2ljL0FORFwiLCBsb2dpY0FuZCk7XG4gICAgXG4gICAgXG4gICAgZnVuY3Rpb24gbG9naWNPcigpe1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IH07XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJhXCIsIFwiYm9vbGVhblwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImJcIiwgXCJib29sZWFuXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImJvb2xlYW5cIik7XG4gICAgfVxuICAgIGxvZ2ljT3IudGl0bGUgPSBcIk9SXCI7XG4gICAgbG9naWNPci5kZXNjID0gXCJSZXR1cm4gdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgaW5wdXQgaXMgdHJ1ZVwiO1xuICAgIGxvZ2ljT3IucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmV0ID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGluWCBpbiB0aGlzLmlucHV0cyl7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRJbnB1dERhdGEoaW5YKSl7XG4gICAgICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgcmV0KTtcbiAgICB9O1xuICAgIGxvZ2ljT3IucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbXCJvclwiLCBcImJvb2xlYW5cIl1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibG9naWMvT1JcIiwgbG9naWNPcik7XG4gICAgXG4gICAgXG4gICAgZnVuY3Rpb24gbG9naWNOb3QoKXtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyB9O1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJib29sZWFuXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImJvb2xlYW5cIik7XG4gICAgfVxuICAgIGxvZ2ljTm90LnRpdGxlID0gXCJOT1RcIjtcbiAgICBsb2dpY05vdC5kZXNjID0gXCJSZXR1cm4gdGhlIGxvZ2ljYWwgbmVnYXRpb25cIjtcbiAgICBsb2dpY05vdC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXQgPSAhdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCByZXQpO1xuICAgIH07XG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJsb2dpYy9OT1RcIiwgbG9naWNOb3QpO1xuICAgIFxuICAgIFxuICAgIGZ1bmN0aW9uIGxvZ2ljQ29tcGFyZSgpe1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IH07XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJhXCIsIFwiYm9vbGVhblwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImJcIiwgXCJib29sZWFuXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImJvb2xlYW5cIik7XG4gICAgfVxuICAgIGxvZ2ljQ29tcGFyZS50aXRsZSA9IFwiYm9vbCA9PSBib29sXCI7XG4gICAgbG9naWNDb21wYXJlLmRlc2MgPSBcIkNvbXBhcmUgZm9yIGxvZ2ljYWwgZXF1YWxpdHlcIjtcbiAgICBsb2dpY0NvbXBhcmUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGFzdCA9IG51bGw7XG4gICAgICAgIHZhciByZXQgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpblggaW4gdGhpcy5pbnB1dHMpe1xuICAgICAgICAgICAgaWYgKGxhc3QgPT09IG51bGwpIGxhc3QgPSB0aGlzLmdldElucHV0RGF0YShpblgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGlmIChsYXN0ICE9IHRoaXMuZ2V0SW5wdXREYXRhKGluWCkpe1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCByZXQpO1xuICAgIH07XG4gICAgbG9naWNDb21wYXJlLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgW1wiYm9vbFwiLCBcImJvb2xlYW5cIl1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibG9naWMvQ29tcGFyZUJvb2xcIiwgbG9naWNDb21wYXJlKTtcbiAgICBcbiAgICBcbiAgICBmdW5jdGlvbiBsb2dpY0JyYW5jaCgpe1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IH07XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJvblRyaWdnZXJcIiwgTGl0ZUdyYXBoLkFDVElPTik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJjb25kaXRpb25cIiwgXCJib29sZWFuXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcInRydWVcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJmYWxzZVwiLCBMaXRlR3JhcGguRVZFTlQpO1xuICAgICAgICB0aGlzLm1vZGUgPSBMaXRlR3JhcGguT05fVFJJR0dFUjtcbiAgICB9XG4gICAgbG9naWNCcmFuY2gudGl0bGUgPSBcIkJyYW5jaFwiO1xuICAgIGxvZ2ljQnJhbmNoLmRlc2MgPSBcIkJyYW5jaCBleGVjdXRpb24gb24gY29uZGl0aW9uXCI7XG4gICAgbG9naWNCcmFuY2gucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKHBhcmFtLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBjb25kdGl0aW9uID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG4gICAgICAgIGlmIChjb25kdGl0aW9uKXtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlclNsb3QoMCk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyU2xvdCgxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJsb2dpYy9JRlwiLCBsb2dpY0JyYW5jaCk7XG59KSh0aGlzKTtcblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAgIHZhciBMaXRlR3JhcGggPSBnbG9iYWwuTGl0ZUdyYXBoO1xuXG4gICAgZnVuY3Rpb24gR3JhcGhpY3NQbG90KCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiQVwiLCBcIk51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIkJcIiwgXCJOdW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJDXCIsIFwiTnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiRFwiLCBcIk51bWJlclwiKTtcblxuICAgICAgICB0aGlzLnZhbHVlcyA9IFtbXSwgW10sIFtdLCBbXV07XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgc2NhbGU6IDIgfTtcbiAgICB9XG5cbiAgICBHcmFwaGljc1Bsb3QudGl0bGUgPSBcIlBsb3RcIjtcbiAgICBHcmFwaGljc1Bsb3QuZGVzYyA9IFwiUGxvdHMgZGF0YSBvdmVyIHRpbWVcIjtcbiAgICBHcmFwaGljc1Bsb3QuY29sb3JzID0gW1wiI0ZGRlwiLCBcIiNGOTlcIiwgXCIjOUY5XCIsIFwiIzk5RlwiXTtcblxuICAgIEdyYXBoaWNzUGxvdC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XG4gICAgICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXNbaV07XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh2KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gc2l6ZVswXSkge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIEdyYXBoaWNzUGxvdC5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuXG4gICAgICAgIHZhciBzY2FsZSA9ICgwLjUgKiBzaXplWzFdKSAvIHRoaXMucHJvcGVydGllcy5zY2FsZTtcbiAgICAgICAgdmFyIGNvbG9ycyA9IEdyYXBoaWNzUGxvdC5jb2xvcnM7XG4gICAgICAgIHZhciBvZmZzZXQgPSBzaXplWzFdICogMC41O1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiMwMDBcIjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHNpemVbMF0sIHNpemVbMV0pO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIiM1NTVcIjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKDAsIG9mZnNldCk7XG4gICAgICAgIGN0eC5saW5lVG8oc2l6ZVswXSwgb2Zmc2V0KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLmlucHV0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlucHV0c1tpXSB8fCAhdGhpcy5pbnB1dHNbaV0ubGluaykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3JzW2ldO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHZhbHVlc1swXSAqIHNjYWxlICogLTEgKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbygwLCBjbGFtcCh2LCAwLCBzaXplWzFdKSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCB2YWx1ZXMubGVuZ3RoICYmIGogPCBzaXplWzBdOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSB2YWx1ZXNbal0gKiBzY2FsZSAqIC0xICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGosIGNsYW1wKHYsIDAsIHNpemVbMV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZ3JhcGhpY3MvcGxvdFwiLCBHcmFwaGljc1Bsb3QpO1xuXG4gICAgZnVuY3Rpb24gR3JhcGhpY3NJbWFnZSgpIHtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJmcmFtZVwiLCBcImltYWdlXCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHVybDogXCJcIiB9O1xuICAgIH1cblxuICAgIEdyYXBoaWNzSW1hZ2UudGl0bGUgPSBcIkltYWdlXCI7XG4gICAgR3JhcGhpY3NJbWFnZS5kZXNjID0gXCJJbWFnZSBsb2FkZXJcIjtcbiAgICBHcmFwaGljc0ltYWdlLndpZGdldHMgPSBbeyBuYW1lOiBcImxvYWRcIiwgdGV4dDogXCJMb2FkXCIsIHR5cGU6IFwiYnV0dG9uXCIgfV07XG5cbiAgICBHcmFwaGljc0ltYWdlLnN1cHBvcnRlZF9leHRlbnNpb25zID0gW1wianBnXCIsIFwianBlZ1wiLCBcInBuZ1wiLCBcImdpZlwiXTtcblxuICAgIEdyYXBoaWNzSW1hZ2UucHJvdG90eXBlLm9uQWRkZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllc1tcInVybFwiXSAhPSBcIlwiICYmIHRoaXMuaW1nID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZEltYWdlKHRoaXMucHJvcGVydGllc1tcInVybFwiXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgR3JhcGhpY3NJbWFnZS5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbWcgJiYgdGhpcy5zaXplWzBdID4gNSAmJiB0aGlzLnNpemVbMV0gPiA1ICYmIHRoaXMuaW1nLndpZHRoKSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuaW1nLCAwLCAwLCB0aGlzLnNpemVbMF0sIHRoaXMuc2l6ZVsxXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgR3JhcGhpY3NJbWFnZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5pbWcpIHtcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBcIiMwMDBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbWcgJiYgdGhpcy5pbWcud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLmltZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW1nICYmIHRoaXMuaW1nLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmltZy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEdyYXBoaWNzSW1hZ2UucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIGlmIChuYW1lID09IFwidXJsXCIgJiYgdmFsdWUgIT0gXCJcIikge1xuICAgICAgICAgICAgdGhpcy5sb2FkSW1hZ2UodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIEdyYXBoaWNzSW1hZ2UucHJvdG90eXBlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHVybCA9PSBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLmltZyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cbiAgICAgICAgaWYgKHVybC5zdWJzdHIoMCwgNCkgPT0gXCJodHRwXCIgJiYgTGl0ZUdyYXBoLnByb3h5KSB7XG4gICAgICAgICAgICB1cmwgPSBMaXRlR3JhcGgucHJveHkgKyB1cmwuc3Vic3RyKHVybC5pbmRleE9mKFwiOlwiKSArIDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbWcuc3JjID0gdXJsO1xuICAgICAgICB0aGlzLmJveGNvbG9yID0gXCIjRjk1XCI7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhpcy5pbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcIkltYWdlIGxvYWRlZCwgc2l6ZTogXCIgKyB0aGF0LmltZy53aWR0aCArIFwieFwiICsgdGhhdC5pbWcuaGVpZ2h0ICk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoYXQuYm94Y29sb3IgPSBcIiM5RjlcIjtcbiAgICAgICAgICAgIHRoYXQuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdGNvbnNvbGUubG9nKFwiZXJyb3IgbG9hZGluZyB0aGUgaW1hZ2U6XCIgKyB1cmwpO1xuXHRcdH1cbiAgICB9O1xuXG4gICAgR3JhcGhpY3NJbWFnZS5wcm90b3R5cGUub25XaWRnZXQgPSBmdW5jdGlvbihlLCB3aWRnZXQpIHtcbiAgICAgICAgaWYgKHdpZGdldC5uYW1lID09IFwibG9hZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRJbWFnZSh0aGlzLnByb3BlcnRpZXNbXCJ1cmxcIl0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEdyYXBoaWNzSW1hZ2UucHJvdG90eXBlLm9uRHJvcEZpbGUgPSBmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3VybCkge1xuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLl91cmwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XG4gICAgICAgIHRoaXMucHJvcGVydGllcy51cmwgPSB0aGlzLl91cmw7XG4gICAgICAgIHRoaXMubG9hZEltYWdlKHRoaXMuX3VybCwgZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgICAgICB0aGF0LnNpemVbMV0gPSAoaW1nLmhlaWdodCAvIGltZy53aWR0aCkgKiB0aGF0LnNpemVbMF07XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImdyYXBoaWNzL2ltYWdlXCIsIEdyYXBoaWNzSW1hZ2UpO1xuXG4gICAgZnVuY3Rpb24gQ29sb3JQYWxldHRlKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiZlwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJDb2xvclwiLCBcImNvbG9yXCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBjb2xvckE6IFwiIzQ0NDQ0NFwiLFxuICAgICAgICAgICAgY29sb3JCOiBcIiM0NEFBRkZcIixcbiAgICAgICAgICAgIGNvbG9yQzogXCIjNDRGRkFBXCIsXG4gICAgICAgICAgICBjb2xvckQ6IFwiI0ZGRkZGRlwiXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgQ29sb3JQYWxldHRlLnRpdGxlID0gXCJQYWxldHRlXCI7XG4gICAgQ29sb3JQYWxldHRlLmRlc2MgPSBcIkdlbmVyYXRlcyBhIGNvbG9yXCI7XG5cbiAgICBDb2xvclBhbGV0dGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuY29sb3JBICE9IG51bGwpIHtcbiAgICAgICAgICAgIGMucHVzaChoZXgybnVtKHRoaXMucHJvcGVydGllcy5jb2xvckEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmNvbG9yQiAhPSBudWxsKSB7XG4gICAgICAgICAgICBjLnB1c2goaGV4Mm51bSh0aGlzLnByb3BlcnRpZXMuY29sb3JCKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5jb2xvckMgIT0gbnVsbCkge1xuICAgICAgICAgICAgYy5wdXNoKGhleDJudW0odGhpcy5wcm9wZXJ0aWVzLmNvbG9yQykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuY29sb3JEICE9IG51bGwpIHtcbiAgICAgICAgICAgIGMucHVzaChoZXgybnVtKHRoaXMucHJvcGVydGllcy5jb2xvckQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmIChmID09IG51bGwpIHtcbiAgICAgICAgICAgIGYgPSAwLjU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGYgPiAxLjApIHtcbiAgICAgICAgICAgIGYgPSAxLjA7XG4gICAgICAgIH0gZWxzZSBpZiAoZiA8IDAuMCkge1xuICAgICAgICAgICAgZiA9IDAuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gWzAsIDAsIDBdO1xuICAgICAgICBpZiAoZiA9PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKGYgPT0gMSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY1tjLmxlbmd0aCAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBvcyA9IChjLmxlbmd0aCAtIDEpICogZjtcbiAgICAgICAgICAgIHZhciBjMSA9IGNbTWF0aC5mbG9vcihwb3MpXTtcbiAgICAgICAgICAgIHZhciBjMiA9IGNbTWF0aC5mbG9vcihwb3MpICsgMV07XG4gICAgICAgICAgICB2YXIgdCA9IHBvcyAtIE1hdGguZmxvb3IocG9zKTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IGMxWzBdICogKDEgLSB0KSArIGMyWzBdICogdDtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IGMxWzFdICogKDEgLSB0KSArIGMyWzFdICogdDtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IGMxWzJdICogKDEgLSB0KSArIGMyWzJdICogdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG5cdGNbMF0gPSAxLjAgLSBNYXRoLmFicyggTWF0aC5zaW4oIDAuMSAqIHJlTW9kdWxhci5nZXRUaW1lKCkgKiBNYXRoLlBJKSApO1xuXHRjWzFdID0gTWF0aC5hYnMoIE1hdGguc2luKCAwLjA3ICogcmVNb2R1bGFyLmdldFRpbWUoKSAqIE1hdGguUEkpICk7XG5cdGNbMl0gPSBNYXRoLmFicyggTWF0aC5zaW4oIDAuMDEgKiByZU1vZHVsYXIuZ2V0VGltZSgpICogTWF0aC5QSSkgKTtcblx0Ki9cblxuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSAvPSAyNTU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJveGNvbG9yID0gY29sb3JUb1N0cmluZyhyZXN1bHQpO1xuICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgcmVzdWx0KTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJjb2xvci9wYWxldHRlXCIsIENvbG9yUGFsZXR0ZSk7XG5cbiAgICBmdW5jdGlvbiBJbWFnZUZyYW1lKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiXCIsIFwiaW1hZ2UsY2FudmFzXCIpO1xuICAgICAgICB0aGlzLnNpemUgPSBbMjAwLCAyMDBdO1xuICAgIH1cblxuICAgIEltYWdlRnJhbWUudGl0bGUgPSBcIkZyYW1lXCI7XG4gICAgSW1hZ2VGcmFtZS5kZXNjID0gXCJGcmFtZSB2aWV3ZXJld1wiO1xuICAgIEltYWdlRnJhbWUud2lkZ2V0cyA9IFtcbiAgICAgICAgeyBuYW1lOiBcInJlc2l6ZVwiLCB0ZXh0OiBcIlJlc2l6ZSBib3hcIiwgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICB7IG5hbWU6IFwidmlld1wiLCB0ZXh0OiBcIlZpZXcgSW1hZ2VcIiwgdHlwZTogXCJidXR0b25cIiB9XG4gICAgXTtcblxuICAgIEltYWdlRnJhbWUucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJhbWUgJiYgIXRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuZnJhbWUsIDAsIDAsIHRoaXMuc2l6ZVswXSwgdGhpcy5zaXplWzFdKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbWFnZUZyYW1lLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5mcmFtZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICB0aGlzLnNldERpcnR5Q2FudmFzKHRydWUpO1xuICAgIH07XG5cbiAgICBJbWFnZUZyYW1lLnByb3RvdHlwZS5vbldpZGdldCA9IGZ1bmN0aW9uKGUsIHdpZGdldCkge1xuICAgICAgICBpZiAod2lkZ2V0Lm5hbWUgPT0gXCJyZXNpemVcIiAmJiB0aGlzLmZyYW1lKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmZyYW1lLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZnJhbWUuaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAoIXdpZHRoICYmIHRoaXMuZnJhbWUudmlkZW9XaWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLmZyYW1lLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5mcmFtZS52aWRlb0hlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdpZHRoICYmIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSA9IFt3aWR0aCwgaGVpZ2h0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2lkZ2V0Lm5hbWUgPT0gXCJ2aWV3XCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEltYWdlRnJhbWUucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy92YXIgc3RyID0gdGhpcy5jYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICAgICAgICBpZiAoc2hvd0VsZW1lbnQgJiYgdGhpcy5mcmFtZSkge1xuICAgICAgICAgICAgc2hvd0VsZW1lbnQodGhpcy5mcmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJncmFwaGljcy9mcmFtZVwiLCBJbWFnZUZyYW1lKTtcblxuICAgIGZ1bmN0aW9uIEltYWdlRmFkZSgpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dHMoW1xuICAgICAgICAgICAgW1wiaW1nMVwiLCBcImltYWdlXCJdLFxuICAgICAgICAgICAgW1wiaW1nMlwiLCBcImltYWdlXCJdLFxuICAgICAgICAgICAgW1wiZmFkZVwiLCBcIm51bWJlclwiXVxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJpbWFnZVwiKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyBmYWRlOiAwLjUsIHdpZHRoOiA1MTIsIGhlaWdodDogNTEyIH07XG4gICAgfVxuXG4gICAgSW1hZ2VGYWRlLnRpdGxlID0gXCJJbWFnZSBmYWRlXCI7XG4gICAgSW1hZ2VGYWRlLmRlc2MgPSBcIkZhZGVzIGJldHdlZW4gaW1hZ2VzXCI7XG4gICAgSW1hZ2VGYWRlLndpZGdldHMgPSBbXG4gICAgICAgIHsgbmFtZTogXCJyZXNpemVBXCIsIHRleHQ6IFwiUmVzaXplIHRvIEFcIiwgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICB7IG5hbWU6IFwicmVzaXplQlwiLCB0ZXh0OiBcIlJlc2l6ZSB0byBCXCIsIHR5cGU6IFwiYnV0dG9uXCIgfVxuICAgIF07XG5cbiAgICBJbWFnZUZhZGUucHJvdG90eXBlLm9uQWRkZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVDYW52YXMoKTtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzAwMFwiO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy5wcm9wZXJ0aWVzW1wid2lkdGhcIl0sIHRoaXMucHJvcGVydGllc1tcImhlaWdodFwiXSk7XG4gICAgfTtcblxuICAgIEltYWdlRmFkZS5wcm90b3R5cGUuY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLnByb3BlcnRpZXNbXCJ3aWR0aFwiXTtcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5wcm9wZXJ0aWVzW1wiaGVpZ2h0XCJdO1xuICAgIH07XG5cbiAgICBJbWFnZUZhZGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoO1xuXG4gICAgICAgIHZhciBBID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG4gICAgICAgIGlmIChBICE9IG51bGwpIHtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoQSwgMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmFkZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xuICAgICAgICBpZiAoZmFkZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBmYWRlID0gdGhpcy5wcm9wZXJ0aWVzW1wiZmFkZVwiXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tcImZhZGVcIl0gPSBmYWRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZmFkZTtcbiAgICAgICAgdmFyIEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcbiAgICAgICAgaWYgKEIgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShCLCAwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxLjA7XG5cbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuY2FudmFzKTtcbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlKTtcbiAgICB9O1xuXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJncmFwaGljcy9pbWFnZWZhZGVcIiwgSW1hZ2VGYWRlKTtcblxuICAgIGZ1bmN0aW9uIEltYWdlQ3JvcCgpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIlwiLCBcImltYWdlXCIpO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcImltYWdlXCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHdpZHRoOiAyNTYsIGhlaWdodDogMjU2LCB4OiAwLCB5OiAwLCBzY2FsZTogMS4wIH07XG4gICAgICAgIHRoaXMuc2l6ZSA9IFs1MCwgMjBdO1xuICAgIH1cblxuICAgIEltYWdlQ3JvcC50aXRsZSA9IFwiQ3JvcFwiO1xuICAgIEltYWdlQ3JvcC5kZXNjID0gXCJDcm9wIEltYWdlXCI7XG5cbiAgICBJbWFnZUNyb3AucHJvdG90eXBlLm9uQWRkZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVDYW52YXMoKTtcbiAgICB9O1xuXG4gICAgSW1hZ2VDcm9wLnByb3RvdHlwZS5jcmVhdGVDYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMucHJvcGVydGllc1tcIndpZHRoXCJdO1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLnByb3BlcnRpZXNbXCJoZWlnaHRcIl07XG4gICAgfTtcblxuICAgIEltYWdlQ3JvcC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXQud2lkdGgpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgLXRoaXMucHJvcGVydGllc1tcInhcIl0sXG4gICAgICAgICAgICAgICAgLXRoaXMucHJvcGVydGllc1tcInlcIl0sXG4gICAgICAgICAgICAgICAgaW5wdXQud2lkdGggKiB0aGlzLnByb3BlcnRpZXNbXCJzY2FsZVwiXSxcbiAgICAgICAgICAgICAgICBpbnB1dC5oZWlnaHQgKiB0aGlzLnByb3BlcnRpZXNbXCJzY2FsZVwiXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLmNhbnZhcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW1hZ2VDcm9wLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcyxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICB0aGlzLnNpemVbMF0sXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplWzFdXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEltYWdlQ3JvcC5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNbbmFtZV0gPSB2YWx1ZTtcblxuICAgICAgICBpZiAobmFtZSA9PSBcInNjYWxlXCIpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tuYW1lXSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcGVydGllc1tuYW1lXSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHNjYWxlXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tuYW1lXSA9IDEuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1tuYW1lXSA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3JlYXRlQ2FudmFzKCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZ3JhcGhpY3MvY3JvcEltYWdlXCIsIEltYWdlQ3JvcCk7XG5cbiAgICAvL0NBTlZBUyBzdHVmZlxuXG4gICAgZnVuY3Rpb24gQ2FudmFzTm9kZSgpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImNsZWFyXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIlwiLCBcImNhbnZhc1wiKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyB3aWR0aDogNTEyLCBoZWlnaHQ6IDUxMiwgYXV0b2NsZWFyOiB0cnVlIH07XG5cbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICB9XG5cbiAgICBDYW52YXNOb2RlLnRpdGxlID0gXCJDYW52YXNcIjtcbiAgICBDYW52YXNOb2RlLmRlc2MgPSBcIkNhbnZhcyB0byByZW5kZXIgc3R1ZmZcIjtcblxuICAgIENhbnZhc05vZGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAgIHZhciB3ID0gdGhpcy5wcm9wZXJ0aWVzLndpZHRoIHwgMDtcbiAgICAgICAgdmFyIGggPSB0aGlzLnByb3BlcnRpZXMuaGVpZ2h0IHwgMDtcbiAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPSB3KSB7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB3O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW52YXMuaGVpZ2h0ICE9IGgpIHtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5hdXRvY2xlYXIpIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCBjYW52YXMpO1xuICAgIH07XG5cbiAgICBDYW52YXNOb2RlLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvbiwgcGFyYW0pIHtcbiAgICAgICAgaWYgKGFjdGlvbiA9PSBcImNsZWFyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImdyYXBoaWNzL2NhbnZhc1wiLCBDYW52YXNOb2RlKTtcblxuICAgIGZ1bmN0aW9uIERyYXdJbWFnZU5vZGUoKSB7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJjYW52YXNcIiwgXCJjYW52YXNcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpbWdcIiwgXCJpbWFnZSxjYW52YXNcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ4XCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwieVwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyB4OiAwLCB5OiAwLCBvcGFjaXR5OiAxIH07XG4gICAgfVxuXG4gICAgRHJhd0ltYWdlTm9kZS50aXRsZSA9IFwiRHJhd0ltYWdlXCI7XG4gICAgRHJhd0ltYWdlTm9kZS5kZXNjID0gXCJEcmF3cyBpbWFnZSBpbnRvIGEgY2FudmFzXCI7XG5cbiAgICBEcmF3SW1hZ2VOb2RlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGltZyA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwiaW1nXCIpO1xuICAgICAgICBpZiAoIWltZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInhcIik7XG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJ5XCIpO1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIHgsIHkpO1xuICAgIH07XG5cbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImdyYXBoaWNzL2RyYXdJbWFnZVwiLCBEcmF3SW1hZ2VOb2RlKTtcblxuICAgIGZ1bmN0aW9uIERyYXdSZWN0YW5nbGVOb2RlKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiY2FudmFzXCIsIFwiY2FudmFzXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwieFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInlcIiwgXCJudW1iZXJcIik7XG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ3XCIsIFwibnVtYmVyXCIpO1xuICAgICAgICB0aGlzLmFkZElucHV0KFwiaFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3OiAxMCxcbiAgICAgICAgICAgIGg6IDEwLFxuICAgICAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBEcmF3UmVjdGFuZ2xlTm9kZS50aXRsZSA9IFwiRHJhd1JlY3RhbmdsZVwiO1xuICAgIERyYXdSZWN0YW5nbGVOb2RlLmRlc2MgPSBcIkRyYXdzIHJlY3RhbmdsZSBpbiBjYW52YXNcIjtcblxuICAgIERyYXdSZWN0YW5nbGVOb2RlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInhcIik7XG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJ5XCIpO1xuICAgICAgICB2YXIgdyA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwid1wiKTtcbiAgICAgICAgdmFyIGggPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcImhcIik7XG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBjdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZ3JhcGhpY3MvZHJhd1JlY3RhbmdsZVwiLCBEcmF3UmVjdGFuZ2xlTm9kZSk7XG5cbiAgICBmdW5jdGlvbiBJbWFnZVZpZGVvKCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KFwidFwiLCBcIm51bWJlclwiKTtcbiAgICAgICAgdGhpcy5hZGRPdXRwdXRzKFtbXCJmcmFtZVwiLCBcImltYWdlXCJdLCBbXCJ0XCIsIFwibnVtYmVyXCJdLCBbXCJkXCIsIFwibnVtYmVyXCJdXSk7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgdXJsOiBcIlwiLCB1c2VfcHJveHk6IHRydWUgfTtcbiAgICB9XG5cbiAgICBJbWFnZVZpZGVvLnRpdGxlID0gXCJWaWRlb1wiO1xuICAgIEltYWdlVmlkZW8uZGVzYyA9IFwiVmlkZW8gcGxheWJhY2tcIjtcbiAgICBJbWFnZVZpZGVvLndpZGdldHMgPSBbXG4gICAgICAgIHsgbmFtZTogXCJwbGF5XCIsIHRleHQ6IFwiUExBWVwiLCB0eXBlOiBcIm1pbmlidXR0b25cIiB9LFxuICAgICAgICB7IG5hbWU6IFwic3RvcFwiLCB0ZXh0OiBcIlNUT1BcIiwgdHlwZTogXCJtaW5pYnV0dG9uXCIgfSxcbiAgICAgICAgeyBuYW1lOiBcImRlbW9cIiwgdGV4dDogXCJEZW1vIHZpZGVvXCIsIHR5cGU6IFwiYnV0dG9uXCIgfSxcbiAgICAgICAgeyBuYW1lOiBcIm11dGVcIiwgdGV4dDogXCJNdXRlIHZpZGVvXCIsIHR5cGU6IFwiYnV0dG9uXCIgfVxuICAgIF07XG5cbiAgICBJbWFnZVZpZGVvLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BlcnRpZXMudXJsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnVybCAhPSB0aGlzLl92aWRlb191cmwpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZFZpZGVvKHRoaXMucHJvcGVydGllcy51cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92aWRlbyB8fCB0aGlzLl92aWRlby53aWR0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuICAgICAgICBpZiAodCAmJiB0ID49IDAgJiYgdCA8PSAxLjApIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvLmN1cnJlbnRUaW1lID0gdCAqIHRoaXMuX3ZpZGVvLmR1cmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5fdmlkZW8ucGF1c2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZpZGVvLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3ZpZGVvKTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDEsIHRoaXMuX3ZpZGVvLmN1cnJlbnRUaW1lKTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDIsIHRoaXMuX3ZpZGVvLmR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlKTtcbiAgICB9O1xuXG4gICAgSW1hZ2VWaWRlby5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICB9O1xuXG4gICAgSW1hZ2VWaWRlby5wcm90b3R5cGUub25TdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH07XG5cbiAgICBJbWFnZVZpZGVvLnByb3RvdHlwZS5sb2FkVmlkZW8gPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgdGhpcy5fdmlkZW9fdXJsID0gdXJsO1xuXG5cdFx0dmFyIHBvcyA9IHVybC5zdWJzdHIoMCwxMCkuaW5kZXhPZihcIjpcIik7XG5cdFx0dmFyIHByb3RvY29sID0gXCJcIjtcblx0XHRpZihwb3MgIT0gLTEpXG5cdFx0XHRwcm90b2NvbCA9IHVybC5zdWJzdHIoMCxwb3MpO1xuXG5cdFx0dmFyIGhvc3QgPSBcIlwiO1xuXHRcdGlmKHByb3RvY29sKVxuXHRcdHtcblx0XHRcdGhvc3QgPSB1cmwuc3Vic3RyKDAsdXJsLmluZGV4T2YoXCIvXCIscHJvdG9jb2wubGVuZ3RoICsgMykpO1xuXHRcdFx0aG9zdCA9IGhvc3Quc3Vic3RyKHByb3RvY29sLmxlbmd0aCszKTtcblx0XHR9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnVzZV9wcm94eSAmJlxuICAgICAgICAgICAgcHJvdG9jb2wgJiZcbiAgICAgICAgICAgIExpdGVHcmFwaC5wcm94eSAmJlxuXHRcdFx0aG9zdCAhPSBsb2NhdGlvbi5ob3N0XG4gICAgICAgICkge1xuICAgICAgICAgICAgdXJsID0gTGl0ZUdyYXBoLnByb3h5ICsgdXJsLnN1YnN0cih1cmwuaW5kZXhPZihcIjpcIikgKyAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuICAgICAgICB0aGlzLl92aWRlby5zcmMgPSB1cmw7XG4gICAgICAgIHRoaXMuX3ZpZGVvLnR5cGUgPSBcInR5cGU9dmlkZW8vbXA0XCI7XG5cbiAgICAgICAgdGhpcy5fdmlkZW8ubXV0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl92aWRlby5hdXRvcGxheSA9IHRydWU7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLl92aWRlby5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgLy9vbmxvYWRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRHVyYXRpb246IFwiICsgdGhpcy5kdXJhdGlvbiArIFwiIHNlY29uZHNcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNpemU6IFwiICsgdGhpcy52aWRlb1dpZHRoICsgXCIsXCIgKyB0aGlzLnZpZGVvSGVpZ2h0KTtcbiAgICAgICAgICAgIHRoYXQuc2V0RGlydHlDYW52YXModHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy52aWRlb1dpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnZpZGVvSGVpZ2h0O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIC8vb25sb2FkXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInZpZGVvIGxvYWRpbmcuLi5cIik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl92aWRlby5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgdmlkZW86IFwiICsgdGhpcy5zcmMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZXJyb3IuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuZXJyb3IuTUVESUFfRVJSX0FCT1JURUQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IHN0b3BwZWQgdGhlIHZpZGVvLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuZXJyb3IuTUVESUFfRVJSX05FVFdPUks6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTmV0d29yayBlcnJvciAtIHBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5lcnJvci5NRURJQV9FUlJfREVDT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlZpZGVvIGlzIGJyb2tlbi4uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5lcnJvci5NRURJQV9FUlJfU1JDX05PVF9TVVBQT1JURUQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiU29ycnksIHlvdXIgYnJvd3NlciBjYW4ndCBwbGF5IHRoaXMgdmlkZW8uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl92aWRlby5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJWaWRlbyBFbmRlZC5cIik7XG4gICAgICAgICAgICB0aGlzLnBsYXkoKTsgLy9sb29wXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnZpZGVvKTtcbiAgICB9O1xuXG4gICAgSW1hZ2VWaWRlby5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJ1cmxcIiAmJiB2YWx1ZSAhPSBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRWaWRlbyh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgSW1hZ2VWaWRlby5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fdmlkZW8gJiYgdGhpcy5fdmlkZW8udmlkZW9XaWR0aCApIHsgLy9pcyBsb2FkZWRcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvLnBsYXkoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbWFnZVZpZGVvLnByb3RvdHlwZS5wbGF5UGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl92aWRlbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl92aWRlby5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEltYWdlVmlkZW8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl92aWRlbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZpZGVvLnBhdXNlKCk7XG4gICAgICAgIHRoaXMuX3ZpZGVvLmN1cnJlbnRUaW1lID0gMDtcbiAgICB9O1xuXG4gICAgSW1hZ2VWaWRlby5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl92aWRlbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVmlkZW8gcGF1c2VkXCIpO1xuICAgICAgICB0aGlzLl92aWRlby5wYXVzZSgpO1xuICAgIH07XG5cbiAgICBJbWFnZVZpZGVvLnByb3RvdHlwZS5vbldpZGdldCA9IGZ1bmN0aW9uKGUsIHdpZGdldCkge1xuICAgICAgICAvKlxuXHRpZih3aWRnZXQubmFtZSA9PSBcImRlbW9cIilcblx0e1xuXHRcdHRoaXMubG9hZFZpZGVvKCk7XG5cdH1cblx0ZWxzZSBpZih3aWRnZXQubmFtZSA9PSBcInBsYXlcIilcblx0e1xuXHRcdGlmKHRoaXMuX3ZpZGVvKVxuXHRcdFx0dGhpcy5wbGF5UGF1c2UoKTtcblx0fVxuXHRpZih3aWRnZXQubmFtZSA9PSBcInN0b3BcIilcblx0e1xuXHRcdHRoaXMuc3RvcCgpO1xuXHR9XG5cdGVsc2UgaWYod2lkZ2V0Lm5hbWUgPT0gXCJtdXRlXCIpXG5cdHtcblx0XHRpZih0aGlzLl92aWRlbylcblx0XHRcdHRoaXMuX3ZpZGVvLm11dGVkID0gIXRoaXMuX3ZpZGVvLm11dGVkO1xuXHR9XG5cdCovXG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZ3JhcGhpY3MvdmlkZW9cIiwgSW1hZ2VWaWRlbyk7XG5cbiAgICAvLyBUZXh0dXJlIFdlYmNhbSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIGZ1bmN0aW9uIEltYWdlV2ViY2FtKCkge1xuICAgICAgICB0aGlzLmFkZE91dHB1dChcIldlYmNhbVwiLCBcImltYWdlXCIpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IGZpbHRlckZhY2luZ01vZGU6IGZhbHNlLCBmYWNpbmdNb2RlOiBcInVzZXJcIiB9O1xuICAgICAgICB0aGlzLmJveGNvbG9yID0gXCJibGFja1wiO1xuICAgICAgICB0aGlzLmZyYW1lID0gMDtcbiAgICB9XG5cbiAgICBJbWFnZVdlYmNhbS50aXRsZSA9IFwiV2ViY2FtXCI7XG4gICAgSW1hZ2VXZWJjYW0uZGVzYyA9IFwiV2ViY2FtIGltYWdlXCI7XG4gICAgSW1hZ2VXZWJjYW0uaXNfd2ViY2FtX29wZW4gPSBmYWxzZTtcblxuICAgIEltYWdlV2ViY2FtLnByb3RvdHlwZS5vcGVuU3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnZXRVc2VyTWVkaWEoKSBpcyBub3Qgc3VwcG9ydGVkIGluIHlvdXIgYnJvd3NlciwgdXNlIGNocm9tZSBhbmQgZW5hYmxlIFdlYlJUQyBmcm9tIGFib3V0Oi8vZmxhZ3MnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3dhaXRpbmdfY29uZmlybWF0aW9uID0gdHJ1ZTtcblxuICAgICAgICAvLyBOb3Qgc2hvd2luZyB2ZW5kb3IgcHJlZml4ZXMuXG4gICAgICAgIHZhciBjb25zdHJhaW50cyA9IHtcbiAgICAgICAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgICAgICAgIHZpZGVvOiAhdGhpcy5wcm9wZXJ0aWVzLmZpbHRlckZhY2luZ01vZGUgPyB0cnVlIDogeyBmYWNpbmdNb2RlOiB0aGlzLnByb3BlcnRpZXMuZmFjaW5nTW9kZSB9XG4gICAgICAgIH07XG4gICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXNcbiAgICAgICAgICAgIC5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG4gICAgICAgICAgICAudGhlbih0aGlzLnN0cmVhbVJlYWR5LmJpbmQodGhpcykpXG4gICAgICAgICAgICAuY2F0Y2gob25GYWlsU29IYXJkKTtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIGZ1bmN0aW9uIG9uRmFpbFNvSGFyZChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIldlYmNhbSByZWplY3RlZFwiLCBlKTtcbiAgICAgICAgICAgIHRoYXQuX3dlYmNhbV9zdHJlYW0gPSBmYWxzZTtcbiAgICAgICAgICAgIEltYWdlV2ViY2FtLmlzX3dlYmNhbV9vcGVuID0gZmFsc2U7XG4gICAgICAgICAgICB0aGF0LmJveGNvbG9yID0gXCJyZWRcIjtcbiAgICAgICAgICAgIHRoYXQudHJpZ2dlcihcInN0cmVhbV9lcnJvclwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBJbWFnZVdlYmNhbS5wcm90b3R5cGUuY2xvc2VTdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlYmNhbV9zdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciB0cmFja3MgPSB0aGlzLl93ZWJjYW1fc3RyZWFtLmdldFRyYWNrcygpO1xuICAgICAgICAgICAgaWYgKHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja3NbaV0uc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEltYWdlV2ViY2FtLmlzX3dlYmNhbV9vcGVuID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl93ZWJjYW1fc3RyZWFtID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBcImJsYWNrXCI7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJzdHJlYW1fY2xvc2VkXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEltYWdlV2ViY2FtLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChuYW1lID09IFwiZmFjaW5nTW9kZVwiKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuZmFjaW5nTW9kZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jbG9zZVN0cmVhbSgpO1xuICAgICAgICAgICAgdGhpcy5vcGVuU3RyZWFtKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW1hZ2VXZWJjYW0ucHJvdG90eXBlLm9uUmVtb3ZlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNsb3NlU3RyZWFtKCk7XG4gICAgfTtcblxuICAgIEltYWdlV2ViY2FtLnByb3RvdHlwZS5zdHJlYW1SZWFkeSA9IGZ1bmN0aW9uKGxvY2FsTWVkaWFTdHJlYW0pIHtcbiAgICAgICAgdGhpcy5fd2ViY2FtX3N0cmVhbSA9IGxvY2FsTWVkaWFTdHJlYW07XG4gICAgICAgIC8vdGhpcy5fd2FpdGluZ19jb25maXJtYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiZ3JlZW5cIjtcblxuICAgICAgICB2YXIgdmlkZW8gPSB0aGlzLl92aWRlbztcbiAgICAgICAgaWYgKCF2aWRlbykge1xuICAgICAgICAgICAgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG4gICAgICAgICAgICB2aWRlby5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgICAgICB2aWRlby5zcmNPYmplY3QgPSBsb2NhbE1lZGlhU3RyZWFtO1xuICAgICAgICAgICAgdGhpcy5fdmlkZW8gPSB2aWRlbztcbiAgICAgICAgICAgIC8vZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggdmlkZW8gKTsgLy9kZWJ1Z1xuICAgICAgICAgICAgLy93aGVuIHZpZGVvIGluZm8gaXMgbG9hZGVkIChzaXplIGFuZCBzbylcbiAgICAgICAgICAgIHZpZGVvLm9ubG9hZGVkbWV0YWRhdGEgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVhZHkgdG8gZ28uIERvIHNvbWUgc3R1ZmYuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgSW1hZ2VXZWJjYW0uaXNfd2ViY2FtX29wZW4gPSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcihcInN0cmVhbV9yZWFkeVwiLCB2aWRlbyk7XG4gICAgfTtcblxuICAgIEltYWdlV2ViY2FtLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlYmNhbV9zdHJlYW0gPT0gbnVsbCAmJiAhdGhpcy5fd2FpdGluZ19jb25maXJtYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMub3BlblN0cmVhbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92aWRlbyB8fCAhdGhpcy5fdmlkZW8udmlkZW9XaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmlkZW8uZnJhbWUgPSArK3RoaXMuZnJhbWU7XG4gICAgICAgIHRoaXMuX3ZpZGVvLndpZHRoID0gdGhpcy5fdmlkZW8udmlkZW9XaWR0aDtcbiAgICAgICAgdGhpcy5fdmlkZW8uaGVpZ2h0ID0gdGhpcy5fdmlkZW8udmlkZW9IZWlnaHQ7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl92aWRlbyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3V0cHV0c1tpXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLm91dHB1dHNbaV0ubmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ3aWR0aFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoaSwgdGhpcy5fdmlkZW8udmlkZW9XaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJoZWlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKGksIHRoaXMuX3ZpZGVvLnZpZGVvSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW1hZ2VXZWJjYW0ucHJvdG90eXBlLmdldEV4dHJhTWVudU9wdGlvbnMgPSBmdW5jdGlvbihncmFwaGNhbnZhcykge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciB0eHQgPSAhdGhhdC5wcm9wZXJ0aWVzLnNob3cgPyBcIlNob3cgRnJhbWVcIiA6IFwiSGlkZSBGcmFtZVwiO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHR4dCxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucHJvcGVydGllcy5zaG93ID0gIXRoYXQucHJvcGVydGllcy5zaG93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9O1xuXG4gICAgSW1hZ2VXZWJjYW0ucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5mbGFncy5jb2xsYXBzZWQgfHxcbiAgICAgICAgICAgIHRoaXMuc2l6ZVsxXSA8PSAyMCB8fFxuICAgICAgICAgICAgIXRoaXMucHJvcGVydGllcy5zaG93XG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92aWRlbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9yZW5kZXIgdG8gZ3JhcGggY2FudmFzXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fdmlkZW8sIDAsIDAsIHRoaXMuc2l6ZVswXSwgdGhpcy5zaXplWzFdKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuXG4gICAgSW1hZ2VXZWJjYW0ucHJvdG90eXBlLm9uR2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgW1wid2lkdGhcIiwgXCJudW1iZXJcIl0sXG4gICAgICAgICAgICBbXCJoZWlnaHRcIiwgXCJudW1iZXJcIl0sXG4gICAgICAgICAgICBbXCJzdHJlYW1fcmVhZHlcIiwgTGl0ZUdyYXBoLkVWRU5UXSxcbiAgICAgICAgICAgIFtcInN0cmVhbV9jbG9zZWRcIiwgTGl0ZUdyYXBoLkVWRU5UXSxcbiAgICAgICAgICAgIFtcInN0cmVhbV9lcnJvclwiLCBMaXRlR3JhcGguRVZFTlRdXG4gICAgICAgIF07XG4gICAgfTtcblxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZ3JhcGhpY3Mvd2ViY2FtXCIsIEltYWdlV2ViY2FtKTtcbn0pKHRoaXMpO1xuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICAgdmFyIExpdGVHcmFwaCA9IGdsb2JhbC5MaXRlR3JhcGg7XG5cdHZhciBMR3JhcGhDYW52YXMgPSBnbG9iYWwuTEdyYXBoQ2FudmFzO1xuXG4gICAgLy9Xb3JrcyB3aXRoIExpdGVnbC5qcyB0byBjcmVhdGUgV2ViR0wgbm9kZXNcbiAgICBnbG9iYWwuTEdyYXBoVGV4dHVyZSA9IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIEdMID09IFwidW5kZWZpbmVkXCIpXG5cdFx0cmV0dXJuO1xuXG5cdExHcmFwaENhbnZhcy5saW5rX3R5cGVfY29sb3JzW1wiVGV4dHVyZVwiXSA9IFwiIzk4N1wiO1xuXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmUoKSB7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ0ZXhcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwibmFtZVwiLCBcInN0cmluZ1wiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IG5hbWU6IFwiXCIsIGZpbHRlcjogdHJ1ZSB9O1xuXHRcdHRoaXMuc2l6ZSA9IFtcblx0XHRcdExHcmFwaFRleHR1cmUuaW1hZ2VfcHJldmlld19zaXplLFxuXHRcdFx0TEdyYXBoVGV4dHVyZS5pbWFnZV9wcmV2aWV3X3NpemVcblx0XHRdO1xuXHR9XG5cblx0Z2xvYmFsLkxHcmFwaFRleHR1cmUgPSBMR3JhcGhUZXh0dXJlO1xuXG5cdExHcmFwaFRleHR1cmUudGl0bGUgPSBcIlRleHR1cmVcIjtcblx0TEdyYXBoVGV4dHVyZS5kZXNjID0gXCJUZXh0dXJlXCI7XG5cdExHcmFwaFRleHR1cmUud2lkZ2V0c19pbmZvID0ge1xuXHRcdG5hbWU6IHsgd2lkZ2V0OiBcInRleHR1cmVcIiB9LFxuXHRcdGZpbHRlcjogeyB3aWRnZXQ6IFwiY2hlY2tib3hcIiB9XG5cdH07XG5cblx0Ly9SRVBMQUNFIFRISVMgVE8gSU5URUdSQVRFIFdJVEggWU9VUiBGUkFNRVdPUktcblx0TEdyYXBoVGV4dHVyZS5sb2FkVGV4dHVyZUNhbGxiYWNrID0gbnVsbDsgLy9mdW5jdGlvbiBpbiBjaGFyZ2Ugb2YgbG9hZGluZyB0ZXh0dXJlcyB3aGVuIG5vdCBwcmVzZW50IGluIHRoZSBjb250YWluZXJcblx0TEdyYXBoVGV4dHVyZS5pbWFnZV9wcmV2aWV3X3NpemUgPSAyNTY7XG5cblx0Ly9mbGFncyB0byBjaG9vc2Ugb3V0cHV0IHRleHR1cmUgdHlwZVxuXHRMR3JhcGhUZXh0dXJlLlVOREVGSU5FRCA9IDA7IC8vbm90IHNwZWNpZmllZFxuXHRMR3JhcGhUZXh0dXJlLlBBU1NfVEhST1VHSCA9IDE7IC8vZG8gbm90IGFwcGx5IEZYIChsaWtlIGRpc2FibGUgYnV0IHBhc3NpbmcgdGhlIGluIHRvIHRoZSBvdXQpXG5cdExHcmFwaFRleHR1cmUuQ09QWSA9IDI7IC8vY3JlYXRlIG5ldyB0ZXh0dXJlIHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBhcyB0aGUgb3JpZ2luIHRleHR1cmVcblx0TEdyYXBoVGV4dHVyZS5MT1cgPSAzOyAvL2NyZWF0ZSBuZXcgdGV4dHVyZSB3aXRoIGxvdyBwcmVjaXNpb24gKGJ5dGUpXG5cdExHcmFwaFRleHR1cmUuSElHSCA9IDQ7IC8vY3JlYXRlIG5ldyB0ZXh0dXJlIHdpdGggaGlnaCBwcmVjaXNpb24gKGhhbGYtZmxvYXQpXG5cdExHcmFwaFRleHR1cmUuUkVVU0UgPSA1OyAvL3JldXNlIGlucHV0IHRleHR1cmVcblx0TEdyYXBoVGV4dHVyZS5ERUZBVUxUID0gMjsgLy91c2UgdGhlIGRlZmF1bHRcblxuXHRMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTID0ge1xuXHRcdFwidW5kZWZpbmVkXCI6IExHcmFwaFRleHR1cmUuVU5ERUZJTkVELFxuXHRcdFwicGFzcyB0aHJvdWdoXCI6IExHcmFwaFRleHR1cmUuUEFTU19USFJPVUdILFxuXHRcdGNvcHk6IExHcmFwaFRleHR1cmUuQ09QWSxcblx0XHRsb3c6IExHcmFwaFRleHR1cmUuTE9XLFxuXHRcdGhpZ2g6IExHcmFwaFRleHR1cmUuSElHSCxcblx0XHRyZXVzZTogTEdyYXBoVGV4dHVyZS5SRVVTRSxcblx0XHRkZWZhdWx0OiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcblx0fTtcblxuXHQvL3JldHVybnMgdGhlIGNvbnRhaW5lciB3aGVyZSBhbGwgdGhlIGxvYWRlZCB0ZXh0dXJlcyBhcmUgc3RvcmVkIChvdmVyd3JpdGUgaWYgeW91IGhhdmUgYSBSZXNvdXJjZXMgTWFuYWdlcilcblx0TEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlc0NvbnRhaW5lciA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBnbC50ZXh0dXJlcztcblx0fTtcblxuXHQvL3Byb2Nlc3MgdGhlIGxvYWRpbmcgb2YgYSB0ZXh0dXJlIChvdmVyd3JpdGUgaXQgaWYgeW91IGhhdmUgYSBSZXNvdXJjZXMgTWFuYWdlcilcblx0TEdyYXBoVGV4dHVyZS5sb2FkVGV4dHVyZSA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHR2YXIgdXJsID0gbmFtZTtcblx0XHRpZiAodXJsLnN1YnN0cigwLCA3KSA9PSBcImh0dHA6Ly9cIikge1xuXHRcdFx0aWYgKExpdGVHcmFwaC5wcm94eSkge1xuXHRcdFx0XHQvL3Byb3h5IGV4dGVybmFsIGZpbGVzXG5cdFx0XHRcdHVybCA9IExpdGVHcmFwaC5wcm94eSArIHVybC5zdWJzdHIoNyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNvbnRhaW5lciA9IExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZXNDb250YWluZXIoKTtcblx0XHR2YXIgdGV4ID0gKGNvbnRhaW5lcltuYW1lXSA9IEdMLlRleHR1cmUuZnJvbVVSTCh1cmwsIG9wdGlvbnMpKTtcblx0XHRyZXR1cm4gdGV4O1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5nZXRUZXh0dXJlc0NvbnRhaW5lcigpO1xuXG5cdFx0aWYgKCFjb250YWluZXIpIHtcblx0XHRcdHRocm93IFwiQ2Fubm90IGxvYWQgdGV4dHVyZSwgY29udGFpbmVyIG9mIHRleHR1cmVzIG5vdCBmb3VuZFwiO1xuXHRcdH1cblxuXHRcdHZhciB0ZXggPSBjb250YWluZXJbbmFtZV07XG5cdFx0aWYgKCF0ZXggJiYgbmFtZSAmJiBuYW1lWzBdICE9IFwiOlwiKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5sb2FkVGV4dHVyZShuYW1lKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4O1xuXHR9O1xuXG5cdC8vdXNlZCB0byBjb21wdXRlIHRoZSBhcHByb3BpYXRlIG91dHB1dCB0ZXh0dXJlXG5cdExHcmFwaFRleHR1cmUuZ2V0VGFyZ2V0VGV4dHVyZSA9IGZ1bmN0aW9uKG9yaWdpbiwgdGFyZ2V0LCBtb2RlKSB7XG5cdFx0aWYgKCFvcmlnaW4pIHtcblx0XHRcdHRocm93IFwiTEdyYXBoVGV4dHVyZS5nZXRUYXJnZXRUZXh0dXJlIGV4cGVjdHMgYSByZWZlcmVuY2UgdGV4dHVyZVwiO1xuXHRcdH1cblxuXHRcdHZhciB0ZXhfdHlwZSA9IG51bGw7XG5cblx0XHRzd2l0Y2ggKG1vZGUpIHtcblx0XHRcdGNhc2UgTEdyYXBoVGV4dHVyZS5MT1c6XG5cdFx0XHRcdHRleF90eXBlID0gZ2wuVU5TSUdORURfQllURTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIExHcmFwaFRleHR1cmUuSElHSDpcblx0XHRcdFx0dGV4X3R5cGUgPSBnbC5ISUdIX1BSRUNJU0lPTl9GT1JNQVQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBMR3JhcGhUZXh0dXJlLlJFVVNFOlxuXHRcdFx0XHRyZXR1cm4gb3JpZ2luO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgTEdyYXBoVGV4dHVyZS5DT1BZOlxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGV4X3R5cGUgPSBvcmlnaW4gPyBvcmlnaW4udHlwZSA6IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdCF0YXJnZXQgfHxcblx0XHRcdHRhcmdldC53aWR0aCAhPSBvcmlnaW4ud2lkdGggfHxcblx0XHRcdHRhcmdldC5oZWlnaHQgIT0gb3JpZ2luLmhlaWdodCB8fFxuXHRcdFx0dGFyZ2V0LnR5cGUgIT0gdGV4X3R5cGUgfHxcblx0XHRcdHRhcmdldC5mb3JtYXQgIT0gb3JpZ2luLmZvcm1hdCBcblx0XHQpIHtcblx0XHRcdHRhcmdldCA9IG5ldyBHTC5UZXh0dXJlKG9yaWdpbi53aWR0aCwgb3JpZ2luLmhlaWdodCwge1xuXHRcdFx0XHR0eXBlOiB0ZXhfdHlwZSxcblx0XHRcdFx0Zm9ybWF0OiBvcmlnaW4uZm9ybWF0LFxuXHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlLmdldFRleHR1cmVUeXBlID0gZnVuY3Rpb24ocHJlY2lzaW9uLCByZWZfdGV4dHVyZSkge1xuXHRcdHZhciB0eXBlID0gcmVmX3RleHR1cmUgPyByZWZfdGV4dHVyZS50eXBlIDogZ2wuVU5TSUdORURfQllURTtcblx0XHRzd2l0Y2ggKHByZWNpc2lvbikge1xuXHRcdFx0Y2FzZSBMR3JhcGhUZXh0dXJlLkhJR0g6XG5cdFx0XHRcdHR5cGUgPSBnbC5ISUdIX1BSRUNJU0lPTl9GT1JNQVQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBMR3JhcGhUZXh0dXJlLkxPVzpcblx0XHRcdFx0dHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Ly9ubyBkZWZhdWx0XG5cdFx0fVxuXHRcdHJldHVybiB0eXBlO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmUuZ2V0V2hpdGVUZXh0dXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3doaXRlX3RleHR1cmUpIHtcblx0XHRcdHJldHVybiB0aGlzLl93aGl0ZV90ZXh0dXJlO1xuXHRcdH1cblx0XHR2YXIgdGV4dHVyZSA9ICh0aGlzLl93aGl0ZV90ZXh0dXJlID0gR0wuVGV4dHVyZS5mcm9tTWVtb3J5KFxuXHRcdFx0MSxcblx0XHRcdDEsXG5cdFx0XHRbMjU1LCAyNTUsIDI1NSwgMjU1XSxcblx0XHRcdHsgZm9ybWF0OiBnbC5SR0JBLCB3cmFwOiBnbC5SRVBFQVQsIGZpbHRlcjogZ2wuTkVBUkVTVCB9XG5cdFx0KSk7XG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZS5nZXROb2lzZVRleHR1cmUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fbm9pc2VfdGV4dHVyZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX25vaXNlX3RleHR1cmU7XG5cdFx0fVxuXG5cdFx0dmFyIG5vaXNlID0gbmV3IFVpbnQ4QXJyYXkoNTEyICogNTEyICogNCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA1MTIgKiA1MTIgKiA0OyArK2kpIHtcblx0XHRcdG5vaXNlW2ldID0gTWF0aC5yYW5kb20oKSAqIDI1NTtcblx0XHR9XG5cblx0XHR2YXIgdGV4dHVyZSA9IEdMLlRleHR1cmUuZnJvbU1lbW9yeSg1MTIsIDUxMiwgbm9pc2UsIHtcblx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdHdyYXA6IGdsLlJFUEVBVCxcblx0XHRcdGZpbHRlcjogZ2wuTkVBUkVTVFxuXHRcdH0pO1xuXHRcdHRoaXMuX25vaXNlX3RleHR1cmUgPSB0ZXh0dXJlO1xuXHRcdHJldHVybiB0ZXh0dXJlO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmUucHJvdG90eXBlLm9uRHJvcEZpbGUgPSBmdW5jdGlvbihkYXRhLCBmaWxlbmFtZSwgZmlsZSkge1xuXHRcdGlmICghZGF0YSkge1xuXHRcdFx0dGhpcy5fZHJvcF90ZXh0dXJlID0gbnVsbDtcblx0XHRcdHRoaXMucHJvcGVydGllcy5uYW1lID0gXCJcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHRleHR1cmUgPSBudWxsO1xuXHRcdFx0aWYgKHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0dGV4dHVyZSA9IEdMLlRleHR1cmUuZnJvbVVSTChkYXRhKTtcblx0XHRcdH0gZWxzZSBpZiAoZmlsZW5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiLmRkc1wiKSAhPSAtMSkge1xuXHRcdFx0XHR0ZXh0dXJlID0gR0wuVGV4dHVyZS5mcm9tRERTSW5NZW1vcnkoZGF0YSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtmaWxlXSk7XG5cdFx0XHRcdHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXHRcdFx0XHR0ZXh0dXJlID0gR0wuVGV4dHVyZS5mcm9tVVJMKHVybCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2Ryb3BfdGV4dHVyZSA9IHRleHR1cmU7XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMubmFtZSA9IGZpbGVuYW1lO1xuXHRcdH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlLnByb3RvdHlwZS5nZXRFeHRyYU1lbnVPcHRpb25zID0gZnVuY3Rpb24oZ3JhcGhjYW52YXMpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0aWYgKCF0aGlzLl9kcm9wX3RleHR1cmUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cmV0dXJuIFtcblx0XHRcdHtcblx0XHRcdFx0Y29udGVudDogXCJDbGVhclwiLFxuXHRcdFx0XHRjYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhhdC5fZHJvcF90ZXh0dXJlID0gbnVsbDtcblx0XHRcdFx0XHR0aGF0LnByb3BlcnRpZXMubmFtZSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRdO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSBudWxsO1xuXHRcdGlmICh0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDEpKSB7XG5cdFx0XHR0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHR9XG5cblx0XHRpZiAoIXRleCAmJiB0aGlzLl9kcm9wX3RleHR1cmUpIHtcblx0XHRcdHRleCA9IHRoaXMuX2Ryb3BfdGV4dHVyZTtcblx0XHR9XG5cblx0XHRpZiAoIXRleCAmJiB0aGlzLnByb3BlcnRpZXMubmFtZSkge1xuXHRcdFx0dGV4ID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlKHRoaXMucHJvcGVydGllcy5uYW1lKTtcblx0XHR9XG5cblx0XHRpZiAoIXRleCkge1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCBudWxsICk7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoIDEsIFwiXCIgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9sYXN0X3RleCA9IHRleDtcblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMuZmlsdGVyID09PSBmYWxzZSkge1xuXHRcdFx0dGV4LnNldFBhcmFtZXRlcihnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0ZXguc2V0UGFyYW1ldGVyKGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcblx0XHR9XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIHRleCApO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMSwgdGV4LmZ1bGxwYXRoIHx8IHRleC5maWxlbmFtZSApO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDI7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dHNbaV07XG5cdFx0XHRpZiAoIW91dHB1dCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHZhciB2ID0gbnVsbDtcblx0XHRcdGlmIChvdXRwdXQubmFtZSA9PSBcIndpZHRoXCIpIHtcblx0XHRcdFx0diA9IHRleC53aWR0aDtcblx0XHRcdH0gZWxzZSBpZiAob3V0cHV0Lm5hbWUgPT0gXCJoZWlnaHRcIikge1xuXHRcdFx0XHR2ID0gdGV4LmhlaWdodDtcblx0XHRcdH0gZWxzZSBpZiAob3V0cHV0Lm5hbWUgPT0gXCJhc3BlY3RcIikge1xuXHRcdFx0XHR2ID0gdGV4LndpZHRoIC8gdGV4LmhlaWdodDtcblx0XHRcdH1cblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YShpLCB2KTtcblx0XHR9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZS5wcm90b3R5cGUub25SZXNvdXJjZVJlbmFtZWQgPSBmdW5jdGlvbihcblx0XHRvbGRfbmFtZSxcblx0XHRuZXdfbmFtZVxuXHQpIHtcblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLm5hbWUgPT0gb2xkX25hbWUpIHtcblx0XHRcdHRoaXMucHJvcGVydGllcy5uYW1lID0gbmV3X25hbWU7XG5cdFx0fVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmUucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQgfHwgdGhpcy5zaXplWzFdIDw9IDIwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2Ryb3BfdGV4dHVyZSAmJiBjdHgud2ViZ2wpIHtcblx0XHRcdGN0eC5kcmF3SW1hZ2UoXG5cdFx0XHRcdHRoaXMuX2Ryb3BfdGV4dHVyZSxcblx0XHRcdFx0MCxcblx0XHRcdFx0MCxcblx0XHRcdFx0dGhpcy5zaXplWzBdLFxuXHRcdFx0XHR0aGlzLnNpemVbMV1cblx0XHRcdCk7XG5cdFx0XHQvL3RoaXMuX2Ryb3BfdGV4dHVyZS5yZW5kZXJRdWFkKHRoaXMucG9zWzBdLHRoaXMucG9zWzFdLHRoaXMuc2l6ZVswXSx0aGlzLnNpemVbMV0pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vRGlmZmVyZW50IHRleHR1cmU/IHRoZW4gZ2V0IGl0IGZyb20gdGhlIEdQVVxuXHRcdGlmICh0aGlzLl9sYXN0X3ByZXZpZXdfdGV4ICE9IHRoaXMuX2xhc3RfdGV4KSB7XG5cdFx0XHRpZiAoY3R4LndlYmdsKSB7XG5cdFx0XHRcdHRoaXMuX2NhbnZhcyA9IHRoaXMuX2xhc3RfdGV4O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHRleF9jYW52YXMgPSBMR3JhcGhUZXh0dXJlLmdlbmVyYXRlTG93UmVzVGV4dHVyZVByZXZpZXcoXG5cdFx0XHRcdFx0dGhpcy5fbGFzdF90ZXhcblx0XHRcdFx0KTtcblx0XHRcdFx0aWYgKCF0ZXhfY2FudmFzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fbGFzdF9wcmV2aWV3X3RleCA9IHRoaXMuX2xhc3RfdGV4O1xuXHRcdFx0XHR0aGlzLl9jYW52YXMgPSBjbG9uZUNhbnZhcyh0ZXhfY2FudmFzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX2NhbnZhcykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vcmVuZGVyIHRvIGdyYXBoIGNhbnZhc1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0aWYgKCFjdHgud2ViZ2wpIHtcblx0XHRcdC8vcmV2ZXJzZSBpbWFnZVxuXHRcdFx0Y3R4LnRyYW5zbGF0ZSgwLCB0aGlzLnNpemVbMV0pO1xuXHRcdFx0Y3R4LnNjYWxlKDEsIC0xKTtcblx0XHR9XG5cdFx0Y3R4LmRyYXdJbWFnZSh0aGlzLl9jYW52YXMsIDAsIDAsIHRoaXMuc2l6ZVswXSwgdGhpcy5zaXplWzFdKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9O1xuXG5cdC8vdmVyeSBzbG93LCB1c2VkIGF0IHlvdXIgb3duIHJpc2tcblx0TEdyYXBoVGV4dHVyZS5nZW5lcmF0ZUxvd1Jlc1RleHR1cmVQcmV2aWV3ID0gZnVuY3Rpb24odGV4KSB7XG5cdFx0aWYgKCF0ZXgpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciBzaXplID0gTEdyYXBoVGV4dHVyZS5pbWFnZV9wcmV2aWV3X3NpemU7XG5cdFx0dmFyIHRlbXBfdGV4ID0gdGV4O1xuXG5cdFx0aWYgKHRleC5mb3JtYXQgPT0gZ2wuREVQVEhfQ09NUE9ORU5UKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IC8vY2Fubm90IGdlbmVyYXRlIGZyb20gZGVwdGhcblxuXHRcdC8vR2VuZXJhdGUgbG93LWxldmVsIHZlcnNpb24gaW4gdGhlIEdQVSB0byBzcGVlZCB1cFxuXHRcdGlmICh0ZXgud2lkdGggPiBzaXplIHx8IHRleC5oZWlnaHQgPiBzaXplKSB7XG5cdFx0XHR0ZW1wX3RleCA9IHRoaXMuX3ByZXZpZXdfdGVtcF90ZXg7XG5cdFx0XHRpZiAoIXRoaXMuX3ByZXZpZXdfdGVtcF90ZXgpIHtcblx0XHRcdFx0dGVtcF90ZXggPSBuZXcgR0wuVGV4dHVyZShzaXplLCBzaXplLCB7XG5cdFx0XHRcdFx0bWluRmlsdGVyOiBnbC5ORUFSRVNUXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR0aGlzLl9wcmV2aWV3X3RlbXBfdGV4ID0gdGVtcF90ZXg7XG5cdFx0XHR9XG5cblx0XHRcdC8vY29weVxuXHRcdFx0dGV4LmNvcHlUbyh0ZW1wX3RleCk7XG5cdFx0XHR0ZXggPSB0ZW1wX3RleDtcblx0XHR9XG5cblx0XHQvL2NyZWF0ZSBpbnRlcm1lZGlhdGUgY2FudmFzIHdpdGggbG93cXVhbGl0eSB2ZXJzaW9uXG5cdFx0dmFyIHRleF9jYW52YXMgPSB0aGlzLl9wcmV2aWV3X2NhbnZhcztcblx0XHRpZiAoIXRleF9jYW52YXMpIHtcblx0XHRcdHRleF9jYW52YXMgPSBjcmVhdGVDYW52YXMoc2l6ZSwgc2l6ZSk7XG5cdFx0XHR0aGlzLl9wcmV2aWV3X2NhbnZhcyA9IHRleF9jYW52YXM7XG5cdFx0fVxuXG5cdFx0aWYgKHRlbXBfdGV4KSB7XG5cdFx0XHR0ZW1wX3RleC50b0NhbnZhcyh0ZXhfY2FudmFzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRleF9jYW52YXM7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZS5wcm90b3R5cGUuZ2V0UmVzb3VyY2VzID0gZnVuY3Rpb24ocmVzKSB7XG5cdFx0aWYodGhpcy5wcm9wZXJ0aWVzLm5hbWUpXG5cdFx0XHRyZXNbdGhpcy5wcm9wZXJ0aWVzLm5hbWVdID0gR0wuVGV4dHVyZTtcblx0XHRyZXR1cm4gcmVzO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmUucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFtbXCJpblwiLCBcIlRleHR1cmVcIl1dO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmUucHJvdG90eXBlLm9uR2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHRbXCJ3aWR0aFwiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcImhlaWdodFwiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcImFzcGVjdFwiLCBcIm51bWJlclwiXVxuXHRcdF07XG5cdH07XG5cblx0Ly91c2VkIHRvIHJlcGxhY2Ugc2hhZGVyIGNvZGVcblx0TEdyYXBoVGV4dHVyZS5yZXBsYWNlQ29kZSA9IGZ1bmN0aW9uKCBjb2RlLCBjb250ZXh0IClcblx0e1xuXHRcdHJldHVybiBjb2RlLnJlcGxhY2UoL1xce1xce1thLXpBLVowLTlfXSpcXH1cXH0vZywgZnVuY3Rpb24odil7XG5cdFx0XHR2ID0gdi5yZXBsYWNlKCAvW1xce1xcfV0vZywgXCJcIiApO1xuXHRcdFx0cmV0dXJuIGNvbnRleHRbdl0gfHwgXCJcIjtcblx0XHR9KTtcblx0fVxuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS90ZXh0dXJlXCIsIExHcmFwaFRleHR1cmUpO1xuXG5cdC8vKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZVByZXZpZXcoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgZmxpcFk6IGZhbHNlIH07XG5cdFx0dGhpcy5zaXplID0gW1xuXHRcdFx0TEdyYXBoVGV4dHVyZS5pbWFnZV9wcmV2aWV3X3NpemUsXG5cdFx0XHRMR3JhcGhUZXh0dXJlLmltYWdlX3ByZXZpZXdfc2l6ZVxuXHRcdF07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlUHJldmlldy50aXRsZSA9IFwiUHJldmlld1wiO1xuXHRMR3JhcGhUZXh0dXJlUHJldmlldy5kZXNjID0gXCJTaG93IGEgdGV4dHVyZSBpbiB0aGUgZ3JhcGggY2FudmFzXCI7XG5cdExHcmFwaFRleHR1cmVQcmV2aWV3LmFsbG93X3ByZXZpZXcgPSBmYWxzZTtcblxuXHRMR3JhcGhUZXh0dXJlUHJldmlldy5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghY3R4LndlYmdsICYmICFMR3JhcGhUZXh0dXJlUHJldmlldy5hbGxvd19wcmV2aWV3KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL25vdCB3b3JraW5nIHdlbGxcblxuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0ZXhfY2FudmFzID0gbnVsbDtcblxuXHRcdGlmICghdGV4LmhhbmRsZSAmJiBjdHgud2ViZ2wpIHtcblx0XHRcdHRleF9jYW52YXMgPSB0ZXg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRleF9jYW52YXMgPSBMR3JhcGhUZXh0dXJlLmdlbmVyYXRlTG93UmVzVGV4dHVyZVByZXZpZXcodGV4KTtcblx0XHR9XG5cblx0XHQvL3JlbmRlciB0byBncmFwaCBjYW52YXNcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMuZmxpcFkpIHtcblx0XHRcdGN0eC50cmFuc2xhdGUoMCwgdGhpcy5zaXplWzFdKTtcblx0XHRcdGN0eC5zY2FsZSgxLCAtMSk7XG5cdFx0fVxuXHRcdGN0eC5kcmF3SW1hZ2UodGV4X2NhbnZhcywgMCwgMCwgdGhpcy5zaXplWzBdLCB0aGlzLnNpemVbMV0pO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH07XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL3ByZXZpZXdcIiwgTEdyYXBoVGV4dHVyZVByZXZpZXcpO1xuXG5cdC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlU2F2ZSgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ0ZXhcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwibmFtZVwiLCBcInN0cmluZ1wiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IG5hbWU6IFwiXCIsIGdlbmVyYXRlX21pcG1hcHM6IGZhbHNlIH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlU2F2ZS50aXRsZSA9IFwiU2F2ZVwiO1xuXHRMR3JhcGhUZXh0dXJlU2F2ZS5kZXNjID0gXCJTYXZlIGEgdGV4dHVyZSBpbiB0aGUgcmVwb3NpdG9yeVwiO1xuXG5cdExHcmFwaFRleHR1cmVTYXZlLnByb3RvdHlwZS5nZXRQcmV2aWV3VGV4dHVyZSA9IGZ1bmN0aW9uKClcblx0e1xuXHRcdHJldHVybiB0aGlzLl90ZXh0dXJlO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZVNhdmUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMuZ2VuZXJhdGVfbWlwbWFwcykge1xuXHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHR0ZXguc2V0UGFyYW1ldGVyKCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUl9NSVBNQVBfTElORUFSICk7XG5cdFx0XHRnbC5nZW5lcmF0ZU1pcG1hcCh0ZXgudGV4dHVyZV90eXBlKTtcblx0XHRcdHRleC51bmJpbmQoMCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5uYW1lKSB7XG5cdFx0XHQvL2ZvciBjYXNlcyB3aGVyZSB3ZSB3YW50IHRvIHBlcmZvcm0gc29tZXRoaW5nIHdoZW4gc3RvcmluZyBpdFxuXHRcdFx0aWYgKExHcmFwaFRleHR1cmUuc3RvcmVUZXh0dXJlKSB7XG5cdFx0XHRcdExHcmFwaFRleHR1cmUuc3RvcmVUZXh0dXJlKHRoaXMucHJvcGVydGllcy5uYW1lLCB0ZXgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGNvbnRhaW5lciA9IExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZXNDb250YWluZXIoKTtcblx0XHRcdFx0Y29udGFpbmVyW3RoaXMucHJvcGVydGllcy5uYW1lXSA9IHRleDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl90ZXh0dXJlID0gdGV4O1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgxLCB0aGlzLnByb3BlcnRpZXMubmFtZSk7XG5cdH07XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL3NhdmVcIiwgTEdyYXBoVGV4dHVyZVNhdmUpO1xuXG5cdC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVPcGVyYXRpb24oKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlQlwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcInZhbHVlXCIsIFwibnVtYmVyXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5oZWxwID0gXCI8cD5waXhlbGNvZGUgbXVzdCBiZSB2ZWMzLCB1dmNvZGUgbXVzdCBiZSB2ZWMyLCBpcyBvcHRpb25hbDwvcD5cXFxuXHRcdDxwPjxzdHJvbmc+dXY6PC9zdHJvbmc+IHRleC4gY29vcmRzPC9wPjxwPjxzdHJvbmc+Y29sb3I6PC9zdHJvbmc+IHRleHR1cmUgPHN0cm9uZz5jb2xvckI6PC9zdHJvbmc+IHRleHR1cmVCPC9wPjxwPjxzdHJvbmc+dGltZTo8L3N0cm9uZz4gc2NlbmUgdGltZSA8c3Ryb25nPnZhbHVlOjwvc3Ryb25nPiBpbnB1dCB2YWx1ZTwvcD48cD5Gb3IgbXVsdGlsaW5lIHlvdSBtdXN0IHR5cGU6IHJlc3VsdCA9IC4uLjwvcD5cIjtcblxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdHZhbHVlOiAxLFxuXHRcdFx0cGl4ZWxjb2RlOiBcImNvbG9yICsgY29sb3JCICogdmFsdWVcIixcblx0XHRcdHV2Y29kZTogXCJcIixcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXG5cdFx0fTtcblxuXHRcdHRoaXMuaGFzX2Vycm9yID0gZmFsc2U7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLndpZGdldHNfaW5mbyA9IHtcblx0XHR1dmNvZGU6IHsgd2lkZ2V0OiBcImNvZGVcIiB9LFxuXHRcdHBpeGVsY29kZTogeyB3aWRnZXQ6IFwiY29kZVwiIH0sXG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24udGl0bGUgPSBcIk9wZXJhdGlvblwiO1xuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLmRlc2MgPSBcIlRleHR1cmUgc2hhZGVyIG9wZXJhdGlvblwiO1xuXG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucHJlc2V0cyA9IHt9O1xuXG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucHJvdG90eXBlLmdldEV4dHJhTWVudU9wdGlvbnMgPSBmdW5jdGlvbihcblx0XHRncmFwaGNhbnZhc1xuXHQpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dmFyIHR4dCA9ICF0aGF0LnByb3BlcnRpZXMuc2hvdyA/IFwiU2hvdyBUZXh0dXJlXCIgOiBcIkhpZGUgVGV4dHVyZVwiO1xuXHRcdHJldHVybiBbXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnRlbnQ6IHR4dCxcblx0XHRcdFx0Y2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoYXQucHJvcGVydGllcy5zaG93ID0gIXRoYXQucHJvcGVydGllcy5zaG93O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKClcblx0e1xuXHRcdHRoaXMuaGFzX2Vycm9yID0gZmFsc2U7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0aWYgKFxuXHRcdFx0dGhpcy5mbGFncy5jb2xsYXBzZWQgfHxcblx0XHRcdHRoaXMuc2l6ZVsxXSA8PSAyMCB8fFxuXHRcdFx0IXRoaXMucHJvcGVydGllcy5zaG93XG5cdFx0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl90ZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvL29ubHkgd29ya3MgaWYgdXNpbmcgYSB3ZWJnbCByZW5kZXJlclxuXHRcdGlmICh0aGlzLl90ZXguZ2wgIT0gY3R4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly9yZW5kZXIgdG8gZ3JhcGggY2FudmFzXG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguZHJhd0ltYWdlKHRoaXMuX3RleCwgMCwgMCwgdGhpcy5zaXplWzBdLCB0aGlzLnNpemVbMV0pO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLlBBU1NfVEhST1VHSCkge1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRleEIgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcblxuXHRcdGlmICghdGhpcy5wcm9wZXJ0aWVzLnV2Y29kZSAmJiAhdGhpcy5wcm9wZXJ0aWVzLnBpeGVsY29kZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB3aWR0aCA9IDUxMjtcblx0XHR2YXIgaGVpZ2h0ID0gNTEyO1xuXHRcdGlmICh0ZXgpIHtcblx0XHRcdHdpZHRoID0gdGV4LndpZHRoO1xuXHRcdFx0aGVpZ2h0ID0gdGV4LmhlaWdodDtcblx0XHR9IGVsc2UgaWYgKHRleEIpIHtcblx0XHRcdHdpZHRoID0gdGV4Qi53aWR0aDtcblx0XHRcdGhlaWdodCA9IHRleEIuaGVpZ2h0O1xuXHRcdH1cblxuXHRcdGlmKCF0ZXhCKVxuXHRcdFx0dGV4QiA9IEdMLlRleHR1cmUuZ2V0V2hpdGVUZXh0dXJlKCk7XG5cblx0XHR2YXIgdHlwZSA9IExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZVR5cGUoIHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24sIHRleCApO1xuXG5cdFx0aWYgKCF0ZXggJiYgIXRoaXMuX3RleCkge1xuXHRcdFx0dGhpcy5fdGV4ID0gbmV3IEdMLlRleHR1cmUod2lkdGgsIGhlaWdodCwgeyB0eXBlOiB0eXBlLCBmb3JtYXQ6IGdsLlJHQkEsIGZpbHRlcjogZ2wuTElORUFSIH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl90ZXggPSBMR3JhcGhUZXh0dXJlLmdldFRhcmdldFRleHR1cmUoIHRleCB8fCB0aGlzLl90ZXgsIHRoaXMuX3RleCwgdGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiApO1xuXHRcdH1cblxuXHRcdHZhciB1dmNvZGUgPSBcIlwiO1xuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMudXZjb2RlKSB7XG5cdFx0XHR1dmNvZGUgPSBcInV2ID0gXCIgKyB0aGlzLnByb3BlcnRpZXMudXZjb2RlO1xuXHRcdFx0aWYgKHRoaXMucHJvcGVydGllcy51dmNvZGUuaW5kZXhPZihcIjtcIikgIT0gLTEpIHtcblx0XHRcdFx0Ly90aGVyZSBhcmUgbGluZSBicmVha3MsIG1lYW5zIG11bHRpbGluZSBjb2RlXG5cdFx0XHRcdHV2Y29kZSA9IHRoaXMucHJvcGVydGllcy51dmNvZGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHBpeGVsY29kZSA9IFwiXCI7XG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5waXhlbGNvZGUpIHtcblx0XHRcdHBpeGVsY29kZSA9IFwicmVzdWx0ID0gXCIgKyB0aGlzLnByb3BlcnRpZXMucGl4ZWxjb2RlO1xuXHRcdFx0aWYgKHRoaXMucHJvcGVydGllcy5waXhlbGNvZGUuaW5kZXhPZihcIjtcIikgIT0gLTEpIHtcblx0XHRcdFx0Ly90aGVyZSBhcmUgbGluZSBicmVha3MsIG1lYW5zIG11bHRpbGluZSBjb2RlXG5cdFx0XHRcdHBpeGVsY29kZSA9IHRoaXMucHJvcGVydGllcy5waXhlbGNvZGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHNoYWRlciA9IHRoaXMuX3NoYWRlcjtcblxuXHRcdGlmICggIXRoaXMuaGFzX2Vycm9yICYmICghc2hhZGVyIHx8IHRoaXMuX3NoYWRlcl9jb2RlICE9IHV2Y29kZSArIFwifFwiICsgcGl4ZWxjb2RlKSApIHtcblxuXHRcdFx0dmFyIGZpbmFsX3BpeGVsX2NvZGUgPSBMR3JhcGhUZXh0dXJlLnJlcGxhY2VDb2RlKCBMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnBpeGVsX3NoYWRlciwgeyBVVl9DT0RFOnV2Y29kZSwgUElYRUxfQ09ERTpwaXhlbGNvZGUgfSk7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHNoYWRlciA9IG5ldyBHTC5TaGFkZXIoIFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUiwgZmluYWxfcGl4ZWxfY29kZSApO1xuXHRcdFx0XHR0aGlzLmJveGNvbG9yID0gXCIjMDBGRjAwXCI7XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIkVycm9yIGNvbXBpbGluZyBzaGFkZXI6IFwiLCBlcnIsIGZpbmFsX3BpeGVsX2NvZGUgKTtcblx0XHRcdFx0R0wuU2hhZGVyLmR1bXBFcnJvclRvQ29uc29sZShlcnIsU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLCBmaW5hbF9waXhlbF9jb2RlKTtcblx0XHRcdFx0dGhpcy5ib3hjb2xvciA9IFwiI0ZGMDAwMFwiO1xuXHRcdFx0XHR0aGlzLmhhc19lcnJvciA9IHRydWU7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NoYWRlciA9IHNoYWRlcjtcblx0XHRcdHRoaXMuX3NoYWRlcl9jb2RlID0gdXZjb2RlICsgXCJ8XCIgKyBwaXhlbGNvZGU7XG5cdFx0fVxuXG5cdFx0aWYoIXRoaXMuX3NoYWRlcilcblx0XHRcdHJldHVybjtcblxuXHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xuXHRcdGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMudmFsdWUgPSB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMucHJvcGVydGllcy52YWx1ZSk7XG5cdFx0fVxuXG5cdFx0dmFyIHRpbWUgPSB0aGlzLmdyYXBoLmdldFRpbWUoKTtcblxuXHRcdHRoaXMuX3RleC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdFx0Z2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuXHRcdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0XHRpZiAodGV4KSB7XG5cdFx0XHRcdHRleC5iaW5kKDApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRleEIpIHtcblx0XHRcdFx0dGV4Qi5iaW5kKDEpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcblx0XHRcdHNoYWRlclxuXHRcdFx0XHQudW5pZm9ybXMoe1xuXHRcdFx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdFx0XHR1X3RleHR1cmVCOiAxLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHR0ZXhTaXplOiBbd2lkdGgsIGhlaWdodCwxL3dpZHRoLDEvaGVpZ2h0XSxcblx0XHRcdFx0XHR0aW1lOiB0aW1lXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5kcmF3KG1lc2gpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleCk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVCO1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzQgdGV4U2l6ZTtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdGltZTtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdmFsdWU7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0dmVjMiB1diA9IHZfY29vcmQ7XFxuXFxcblx0XHRcdHt7VVZfQ09ERX19O1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yNCA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2KTtcXG5cXFxuXHRcdFx0dmVjMyBjb2xvciA9IGNvbG9yNC5yZ2I7XFxuXFxcblx0XHRcdHZlYzQgY29sb3I0QiA9IHRleHR1cmUyRCh1X3RleHR1cmVCLCB1dik7XFxuXFxcblx0XHRcdHZlYzMgY29sb3JCID0gY29sb3I0Qi5yZ2I7XFxuXFxcblx0XHRcdHZlYzMgcmVzdWx0ID0gY29sb3I7XFxuXFxcblx0XHRcdGZsb2F0IGFscGhhID0gMS4wO1xcblxcXG5cdFx0XHR7e1BJWEVMX0NPREV9fTtcXG5cXFxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChyZXN1bHQsIGFscGhhKTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQgPSBmdW5jdGlvbiAoIG5hbWUsIGNvZGUgKVxuXHR7XG5cdFx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5wcmVzZXRzW25hbWVdID0gY29kZTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJcIixcIlwiKTtcblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcImJ5cGFzc1wiLFwiY29sb3JcIik7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJhZGRcIixcImNvbG9yICsgY29sb3JCICogdmFsdWVcIik7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJzdWJzdHJhY3RcIixcIihjb2xvciAtIGNvbG9yQikgKiB2YWx1ZVwiKTtcblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcIm1hdGVcIixcIm1peCggY29sb3IsIGNvbG9yQiwgY29sb3I0Qi5hICogdmFsdWUpXCIpO1xuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnJlZ2lzdGVyUHJlc2V0KFwiaW52ZXJ0XCIsXCJ2ZWMzKDEuMCkgLSBjb2xvclwiKTtcblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcIm11bHRpcGx5XCIsXCJjb2xvciAqIGNvbG9yQiAqIHZhbHVlXCIpO1xuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnJlZ2lzdGVyUHJlc2V0KFwiZGl2aWRlXCIsXCIoY29sb3IgLyBjb2xvckIpIC8gdmFsdWVcIik7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJkaWZmZXJlbmNlXCIsXCJhYnMoY29sb3IgLSBjb2xvckIpICogdmFsdWVcIik7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJtYXhcIixcIm1heChjb2xvciwgY29sb3JCKSAqIHZhbHVlXCIpO1xuXHRMR3JhcGhUZXh0dXJlT3BlcmF0aW9uLnJlZ2lzdGVyUHJlc2V0KFwibWluXCIsXCJtaW4oY29sb3IsIGNvbG9yQikgKiB2YWx1ZVwiKTtcblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcImRpc3BsYWNlXCIsXCJ0ZXh0dXJlMkQodV90ZXh0dXJlLCB1diArIChjb2xvckIueHkgLSB2ZWMyKDAuNSkpICogdmFsdWUpLnh5elwiKTtcblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5yZWdpc3RlclByZXNldChcImdyYXlzY2FsZVwiLFwidmVjMyhjb2xvci54ICsgY29sb3IueSArIGNvbG9yLnopICogdmFsdWUgLyAzLjBcIik7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJzYXR1cmF0aW9uXCIsXCJtaXgoIHZlYzMoY29sb3IueCArIGNvbG9yLnkgKyBjb2xvci56KSAvIDMuMCwgY29sb3IsIHZhbHVlIClcIik7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJub3JtYWxtYXBcIixcIlxcblxcXG5cdFx0ZmxvYXQgejAgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB1diArIHZlYzIoLXRleFNpemUueiwgLXRleFNpemUudykgKS54O1xcblxcXG5cdFx0ZmxvYXQgejEgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB1diArIHZlYzIoMC4wLCAtdGV4U2l6ZS53KSApLng7XFxuXFxcblx0XHRmbG9hdCB6MiA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2ICsgdmVjMih0ZXhTaXplLnosIC10ZXhTaXplLncpICkueDtcXG5cXFxuXHRcdGZsb2F0IHozID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdXYgKyB2ZWMyKC10ZXhTaXplLnosIDAuMCkgKS54O1xcblxcXG5cdFx0ZmxvYXQgejQgPSBjb2xvci54O1xcblxcXG5cdFx0ZmxvYXQgejUgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB1diArIHZlYzIodGV4U2l6ZS56LCAwLjApICkueDtcXG5cXFxuXHRcdGZsb2F0IHo2ID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdXYgKyB2ZWMyKC10ZXhTaXplLnosIHRleFNpemUudykgKS54O1xcblxcXG5cdFx0ZmxvYXQgejcgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB1diArIHZlYzIoMC4wLCB0ZXhTaXplLncpICkueDtcXG5cXFxuXHRcdGZsb2F0IHo4ID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdXYgKyB2ZWMyKHRleFNpemUueiwgdGV4U2l6ZS53KSApLng7XFxuXFxcblx0XHR2ZWMzIG5vcm1hbCA9IHZlYzMoIHoyICsgMi4wKno0ICsgejcgLSB6MCAtIDIuMCp6MyAtIHo1LCB6NSArIDIuMCp6NiArIHo3IC16MCAtIDIuMCp6MSAtIHoyLCAxLjAgKTtcXG5cXFxuXHRcdG5vcm1hbC54eSAqPSB2YWx1ZTtcXG5cXFxuXHRcdHJlc3VsdC54eXogPSBub3JtYWxpemUobm9ybWFsKSAqIDAuNSArIHZlYzMoMC41KTtcXG5cXFxuXHRcIik7XG5cdExHcmFwaFRleHR1cmVPcGVyYXRpb24ucmVnaXN0ZXJQcmVzZXQoXCJ0aHJlc2hvbGRcIixcInZlYzMoY29sb3IueCA+IGNvbG9yQi54ICogdmFsdWUgPyAxLjAgOiAwLjAsY29sb3IueSA+IGNvbG9yQi55ICogdmFsdWUgPyAxLjAgOiAwLjAsY29sb3IueiA+IGNvbG9yQi56ICogdmFsdWUgPyAxLjAgOiAwLjApXCIpO1xuXG5cdC8vd2ViZ2xzdHVkaW8gc3R1ZmYuLi5cblx0TEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5wcm90b3R5cGUub25JbnNwZWN0ID0gZnVuY3Rpb24od2lkZ2V0cylcblx0e1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR3aWRnZXRzLmFkZENvbWJvKFwiUHJlc2V0c1wiLFwiXCIseyB2YWx1ZXM6IE9iamVjdC5rZXlzKExHcmFwaFRleHR1cmVPcGVyYXRpb24ucHJlc2V0cyksIGNhbGxiYWNrOiBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBjb2RlID0gTEdyYXBoVGV4dHVyZU9wZXJhdGlvbi5wcmVzZXRzW3ZdO1xuXHRcdFx0aWYoIWNvZGUpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHRoYXQuc2V0UHJvcGVydHkoXCJwaXhlbGNvZGVcIixjb2RlKTtcblx0XHRcdHRoYXQudGl0bGUgPSB2O1xuXHRcdFx0d2lkZ2V0cy5yZWZyZXNoKCk7XG5cdFx0fX0pO1xuXHR9XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL29wZXJhdGlvblwiLCBMR3JhcGhUZXh0dXJlT3BlcmF0aW9uKTtcblxuXHQvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlU2hhZGVyKCkge1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRjb2RlOiBcIlwiLFxuXHRcdFx0dV92YWx1ZTogMSxcblx0XHRcdHVfY29sb3I6IFsxLDEsMSwxXSxcblx0XHRcdHdpZHRoOiA1MTIsXG5cdFx0XHRoZWlnaHQ6IDUxMixcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXG5cdFx0fTtcblxuXHRcdHRoaXMucHJvcGVydGllcy5jb2RlID0gTEdyYXBoVGV4dHVyZVNoYWRlci5waXhlbF9zaGFkZXI7XG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7IHVfdmFsdWU6IDEsIHVfY29sb3I6IHZlYzQuY3JlYXRlKCksIGluX3RleHR1cmU6IDAsIHRleFNpemU6IHZlYzQuY3JlYXRlKCksIHRpbWU6IDAgfTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVTaGFkZXIudGl0bGUgPSBcIlNoYWRlclwiO1xuXHRMR3JhcGhUZXh0dXJlU2hhZGVyLmRlc2MgPSBcIlRleHR1cmUgc2hhZGVyXCI7XG5cdExHcmFwaFRleHR1cmVTaGFkZXIud2lkZ2V0c19pbmZvID0ge1xuXHRcdGNvZGU6IHsgdHlwZTogXCJjb2RlXCIsIGxhbmc6IFwiZ2xzbFwiIH0sXG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVTaGFkZXIucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24oXG5cdFx0bmFtZSxcblx0XHR2YWx1ZVxuXHQpIHtcblx0XHRpZiAobmFtZSAhPSBcImNvZGVcIikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzaGFkZXIgPSB0aGlzLmdldFNoYWRlcigpO1xuXHRcdGlmICghc2hhZGVyKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly91cGRhdGUgY29ubmVjdGlvbnNcblx0XHR2YXIgdW5pZm9ybXMgPSBzaGFkZXIudW5pZm9ybUluZm87XG5cblx0XHQvL3JlbW92ZSBkZXByZWNhdGVkIHNsb3RzXG5cdFx0aWYgKHRoaXMuaW5wdXRzKSB7XG5cdFx0XHR2YXIgYWxyZWFkeSA9IHt9O1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR2YXIgaW5mbyA9IHRoaXMuZ2V0SW5wdXRJbmZvKGkpO1xuXHRcdFx0XHRpZiAoIWluZm8pIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh1bmlmb3Jtc1tpbmZvLm5hbWVdICYmICFhbHJlYWR5W2luZm8ubmFtZV0pIHtcblx0XHRcdFx0XHRhbHJlYWR5W2luZm8ubmFtZV0gPSB0cnVlO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucmVtb3ZlSW5wdXQoaSk7XG5cdFx0XHRcdGktLTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL3VwZGF0ZSBleGlzdGluZyBvbmVzXG5cdFx0Zm9yICh2YXIgaSBpbiB1bmlmb3Jtcykge1xuXHRcdFx0dmFyIGluZm8gPSBzaGFkZXIudW5pZm9ybUluZm9baV07XG5cdFx0XHRpZiAoaW5mby5sb2MgPT09IG51bGwpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IC8vaXMgYW4gYXR0cmlidXRlLCBub3QgYSB1bmlmb3JtXG5cdFx0XHRpZiAoaSA9PSBcInRpbWVcIikge1xuXHRcdFx0XHQvL2RlZmF1bHQgb25lXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHRpZiAodGhpcy5fc2hhZGVyLnNhbXBsZXJzW2ldKSB7XG5cdFx0XHRcdHR5cGUgPSBcInRleHR1cmVcIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN3aXRjaCAoaW5mby5zaXplKSB7XG5cdFx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0XHR0eXBlID0gXCJ2ZWMyXCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0XHR0eXBlID0gXCJ2ZWMzXCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0XHR0eXBlID0gXCJ2ZWM0XCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDk6XG5cdFx0XHRcdFx0XHR0eXBlID0gXCJtYXQzXCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDE2OlxuXHRcdFx0XHRcdFx0dHlwZSA9IFwibWF0NFwiO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzbG90ID0gdGhpcy5maW5kSW5wdXRTbG90KGkpO1xuXHRcdFx0aWYgKHNsb3QgPT0gLTEpIHtcblx0XHRcdFx0dGhpcy5hZGRJbnB1dChpLCB0eXBlKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpbnB1dF9pbmZvID0gdGhpcy5nZXRJbnB1dEluZm8oc2xvdCk7XG5cdFx0XHRpZiAoIWlucHV0X2luZm8pIHtcblx0XHRcdFx0dGhpcy5hZGRJbnB1dChpLCB0eXBlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChpbnB1dF9pbmZvLnR5cGUgPT0gdHlwZSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucmVtb3ZlSW5wdXQoc2xvdCwgdHlwZSk7XG5cdFx0XHRcdHRoaXMuYWRkSW5wdXQoaSwgdHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVTaGFkZXIucHJvdG90eXBlLmdldFNoYWRlciA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vcmVwbHVnXG5cdFx0aWYgKHRoaXMuX3NoYWRlciAmJiB0aGlzLl9zaGFkZXJfY29kZSA9PSB0aGlzLnByb3BlcnRpZXMuY29kZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3NoYWRlcjtcblx0XHR9XG5cblx0XHR0aGlzLl9zaGFkZXJfY29kZSA9IHRoaXMucHJvcGVydGllcy5jb2RlO1xuXHRcdHRoaXMuX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoIFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUiwgdGhpcy5wcm9wZXJ0aWVzLmNvZGUgKTtcblx0XHRpZiAoIXRoaXMuX3NoYWRlcikge1xuXHRcdFx0dGhpcy5ib3hjb2xvciA9IFwicmVkXCI7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5ib3hjb2xvciA9IFwiZ3JlZW5cIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3NoYWRlcjtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlU2hhZGVyLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0dmFyIHNoYWRlciA9IHRoaXMuZ2V0U2hhZGVyKCk7XG5cdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdGV4X3Nsb3QgPSAwO1xuXHRcdHZhciBpbl90ZXggPSBudWxsO1xuXG5cdFx0Ly9zZXQgdW5pZm9ybXNcblx0XHRpZih0aGlzLmlucHV0cylcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgaW5mbyA9IHRoaXMuZ2V0SW5wdXRJbmZvKGkpO1xuXHRcdFx0dmFyIGRhdGEgPSB0aGlzLmdldElucHV0RGF0YShpKTtcblx0XHRcdGlmIChkYXRhID09IG51bGwpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRhLmNvbnN0cnVjdG9yID09PSBHTC5UZXh0dXJlKSB7XG5cdFx0XHRcdGRhdGEuYmluZCh0ZXhfc2xvdCk7XG5cdFx0XHRcdGlmICghaW5fdGV4KSB7XG5cdFx0XHRcdFx0aW5fdGV4ID0gZGF0YTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhID0gdGV4X3Nsb3Q7XG5cdFx0XHRcdHRleF9zbG90Kys7XG5cdFx0XHR9XG5cdFx0XHRzaGFkZXIuc2V0VW5pZm9ybShpbmZvLm5hbWUsIGRhdGEpOyAvL2RhdGEgaXMgdGV4X3Nsb3Rcblx0XHR9XG5cblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3Jtcztcblx0XHR2YXIgdHlwZSA9IExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZVR5cGUoIHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24sIGluX3RleCApO1xuXG5cdFx0Ly9yZW5kZXIgdG8gdGV4dHVyZVxuXHRcdHZhciB3ID0gdGhpcy5wcm9wZXJ0aWVzLndpZHRoIHwgMDtcblx0XHR2YXIgaCA9IHRoaXMucHJvcGVydGllcy5oZWlnaHQgfCAwO1xuXHRcdGlmICh3ID09IDApIHtcblx0XHRcdHcgPSBpbl90ZXggPyBpbl90ZXgud2lkdGggOiBnbC5jYW52YXMud2lkdGg7XG5cdFx0fVxuXHRcdGlmIChoID09IDApIHtcblx0XHRcdGggPSBpbl90ZXggPyBpbl90ZXguaGVpZ2h0IDogZ2wuY2FudmFzLmhlaWdodDtcblx0XHR9XG5cdFx0dW5pZm9ybXMudGV4U2l6ZVswXSA9IHc7XG5cdFx0dW5pZm9ybXMudGV4U2l6ZVsxXSA9IGg7XG5cdFx0dW5pZm9ybXMudGV4U2l6ZVsyXSA9IDEvdztcblx0XHR1bmlmb3Jtcy50ZXhTaXplWzNdID0gMS9oO1xuXHRcdHVuaWZvcm1zLnRpbWUgPSB0aGlzLmdyYXBoLmdldFRpbWUoKTtcblx0XHR1bmlmb3Jtcy51X3ZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzLnVfdmFsdWU7XG5cdFx0dW5pZm9ybXMudV9jb2xvci5zZXQoIHRoaXMucHJvcGVydGllcy51X2NvbG9yICk7XG5cblx0XHRpZiAoICF0aGlzLl90ZXggfHwgdGhpcy5fdGV4LnR5cGUgIT0gdHlwZSB8fCAgdGhpcy5fdGV4LndpZHRoICE9IHcgfHwgdGhpcy5fdGV4LmhlaWdodCAhPSBoICkge1xuXHRcdFx0dGhpcy5fdGV4ID0gbmV3IEdMLlRleHR1cmUodywgaCwgeyAgdHlwZTogdHlwZSwgZm9ybWF0OiBnbC5SR0JBLCBmaWx0ZXI6IGdsLkxJTkVBUiB9KTtcblx0XHR9XG5cdFx0dmFyIHRleCA9IHRoaXMuX3RleDtcblx0XHR0ZXguZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0c2hhZGVyLnVuaWZvcm1zKHVuaWZvcm1zKS5kcmF3KEdMLk1lc2guZ2V0U2NyZWVuUXVhZCgpKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZXgpO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVTaGFkZXIucGl4ZWxfc2hhZGVyID1cblwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cXG5cXFxudmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcbnVuaWZvcm0gZmxvYXQgdGltZTsgLy90aW1lIGluIHNlY29uZHNcXG5cXFxudW5pZm9ybSB2ZWM0IHRleFNpemU7IC8vdGV4IHJlc29sdXRpb25cXG5cXFxudW5pZm9ybSBmbG9hdCB1X3ZhbHVlO1xcblxcXG51bmlmb3JtIHZlYzQgdV9jb2xvcjtcXG5cXG5cXFxudm9pZCBtYWluKCkge1xcblxcXG5cdHZlYzIgdXYgPSB2X2Nvb3JkO1xcblxcXG5cdHZlYzMgY29sb3IgPSB2ZWMzKDAuMCk7XFxuXFxcblx0Ly95b3VyIGNvZGUgaGVyZVxcblxcXG5cdGNvbG9yLnh5PXV2O1xcblxcblxcXG5cdGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuMCk7XFxuXFxcbn1cXG5cXFxuXCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL3NoYWRlclwiLCBMR3JhcGhUZXh0dXJlU2hhZGVyKTtcblxuXHQvLyBUZXh0dXJlIFNjYWxlIE9mZnNldFxuXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVTY2FsZU9mZnNldCgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJzY2FsZVwiLCBcInZlYzJcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIm9mZnNldFwiLCBcInZlYzJcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdG9mZnNldDogdmVjMi5mcm9tVmFsdWVzKDAsIDApLFxuXHRcdFx0c2NhbGU6IHZlYzIuZnJvbVZhbHVlcygxLCAxKSxcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXG5cdFx0fTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVTY2FsZU9mZnNldC53aWRnZXRzX2luZm8gPSB7XG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVTY2FsZU9mZnNldC50aXRsZSA9IFwiU2NhbGUvT2Zmc2V0XCI7XG5cdExHcmFwaFRleHR1cmVTY2FsZU9mZnNldC5kZXNjID0gXCJBcHBsaWVzIGFuIHNjYWxpbmcgYW5kIG9mZnNldGluZ1wiO1xuXG5cdExHcmFwaFRleHR1cmVTY2FsZU9mZnNldC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApIHx8ICF0ZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuUEFTU19USFJPVUdIKSB7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgd2lkdGggPSB0ZXgud2lkdGg7XG5cdFx0dmFyIGhlaWdodCA9IHRleC5oZWlnaHQ7XG5cdFx0dmFyIHR5cGUgPSAgdGhpcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuTE9XID8gZ2wuVU5TSUdORURfQllURSA6IGdsLkhJR0hfUFJFQ0lTSU9OX0ZPUk1BVDtcblx0XHRpZiAodGhpcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuREVGQVVMVCkge1xuXHRcdFx0dHlwZSA9IHRleC50eXBlO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdCF0aGlzLl90ZXggfHxcblx0XHRcdHRoaXMuX3RleC53aWR0aCAhPSB3aWR0aCB8fFxuXHRcdFx0dGhpcy5fdGV4LmhlaWdodCAhPSBoZWlnaHQgfHxcblx0XHRcdHRoaXMuX3RleC50eXBlICE9IHR5cGVcblx0XHQpIHtcblx0XHRcdHRoaXMuX3RleCA9IG5ldyBHTC5UZXh0dXJlKHdpZHRoLCBoZWlnaHQsIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIHNoYWRlciA9IHRoaXMuX3NoYWRlcjtcblxuXHRcdGlmICghc2hhZGVyKSB7XG5cdFx0XHRzaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdExHcmFwaFRleHR1cmVTY2FsZU9mZnNldC5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cdFx0aWYgKHNjYWxlKSB7XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMuc2NhbGVbMF0gPSBzY2FsZVswXTtcblx0XHRcdHRoaXMucHJvcGVydGllcy5zY2FsZVsxXSA9IHNjYWxlWzFdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzY2FsZSA9IHRoaXMucHJvcGVydGllcy5zY2FsZTtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XG5cdFx0aWYgKG9mZnNldCkge1xuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLm9mZnNldFswXSA9IG9mZnNldFswXTtcblx0XHRcdHRoaXMucHJvcGVydGllcy5vZmZzZXRbMV0gPSBvZmZzZXRbMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZnNldCA9IHRoaXMucHJvcGVydGllcy5vZmZzZXQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdGV4LmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSk7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRcdHRleC5iaW5kKDApO1xuXHRcdFx0dmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcblx0XHRcdHNoYWRlclxuXHRcdFx0XHQudW5pZm9ybXMoe1xuXHRcdFx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdFx0XHR1X3NjYWxlOiBzY2FsZSxcblx0XHRcdFx0XHR1X29mZnNldDogb2Zmc2V0XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5kcmF3KG1lc2gpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleCk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVNjYWxlT2Zmc2V0LnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZUI7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjMiB1X3NjYWxlO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWMyIHVfb2Zmc2V0O1xcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdHZlYzIgdXYgPSB2X2Nvb3JkO1xcblxcXG5cdFx0XHR1diA9IHV2IC8gdV9zY2FsZSAtIHVfb2Zmc2V0O1xcblxcXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB1dik7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcblx0XHRcInRleHR1cmUvc2NhbGVPZmZzZXRcIixcblx0XHRMR3JhcGhUZXh0dXJlU2NhbGVPZmZzZXRcblx0KTtcblxuXHQvLyBXYXJwIChkaXN0b3J0IGEgdGV4dHVyZSkgKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVXYXJwKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIndhcnBcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJmYWN0b3JcIiwgXCJudW1iZXJcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdGZhY3RvcjogMC4wMSxcblx0XHRcdHNjYWxlOiBbMSwxXSxcblx0XHRcdG9mZnNldDogWzAsMF0sXG5cdFx0XHRwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVFxuXHRcdH07XG5cblx0XHR0aGlzLl91bmlmb3JtcyA9IHsgXG5cdFx0XHR1X3RleHR1cmU6IDAsIFxuXHRcdFx0dV90ZXh0dXJlQjogMSwgXG5cdFx0XHR1X2ZhY3RvcjogMSwgXG5cdFx0XHR1X3NjYWxlOiB2ZWMyLmNyZWF0ZSgpLFxuXHRcdFx0dV9vZmZzZXQ6IHZlYzIuY3JlYXRlKClcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZVdhcnAud2lkZ2V0c19pbmZvID0ge1xuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlV2FycC50aXRsZSA9IFwiV2FycFwiO1xuXHRMR3JhcGhUZXh0dXJlV2FycC5kZXNjID0gXCJUZXh0dXJlIHdhcnAgb3BlcmF0aW9uXCI7XG5cblx0TEdyYXBoVGV4dHVyZVdhcnAucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblxuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5QQVNTX1RIUk9VR0gpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0ZXhCID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cblx0XHR2YXIgd2lkdGggPSA1MTI7XG5cdFx0dmFyIGhlaWdodCA9IDUxMjtcblx0XHR2YXIgdHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0aWYgKHRleCkge1xuXHRcdFx0d2lkdGggPSB0ZXgud2lkdGg7XG5cdFx0XHRoZWlnaHQgPSB0ZXguaGVpZ2h0O1xuXHRcdFx0dHlwZSA9IHRleC50eXBlO1xuXHRcdH0gZWxzZSBpZiAodGV4Qikge1xuXHRcdFx0d2lkdGggPSB0ZXhCLndpZHRoO1xuXHRcdFx0aGVpZ2h0ID0gdGV4Qi5oZWlnaHQ7XG5cdFx0XHR0eXBlID0gdGV4Qi50eXBlO1xuXHRcdH1cblxuXHRcdGlmICghdGV4ICYmICF0aGlzLl90ZXgpIHtcblx0XHRcdHRoaXMuX3RleCA9IG5ldyBHTC5UZXh0dXJlKHdpZHRoLCBoZWlnaHQsIHtcblx0XHRcdFx0dHlwZTpcblx0XHRcdFx0XHR0aGlzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5MT1dcblx0XHRcdFx0XHRcdD8gZ2wuVU5TSUdORURfQllURVxuXHRcdFx0XHRcdFx0OiBnbC5ISUdIX1BSRUNJU0lPTl9GT1JNQVQsXG5cdFx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdFx0ZmlsdGVyOiBnbC5MSU5FQVJcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl90ZXggPSBMR3JhcGhUZXh0dXJlLmdldFRhcmdldFRleHR1cmUoXG5cdFx0XHRcdHRleCB8fCB0aGlzLl90ZXgsXG5cdFx0XHRcdHRoaXMuX3RleCxcblx0XHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvblxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR2YXIgc2hhZGVyID0gdGhpcy5fc2hhZGVyO1xuXG5cdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdHNoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoVGV4dHVyZVdhcnAucGl4ZWxfc2hhZGVyXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHZhciBmYWN0b3IgPSB0aGlzLmdldElucHV0RGF0YSgyKTtcblx0XHRpZiAoZmFjdG9yICE9IG51bGwpIHtcblx0XHRcdHRoaXMucHJvcGVydGllcy5mYWN0b3IgPSBmYWN0b3I7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZhY3RvciA9IHBhcnNlRmxvYXQodGhpcy5wcm9wZXJ0aWVzLmZhY3Rvcik7XG5cdFx0fVxuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXHRcdHVuaWZvcm1zLnVfZmFjdG9yID0gZmFjdG9yO1xuXHRcdHVuaWZvcm1zLnVfc2NhbGUuc2V0KCB0aGlzLnByb3BlcnRpZXMuc2NhbGUgKTtcblx0XHR1bmlmb3Jtcy51X29mZnNldC5zZXQoIHRoaXMucHJvcGVydGllcy5vZmZzZXQgKTtcblxuXHRcdHRoaXMuX3RleC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdFx0Z2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuXHRcdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0XHRpZiAodGV4KSB7XG5cdFx0XHRcdHRleC5iaW5kKDApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRleEIpIHtcblx0XHRcdFx0dGV4Qi5iaW5kKDEpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcblx0XHRcdHNoYWRlclxuXHRcdFx0XHQudW5pZm9ybXMoIHVuaWZvcm1zIClcblx0XHRcdFx0LmRyYXcobWVzaCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGV4KTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlV2FycC5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVCO1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfZmFjdG9yO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWMyIHVfc2NhbGU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzIgdV9vZmZzZXQ7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0dmVjMiB1diA9IHZfY29vcmQ7XFxuXFxcblx0XHRcdHV2ICs9ICggdGV4dHVyZTJEKHVfdGV4dHVyZUIsIHV2KS5yZyAtIHZlYzIoMC41KSkgKiB1X2ZhY3RvciAqIHVfc2NhbGUgKyB1X29mZnNldDtcXG5cXFxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdXYpO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL3dhcnBcIiwgTEdyYXBoVGV4dHVyZVdhcnApO1xuXG5cdC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5cdC8vIFRleHR1cmUgdG8gVmlld3BvcnQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZVRvVmlld3BvcnQoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdGFkZGl0aXZlOiBmYWxzZSxcblx0XHRcdGFudGlhbGlhc2luZzogZmFsc2UsXG5cdFx0XHRmaWx0ZXI6IHRydWUsXG5cdFx0XHRkaXNhYmxlX2FscGhhOiBmYWxzZSxcblx0XHRcdGdhbW1hOiAxLjAsXG5cdFx0XHR2aWV3cG9ydDogWzAsMCwxLDFdXG5cdFx0fTtcblx0XHR0aGlzLnNpemVbMF0gPSAxMzA7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC50aXRsZSA9IFwidG8gVmlld3BvcnRcIjtcblx0TEdyYXBoVGV4dHVyZVRvVmlld3BvcnQuZGVzYyA9IFwiVGV4dHVyZSB0byB2aWV3cG9ydFwiO1xuXG5cdExHcmFwaFRleHR1cmVUb1ZpZXdwb3J0Ll9wcmV2X3ZpZXdwb3J0ID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcblxuXHRMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKCBjdHggKVxuXHR7XG5cdFx0aWYgKCB0aGlzLmZsYWdzLmNvbGxhcHNlZCB8fCB0aGlzLnNpemVbMV0gPD0gNDAgKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y3R4LmRyYXdJbWFnZSggY3R4ID09IGdsID8gdGV4IDogZ2wuY2FudmFzLCAxMCwzMCwgdGhpcy5zaXplWzBdIC0yMCwgdGhpcy5zaXplWzFdIC00MCk7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5kaXNhYmxlX2FscGhhKSB7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2wuZW5hYmxlKGdsLkJMRU5EKTtcblx0XHRcdGlmICh0aGlzLnByb3BlcnRpZXMuYWRkaXRpdmUpIHtcblx0XHRcdFx0Z2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0dmFyIGdhbW1hID0gdGhpcy5wcm9wZXJ0aWVzLmdhbW1hIHx8IDEuMDtcblx0XHRpZiAodGhpcy5pc0lucHV0Q29ubmVjdGVkKDEpKSB7XG5cdFx0XHRnYW1tYSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuXHRcdH1cblxuXHRcdHRleC5zZXRQYXJhbWV0ZXIoXG5cdFx0XHRnbC5URVhUVVJFX01BR19GSUxURVIsXG5cdFx0XHR0aGlzLnByb3BlcnRpZXMuZmlsdGVyID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVFxuXHRcdCk7XG5cblx0XHR2YXIgb2xkX3ZpZXdwb3J0ID0gTEdyYXBoVGV4dHVyZVRvVmlld3BvcnQuX3ByZXZfdmlld3BvcnQ7XG5cdFx0b2xkX3ZpZXdwb3J0LnNldCggZ2wudmlld3BvcnRfZGF0YSApO1xuXHRcdHZhciBuZXdfdmlldyA9IHRoaXMucHJvcGVydGllcy52aWV3cG9ydDtcblx0XHRnbC52aWV3cG9ydCggb2xkX3ZpZXdwb3J0WzBdICsgb2xkX3ZpZXdwb3J0WzJdICogbmV3X3ZpZXdbMF0sIG9sZF92aWV3cG9ydFsxXSArIG9sZF92aWV3cG9ydFszXSAqIG5ld192aWV3WzFdLCBvbGRfdmlld3BvcnRbMl0gKiBuZXdfdmlld1syXSwgb2xkX3ZpZXdwb3J0WzNdICogbmV3X3ZpZXdbM10gKTtcblx0XHR2YXIgdmlld3BvcnQgPSBnbC5nZXRWaWV3cG9ydCgpOyAvL2dsLmdldFBhcmFtZXRlcihnbC5WSUVXUE9SVCk7XG5cblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLmFudGlhbGlhc2luZykge1xuXHRcdFx0aWYgKCFMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC5fc2hhZGVyKSB7XG5cdFx0XHRcdExHcmFwaFRleHR1cmVUb1ZpZXdwb3J0Ll9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0XHRMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC5hYV9waXhlbF9zaGFkZXJcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcblx0XHRcdHRleC5iaW5kKDApO1xuXHRcdFx0TEdyYXBoVGV4dHVyZVRvVmlld3BvcnQuX3NoYWRlclxuXHRcdFx0XHQudW5pZm9ybXMoe1xuXHRcdFx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdFx0XHR1Vmlld3BvcnRTaXplOiBbdGV4LndpZHRoLCB0ZXguaGVpZ2h0XSxcblx0XHRcdFx0XHR1X2lnYW1tYTogMSAvIGdhbW1hLFxuXHRcdFx0XHRcdGludmVyc2VWUDogWzEgLyB0ZXgud2lkdGgsIDEgLyB0ZXguaGVpZ2h0XVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuZHJhdyhtZXNoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGdhbW1hICE9IDEuMCkge1xuXHRcdFx0XHRpZiAoIUxHcmFwaFRleHR1cmVUb1ZpZXdwb3J0Ll9nYW1tYV9zaGFkZXIpIHtcblx0XHRcdFx0XHRMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydC5fZ2FtbWFfc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0XHRcdFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0XHRcdExHcmFwaFRleHR1cmVUb1ZpZXdwb3J0LmdhbW1hX3BpeGVsX3NoYWRlclxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGV4LnRvVmlld3BvcnQoTEdyYXBoVGV4dHVyZVRvVmlld3BvcnQuX2dhbW1hX3NoYWRlciwge1xuXHRcdFx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdFx0XHR1X2lnYW1tYTogMSAvIGdhbW1hXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGV4LnRvVmlld3BvcnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRnbC52aWV3cG9ydCggb2xkX3ZpZXdwb3J0WzBdLCBvbGRfdmlld3BvcnRbMV0sIG9sZF92aWV3cG9ydFsyXSwgb2xkX3ZpZXdwb3J0WzNdICk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVRvVmlld3BvcnQucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFtbXCJnYW1tYVwiLCBcIm51bWJlclwiXV07XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVRvVmlld3BvcnQuYWFfcGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWMyIHVWaWV3cG9ydFNpemU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzIgaW52ZXJzZVZQO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2lnYW1tYTtcXG5cXFxuXHRcdCNkZWZpbmUgRlhBQV9SRURVQ0VfTUlOICAgKDEuMC8gMTI4LjApXFxuXFxcblx0XHQjZGVmaW5lIEZYQUFfUkVEVUNFX01VTCAgICgxLjAgLyA4LjApXFxuXFxcblx0XHQjZGVmaW5lIEZYQUFfU1BBTl9NQVggICAgIDguMFxcblxcXG5cdFx0XFxuXFxcblx0XHQvKiBmcm9tIG1pdHN1aGlrby93ZWJnbC1tZWluY3JhZnQgYmFzZWQgb24gdGhlIGNvZGUgb24gZ2Vla3MzZC5jb20gKi9cXG5cXFxuXHRcdHZlYzQgYXBwbHlGWEFBKHNhbXBsZXIyRCB0ZXgsIHZlYzIgZnJhZ0Nvb3JkKVxcblxcXG5cdFx0e1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcblxcXG5cdFx0XHQvKnZlYzIgaW52ZXJzZVZQID0gdmVjMigxLjAgLyB1Vmlld3BvcnRTaXplLngsIDEuMCAvIHVWaWV3cG9ydFNpemUueSk7Ki9cXG5cXFxuXHRcdFx0dmVjMyByZ2JOVyA9IHRleHR1cmUyRCh0ZXgsIChmcmFnQ29vcmQgKyB2ZWMyKC0xLjAsIC0xLjApKSAqIGludmVyc2VWUCkueHl6O1xcblxcXG5cdFx0XHR2ZWMzIHJnYk5FID0gdGV4dHVyZTJEKHRleCwgKGZyYWdDb29yZCArIHZlYzIoMS4wLCAtMS4wKSkgKiBpbnZlcnNlVlApLnh5ejtcXG5cXFxuXHRcdFx0dmVjMyByZ2JTVyA9IHRleHR1cmUyRCh0ZXgsIChmcmFnQ29vcmQgKyB2ZWMyKC0xLjAsIDEuMCkpICogaW52ZXJzZVZQKS54eXo7XFxuXFxcblx0XHRcdHZlYzMgcmdiU0UgPSB0ZXh0dXJlMkQodGV4LCAoZnJhZ0Nvb3JkICsgdmVjMigxLjAsIDEuMCkpICogaW52ZXJzZVZQKS54eXo7XFxuXFxcblx0XHRcdHZlYzMgcmdiTSAgPSB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgICogaW52ZXJzZVZQKS54eXo7XFxuXFxcblx0XHRcdHZlYzMgbHVtYSA9IHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCk7XFxuXFxcblx0XHRcdGZsb2F0IGx1bWFOVyA9IGRvdChyZ2JOVywgbHVtYSk7XFxuXFxcblx0XHRcdGZsb2F0IGx1bWFORSA9IGRvdChyZ2JORSwgbHVtYSk7XFxuXFxcblx0XHRcdGZsb2F0IGx1bWFTVyA9IGRvdChyZ2JTVywgbHVtYSk7XFxuXFxcblx0XHRcdGZsb2F0IGx1bWFTRSA9IGRvdChyZ2JTRSwgbHVtYSk7XFxuXFxcblx0XHRcdGZsb2F0IGx1bWFNICA9IGRvdChyZ2JNLCAgbHVtYSk7XFxuXFxcblx0XHRcdGZsb2F0IGx1bWFNaW4gPSBtaW4obHVtYU0sIG1pbihtaW4obHVtYU5XLCBsdW1hTkUpLCBtaW4obHVtYVNXLCBsdW1hU0UpKSk7XFxuXFxcblx0XHRcdGZsb2F0IGx1bWFNYXggPSBtYXgobHVtYU0sIG1heChtYXgobHVtYU5XLCBsdW1hTkUpLCBtYXgobHVtYVNXLCBsdW1hU0UpKSk7XFxuXFxcblx0XHRcdFxcblxcXG5cdFx0XHR2ZWMyIGRpcjtcXG5cXFxuXHRcdFx0ZGlyLnggPSAtKChsdW1hTlcgKyBsdW1hTkUpIC0gKGx1bWFTVyArIGx1bWFTRSkpO1xcblxcXG5cdFx0XHRkaXIueSA9ICAoKGx1bWFOVyArIGx1bWFTVykgLSAobHVtYU5FICsgbHVtYVNFKSk7XFxuXFxcblx0XHRcdFxcblxcXG5cdFx0XHRmbG9hdCBkaXJSZWR1Y2UgPSBtYXgoKGx1bWFOVyArIGx1bWFORSArIGx1bWFTVyArIGx1bWFTRSkgKiAoMC4yNSAqIEZYQUFfUkVEVUNFX01VTCksIEZYQUFfUkVEVUNFX01JTik7XFxuXFxcblx0XHRcdFxcblxcXG5cdFx0XHRmbG9hdCByY3BEaXJNaW4gPSAxLjAgLyAobWluKGFicyhkaXIueCksIGFicyhkaXIueSkpICsgZGlyUmVkdWNlKTtcXG5cXFxuXHRcdFx0ZGlyID0gbWluKHZlYzIoRlhBQV9TUEFOX01BWCwgRlhBQV9TUEFOX01BWCksIG1heCh2ZWMyKC1GWEFBX1NQQU5fTUFYLCAtRlhBQV9TUEFOX01BWCksIGRpciAqIHJjcERpck1pbikpICogaW52ZXJzZVZQO1xcblxcXG5cdFx0XHRcXG5cXFxuXHRcdFx0dmVjMyByZ2JBID0gMC41ICogKHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIGludmVyc2VWUCArIGRpciAqICgxLjAgLyAzLjAgLSAwLjUpKS54eXogKyBcXG5cXFxuXHRcdFx0XHR0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAoMi4wIC8gMy4wIC0gMC41KSkueHl6KTtcXG5cXFxuXHRcdFx0dmVjMyByZ2JCID0gcmdiQSAqIDAuNSArIDAuMjUgKiAodGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogLTAuNSkueHl6ICsgXFxuXFxcblx0XHRcdFx0dGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogMC41KS54eXopO1xcblxcXG5cdFx0XHRcXG5cXFxuXHRcdFx0Ly9yZXR1cm4gdmVjNChyZ2JBLDEuMCk7XFxuXFxcblx0XHRcdGZsb2F0IGx1bWFCID0gZG90KHJnYkIsIGx1bWEpO1xcblxcXG5cdFx0XHRpZiAoKGx1bWFCIDwgbHVtYU1pbikgfHwgKGx1bWFCID4gbHVtYU1heCkpXFxuXFxcblx0XHRcdFx0Y29sb3IgPSB2ZWM0KHJnYkEsIDEuMCk7XFxuXFxcblx0XHRcdGVsc2VcXG5cXFxuXHRcdFx0XHRjb2xvciA9IHZlYzQocmdiQiwgMS4wKTtcXG5cXFxuXHRcdFx0aWYodV9pZ2FtbWEgIT0gMS4wKVxcblxcXG5cdFx0XHRcdGNvbG9yLnh5eiA9IHBvdyggY29sb3IueHl6LCB2ZWMzKHVfaWdhbW1hKSApO1xcblxcXG5cdFx0XHRyZXR1cm4gY29sb3I7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdCAgIGdsX0ZyYWdDb2xvciA9IGFwcGx5RlhBQSggdV90ZXh0dXJlLCB2X2Nvb3JkICogdVZpZXdwb3J0U2l6ZSkgO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TEdyYXBoVGV4dHVyZVRvVmlld3BvcnQuZ2FtbWFfcGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2lnYW1tYTtcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCggdV90ZXh0dXJlLCB2X2Nvb3JkKTtcXG5cXFxuXHRcdFx0Y29sb3IueHl6ID0gcG93KGNvbG9yLnh5eiwgdmVjMyh1X2lnYW1tYSkgKTtcXG5cXFxuXHRcdCAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXG5cdFx0XCJ0ZXh0dXJlL3Rvdmlld3BvcnRcIixcblx0XHRMR3JhcGhUZXh0dXJlVG9WaWV3cG9ydFxuXHQpO1xuXG5cdC8vIFRleHR1cmUgQ29weSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlQ29weSgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdHNpemU6IDAsXG5cdFx0XHRnZW5lcmF0ZV9taXBtYXBzOiBmYWxzZSxcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXG5cdFx0fTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVDb3B5LnRpdGxlID0gXCJDb3B5XCI7XG5cdExHcmFwaFRleHR1cmVDb3B5LmRlc2MgPSBcIkNvcHkgVGV4dHVyZVwiO1xuXHRMR3JhcGhUZXh0dXJlQ29weS53aWRnZXRzX2luZm8gPSB7XG5cdFx0c2l6ZToge1xuXHRcdFx0d2lkZ2V0OiBcImNvbWJvXCIsXG5cdFx0XHR2YWx1ZXM6IFswLCAzMiwgNjQsIDEyOCwgMjU2LCA1MTIsIDEwMjQsIDIwNDhdXG5cdFx0fSxcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUNvcHkucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCAmJiAhdGhpcy5fdGVtcF90ZXh0dXJlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdC8vY29weSB0aGUgdGV4dHVyZVxuXHRcdGlmICh0ZXgpIHtcblx0XHRcdHZhciB3aWR0aCA9IHRleC53aWR0aDtcblx0XHRcdHZhciBoZWlnaHQgPSB0ZXguaGVpZ2h0O1xuXG5cdFx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnNpemUgIT0gMCkge1xuXHRcdFx0XHR3aWR0aCA9IHRoaXMucHJvcGVydGllcy5zaXplO1xuXHRcdFx0XHRoZWlnaHQgPSB0aGlzLnByb3BlcnRpZXMuc2l6ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHRlbXAgPSB0aGlzLl90ZW1wX3RleHR1cmU7XG5cblx0XHRcdHZhciB0eXBlID0gdGV4LnR5cGU7XG5cdFx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5MT1cpIHtcblx0XHRcdFx0dHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuSElHSCkge1xuXHRcdFx0XHR0eXBlID0gZ2wuSElHSF9QUkVDSVNJT05fRk9STUFUO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdCF0ZW1wIHx8XG5cdFx0XHRcdHRlbXAud2lkdGggIT0gd2lkdGggfHxcblx0XHRcdFx0dGVtcC5oZWlnaHQgIT0gaGVpZ2h0IHx8XG5cdFx0XHRcdHRlbXAudHlwZSAhPSB0eXBlXG5cdFx0XHQpIHtcblx0XHRcdFx0dmFyIG1pbkZpbHRlciA9IGdsLkxJTkVBUjtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHRoaXMucHJvcGVydGllcy5nZW5lcmF0ZV9taXBtYXBzICYmXG5cdFx0XHRcdFx0aXNQb3dlck9mVHdvKHdpZHRoKSAmJlxuXHRcdFx0XHRcdGlzUG93ZXJPZlR3byhoZWlnaHQpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdG1pbkZpbHRlciA9IGdsLkxJTkVBUl9NSVBNQVBfTElORUFSO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKHdpZHRoLCBoZWlnaHQsIHtcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdFx0XHRtaW5GaWx0ZXI6IG1pbkZpbHRlcixcblx0XHRcdFx0XHRtYWdGaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHRleC5jb3B5VG8odGhpcy5fdGVtcF90ZXh0dXJlKTtcblxuXHRcdFx0aWYgKHRoaXMucHJvcGVydGllcy5nZW5lcmF0ZV9taXBtYXBzKSB7XG5cdFx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZS5iaW5kKDApO1xuXHRcdFx0XHRnbC5nZW5lcmF0ZU1pcG1hcCh0aGlzLl90ZW1wX3RleHR1cmUudGV4dHVyZV90eXBlKTtcblx0XHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlLnVuYmluZCgwKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGVtcF90ZXh0dXJlKTtcblx0fTtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvY29weVwiLCBMR3JhcGhUZXh0dXJlQ29weSk7XG5cblx0Ly8gVGV4dHVyZSBEb3duc2FtcGxlICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVEb3duc2FtcGxlKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIlwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0aXRlcmF0aW9uczogMSxcblx0XHRcdGdlbmVyYXRlX21pcG1hcHM6IGZhbHNlLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZURvd25zYW1wbGUudGl0bGUgPSBcIkRvd25zYW1wbGVcIjtcblx0TEdyYXBoVGV4dHVyZURvd25zYW1wbGUuZGVzYyA9IFwiRG93bnNhbXBsZSBUZXh0dXJlXCI7XG5cdExHcmFwaFRleHR1cmVEb3duc2FtcGxlLndpZGdldHNfaW5mbyA9IHtcblx0XHRpdGVyYXRpb25zOiB7IHR5cGU6IFwibnVtYmVyXCIsIHN0ZXA6IDEsIHByZWNpc2lvbjogMCwgbWluOiAwIH0sXG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVEb3duc2FtcGxlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCF0ZXggJiYgIXRoaXMuX3RlbXBfdGV4dHVyZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHQvL3dlIGRvIG5vdCBhbGxvdyBhbnkgdGV4dHVyZSBkaWZmZXJlbnQgdGhhbiB0ZXh0dXJlIDJEXG5cdFx0aWYgKCF0ZXggfHwgdGV4LnRleHR1cmVfdHlwZSAhPT0gR0wuVEVYVFVSRV8yRCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMuaXRlcmF0aW9ucyA8IDEpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhUZXh0dXJlRG93bnNhbXBsZS5fc2hhZGVyO1xuXHRcdGlmICghc2hhZGVyKSB7XG5cdFx0XHRMR3JhcGhUZXh0dXJlRG93bnNhbXBsZS5fc2hhZGVyID0gc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0R0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRMR3JhcGhUZXh0dXJlRG93bnNhbXBsZS5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dmFyIHdpZHRoID0gdGV4LndpZHRoIHwgMDtcblx0XHR2YXIgaGVpZ2h0ID0gdGV4LmhlaWdodCB8IDA7XG5cdFx0dmFyIHR5cGUgPSB0ZXgudHlwZTtcblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5MT1cpIHtcblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5ISUdIKSB7XG5cdFx0XHR0eXBlID0gZ2wuSElHSF9QUkVDSVNJT05fRk9STUFUO1xuXHRcdH1cblx0XHR2YXIgaXRlcmF0aW9ucyA9IHRoaXMucHJvcGVydGllcy5pdGVyYXRpb25zIHx8IDE7XG5cblx0XHR2YXIgb3JpZ2luID0gdGV4O1xuXHRcdHZhciB0YXJnZXQgPSBudWxsO1xuXG5cdFx0dmFyIHRlbXAgPSBbXTtcblx0XHR2YXIgb3B0aW9ucyA9IHtcblx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRmb3JtYXQ6IHRleC5mb3JtYXRcblx0XHR9O1xuXG5cdFx0dmFyIG9mZnNldCA9IHZlYzIuY3JlYXRlKCk7XG5cdFx0dmFyIHVuaWZvcm1zID0ge1xuXHRcdFx0dV9vZmZzZXQ6IG9mZnNldFxuXHRcdH07XG5cblx0XHRpZiAodGhpcy5fdGV4dHVyZSkge1xuXHRcdFx0R0wuVGV4dHVyZS5yZWxlYXNlVGVtcG9yYXJ5KHRoaXMuX3RleHR1cmUpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgKytpKSB7XG5cdFx0XHRvZmZzZXRbMF0gPSAxIC8gd2lkdGg7XG5cdFx0XHRvZmZzZXRbMV0gPSAxIC8gaGVpZ2h0O1xuXHRcdFx0d2lkdGggPSB3aWR0aCA+PiAxIHx8IDA7XG5cdFx0XHRoZWlnaHQgPSBoZWlnaHQgPj4gMSB8fCAwO1xuXHRcdFx0dGFyZ2V0ID0gR0wuVGV4dHVyZS5nZXRUZW1wb3Jhcnkod2lkdGgsIGhlaWdodCwgb3B0aW9ucyk7XG5cdFx0XHR0ZW1wLnB1c2godGFyZ2V0KTtcblx0XHRcdG9yaWdpbi5zZXRQYXJhbWV0ZXIoR0wuVEVYVFVSRV9NQUdfRklMVEVSLCBHTC5ORUFSRVNUKTtcblx0XHRcdG9yaWdpbi5jb3B5VG8odGFyZ2V0LCBzaGFkZXIsIHVuaWZvcm1zKTtcblx0XHRcdGlmICh3aWR0aCA9PSAxICYmIGhlaWdodCA9PSAxKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fSAvL25vdGhpbmcgZWxzZSB0byBkb1xuXHRcdFx0b3JpZ2luID0gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdC8va2VlcCB0aGUgbGFzdCB0ZXh0dXJlIHVzZWRcblx0XHR0aGlzLl90ZXh0dXJlID0gdGVtcC5wb3AoKTtcblxuXHRcdC8vZnJlZSB0aGUgcmVzdFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGVtcC5sZW5ndGg7ICsraSkge1xuXHRcdFx0R0wuVGV4dHVyZS5yZWxlYXNlVGVtcG9yYXJ5KHRlbXBbaV0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMuZ2VuZXJhdGVfbWlwbWFwcykge1xuXHRcdFx0dGhpcy5fdGV4dHVyZS5iaW5kKDApO1xuXHRcdFx0Z2wuZ2VuZXJhdGVNaXBtYXAodGhpcy5fdGV4dHVyZS50ZXh0dXJlX3R5cGUpO1xuXHRcdFx0dGhpcy5fdGV4dHVyZS51bmJpbmQoMCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleHR1cmUpO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVEb3duc2FtcGxlLnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzIgdV9vZmZzZXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCApO1xcblxcXG5cdFx0XHRjb2xvciArPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkICsgdmVjMiggdV9vZmZzZXQueCwgMC4wICkgKTtcXG5cXFxuXHRcdFx0Y29sb3IgKz0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCArIHZlYzIoIDAuMCwgdV9vZmZzZXQueSApICk7XFxuXFxcblx0XHRcdGNvbG9yICs9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQgKyB2ZWMyKCB1X29mZnNldC54LCB1X29mZnNldC55ICkgKTtcXG5cXFxuXHRcdCAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yICogMC4yNTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFxuXHRcdFwidGV4dHVyZS9kb3duc2FtcGxlXCIsXG5cdFx0TEdyYXBoVGV4dHVyZURvd25zYW1wbGVcblx0KTtcblxuXG5cblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZVJlc2l6ZSgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdHNpemU6IFs1MTIsNTEyXSxcblx0XHRcdGdlbmVyYXRlX21pcG1hcHM6IGZhbHNlLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZVJlc2l6ZS50aXRsZSA9IFwiUmVzaXplXCI7XG5cdExHcmFwaFRleHR1cmVSZXNpemUuZGVzYyA9IFwiUmVzaXplIFRleHR1cmVcIjtcblx0TEdyYXBoVGV4dHVyZVJlc2l6ZS53aWRnZXRzX2luZm8gPSB7XG5cdFx0aXRlcmF0aW9uczogeyB0eXBlOiBcIm51bWJlclwiLCBzdGVwOiAxLCBwcmVjaXNpb246IDAsIG1pbjogMCB9LFxuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlUmVzaXplLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCF0ZXggJiYgIXRoaXMuX3RlbXBfdGV4dHVyZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHQvL3dlIGRvIG5vdCBhbGxvdyBhbnkgdGV4dHVyZSBkaWZmZXJlbnQgdGhhbiB0ZXh0dXJlIDJEXG5cdFx0aWYgKCF0ZXggfHwgdGV4LnRleHR1cmVfdHlwZSAhPT0gR0wuVEVYVFVSRV8yRCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB3aWR0aCA9IHRoaXMucHJvcGVydGllcy5zaXplWzBdIHwgMDtcblx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5wcm9wZXJ0aWVzLnNpemVbMV0gfCAwO1xuXHRcdGlmKHdpZHRoID09IDApXG5cdFx0XHR3aWR0aCA9IHRleC53aWR0aDtcblx0XHRpZihoZWlnaHQgPT0gMClcblx0XHRcdGhlaWdodCA9IHRleC5oZWlnaHQ7XG5cdFx0dmFyIHR5cGUgPSB0ZXgudHlwZTtcblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5MT1cpIHtcblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5ISUdIKSB7XG5cdFx0XHR0eXBlID0gZ2wuSElHSF9QUkVDSVNJT05fRk9STUFUO1xuXHRcdH1cblxuXHRcdGlmKCAhdGhpcy5fdGV4dHVyZSB8fCB0aGlzLl90ZXh0dXJlLndpZHRoICE9IHdpZHRoIHx8IHRoaXMuX3RleHR1cmUuaGVpZ2h0ICE9IGhlaWdodCB8fCB0aGlzLl90ZXh0dXJlLnR5cGUgIT0gdHlwZSApXG5cdFx0XHR0aGlzLl90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoIHdpZHRoLCBoZWlnaHQsIHsgdHlwZTogdHlwZSB9ICk7XG5cblx0XHR0ZXguY29weVRvKCB0aGlzLl90ZXh0dXJlICk7XG5cblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLmdlbmVyYXRlX21pcG1hcHMpIHtcblx0XHRcdHRoaXMuX3RleHR1cmUuYmluZCgwKTtcblx0XHRcdGdsLmdlbmVyYXRlTWlwbWFwKHRoaXMuX3RleHR1cmUudGV4dHVyZV90eXBlKTtcblx0XHRcdHRoaXMuX3RleHR1cmUudW5iaW5kKDApO1xuXHRcdH1cblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZXh0dXJlKTtcblx0fTtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJ0ZXh0dXJlL3Jlc2l6ZVwiLCBMR3JhcGhUZXh0dXJlUmVzaXplICk7XG5cblx0Ly8gVGV4dHVyZSBBdmVyYWdlICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlQXZlcmFnZSgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ0ZXhcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiYXZnXCIsIFwidmVjNFwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcImx1bVwiLCBcIm51bWJlclwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHR1c2VfcHJldmlvdXNfZnJhbWU6IHRydWUsIC8vdG8gYXZvaWQgc3RhbGxzIFxuXHRcdFx0aGlnaF9xdWFsaXR5OiBmYWxzZSAvL3RvIHVzZSBhcyBtdWNoIHBpeGVscyBhcyBwb3NzaWJsZVxuXHRcdH07XG5cblx0XHR0aGlzLl91bmlmb3JtcyA9IHtcblx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdHVfbWlwbWFwX29mZnNldDogMFxuXHRcdH07XG5cdFx0dGhpcy5fbHVtaW5hbmNlID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVBdmVyYWdlLnRpdGxlID0gXCJBdmVyYWdlXCI7XG5cdExHcmFwaFRleHR1cmVBdmVyYWdlLmRlc2MgPVxuXHRcdFwiQ29tcHV0ZSBhIHBhcnRpYWwgYXZlcmFnZSAoMzIgcmFuZG9tIHNhbXBsZXMpIG9mIGEgdGV4dHVyZSBhbmQgc3RvcmVzIGl0IGFzIGEgMXgxIHBpeGVsIHRleHR1cmUuXFxuIElmIGhpZ2hfcXVhbGl0eSBpcyB0cnVlLCB0aGVuIGl0IGdlbmVyYXRlcyB0aGUgbWlwbWFwcyBmaXJzdCBhbmQgcmVhZHMgZnJvbSB0aGUgbG93ZXIgb25lLlwiO1xuXG5cdExHcmFwaFRleHR1cmVBdmVyYWdlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMucHJvcGVydGllcy51c2VfcHJldmlvdXNfZnJhbWUpIHtcblx0XHRcdHRoaXMudXBkYXRlQXZlcmFnZSgpO1xuXHRcdH1cblxuXHRcdHZhciB2ID0gdGhpcy5fbHVtaW5hbmNlO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZW1wX3RleHR1cmUpO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgxLCB2KTtcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMiwgKHZbMF0gKyB2WzFdICsgdlsyXSkgLyAzKTtcblx0fTtcblxuXHQvL2V4ZWN1dGVkIGJlZm9yZSByZW5kZXJpbmcgdGhlIGZyYW1lXG5cdExHcmFwaFRleHR1cmVBdmVyYWdlLnByb3RvdHlwZS5vblByZVJlbmRlckV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVwZGF0ZUF2ZXJhZ2UoKTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlQXZlcmFnZS5wcm90b3R5cGUudXBkYXRlQXZlcmFnZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApICYmXG5cdFx0XHQhdGhpcy5pc091dHB1dENvbm5lY3RlZCgxKSAmJlxuXHRcdFx0IXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMilcblx0XHQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0aWYgKCFMR3JhcGhUZXh0dXJlQXZlcmFnZS5fc2hhZGVyKSB7XG5cdFx0XHRMR3JhcGhUZXh0dXJlQXZlcmFnZS5fc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0R0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRMR3JhcGhUZXh0dXJlQXZlcmFnZS5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0XHQvL2NyZWF0ZXMgMjU2IHJhbmRvbSBudW1iZXJzIGFuZCBzdG9yZXMgdGhlbSBpbiB0d28gbWF0NFxuXHRcdFx0dmFyIHNhbXBsZXMgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRzYW1wbGVzW2ldID0gTWF0aC5yYW5kb20oKTsgLy9wb29ybHkgZGlzdHJpYnV0ZWQgc2FtcGxlc1xuXHRcdFx0fVxuXHRcdFx0Ly91cGxvYWQgb25seSBvbmNlXG5cdFx0XHRMR3JhcGhUZXh0dXJlQXZlcmFnZS5fc2hhZGVyLnVuaWZvcm1zKHtcblx0XHRcdFx0dV9zYW1wbGVzX2E6IHNhbXBsZXMuc3ViYXJyYXkoMCwgMTYpLFxuXHRcdFx0XHR1X3NhbXBsZXNfYjogc2FtcGxlcy5zdWJhcnJheSgxNiwgMzIpXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgdGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblx0XHR2YXIgdHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0aWYgKHRleC50eXBlICE9IHR5cGUpIHtcblx0XHRcdC8vZm9yY2UgZmxvYXRzLCBoYWxmIGZsb2F0cyBjYW5ub3QgYmUgcmVhZCB3aXRoIGdsLnJlYWRQaXhlbHNcblx0XHRcdHR5cGUgPSBnbC5GTE9BVDtcblx0XHR9XG5cblx0XHRpZiAoIXRlbXAgfHwgdGVtcC50eXBlICE9IHR5cGUpIHtcblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKDEsIDEsIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0XHRmaWx0ZXI6IGdsLk5FQVJFU1Rcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VuaWZvcm1zLnVfbWlwbWFwX29mZnNldCA9IDA7XG5cblx0XHRpZih0aGlzLnByb3BlcnRpZXMuaGlnaF9xdWFsaXR5KVxuXHRcdHtcblx0XHRcdGlmKCAhdGhpcy5fdGVtcF9wb3QyX3RleHR1cmUgfHwgdGhpcy5fdGVtcF9wb3QyX3RleHR1cmUudHlwZSAhPSB0eXBlIClcblx0XHRcdFx0dGhpcy5fdGVtcF9wb3QyX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSg1MTIsIDUxMiwge1xuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0XHRcdG1pbkZpbHRlcjogZ2wuTElORUFSX01JUE1BUF9MSU5FQVIsXG5cdFx0XHRcdFx0bWFnRmlsdGVyOiBnbC5MSU5FQVJcblx0XHRcdFx0fSk7XG5cblx0XHRcdHRleC5jb3B5VG8oIHRoaXMuX3RlbXBfcG90Ml90ZXh0dXJlICk7XG5cdFx0XHR0ZXggPSB0aGlzLl90ZW1wX3BvdDJfdGV4dHVyZTtcblx0XHRcdHRleC5iaW5kKDApO1xuXHRcdFx0Z2wuZ2VuZXJhdGVNaXBtYXAoR0wuVEVYVFVSRV8yRCk7XG5cdFx0XHR0aGlzLl91bmlmb3Jtcy51X21pcG1hcF9vZmZzZXQgPSA5O1xuXHRcdH1cblxuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhUZXh0dXJlQXZlcmFnZS5fc2hhZGVyO1xuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXHRcdHVuaWZvcm1zLnVfbWlwbWFwX29mZnNldCA9IHRoaXMucHJvcGVydGllcy5taXBtYXBfb2Zmc2V0O1xuXHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0dGhpcy5fdGVtcF90ZXh0dXJlLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdHRleC50b1ZpZXdwb3J0KHNoYWRlciwgdW5pZm9ybXMpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMSkgfHwgdGhpcy5pc091dHB1dENvbm5lY3RlZCgyKSkge1xuXHRcdFx0dmFyIHBpeGVsID0gdGhpcy5fdGVtcF90ZXh0dXJlLmdldFBpeGVscygpO1xuXHRcdFx0aWYgKHBpeGVsKSB7XG5cdFx0XHRcdHZhciB2ID0gdGhpcy5fbHVtaW5hbmNlO1xuXHRcdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3RlbXBfdGV4dHVyZS50eXBlO1xuXHRcdFx0XHR2LnNldChwaXhlbCk7XG5cdFx0XHRcdGlmICh0eXBlID09IGdsLlVOU0lHTkVEX0JZVEUpIHtcblx0XHRcdFx0XHR2ZWM0LnNjYWxlKHYsIHYsIDEgLyAyNTUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRcdHR5cGUgPT0gR0wuSEFMRl9GTE9BVCB8fFxuXHRcdFx0XHRcdHR5cGUgPT0gR0wuSEFMRl9GTE9BVF9PRVNcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Ly9ubyBoYWxmIGZsb2F0cyBwb3NzaWJsZSwgaGFyZCB0byByZWFkIGJhY2sgdW5sZXNzIGNvcHllZCB0byBhIEZMT0FUIHRleHR1cmUsIHNvIHRlbXBfdGV4dHVyZSBpcyBhbHdheXMgZm9yY2VkIHRvIEZMT0FUXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUF2ZXJhZ2UucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHVuaWZvcm0gbWF0NCB1X3NhbXBsZXNfYTtcXG5cXFxuXHRcdHVuaWZvcm0gbWF0NCB1X3NhbXBsZXNfYjtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9taXBtYXBfb2Zmc2V0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0dmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG5cXFxuXHRcdFx0Ly9yYW5kb20gYXZlcmFnZVxcblxcXG5cdFx0XHRmb3IoaW50IGkgPSAwOyBpIDwgNDsgKytpKVxcblxcXG5cdFx0XHRcdGZvcihpbnQgaiA9IDA7IGogPCA0OyArK2opXFxuXFxcblx0XHRcdFx0e1xcblxcXG5cdFx0XHRcdFx0Y29sb3IgKz0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdmVjMiggdV9zYW1wbGVzX2FbaV1bal0sIHVfc2FtcGxlc19iW2ldW2pdICksIHVfbWlwbWFwX29mZnNldCApO1xcblxcXG5cdFx0XHRcdFx0Y29sb3IgKz0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdmVjMiggMS4wIC0gdV9zYW1wbGVzX2FbaV1bal0sIDEuMCAtIHVfc2FtcGxlc19iW2ldW2pdICksIHVfbWlwbWFwX29mZnNldCApO1xcblxcXG5cdFx0XHRcdH1cXG5cXFxuXHRcdCAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yICogMC4wMzEyNTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9hdmVyYWdlXCIsIExHcmFwaFRleHR1cmVBdmVyYWdlKTtcblxuXG5cblx0Ly8gQ29tcHV0ZXMgb3BlcmF0aW9uIGJldHdlZW4gcGl4ZWxzIChtYXgsIG1pbikgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVNaW5NYXgoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwibWluX3RcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwibWF4X3RcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwibWluXCIsIFwidmVjNFwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIm1heFwiLCBcInZlYzRcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0bW9kZTogXCJtYXhcIixcblx0XHRcdHVzZV9wcmV2aW91c19mcmFtZTogdHJ1ZSAvL3RvIGF2b2lkIHN0YWxscyBcblx0XHR9O1xuXG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7XG5cdFx0XHR1X3RleHR1cmU6IDBcblx0XHR9O1xuXG5cdFx0dGhpcy5fbWF4ID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcblx0XHR0aGlzLl9taW4gPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuXG5cdFx0dGhpcy5fdGV4dHVyZXNfY2hhaW4gPSBbXTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVNaW5NYXgud2lkZ2V0c19pbmZvID0ge1xuXHRcdG1vZGU6IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogW1wibWluXCIsXCJtYXhcIixcImF2Z1wiXSB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZU1pbk1heC50aXRsZSA9IFwiTWluTWF4XCI7XG5cdExHcmFwaFRleHR1cmVNaW5NYXguZGVzYyA9IFwiQ29tcHV0ZSB0aGUgc2NlbmUgbWluIG1heFwiO1xuXG5cdExHcmFwaFRleHR1cmVNaW5NYXgucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5wcm9wZXJ0aWVzLnVzZV9wcmV2aW91c19mcmFtZSkge1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGVtcF90ZXh0dXJlKTtcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMSwgdGhpcy5fbHVtaW5hbmNlKTtcblx0fTtcblxuXHQvL2V4ZWN1dGVkIGJlZm9yZSByZW5kZXJpbmcgdGhlIGZyYW1lXG5cdExHcmFwaFRleHR1cmVNaW5NYXgucHJvdG90eXBlLm9uUHJlUmVuZGVyRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZU1pbk1heC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSAmJiAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgxKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0aWYgKCFMR3JhcGhUZXh0dXJlTWluTWF4Ll9zaGFkZXIpIHtcblx0XHRcdExHcmFwaFRleHR1cmVNaW5NYXguX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoIEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUiwgTEdyYXBoVGV4dHVyZU1pbk1heC5waXhlbF9zaGFkZXIgKTtcblx0XHR9XG5cblx0XHR2YXIgdGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblx0XHR2YXIgdHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0aWYgKHRleC50eXBlICE9IHR5cGUpIHtcblx0XHRcdC8vZm9yY2UgZmxvYXRzLCBoYWxmIGZsb2F0cyBjYW5ub3QgYmUgcmVhZCB3aXRoIGdsLnJlYWRQaXhlbHNcblx0XHRcdHR5cGUgPSBnbC5GTE9BVDtcblx0XHR9XG5cblx0XHR2YXIgc2l6ZSA9IDUxMjtcblxuXHRcdGlmKCAhdGhpcy5fdGV4dHVyZXNfY2hhaW4ubGVuZ3RoIHx8IHRoaXMuX3RleHR1cmVzX2NoYWluWzBdLnR5cGUgIT0gdHlwZSApXG5cdFx0e1xuXHRcdFx0dmFyIGluZGV4ID0gMDtcblx0XHRcdHdoaWxlKGkpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX3RleHR1cmVzX2NoYWluW2ldID0gbmV3IEdMLlRleHR1cmUoIHNpemUsIHNpemUsIHtcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdFx0XHRmaWx0ZXI6IGdsLk5FQVJFU1Rcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNpemUgPSBzaXplID4+IDI7XG5cdFx0XHRcdGkrKztcblx0XHRcdFx0aWYoc2l6ZSA9PSAxKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRleC5jb3B5VG8oIHRoaXMuX3RleHR1cmVzX2NoYWluWzBdICk7XG5cdFx0dmFyIHByZXYgPSB0aGlzLl90ZXh0dXJlc19jaGFpblswXTtcblx0XHRmb3IodmFyIGkgPSAxOyBpIDw9IHRoaXMuX3RleHR1cmVzX2NoYWluLmxlbmd0aDsgKytpKVxuXHRcdHtcblx0XHRcdHZhciB0ZXggPSB0aGlzLl90ZXh0dXJlc19jaGFpbltpXTtcblxuXHRcdFx0cHJldiA9IHRleDtcdFx0XHRcdFxuXHRcdH1cblxuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhUZXh0dXJlTWluTWF4Ll9zaGFkZXI7XG5cdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XG5cdFx0dW5pZm9ybXMudV9taXBtYXBfb2Zmc2V0ID0gdGhpcy5wcm9wZXJ0aWVzLm1pcG1hcF9vZmZzZXQ7XG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHR0aGlzLl90ZW1wX3RleHR1cmUuZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGV4LnRvVmlld3BvcnQoc2hhZGVyLCB1bmlmb3Jtcyk7XG5cdFx0fSk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZU1pbk1heC5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dW5pZm9ybSBtYXQ0IHVfc2FtcGxlc19hO1xcblxcXG5cdFx0dW5pZm9ybSBtYXQ0IHVfc2FtcGxlc19iO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X21pcG1hcF9vZmZzZXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcblxcXG5cdFx0XHQvL3JhbmRvbSBhdmVyYWdlXFxuXFxcblx0XHRcdGZvcihpbnQgaSA9IDA7IGkgPCA0OyArK2kpXFxuXFxcblx0XHRcdFx0Zm9yKGludCBqID0gMDsgaiA8IDQ7ICsrailcXG5cXFxuXHRcdFx0XHR7XFxuXFxcblx0XHRcdFx0XHRjb2xvciArPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2ZWMyKCB1X3NhbXBsZXNfYVtpXVtqXSwgdV9zYW1wbGVzX2JbaV1bal0gKSwgdV9taXBtYXBfb2Zmc2V0ICk7XFxuXFxcblx0XHRcdFx0XHRjb2xvciArPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2ZWMyKCAxLjAgLSB1X3NhbXBsZXNfYVtpXVtqXSwgMS4wIC0gdV9zYW1wbGVzX2JbaV1bal0gKSwgdV9taXBtYXBfb2Zmc2V0ICk7XFxuXFxcblx0XHRcdFx0fVxcblxcXG5cdFx0ICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgKiAwLjAzMTI1O1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0Ly9MaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvY2x1c3RlcmVkX29wZXJhdGlvblwiLCBMR3JhcGhUZXh0dXJlQ2x1c3RlcmVkT3BlcmF0aW9uKTtcblxuXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVUZW1wb3JhbFNtb290aCgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJmYWN0b3JcIiwgXCJOdW1iZXJcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgZmFjdG9yOiAwLjUgfTtcblx0XHR0aGlzLl91bmlmb3JtcyA9IHtcblx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdHVfdGV4dHVyZUI6IDEsXG5cdFx0XHR1X2ZhY3RvcjogdGhpcy5wcm9wZXJ0aWVzLmZhY3RvclxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlVGVtcG9yYWxTbW9vdGgudGl0bGUgPSBcIlNtb290aFwiO1xuXHRMR3JhcGhUZXh0dXJlVGVtcG9yYWxTbW9vdGguZGVzYyA9IFwiU21vb3RoIHRleHR1cmUgb3ZlciB0aW1lXCI7XG5cblx0TEdyYXBoVGV4dHVyZVRlbXBvcmFsU21vb3RoLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCF0ZXggfHwgIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIUxHcmFwaFRleHR1cmVUZW1wb3JhbFNtb290aC5fc2hhZGVyKSB7XG5cdFx0XHRMR3JhcGhUZXh0dXJlVGVtcG9yYWxTbW9vdGguX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoVGV4dHVyZVRlbXBvcmFsU21vb3RoLnBpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR2YXIgdGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblx0XHRpZiAoXG5cdFx0XHQhdGVtcCB8fFxuXHRcdFx0dGVtcC50eXBlICE9IHRleC50eXBlIHx8XG5cdFx0XHR0ZW1wLndpZHRoICE9IHRleC53aWR0aCB8fFxuXHRcdFx0dGVtcC5oZWlnaHQgIT0gdGV4LmhlaWdodFxuXHRcdCkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB7XG5cdFx0XHRcdHR5cGU6IHRleC50eXBlLFxuXHRcdFx0XHRmb3JtYXQ6IGdsLlJHQkEsXG5cdFx0XHRcdGZpbHRlcjogZ2wuTkVBUkVTVFxuXHRcdFx0fTtcblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKHRleC53aWR0aCwgdGV4LmhlaWdodCwgb3B0aW9ucyApO1xuXHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlMiA9IG5ldyBHTC5UZXh0dXJlKHRleC53aWR0aCwgdGV4LmhlaWdodCwgb3B0aW9ucyApO1xuXHRcdFx0dGV4LmNvcHlUbyh0aGlzLl90ZW1wX3RleHR1cmUyKTtcblx0XHR9XG5cblx0XHR2YXIgdGVtcEEgPSB0aGlzLl90ZW1wX3RleHR1cmU7XG5cdFx0dmFyIHRlbXBCID0gdGhpcy5fdGVtcF90ZXh0dXJlMjtcblxuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhUZXh0dXJlVGVtcG9yYWxTbW9vdGguX3NoYWRlcjtcblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3Jtcztcblx0XHR1bmlmb3Jtcy51X2ZhY3RvciA9IDEuMCAtIHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwiZmFjdG9yXCIpO1xuXG5cdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblx0XHR0ZW1wQS5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHR0ZW1wQi5iaW5kKDEpO1xuXHRcdFx0dGV4LnRvVmlld3BvcnQoc2hhZGVyLCB1bmlmb3Jtcyk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGVtcEEpO1xuXG5cdFx0Ly9zd2FwXG5cdFx0dGhpcy5fdGVtcF90ZXh0dXJlID0gdGVtcEI7XG5cdFx0dGhpcy5fdGVtcF90ZXh0dXJlMiA9IHRlbXBBO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVUZW1wb3JhbFNtb290aC5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlQjtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9mYWN0b3I7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSBtaXgoIHRleHR1cmUyRCggdV90ZXh0dXJlLCB2X2Nvb3JkICksIHRleHR1cmUyRCggdV90ZXh0dXJlQiwgdl9jb29yZCApLCB1X2ZhY3RvciApO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwidGV4dHVyZS90ZW1wb3JhbF9zbW9vdGhcIiwgTEdyYXBoVGV4dHVyZVRlbXBvcmFsU21vb3RoICk7XG5cblxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlTGluZWFyQXZnU21vb3RoKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJhdmdcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiYXJyYXlcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgc2FtcGxlczogNjQsIGZyYW1lc19pbnRlcnZhbDogMSB9O1xuXHRcdHRoaXMuX3VuaWZvcm1zID0ge1xuXHRcdFx0dV90ZXh0dXJlOiAwLFxuXHRcdFx0dV90ZXh0dXJlQjogMSxcblx0XHRcdHVfc2FtcGxlczogdGhpcy5wcm9wZXJ0aWVzLnNhbXBsZXMsXG5cdFx0XHR1X2lzYW1wbGVzOiAxL3RoaXMucHJvcGVydGllcy5zYW1wbGVzXG5cdFx0fTtcblx0XHR0aGlzLmZyYW1lID0gMDtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVMaW5lYXJBdmdTbW9vdGgudGl0bGUgPSBcIkxpbmVhbCBBdmcgU21vb3RoXCI7XG5cdExHcmFwaFRleHR1cmVMaW5lYXJBdmdTbW9vdGguZGVzYyA9IFwiU21vb3RoIHRleHR1cmUgbGluZWFybHkgb3ZlciB0aW1lXCI7XG5cblx0TEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aFtcIkBzYW1wbGVzXCJdID0geyB0eXBlOiBcIm51bWJlclwiLCBtaW46IDEsIG1heDogNjQsIHN0ZXA6IDEsIHByZWNpc2lvbjogMSB9O1xuXG5cdExHcmFwaFRleHR1cmVMaW5lYXJBdmdTbW9vdGgucHJvdG90eXBlLmdldFByZXZpZXdUZXh0dXJlID0gZnVuY3Rpb24oKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX3RlbXBfdGV4dHVyZTI7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlTGluZWFyQXZnU21vb3RoLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCB8fCAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghTEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aC5fc2hhZGVyKSB7XG5cdFx0XHRMR3JhcGhUZXh0dXJlTGluZWFyQXZnU21vb3RoLl9zaGFkZXJfY29weSA9IG5ldyBHTC5TaGFkZXIoIEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUiwgTEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aC5waXhlbF9zaGFkZXJfY29weSApO1xuXHRcdFx0TEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aC5fc2hhZGVyX2F2ZyA9IG5ldyBHTC5TaGFkZXIoIEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUiwgTEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aC5waXhlbF9zaGFkZXJfYXZnICk7XG5cdFx0fVxuXG5cdFx0dmFyIHNhbXBsZXMgPSBjbGFtcCh0aGlzLnByb3BlcnRpZXMuc2FtcGxlcywwLDY0KTtcblx0XHR2YXIgZnJhbWUgPSB0aGlzLmZyYW1lO1xuXHRcdHZhciBpbnRlcnZhbCA9IHRoaXMucHJvcGVydGllcy5mcmFtZXNfaW50ZXJ2YWw7XG5cblx0XHRpZiggaW50ZXJ2YWwgPT0gMCB8fCBmcmFtZSAlIGludGVydmFsID09IDAgKVxuXHRcdHtcblx0XHRcdHZhciB0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXHRcdFx0aWYgKCAhdGVtcCB8fCB0ZW1wLnR5cGUgIT0gdGV4LnR5cGUgfHwgdGVtcC53aWR0aCAhPSBzYW1wbGVzICkge1xuXHRcdFx0XHR2YXIgb3B0aW9ucyA9IHtcblx0XHRcdFx0XHR0eXBlOiB0ZXgudHlwZSxcblx0XHRcdFx0XHRmb3JtYXQ6IGdsLlJHQkEsXG5cdFx0XHRcdFx0ZmlsdGVyOiBnbC5ORUFSRVNUXG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKCBzYW1wbGVzLCAxLCBvcHRpb25zICk7XG5cdFx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZTIgPSBuZXcgR0wuVGV4dHVyZSggc2FtcGxlcywgMSwgb3B0aW9ucyApO1xuXHRcdFx0XHR0aGlzLl90ZW1wX3RleHR1cmVfb3V0ID0gbmV3IEdMLlRleHR1cmUoIDEsIDEsIG9wdGlvbnMgKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHRlbXBBID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXHRcdFx0dmFyIHRlbXBCID0gdGhpcy5fdGVtcF90ZXh0dXJlMjtcblxuXHRcdFx0dmFyIHNoYWRlcl9jb3B5ID0gTEdyYXBoVGV4dHVyZUxpbmVhckF2Z1Ntb290aC5fc2hhZGVyX2NvcHk7XG5cdFx0XHR2YXIgc2hhZGVyX2F2ZyA9IExHcmFwaFRleHR1cmVMaW5lYXJBdmdTbW9vdGguX3NoYWRlcl9hdmc7XG5cdFx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3Jtcztcblx0XHRcdHVuaWZvcm1zLnVfc2FtcGxlcyA9IHNhbXBsZXM7XG5cdFx0XHR1bmlmb3Jtcy51X2lzYW1wbGVzID0gMS4wIC8gc2FtcGxlcztcblxuXHRcdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdFx0dGVtcEEuZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0ZW1wQi5iaW5kKDEpO1xuXHRcdFx0XHR0ZXgudG9WaWV3cG9ydCggc2hhZGVyX2NvcHksIHVuaWZvcm1zICk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlX291dC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRlbXBBLnRvVmlld3BvcnQoIHNoYWRlcl9hdmcsIHVuaWZvcm1zICk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCB0aGlzLl90ZW1wX3RleHR1cmVfb3V0ICk7XG5cblx0XHRcdC8vc3dhcFxuXHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlID0gdGVtcEI7XG5cdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUyID0gdGVtcEE7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZW1wX3RleHR1cmVfb3V0KTtcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMSwgdGhpcy5fdGVtcF90ZXh0dXJlMik7XG5cdFx0dGhpcy5mcmFtZSsrO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVMaW5lYXJBdmdTbW9vdGgucGl4ZWxfc2hhZGVyX2NvcHkgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlQjtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9pc2FtcGxlcztcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdGlmKCB2X2Nvb3JkLnggPD0gdV9pc2FtcGxlcyApXFxuXFxcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB1X3RleHR1cmUsIHZlYzIoMC41KSApO1xcblxcXG5cdFx0XHRlbHNlXFxuXFxcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB1X3RleHR1cmVCLCB2X2Nvb3JkIC0gdmVjMih1X2lzYW1wbGVzLDAuMCkgKTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cdExHcmFwaFRleHR1cmVMaW5lYXJBdmdTbW9vdGgucGl4ZWxfc2hhZGVyX2F2ZyA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIGludCB1X3NhbXBsZXM7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfaXNhbXBsZXM7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcblxcXG5cdFx0XHRmb3IoaW50IGkgPSAwOyBpIDwgNjQ7ICsraSlcXG5cXFxuXHRcdFx0e1xcblxcXG5cdFx0XHRcdGNvbG9yICs9IHRleHR1cmUyRCggdV90ZXh0dXJlLCB2ZWMyKCBmbG9hdChpKSp1X2lzYW1wbGVzLDAuMCkgKTtcXG5cXFxuXHRcdFx0XHRpZihpID09ICh1X3NhbXBsZXMgLSAxKSlcXG5cXFxuXHRcdFx0XHRcdGJyZWFrO1xcblxcXG5cdFx0XHR9XFxuXFxcblx0XHRcdGdsX0ZyYWdDb2xvciA9IGNvbG9yICogdV9pc2FtcGxlcztcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwidGV4dHVyZS9saW5lYXJfYXZnX3Ntb290aFwiLCBMR3JhcGhUZXh0dXJlTGluZWFyQXZnU21vb3RoICk7XG5cblx0Ly8gSW1hZ2UgVG8gVGV4dHVyZSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhJbWFnZVRvVGV4dHVyZSgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiSW1hZ2VcIiwgXCJpbWFnZVwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIlwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge307XG5cdH1cblxuXHRMR3JhcGhJbWFnZVRvVGV4dHVyZS50aXRsZSA9IFwiSW1hZ2UgdG8gVGV4dHVyZVwiO1xuXHRMR3JhcGhJbWFnZVRvVGV4dHVyZS5kZXNjID0gXCJVcGxvYWRzIGFuIGltYWdlIHRvIHRoZSBHUFVcIjtcblx0Ly9MR3JhcGhJbWFnZVRvVGV4dHVyZS53aWRnZXRzX2luZm8gPSB7IHNpemU6IHsgd2lkZ2V0OlwiY29tYm9cIiwgdmFsdWVzOlswLDMyLDY0LDEyOCwyNTYsNTEyLDEwMjQsMjA0OF19IH07XG5cblx0TEdyYXBoSW1hZ2VUb1RleHR1cmUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpbWcgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIWltZykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB3aWR0aCA9IGltZy52aWRlb1dpZHRoIHx8IGltZy53aWR0aDtcblx0XHR2YXIgaGVpZ2h0ID0gaW1nLnZpZGVvSGVpZ2h0IHx8IGltZy5oZWlnaHQ7XG5cblx0XHQvL3RoaXMgaXMgaW4gY2FzZSB3ZSBhcmUgdXNpbmcgYSB3ZWJnbCBjYW52YXMgYWxyZWFkeSwgbm8gbmVlZCB0byByZXVwbG9hZCBpdFxuXHRcdGlmIChpbWcuZ2x0ZXh0dXJlKSB7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgaW1nLmdsdGV4dHVyZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRlbXAgPSB0aGlzLl90ZW1wX3RleHR1cmU7XG5cdFx0aWYgKCF0ZW1wIHx8IHRlbXAud2lkdGggIT0gd2lkdGggfHwgdGVtcC5oZWlnaHQgIT0gaGVpZ2h0KSB7XG5cdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSh3aWR0aCwgaGVpZ2h0LCB7XG5cdFx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdFx0ZmlsdGVyOiBnbC5MSU5FQVJcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUudXBsb2FkSW1hZ2UoaW1nKTtcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cdFx0XHRcdFwiaW1hZ2UgY29tZXMgZnJvbSBhbiB1bnNhZmUgbG9jYXRpb24sIGNhbm5vdCBiZSB1cGxvYWRlZCB0byB3ZWJnbDogXCIgK1xuXHRcdFx0XHRcdGVyclxuXHRcdFx0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGVtcF90ZXh0dXJlKTtcblx0fTtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcblx0XHRcInRleHR1cmUvaW1hZ2VUb1RleHR1cmVcIixcblx0XHRMR3JhcGhJbWFnZVRvVGV4dHVyZVxuXHQpO1xuXG5cdC8vIFRleHR1cmUgTFVUICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVMVVQoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJMVVRcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJJbnRlbnNpdHlcIiwgXCJudW1iZXJcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgZW5hYmxlZDogdHJ1ZSwgaW50ZW5zaXR5OiAxLCBwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVCwgdGV4dHVyZTogbnVsbCB9O1xuXG5cdFx0aWYgKCFMR3JhcGhUZXh0dXJlTFVULl9zaGFkZXIpIHtcblx0XHRcdExHcmFwaFRleHR1cmVMVVQuX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoIFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUiwgTEdyYXBoVGV4dHVyZUxVVC5waXhlbF9zaGFkZXIgKTtcblx0XHR9XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlTFVULndpZGdldHNfaW5mbyA9IHtcblx0XHR0ZXh0dXJlOiB7IHdpZGdldDogXCJ0ZXh0dXJlXCIgfSxcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUxVVC50aXRsZSA9IFwiTFVUXCI7XG5cdExHcmFwaFRleHR1cmVMVVQuZGVzYyA9IFwiQXBwbHkgTFVUIHRvIFRleHR1cmVcIjtcblxuXHRMR3JhcGhUZXh0dXJlTFVULnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuUEFTU19USFJPVUdIIHx8IHRoaXMucHJvcGVydGllcy5lbmFibGVkID09PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0ZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbHV0X3RleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuXG5cdFx0aWYgKCFsdXRfdGV4KSB7XG5cdFx0XHRsdXRfdGV4ID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlKHRoaXMucHJvcGVydGllcy50ZXh0dXJlKTtcblx0XHR9XG5cblx0XHRpZiAoIWx1dF90ZXgpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGx1dF90ZXguYmluZCgwKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKFxuXHRcdFx0Z2wuVEVYVFVSRV8yRCxcblx0XHRcdGdsLlRFWFRVUkVfV1JBUF9TLFxuXHRcdFx0Z2wuQ0xBTVBfVE9fRURHRVxuXHRcdCk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShcblx0XHRcdGdsLlRFWFRVUkVfMkQsXG5cdFx0XHRnbC5URVhUVVJFX1dSQVBfVCxcblx0XHRcdGdsLkNMQU1QX1RPX0VER0Vcblx0XHQpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXG5cdFx0dmFyIGludGVuc2l0eSA9IHRoaXMucHJvcGVydGllcy5pbnRlbnNpdHk7XG5cdFx0aWYgKHRoaXMuaXNJbnB1dENvbm5lY3RlZCgyKSkge1xuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLmludGVuc2l0eSA9IGludGVuc2l0eSA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RleCA9IExHcmFwaFRleHR1cmUuZ2V0VGFyZ2V0VGV4dHVyZShcblx0XHRcdHRleCxcblx0XHRcdHRoaXMuX3RleCxcblx0XHRcdHRoaXMucHJvcGVydGllcy5wcmVjaXNpb25cblx0XHQpO1xuXG5cdFx0Ly92YXIgbWVzaCA9IE1lc2guZ2V0U2NyZWVuUXVhZCgpO1xuXG5cdFx0dGhpcy5fdGV4LmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdGx1dF90ZXguYmluZCgxKTtcblx0XHRcdHRleC50b1ZpZXdwb3J0KExHcmFwaFRleHR1cmVMVVQuX3NoYWRlciwge1xuXHRcdFx0XHR1X3RleHR1cmU6IDAsXG5cdFx0XHRcdHVfdGV4dHVyZUI6IDEsXG5cdFx0XHRcdHVfYW1vdW50OiBpbnRlbnNpdHlcblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleCk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUxVVC5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVCO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2Ftb3VudDtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHQgbG93cCB2ZWM0IHRleHR1cmVDb2xvciA9IGNsYW1wKCB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkKSwgdmVjNCgwLjApLCB2ZWM0KDEuMCkgKTtcXG5cXFxuXHRcdFx0IG1lZGl1bXAgZmxvYXQgYmx1ZUNvbG9yID0gdGV4dHVyZUNvbG9yLmIgKiA2My4wO1xcblxcXG5cdFx0XHQgbWVkaXVtcCB2ZWMyIHF1YWQxO1xcblxcXG5cdFx0XHQgcXVhZDEueSA9IGZsb29yKGZsb29yKGJsdWVDb2xvcikgLyA4LjApO1xcblxcXG5cdFx0XHQgcXVhZDEueCA9IGZsb29yKGJsdWVDb2xvcikgLSAocXVhZDEueSAqIDguMCk7XFxuXFxcblx0XHRcdCBtZWRpdW1wIHZlYzIgcXVhZDI7XFxuXFxcblx0XHRcdCBxdWFkMi55ID0gZmxvb3IoY2VpbChibHVlQ29sb3IpIC8gOC4wKTtcXG5cXFxuXHRcdFx0IHF1YWQyLnggPSBjZWlsKGJsdWVDb2xvcikgLSAocXVhZDIueSAqIDguMCk7XFxuXFxcblx0XHRcdCBoaWdocCB2ZWMyIHRleFBvczE7XFxuXFxcblx0XHRcdCB0ZXhQb3MxLnggPSAocXVhZDEueCAqIDAuMTI1KSArIDAuNS81MTIuMCArICgoMC4xMjUgLSAxLjAvNTEyLjApICogdGV4dHVyZUNvbG9yLnIpO1xcblxcXG5cdFx0XHQgdGV4UG9zMS55ID0gMS4wIC0gKChxdWFkMS55ICogMC4xMjUpICsgMC41LzUxMi4wICsgKCgwLjEyNSAtIDEuMC81MTIuMCkgKiB0ZXh0dXJlQ29sb3IuZykpO1xcblxcXG5cdFx0XHQgaGlnaHAgdmVjMiB0ZXhQb3MyO1xcblxcXG5cdFx0XHQgdGV4UG9zMi54ID0gKHF1YWQyLnggKiAwLjEyNSkgKyAwLjUvNTEyLjAgKyAoKDAuMTI1IC0gMS4wLzUxMi4wKSAqIHRleHR1cmVDb2xvci5yKTtcXG5cXFxuXHRcdFx0IHRleFBvczIueSA9IDEuMCAtICgocXVhZDIueSAqIDAuMTI1KSArIDAuNS81MTIuMCArICgoMC4xMjUgLSAxLjAvNTEyLjApICogdGV4dHVyZUNvbG9yLmcpKTtcXG5cXFxuXHRcdFx0IGxvd3AgdmVjNCBuZXdDb2xvcjEgPSB0ZXh0dXJlMkQodV90ZXh0dXJlQiwgdGV4UG9zMSk7XFxuXFxcblx0XHRcdCBsb3dwIHZlYzQgbmV3Q29sb3IyID0gdGV4dHVyZTJEKHVfdGV4dHVyZUIsIHRleFBvczIpO1xcblxcXG5cdFx0XHQgbG93cCB2ZWM0IG5ld0NvbG9yID0gbWl4KG5ld0NvbG9yMSwgbmV3Q29sb3IyLCBmcmFjdChibHVlQ29sb3IpKTtcXG5cXFxuXHRcdFx0IGdsX0ZyYWdDb2xvciA9IHZlYzQoIG1peCggdGV4dHVyZUNvbG9yLnJnYiwgbmV3Q29sb3IucmdiLCB1X2Ftb3VudCksIHRleHR1cmVDb2xvci53KTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9MVVRcIiwgTEdyYXBoVGV4dHVyZUxVVCk7XG5cblxuXHQvLyBUZXh0dXJlIExVVCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlRW5jb2RlKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiQXRsYXNcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IGVuYWJsZWQ6IHRydWUsIG51bV9yb3dfc3ltYm9sczogNCwgc3ltYm9sX3NpemU6IDE2LCBicmlnaHRuZXNzOiAxLCBjb2xvcml6ZTogZmFsc2UsIGZpbHRlcjogZmFsc2UsIGludmVydDogZmFsc2UsIHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxULCBnZW5lcmF0ZV9taXBtYXBzOiBmYWxzZSwgdGV4dHVyZTogbnVsbCB9O1xuXG5cdFx0aWYgKCFMR3JhcGhUZXh0dXJlRW5jb2RlLl9zaGFkZXIpIHtcblx0XHRcdExHcmFwaFRleHR1cmVFbmNvZGUuX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoIFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUiwgTEdyYXBoVGV4dHVyZUVuY29kZS5waXhlbF9zaGFkZXIgKTtcblx0XHR9XG5cblx0XHR0aGlzLl91bmlmb3JtcyA9IHtcblx0XHRcdFx0dV90ZXh0dXJlOiAwLFxuXHRcdFx0XHR1X3RleHR1cmVCOiAxLFxuXHRcdFx0XHR1X3Jvd19zaW1ib2xzOiA0LFxuXHRcdFx0XHR1X3NpbWJvbF9zaXplOiAxNixcblx0XHRcdFx0dV9yZXM6IHZlYzIuY3JlYXRlKClcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUVuY29kZS53aWRnZXRzX2luZm8gPSB7XG5cdFx0dGV4dHVyZTogeyB3aWRnZXQ6IFwidGV4dHVyZVwiIH0sXG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVFbmNvZGUudGl0bGUgPSBcIkVuY29kZVwiO1xuXHRMR3JhcGhUZXh0dXJlRW5jb2RlLmRlc2MgPSBcIkFwcGx5IGEgdGV4dHVyZSBhdGxhcyB0byBlbmNvZGUgYSB0ZXh0dXJlXCI7XG5cblx0TEdyYXBoVGV4dHVyZUVuY29kZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLlBBU1NfVEhST1VHSCB8fCB0aGlzLnByb3BlcnRpZXMuZW5hYmxlZCA9PT0gZmFsc2UpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHN5bWJvbHNfdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cblx0XHRpZiAoIXN5bWJvbHNfdGV4KSB7XG5cdFx0XHRzeW1ib2xzX3RleCA9IExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZSh0aGlzLnByb3BlcnRpZXMudGV4dHVyZSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFzeW1ib2xzX3RleCkge1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0c3ltYm9sc190ZXguYmluZCgwKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5wcm9wZXJ0aWVzLmZpbHRlciA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5wcm9wZXJ0aWVzLmZpbHRlciA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXG5cdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XG5cdFx0dW5pZm9ybXMudV9yb3dfc2ltYm9scyA9IE1hdGguZmxvb3IodGhpcy5wcm9wZXJ0aWVzLm51bV9yb3dfc3ltYm9scyk7XG5cdFx0dW5pZm9ybXMudV9zeW1ib2xfc2l6ZSA9IHRoaXMucHJvcGVydGllcy5zeW1ib2xfc2l6ZTtcblx0XHR1bmlmb3Jtcy51X2JyaWdodG5lc3MgPSB0aGlzLnByb3BlcnRpZXMuYnJpZ2h0bmVzcztcblx0XHR1bmlmb3Jtcy51X2ludmVydCA9IHRoaXMucHJvcGVydGllcy5pbnZlcnQgPyAxIDogMDtcblx0XHR1bmlmb3Jtcy51X2NvbG9yaXplID0gdGhpcy5wcm9wZXJ0aWVzLmNvbG9yaXplID8gMSA6IDA7XG5cblx0XHR0aGlzLl90ZXggPSBMR3JhcGhUZXh0dXJlLmdldFRhcmdldFRleHR1cmUoIHRleCwgdGhpcy5fdGV4LCB0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uICk7XG5cdFx0dW5pZm9ybXMudV9yZXNbMF0gPSB0aGlzLl90ZXgud2lkdGg7XG5cdFx0dW5pZm9ybXMudV9yZXNbMV0gPSB0aGlzLl90ZXguaGVpZ2h0O1xuXHRcdHRoaXMuX3RleC5iaW5kKDApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcblxuXHRcdHRoaXMuX3RleC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRzeW1ib2xzX3RleC5iaW5kKDEpO1xuXHRcdFx0dGV4LnRvVmlld3BvcnQoTEdyYXBoVGV4dHVyZUVuY29kZS5fc2hhZGVyLCB1bmlmb3Jtcyk7XG5cdFx0fSk7XG5cblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLmdlbmVyYXRlX21pcG1hcHMpIHtcblx0XHRcdHRoaXMuX3RleC5iaW5kKDApO1xuXHRcdFx0Z2wuZ2VuZXJhdGVNaXBtYXAodGhpcy5fdGV4LnRleHR1cmVfdHlwZSk7XG5cdFx0XHR0aGlzLl90ZXgudW5iaW5kKDApO1xuXHRcdH1cblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZXgpO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVFbmNvZGUucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlQjtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9yb3dfc2ltYm9scztcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9zeW1ib2xfc2l6ZTtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9icmlnaHRuZXNzO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2ludmVydDtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9jb2xvcml6ZTtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjMiB1X3JlcztcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWMyIHRvdGFsX3N5bWJvbHMgPSB1X3JlcyAvIHVfc3ltYm9sX3NpemU7XFxuXFxcblx0XHRcdHZlYzIgdXYgPSBmbG9vcih2X2Nvb3JkICogdG90YWxfc3ltYm9scykgLyB0b3RhbF9zeW1ib2xzOyAvL3BpeGVsYXRlIFxcblxcXG5cdFx0XHR2ZWMyIGxvY2FsX3V2ID0gbW9kKHZfY29vcmQgKiB1X3JlcywgdV9zeW1ib2xfc2l6ZSkgLyB1X3N5bWJvbF9zaXplO1xcblxcXG5cdFx0XHRsb3dwIHZlYzQgdGV4dHVyZUNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdXYgKTtcXG5cXFxuXHRcdFx0ZmxvYXQgbHVtID0gY2xhbXAodV9icmlnaHRuZXNzICogKHRleHR1cmVDb2xvci54ICsgdGV4dHVyZUNvbG9yLnkgKyB0ZXh0dXJlQ29sb3IueikvMy4wLDAuMCwxLjApO1xcblxcXG5cdFx0XHRpZiggdV9pbnZlcnQgPT0gMS4wICkgbHVtID0gMS4wIC0gbHVtO1xcblxcXG5cdFx0XHRmbG9hdCBpbmRleCA9IGZsb29yKCBsdW0gKiAodV9yb3dfc2ltYm9scyAqIHVfcm93X3NpbWJvbHMgLSAxLjApKTtcXG5cXFxuXHRcdFx0ZmxvYXQgY29sID0gbW9kKCBpbmRleCwgdV9yb3dfc2ltYm9scyApO1xcblxcXG5cdFx0XHRmbG9hdCByb3cgPSB1X3Jvd19zaW1ib2xzIC0gZmxvb3IoIGluZGV4IC8gdV9yb3dfc2ltYm9scyApIC0gMS4wO1xcblxcXG5cdFx0XHR2ZWMyIHNpbWJvbF91diA9ICggdmVjMiggY29sLCByb3cgKSArIGxvY2FsX3V2ICkgLyB1X3Jvd19zaW1ib2xzO1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKCB1X3RleHR1cmVCLCBzaW1ib2xfdXYgKTtcXG5cXFxuXHRcdFx0aWYodV9jb2xvcml6ZSA9PSAxLjApXFxuXFxcblx0XHRcdFx0Y29sb3IgKj0gdGV4dHVyZUNvbG9yO1xcblxcXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9lbmNvZGVcIiwgTEdyYXBoVGV4dHVyZUVuY29kZSk7XG5cblx0Ly8gVGV4dHVyZSBDaGFubmVscyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlQ2hhbm5lbHMoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJSXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIkdcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiQlwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJBXCIsIFwiVGV4dHVyZVwiKTtcblxuXHRcdC8vdGhpcy5wcm9wZXJ0aWVzID0geyB1c2Vfc2luZ2xlX2NoYW5uZWw6IHRydWUgfTtcblx0XHRpZiAoIUxHcmFwaFRleHR1cmVDaGFubmVscy5fc2hhZGVyKSB7XG5cdFx0XHRMR3JhcGhUZXh0dXJlQ2hhbm5lbHMuX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoVGV4dHVyZUNoYW5uZWxzLnBpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlQ2hhbm5lbHMudGl0bGUgPSBcIlRleHR1cmUgdG8gQ2hhbm5lbHNcIjtcblx0TEdyYXBoVGV4dHVyZUNoYW5uZWxzLmRlc2MgPSBcIlNwbGl0IHRleHR1cmUgY2hhbm5lbHNcIjtcblxuXHRMR3JhcGhUZXh0dXJlQ2hhbm5lbHMucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXhBID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCF0ZXhBKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9jaGFubmVscykge1xuXHRcdFx0dGhpcy5fY2hhbm5lbHMgPSBBcnJheSg0KTtcblx0XHR9XG5cblx0XHQvL3ZhciBmb3JtYXQgPSB0aGlzLnByb3BlcnRpZXMudXNlX3NpbmdsZV9jaGFubmVsID8gZ2wuTFVNSU5BTkNFIDogZ2wuUkdCQTsgLy9ub3Qgc3VwcG9ydGVkIGJ5IFdlYkdMMVxuXHRcdHZhciBmb3JtYXQgPSBnbC5SR0I7XG5cdFx0dmFyIGNvbm5lY3Rpb25zID0gMDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoaSkpIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCF0aGlzLl9jaGFubmVsc1tpXSB8fFxuXHRcdFx0XHRcdHRoaXMuX2NoYW5uZWxzW2ldLndpZHRoICE9IHRleEEud2lkdGggfHxcblx0XHRcdFx0XHR0aGlzLl9jaGFubmVsc1tpXS5oZWlnaHQgIT0gdGV4QS5oZWlnaHQgfHxcblx0XHRcdFx0XHR0aGlzLl9jaGFubmVsc1tpXS50eXBlICE9IHRleEEudHlwZSB8fFxuXHRcdFx0XHRcdHRoaXMuX2NoYW5uZWxzW2ldLmZvcm1hdCAhPSBmb3JtYXRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0dGhpcy5fY2hhbm5lbHNbaV0gPSBuZXcgR0wuVGV4dHVyZShcblx0XHRcdFx0XHRcdHRleEEud2lkdGgsXG5cdFx0XHRcdFx0XHR0ZXhBLmhlaWdodCxcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dHlwZTogdGV4QS50eXBlLFxuXHRcdFx0XHRcdFx0XHRmb3JtYXQ6IGZvcm1hdCxcblx0XHRcdFx0XHRcdFx0ZmlsdGVyOiBnbC5MSU5FQVJcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbm5lY3Rpb25zKys7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9jaGFubmVsc1tpXSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFjb25uZWN0aW9ucykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cblx0XHR2YXIgbWVzaCA9IE1lc2guZ2V0U2NyZWVuUXVhZCgpO1xuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhUZXh0dXJlQ2hhbm5lbHMuX3NoYWRlcjtcblx0XHR2YXIgbWFza3MgPSBbXG5cdFx0XHRbMSwgMCwgMCwgMF0sXG5cdFx0XHRbMCwgMSwgMCwgMF0sXG5cdFx0XHRbMCwgMCwgMSwgMF0sXG5cdFx0XHRbMCwgMCwgMCwgMV1cblx0XHRdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdGlmICghdGhpcy5fY2hhbm5lbHNbaV0pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2NoYW5uZWxzW2ldLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdFx0dGV4QS5iaW5kKDApO1xuXHRcdFx0XHRzaGFkZXJcblx0XHRcdFx0XHQudW5pZm9ybXMoeyB1X3RleHR1cmU6IDAsIHVfbWFzazogbWFza3NbaV0gfSlcblx0XHRcdFx0XHQuZHJhdyhtZXNoKTtcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKGksIHRoaXMuX2NoYW5uZWxzW2ldKTtcblx0XHR9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUNoYW5uZWxzLnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjNCB1X21hc2s7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdCAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIGxlbmd0aCggdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCkgKiB1X21hc2sgKSksIDEuMCApO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXG5cdFx0XCJ0ZXh0dXJlL3RleHR1cmVDaGFubmVsc1wiLFxuXHRcdExHcmFwaFRleHR1cmVDaGFubmVsc1xuXHQpO1xuXG5cdC8vIFRleHR1cmUgQ2hhbm5lbHMgdG8gVGV4dHVyZSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhDaGFubmVsc1RleHR1cmUoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlJcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJHXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiQlwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIkFcIiwgXCJUZXh0dXJlXCIpO1xuXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxULFxuXHRcdFx0UjogMSxcblx0XHRcdEc6IDEsXG5cdFx0XHRCOiAxLFxuXHRcdFx0QTogMVxuXHRcdH07XG5cdFx0dGhpcy5fY29sb3IgPSB2ZWM0LmNyZWF0ZSgpO1xuXHRcdHRoaXMuX3VuaWZvcm1zID0ge1xuXHRcdFx0dV90ZXh0dXJlUjogMCxcblx0XHRcdHVfdGV4dHVyZUc6IDEsXG5cdFx0XHR1X3RleHR1cmVCOiAyLFxuXHRcdFx0dV90ZXh0dXJlQTogMyxcblx0XHRcdHVfY29sb3I6IHRoaXMuX2NvbG9yXG5cdFx0fTtcblx0fVxuXG5cdExHcmFwaENoYW5uZWxzVGV4dHVyZS50aXRsZSA9IFwiQ2hhbm5lbHMgdG8gVGV4dHVyZVwiO1xuXHRMR3JhcGhDaGFubmVsc1RleHR1cmUuZGVzYyA9IFwiU3BsaXQgdGV4dHVyZSBjaGFubmVsc1wiO1xuXHRMR3JhcGhDaGFubmVsc1RleHR1cmUud2lkZ2V0c19pbmZvID0ge1xuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhDaGFubmVsc1RleHR1cmUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB3aGl0ZSA9IExHcmFwaFRleHR1cmUuZ2V0V2hpdGVUZXh0dXJlKCk7XG5cdFx0dmFyIHRleFIgPSB0aGlzLmdldElucHV0RGF0YSgwKSB8fCB3aGl0ZTtcblx0XHR2YXIgdGV4RyA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpIHx8IHdoaXRlO1xuXHRcdHZhciB0ZXhCID0gdGhpcy5nZXRJbnB1dERhdGEoMikgfHwgd2hpdGU7XG5cdFx0dmFyIHRleEEgPSB0aGlzLmdldElucHV0RGF0YSgzKSB8fCB3aGl0ZTtcblxuXHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cblx0XHR2YXIgbWVzaCA9IE1lc2guZ2V0U2NyZWVuUXVhZCgpO1xuXHRcdGlmICghTEdyYXBoQ2hhbm5lbHNUZXh0dXJlLl9zaGFkZXIpIHtcblx0XHRcdExHcmFwaENoYW5uZWxzVGV4dHVyZS5fc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0U2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxuXHRcdFx0XHRMR3JhcGhDaGFubmVsc1RleHR1cmUucGl4ZWxfc2hhZGVyXG5cdFx0XHQpO1xuXHRcdH1cblx0XHR2YXIgc2hhZGVyID0gTEdyYXBoQ2hhbm5lbHNUZXh0dXJlLl9zaGFkZXI7XG5cblx0XHR2YXIgdyA9IE1hdGgubWF4KHRleFIud2lkdGgsIHRleEcud2lkdGgsIHRleEIud2lkdGgsIHRleEEud2lkdGgpO1xuXHRcdHZhciBoID0gTWF0aC5tYXgoXG5cdFx0XHR0ZXhSLmhlaWdodCxcblx0XHRcdHRleEcuaGVpZ2h0LFxuXHRcdFx0dGV4Qi5oZWlnaHQsXG5cdFx0XHR0ZXhBLmhlaWdodFxuXHRcdCk7XG5cdFx0dmFyIHR5cGUgPVxuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PSBMR3JhcGhUZXh0dXJlLkhJR0hcblx0XHRcdFx0PyBMR3JhcGhUZXh0dXJlLkhJR0hfUFJFQ0lTSU9OX0ZPUk1BVFxuXHRcdFx0XHQ6IGdsLlVOU0lHTkVEX0JZVEU7XG5cblx0XHRpZiAoXG5cdFx0XHQhdGhpcy5fdGV4dHVyZSB8fFxuXHRcdFx0dGhpcy5fdGV4dHVyZS53aWR0aCAhPSB3IHx8XG5cdFx0XHR0aGlzLl90ZXh0dXJlLmhlaWdodCAhPSBoIHx8XG5cdFx0XHR0aGlzLl90ZXh0dXJlLnR5cGUgIT0gdHlwZVxuXHRcdCkge1xuXHRcdFx0dGhpcy5fdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKHcsIGgsIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIGNvbG9yID0gdGhpcy5fY29sb3I7XG5cdFx0Y29sb3JbMF0gPSB0aGlzLnByb3BlcnRpZXMuUjtcblx0XHRjb2xvclsxXSA9IHRoaXMucHJvcGVydGllcy5HO1xuXHRcdGNvbG9yWzJdID0gdGhpcy5wcm9wZXJ0aWVzLkI7XG5cdFx0Y29sb3JbM10gPSB0aGlzLnByb3BlcnRpZXMuQTtcblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3JtcztcblxuXHRcdHRoaXMuX3RleHR1cmUuZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGV4Ui5iaW5kKDApO1xuXHRcdFx0dGV4Ry5iaW5kKDEpO1xuXHRcdFx0dGV4Qi5iaW5kKDIpO1xuXHRcdFx0dGV4QS5iaW5kKDMpO1xuXHRcdFx0c2hhZGVyLnVuaWZvcm1zKHVuaWZvcm1zKS5kcmF3KG1lc2gpO1xuXHRcdH0pO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZXh0dXJlKTtcblx0fTtcblxuXHRMR3JhcGhDaGFubmVsc1RleHR1cmUucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlUjtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZUc7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVCO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlQTtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHQgICBnbF9GcmFnQ29sb3IgPSB1X2NvbG9yICogdmVjNCggXFxcblx0XHRcdFx0XHR0ZXh0dXJlMkQodV90ZXh0dXJlUiwgdl9jb29yZCkucixcXFxuXHRcdFx0XHRcdHRleHR1cmUyRCh1X3RleHR1cmVHLCB2X2Nvb3JkKS5yLFxcXG5cdFx0XHRcdFx0dGV4dHVyZTJEKHVfdGV4dHVyZUIsIHZfY29vcmQpLnIsXFxcblx0XHRcdFx0XHR0ZXh0dXJlMkQodV90ZXh0dXJlQSwgdl9jb29yZCkucik7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcblx0XHRcInRleHR1cmUvY2hhbm5lbHNUZXh0dXJlXCIsXG5cdFx0TEdyYXBoQ2hhbm5lbHNUZXh0dXJlXG5cdCk7XG5cblx0Ly8gVGV4dHVyZSBDb2xvciAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlQ29sb3IoKSB7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblxuXHRcdHRoaXMuX3RleF9jb2xvciA9IHZlYzQuY3JlYXRlKCk7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0Y29sb3I6IHZlYzQuY3JlYXRlKCksXG5cdFx0XHRwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVFxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlQ29sb3IudGl0bGUgPSBcIkNvbG9yXCI7XG5cdExHcmFwaFRleHR1cmVDb2xvci5kZXNjID1cblx0XHRcIkdlbmVyYXRlcyBhIDF4MSB0ZXh0dXJlIHdpdGggYSBjb25zdGFudCBjb2xvclwiO1xuXG5cdExHcmFwaFRleHR1cmVDb2xvci53aWRnZXRzX2luZm8gPSB7XG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVDb2xvci5wcm90b3R5cGUub25EcmF3QmFja2dyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdHZhciBjID0gdGhpcy5wcm9wZXJ0aWVzLmNvbG9yO1xuXHRcdGN0eC5maWxsU3R5bGUgPVxuXHRcdFx0XCJyZ2IoXCIgK1xuXHRcdFx0TWF0aC5mbG9vcihjbGFtcChjWzBdLCAwLCAxKSAqIDI1NSkgK1xuXHRcdFx0XCIsXCIgK1xuXHRcdFx0TWF0aC5mbG9vcihjbGFtcChjWzFdLCAwLCAxKSAqIDI1NSkgK1xuXHRcdFx0XCIsXCIgK1xuXHRcdFx0TWF0aC5mbG9vcihjbGFtcChjWzJdLCAwLCAxKSAqIDI1NSkgK1xuXHRcdFx0XCIpXCI7XG5cdFx0aWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XG5cdFx0XHR0aGlzLmJveGNvbG9yID0gY3R4LmZpbGxTdHlsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuc2l6ZVswXSwgdGhpcy5zaXplWzFdKTtcblx0XHR9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUNvbG9yLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHlwZSA9XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09IExHcmFwaFRleHR1cmUuSElHSFxuXHRcdFx0XHQ/IExHcmFwaFRleHR1cmUuSElHSF9QUkVDSVNJT05fRk9STUFUXG5cdFx0XHRcdDogZ2wuVU5TSUdORURfQllURTtcblxuXHRcdGlmICghdGhpcy5fdGV4IHx8IHRoaXMuX3RleC50eXBlICE9IHR5cGUpIHtcblx0XHRcdHRoaXMuX3RleCA9IG5ldyBHTC5UZXh0dXJlKDEsIDEsIHtcblx0XHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRtaW5GaWx0ZXI6IGdsLk5FQVJFU1Rcblx0XHRcdH0pO1xuXHRcdH1cblx0XHR2YXIgY29sb3IgPSB0aGlzLnByb3BlcnRpZXMuY29sb3I7XG5cblx0XHRpZiAodGhpcy5pbnB1dHMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XG5cdFx0XHRcdHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XG5cdFx0XHRcdGlmICh2ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKGlucHV0Lm5hbWUpIHtcblx0XHRcdFx0XHRjYXNlIFwiUkdCXCI6XG5cdFx0XHRcdFx0Y2FzZSBcIlJHQkFcIjpcblx0XHRcdFx0XHRcdGNvbG9yLnNldCh2KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJSXCI6XG5cdFx0XHRcdFx0XHRjb2xvclswXSA9IHY7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiR1wiOlxuXHRcdFx0XHRcdFx0Y29sb3JbMV0gPSB2O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIkJcIjpcblx0XHRcdFx0XHRcdGNvbG9yWzJdID0gdjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJBXCI6XG5cdFx0XHRcdFx0XHRjb2xvclszXSA9IHY7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh2ZWM0LnNxckRpc3QodGhpcy5fdGV4X2NvbG9yLCBjb2xvcikgPiAwLjAwMSkge1xuXHRcdFx0dGhpcy5fdGV4X2NvbG9yLnNldChjb2xvcik7XG5cdFx0XHR0aGlzLl90ZXguZmlsbChjb2xvcik7XG5cdFx0fVxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZXgpO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVDb2xvci5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0W1wiUkdCXCIsIFwidmVjM1wiXSxcblx0XHRcdFtcIlJHQkFcIiwgXCJ2ZWM0XCJdLFxuXHRcdFx0W1wiUlwiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcIkdcIiwgXCJudW1iZXJcIl0sXG5cdFx0XHRbXCJCXCIsIFwibnVtYmVyXCJdLFxuXHRcdFx0W1wiQVwiLCBcIm51bWJlclwiXVxuXHRcdF07XG5cdH07XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL2NvbG9yXCIsIExHcmFwaFRleHR1cmVDb2xvcik7XG5cblx0Ly8gVGV4dHVyZSBDaGFubmVscyB0byBUZXh0dXJlICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVHcmFkaWVudCgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiQVwiLCBcImNvbG9yXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJCXCIsIFwiY29sb3JcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdGFuZ2xlOiAwLFxuXHRcdFx0c2NhbGU6IDEsXG5cdFx0XHRBOiBbMCwgMCwgMF0sXG5cdFx0XHRCOiBbMSwgMSwgMV0sXG5cdFx0XHR0ZXh0dXJlX3NpemU6IDMyXG5cdFx0fTtcblx0XHRpZiAoIUxHcmFwaFRleHR1cmVHcmFkaWVudC5fc2hhZGVyKSB7XG5cdFx0XHRMR3JhcGhUZXh0dXJlR3JhZGllbnQuX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoVGV4dHVyZUdyYWRpZW50LnBpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0aGlzLl91bmlmb3JtcyA9IHtcblx0XHRcdHVfYW5nbGU6IDAsXG5cdFx0XHR1X2NvbG9yQTogdmVjMy5jcmVhdGUoKSxcblx0XHRcdHVfY29sb3JCOiB2ZWMzLmNyZWF0ZSgpXG5cdFx0fTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVHcmFkaWVudC50aXRsZSA9IFwiR3JhZGllbnRcIjtcblx0TEdyYXBoVGV4dHVyZUdyYWRpZW50LmRlc2MgPSBcIkdlbmVyYXRlcyBhIGdyYWRpZW50XCI7XG5cdExHcmFwaFRleHR1cmVHcmFkaWVudFtcIkBBXCJdID0geyB0eXBlOiBcImNvbG9yXCIgfTtcblx0TEdyYXBoVGV4dHVyZUdyYWRpZW50W1wiQEJcIl0gPSB7IHR5cGU6IFwiY29sb3JcIiB9O1xuXHRMR3JhcGhUZXh0dXJlR3JhZGllbnRbXCJAdGV4dHVyZV9zaXplXCJdID0ge1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdHZhbHVlczogWzMyLCA2NCwgMTI4LCAyNTYsIDUxMl1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlR3JhZGllbnQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cblx0XHR2YXIgbWVzaCA9IEdMLk1lc2guZ2V0U2NyZWVuUXVhZCgpO1xuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhUZXh0dXJlR3JhZGllbnQuX3NoYWRlcjtcblxuXHRcdHZhciBBID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYgKCFBKSB7XG5cdFx0XHRBID0gdGhpcy5wcm9wZXJ0aWVzLkE7XG5cdFx0fVxuXHRcdHZhciBCID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cdFx0aWYgKCFCKSB7XG5cdFx0XHRCID0gdGhpcy5wcm9wZXJ0aWVzLkI7XG5cdFx0fVxuXG5cdFx0Ly9hbmdsZSBhbmQgc2NhbGVcblx0XHRmb3IgKHZhciBpID0gMjsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcblx0XHRcdHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XG5cdFx0XHRpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzW2lucHV0Lm5hbWVdID0gdjtcblx0XHR9XG5cblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3Jtcztcblx0XHR0aGlzLl91bmlmb3Jtcy51X2FuZ2xlID0gdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlICogREVHMlJBRDtcblx0XHR0aGlzLl91bmlmb3Jtcy51X3NjYWxlID0gdGhpcy5wcm9wZXJ0aWVzLnNjYWxlO1xuXHRcdHZlYzMuY29weSh1bmlmb3Jtcy51X2NvbG9yQSwgQSk7XG5cdFx0dmVjMy5jb3B5KHVuaWZvcm1zLnVfY29sb3JCLCBCKTtcblxuXHRcdHZhciBzaXplID0gcGFyc2VJbnQodGhpcy5wcm9wZXJ0aWVzLnRleHR1cmVfc2l6ZSk7XG5cdFx0aWYgKCF0aGlzLl90ZXggfHwgdGhpcy5fdGV4LndpZHRoICE9IHNpemUpIHtcblx0XHRcdHRoaXMuX3RleCA9IG5ldyBHTC5UZXh0dXJlKHNpemUsIHNpemUsIHtcblx0XHRcdFx0Zm9ybWF0OiBnbC5SR0IsXG5cdFx0XHRcdGZpbHRlcjogZ2wuTElORUFSXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLl90ZXguZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0c2hhZGVyLnVuaWZvcm1zKHVuaWZvcm1zKS5kcmF3KG1lc2gpO1xuXHRcdH0pO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZXgpO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVHcmFkaWVudC5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gW1tcImFuZ2xlXCIsIFwibnVtYmVyXCJdLCBbXCJzY2FsZVwiLCBcIm51bWJlclwiXV07XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUdyYWRpZW50LnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9hbmdsZTtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9zY2FsZTtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjMyB1X2NvbG9yQTtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjMyB1X2NvbG9yQjtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dmVjMiByb3RhdGUodmVjMiB2LCBmbG9hdCBhbmdsZSlcXG5cXFxuXHRcdHtcXG5cXFxuXHRcdFx0dmVjMiByZXN1bHQ7XFxuXFxcblx0XHRcdGZsb2F0IF9jb3MgPSBjb3MoYW5nbGUpO1xcblxcXG5cdFx0XHRmbG9hdCBfc2luID0gc2luKGFuZ2xlKTtcXG5cXFxuXHRcdFx0cmVzdWx0LnggPSB2LnggKiBfY29zIC0gdi55ICogX3NpbjtcXG5cXFxuXHRcdFx0cmVzdWx0LnkgPSB2LnggKiBfc2luICsgdi55ICogX2NvcztcXG5cXFxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0ZmxvYXQgZiA9IChyb3RhdGUodV9zY2FsZSAqICh2X2Nvb3JkIC0gdmVjMigwLjUpKSwgdV9hbmdsZSkgKyB2ZWMyKDAuNSkpLng7XFxuXFxcblx0XHRcdHZlYzMgY29sb3IgPSBtaXgodV9jb2xvckEsdV9jb2xvckIsY2xhbXAoZiwwLjAsMS4wKSk7XFxuXFxcblx0XHQgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLDEuMCk7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvZ3JhZGllbnRcIiwgTEdyYXBoVGV4dHVyZUdyYWRpZW50KTtcblxuXHQvLyBUZXh0dXJlIE1peCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlTWl4KCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJBXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiQlwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIk1peGVyXCIsIFwiVGV4dHVyZVwiKTtcblxuXHRcdHRoaXMuYWRkT3V0cHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBmYWN0b3I6IDAuNSwgc2l6ZV9mcm9tX2JpZ2dlc3Q6IHRydWUsIGludmVydDogZmFsc2UsIHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUIH07XG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7XG5cdFx0XHR1X3RleHR1cmVBOiAwLFxuXHRcdFx0dV90ZXh0dXJlQjogMSxcblx0XHRcdHVfdGV4dHVyZU1peDogMixcblx0XHRcdHVfbWl4OiB2ZWM0LmNyZWF0ZSgpXG5cdFx0fTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVNaXgudGl0bGUgPSBcIk1peFwiO1xuXHRMR3JhcGhUZXh0dXJlTWl4LmRlc2MgPSBcIkdlbmVyYXRlcyBhIHRleHR1cmUgbWl4aW5nIHR3byB0ZXh0dXJlc1wiO1xuXG5cdExHcmFwaFRleHR1cmVNaXgud2lkZ2V0c19pbmZvID0ge1xuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlTWl4LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGV4QSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLlBBU1NfVEhST1VHSCkge1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleEEpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0ZXhCID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cdFx0aWYgKCF0ZXhBIHx8ICF0ZXhCKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRleE1peCA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xuXG5cdFx0dmFyIGZhY3RvciA9IHRoaXMuZ2V0SW5wdXREYXRhKDMpO1xuXG5cdFx0dGhpcy5fdGV4ID0gTEdyYXBoVGV4dHVyZS5nZXRUYXJnZXRUZXh0dXJlKFxuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnNpemVfZnJvbV9iaWdnZXN0ICYmIHRleEIud2lkdGggPiB0ZXhBLndpZHRoID8gdGV4QiA6IHRleEEsXG5cdFx0XHR0aGlzLl90ZXgsXG5cdFx0XHR0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uXG5cdFx0KTtcblxuXHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cblx0XHR2YXIgbWVzaCA9IE1lc2guZ2V0U2NyZWVuUXVhZCgpO1xuXHRcdHZhciBzaGFkZXIgPSBudWxsO1xuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXHRcdGlmICh0ZXhNaXgpIHtcblx0XHRcdHNoYWRlciA9IExHcmFwaFRleHR1cmVNaXguX3NoYWRlcl90ZXg7XG5cdFx0XHRpZiAoIXNoYWRlcikge1xuXHRcdFx0XHRzaGFkZXIgPSBMR3JhcGhUZXh0dXJlTWl4Ll9zaGFkZXJfdGV4ID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0XHRTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdFx0TEdyYXBoVGV4dHVyZU1peC5waXhlbF9zaGFkZXIsXG5cdFx0XHRcdFx0eyBNSVhfVEVYOiBcIlwiIH1cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c2hhZGVyID0gTEdyYXBoVGV4dHVyZU1peC5fc2hhZGVyX2ZhY3Rvcjtcblx0XHRcdGlmICghc2hhZGVyKSB7XG5cdFx0XHRcdHNoYWRlciA9IExHcmFwaFRleHR1cmVNaXguX3NoYWRlcl9mYWN0b3IgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRcdFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0XHRMR3JhcGhUZXh0dXJlTWl4LnBpeGVsX3NoYWRlclxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGYgPSBmYWN0b3IgPT0gbnVsbCA/IHRoaXMucHJvcGVydGllcy5mYWN0b3IgOiBmYWN0b3I7XG5cdFx0XHR1bmlmb3Jtcy51X21peC5zZXQoW2YsIGYsIGYsIGZdKTtcblx0XHR9XG5cblx0XHR2YXIgaW52ZXJ0ID0gdGhpcy5wcm9wZXJ0aWVzLmludmVydDtcblxuXHRcdHRoaXMuX3RleC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHR0ZXhBLmJpbmQoIGludmVydCA/IDEgOiAwICk7XG5cdFx0XHR0ZXhCLmJpbmQoIGludmVydCA/IDAgOiAxICk7XG5cdFx0XHRpZiAodGV4TWl4KSB7XG5cdFx0XHRcdHRleE1peC5iaW5kKDIpO1xuXHRcdFx0fVxuXHRcdFx0c2hhZGVyLnVuaWZvcm1zKHVuaWZvcm1zKS5kcmF3KG1lc2gpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleCk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZU1peC5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gW1tcImZhY3RvclwiLCBcIm51bWJlclwiXV07XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZU1peC5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVBO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlQjtcXG5cXFxuXHRcdCNpZmRlZiBNSVhfVEVYXFxuXFxcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZU1peDtcXG5cXFxuXHRcdCNlbHNlXFxuXFxcblx0XHRcdHVuaWZvcm0gdmVjNCB1X21peDtcXG5cXFxuXHRcdCNlbmRpZlxcblxcXG5cdFx0XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRcdCNpZmRlZiBNSVhfVEVYXFxuXFxcblx0XHRcdCAgIHZlYzQgZiA9IHRleHR1cmUyRCh1X3RleHR1cmVNaXgsIHZfY29vcmQpO1xcblxcXG5cdFx0XHQjZWxzZVxcblxcXG5cdFx0XHQgICB2ZWM0IGYgPSB1X21peDtcXG5cXFxuXHRcdFx0I2VuZGlmXFxuXFxcblx0XHQgICBnbF9GcmFnQ29sb3IgPSBtaXgoIHRleHR1cmUyRCh1X3RleHR1cmVBLCB2X2Nvb3JkKSwgdGV4dHVyZTJEKHVfdGV4dHVyZUIsIHZfY29vcmQpLCBmICk7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvbWl4XCIsIExHcmFwaFRleHR1cmVNaXgpO1xuXG5cdC8vIFRleHR1cmUgRWRnZXMgZGV0ZWN0aW9uICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVFZGdlcygpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4LlwiLCBcIlRleHR1cmVcIik7XG5cblx0XHR0aGlzLmFkZE91dHB1dChcIkVkZ2VzXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRpbnZlcnQ6IHRydWUsXG5cdFx0XHR0aHJlc2hvbGQ6IGZhbHNlLFxuXHRcdFx0ZmFjdG9yOiAxLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcblx0XHR9O1xuXG5cdFx0aWYgKCFMR3JhcGhUZXh0dXJlRWRnZXMuX3NoYWRlcikge1xuXHRcdFx0TEdyYXBoVGV4dHVyZUVkZ2VzLl9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdExHcmFwaFRleHR1cmVFZGdlcy5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUVkZ2VzLnRpdGxlID0gXCJFZGdlc1wiO1xuXHRMR3JhcGhUZXh0dXJlRWRnZXMuZGVzYyA9IFwiRGV0ZWN0cyBlZGdlc1wiO1xuXG5cdExHcmFwaFRleHR1cmVFZGdlcy53aWRnZXRzX2luZm8gPSB7XG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVFZGdlcy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLlBBU1NfVEhST1VHSCkge1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0ZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl90ZXggPSBMR3JhcGhUZXh0dXJlLmdldFRhcmdldFRleHR1cmUoXG5cdFx0XHR0ZXgsXG5cdFx0XHR0aGlzLl90ZXgsXG5cdFx0XHR0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uXG5cdFx0KTtcblxuXHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cblx0XHR2YXIgbWVzaCA9IE1lc2guZ2V0U2NyZWVuUXVhZCgpO1xuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhUZXh0dXJlRWRnZXMuX3NoYWRlcjtcblx0XHR2YXIgaW52ZXJ0ID0gdGhpcy5wcm9wZXJ0aWVzLmludmVydDtcblx0XHR2YXIgZmFjdG9yID0gdGhpcy5wcm9wZXJ0aWVzLmZhY3Rvcjtcblx0XHR2YXIgdGhyZXNob2xkID0gdGhpcy5wcm9wZXJ0aWVzLnRocmVzaG9sZCA/IDEgOiAwO1xuXG5cdFx0dGhpcy5fdGV4LmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdHRleC5iaW5kKDApO1xuXHRcdFx0c2hhZGVyXG5cdFx0XHRcdC51bmlmb3Jtcyh7XG5cdFx0XHRcdFx0dV90ZXh0dXJlOiAwLFxuXHRcdFx0XHRcdHVfaXNpemU6IFsxIC8gdGV4LndpZHRoLCAxIC8gdGV4LmhlaWdodF0sXG5cdFx0XHRcdFx0dV9mYWN0b3I6IGZhY3Rvcixcblx0XHRcdFx0XHR1X3RocmVzaG9sZDogdGhyZXNob2xkLFxuXHRcdFx0XHRcdHVfaW52ZXJ0OiBpbnZlcnQgPyAxIDogMFxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuZHJhdyhtZXNoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZXgpO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVFZGdlcy5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzIgdV9pc2l6ZTtcXG5cXFxuXHRcdHVuaWZvcm0gaW50IHVfaW52ZXJ0O1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2ZhY3RvcjtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV90aHJlc2hvbGQ7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0dmVjNCBjZW50ZXIgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkKTtcXG5cXFxuXHRcdFx0dmVjNCB1cCA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQgKyB1X2lzaXplICogdmVjMigwLjAsMS4wKSApO1xcblxcXG5cdFx0XHR2ZWM0IGRvd24gPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkICsgdV9pc2l6ZSAqIHZlYzIoMC4wLC0xLjApICk7XFxuXFxcblx0XHRcdHZlYzQgbGVmdCA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQgKyB1X2lzaXplICogdmVjMigxLjAsMC4wKSApO1xcblxcXG5cdFx0XHR2ZWM0IHJpZ2h0ID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCArIHVfaXNpemUgKiB2ZWMyKC0xLjAsMC4wKSApO1xcblxcXG5cdFx0XHR2ZWM0IGRpZmYgPSBhYnMoY2VudGVyIC0gdXApICsgYWJzKGNlbnRlciAtIGRvd24pICsgYWJzKGNlbnRlciAtIGxlZnQpICsgYWJzKGNlbnRlciAtIHJpZ2h0KTtcXG5cXFxuXHRcdFx0ZGlmZiAqPSB1X2ZhY3RvcjtcXG5cXFxuXHRcdFx0aWYodV9pbnZlcnQgPT0gMSlcXG5cXFxuXHRcdFx0XHRkaWZmLnh5eiA9IHZlYzMoMS4wKSAtIGRpZmYueHl6O1xcblxcXG5cdFx0XHRpZiggdV90aHJlc2hvbGQgPT0gMC4wIClcXG5cXFxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBkaWZmLnh5eiwgY2VudGVyLmEgKTtcXG5cXFxuXHRcdFx0ZWxzZVxcblxcXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGRpZmYueCA+IDAuNSA/IDEuMCA6IDAuMCwgZGlmZi55ID4gMC41ID8gMS4wIDogMC4wLCBkaWZmLnogPiAwLjUgPyAxLjAgOiAwLjAsIGNlbnRlci5hICk7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvZWRnZXNcIiwgTEdyYXBoVGV4dHVyZUVkZ2VzKTtcblxuXHQvLyBUZXh0dXJlIERlcHRoICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVEZXB0aFJhbmdlKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiRGlzdGFuY2VcIiwgXCJudW1iZXJcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcIlJhbmdlXCIsIFwibnVtYmVyXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0ZGlzdGFuY2U6IDEwMCxcblx0XHRcdHJhbmdlOiA1MCxcblx0XHRcdG9ubHlfZGVwdGg6IGZhbHNlLFxuXHRcdFx0aGlnaF9wcmVjaXNpb246IGZhbHNlXG5cdFx0fTtcblx0XHR0aGlzLl91bmlmb3JtcyA9IHtcblx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdHVfZGlzdGFuY2U6IDEwMCxcblx0XHRcdHVfcmFuZ2U6IDUwLFxuXHRcdFx0dV9jYW1lcmFfcGxhbmVzOiBudWxsXG5cdFx0fTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVEZXB0aFJhbmdlLnRpdGxlID0gXCJEZXB0aCBSYW5nZVwiO1xuXHRMR3JhcGhUZXh0dXJlRGVwdGhSYW5nZS5kZXNjID0gXCJHZW5lcmF0ZXMgYSB0ZXh0dXJlIHdpdGggYSBkZXB0aCByYW5nZVwiO1xuXG5cdExHcmFwaFRleHR1cmVEZXB0aFJhbmdlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHByZWNpc2lvbiA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0aWYgKHRoaXMucHJvcGVydGllcy5oaWdoX3ByZWNpc2lvbikge1xuXHRcdFx0cHJlY2lzaW9uID0gZ2wuaGFsZl9mbG9hdF9leHQgPyBnbC5IQUxGX0ZMT0FUX09FUyA6IGdsLkZMT0FUO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdCF0aGlzLl90ZW1wX3RleHR1cmUgfHxcblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZS50eXBlICE9IHByZWNpc2lvbiB8fFxuXHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlLndpZHRoICE9IHRleC53aWR0aCB8fFxuXHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlLmhlaWdodCAhPSB0ZXguaGVpZ2h0XG5cdFx0KSB7XG5cdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSh0ZXgud2lkdGgsIHRleC5oZWlnaHQsIHtcblx0XHRcdFx0dHlwZTogcHJlY2lzaW9uLFxuXHRcdFx0XHRmb3JtYXQ6IGdsLlJHQkEsXG5cdFx0XHRcdGZpbHRlcjogZ2wuTElORUFSXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3JtcztcblxuXHRcdC8vaXRlcmF0aW9uc1xuXHRcdHZhciBkaXN0YW5jZSA9IHRoaXMucHJvcGVydGllcy5kaXN0YW5jZTtcblx0XHRpZiAodGhpcy5pc0lucHV0Q29ubmVjdGVkKDEpKSB7XG5cdFx0XHRkaXN0YW5jZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5cdFx0fVxuXG5cdFx0dmFyIHJhbmdlID0gdGhpcy5wcm9wZXJ0aWVzLnJhbmdlO1xuXHRcdGlmICh0aGlzLmlzSW5wdXRDb25uZWN0ZWQoMikpIHtcblx0XHRcdHJhbmdlID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMucmFuZ2UgPSByYW5nZTtcblx0XHR9XG5cblx0XHR1bmlmb3Jtcy51X2Rpc3RhbmNlID0gZGlzdGFuY2U7XG5cdFx0dW5pZm9ybXMudV9yYW5nZSA9IHJhbmdlO1xuXG5cdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblx0XHR2YXIgbWVzaCA9IE1lc2guZ2V0U2NyZWVuUXVhZCgpO1xuXHRcdGlmICghTEdyYXBoVGV4dHVyZURlcHRoUmFuZ2UuX3NoYWRlcikge1xuXHRcdFx0TEdyYXBoVGV4dHVyZURlcHRoUmFuZ2UuX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdFNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoVGV4dHVyZURlcHRoUmFuZ2UucGl4ZWxfc2hhZGVyXG5cdFx0XHQpO1xuXHRcdFx0TEdyYXBoVGV4dHVyZURlcHRoUmFuZ2UuX3NoYWRlcl9vbmx5ZGVwdGggPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdExHcmFwaFRleHR1cmVEZXB0aFJhbmdlLnBpeGVsX3NoYWRlcixcblx0XHRcdFx0eyBPTkxZX0RFUFRIOiBcIlwiIH1cblx0XHRcdCk7XG5cdFx0fVxuXHRcdHZhciBzaGFkZXIgPSB0aGlzLnByb3BlcnRpZXMub25seV9kZXB0aFxuXHRcdFx0PyBMR3JhcGhUZXh0dXJlRGVwdGhSYW5nZS5fc2hhZGVyX29ubHlkZXB0aFxuXHRcdFx0OiBMR3JhcGhUZXh0dXJlRGVwdGhSYW5nZS5fc2hhZGVyO1xuXG5cdFx0Ly9ORUFSIEFORCBGQVIgUExBTkVTXG5cdFx0dmFyIHBsYW5lcyA9IG51bGw7XG5cdFx0aWYgKHRleC5uZWFyX2Zhcl9wbGFuZXMpIHtcblx0XHRcdHBsYW5lcyA9IHRleC5uZWFyX2Zhcl9wbGFuZXM7XG5cdFx0fSBlbHNlIGlmICh3aW5kb3cuTFMgJiYgTFMuUmVuZGVyZXIuX21haW5fY2FtZXJhKSB7XG5cdFx0XHRwbGFuZXMgPSBMUy5SZW5kZXJlci5fbWFpbl9jYW1lcmEuX3VuaWZvcm1zLnVfY2FtZXJhX3BsYW5lcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGxhbmVzID0gWzAuMSwgMTAwMF07XG5cdFx0fSAvL2hhcmRjb2RlZFxuXHRcdHVuaWZvcm1zLnVfY2FtZXJhX3BsYW5lcyA9IHBsYW5lcztcblxuXHRcdHRoaXMuX3RlbXBfdGV4dHVyZS5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHR0ZXguYmluZCgwKTtcblx0XHRcdHNoYWRlci51bmlmb3Jtcyh1bmlmb3JtcykuZHJhdyhtZXNoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX3RlbXBfdGV4dHVyZS5uZWFyX2Zhcl9wbGFuZXMgPSBwbGFuZXM7XG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RlbXBfdGV4dHVyZSk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZURlcHRoUmFuZ2UucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWMyIHVfY2FtZXJhX3BsYW5lcztcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9kaXN0YW5jZTtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9yYW5nZTtcXG5cXFxuXHRcdFxcblxcXG5cdFx0ZmxvYXQgTGluZWFyRGVwdGgoKVxcblxcXG5cdFx0e1xcblxcXG5cdFx0XHRmbG9hdCB6TmVhciA9IHVfY2FtZXJhX3BsYW5lcy54O1xcblxcXG5cdFx0XHRmbG9hdCB6RmFyID0gdV9jYW1lcmFfcGxhbmVzLnk7XFxuXFxcblx0XHRcdGZsb2F0IGRlcHRoID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCkueDtcXG5cXFxuXHRcdFx0ZGVwdGggPSBkZXB0aCAqIDIuMCAtIDEuMDtcXG5cXFxuXHRcdFx0cmV0dXJuIHpOZWFyICogKGRlcHRoICsgMS4wKSAvICh6RmFyICsgek5lYXIgLSBkZXB0aCAqICh6RmFyIC0gek5lYXIpKTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHRmbG9hdCBkZXB0aCA9IExpbmVhckRlcHRoKCk7XFxuXFxcblx0XHRcdCNpZmRlZiBPTkxZX0RFUFRIXFxuXFxcblx0XHRcdCAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoZGVwdGgpO1xcblxcXG5cdFx0XHQjZWxzZVxcblxcXG5cdFx0XHRcdGZsb2F0IGRpZmYgPSBhYnMoZGVwdGggKiB1X2NhbWVyYV9wbGFuZXMueSAtIHVfZGlzdGFuY2UpO1xcblxcXG5cdFx0XHRcdGZsb2F0IGRvZiA9IDEuMDtcXG5cXFxuXHRcdFx0XHRpZihkaWZmIDw9IHVfcmFuZ2UpXFxuXFxcblx0XHRcdFx0XHRkb2YgPSBkaWZmIC8gdV9yYW5nZTtcXG5cXFxuXHRcdFx0ICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChkb2YpO1xcblxcXG5cdFx0XHQjZW5kaWZcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcInRleHR1cmUvZGVwdGhfcmFuZ2VcIiwgTEdyYXBoVGV4dHVyZURlcHRoUmFuZ2UgKTtcblxuXG5cdC8vIFRleHR1cmUgRGVwdGggKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZUxpbmVhckRlcHRoKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxULFxuXHRcdFx0aW52ZXJ0OiBmYWxzZVxuXHRcdH07XG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7XG5cdFx0XHR1X3RleHR1cmU6IDAsXG5cdFx0XHR1X2NhbWVyYV9wbGFuZXM6IG51bGwsIC8vZmlsbGVkIGxhdGVyXG5cdFx0XHR1X2lyZXM6IHZlYzIuY3JlYXRlKClcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUxpbmVhckRlcHRoLndpZGdldHNfaW5mbyA9IHtcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUxpbmVhckRlcHRoLnRpdGxlID0gXCJMaW5lYXIgRGVwdGhcIjtcblx0TEdyYXBoVGV4dHVyZUxpbmVhckRlcHRoLmRlc2MgPSBcIkNyZWF0ZXMgYSBjb2xvciB0ZXh0dXJlIHdpdGggbGluZWFyIGRlcHRoXCI7XG5cblx0TEdyYXBoVGV4dHVyZUxpbmVhckRlcHRoLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4IHx8ICh0ZXguZm9ybWF0ICE9IGdsLkRFUFRIX0NPTVBPTkVOVCAmJiB0ZXguZm9ybWF0ICE9IGdsLkRFUFRIX1NURU5DSUwpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBwcmVjaXNpb24gPSB0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09IExHcmFwaFRleHR1cmUuSElHSCA/IGdsLkhJR0hfUFJFQ0lTSU9OX0ZPUk1BVCA6IGdsLlVOU0lHTkVEX0JZVEU7XG5cblx0XHRpZiAoICF0aGlzLl90ZW1wX3RleHR1cmUgfHwgdGhpcy5fdGVtcF90ZXh0dXJlLnR5cGUgIT0gcHJlY2lzaW9uIHx8IHRoaXMuX3RlbXBfdGV4dHVyZS53aWR0aCAhPSB0ZXgud2lkdGggfHwgdGhpcy5fdGVtcF90ZXh0dXJlLmhlaWdodCAhPSB0ZXguaGVpZ2h0ICkge1xuXHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUodGV4LndpZHRoLCB0ZXguaGVpZ2h0LCB7XG5cdFx0XHRcdHR5cGU6IHByZWNpc2lvbixcblx0XHRcdFx0Zm9ybWF0OiBnbC5SR0IsXG5cdFx0XHRcdGZpbHRlcjogZ2wuTElORUFSXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3Jtcztcblx0XHR1bmlmb3Jtcy51X2ludmVydCA9IHRoaXMucHJvcGVydGllcy5pbnZlcnQgPyAxIDogMDtcblxuXHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0dmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcblx0XHRpZighTEdyYXBoVGV4dHVyZUxpbmVhckRlcHRoLl9zaGFkZXIpXG5cdFx0XHRMR3JhcGhUZXh0dXJlTGluZWFyRGVwdGguX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoIEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUiwgTEdyYXBoVGV4dHVyZUxpbmVhckRlcHRoLnBpeGVsX3NoYWRlcik7XG5cdFx0dmFyIHNoYWRlciA9IExHcmFwaFRleHR1cmVMaW5lYXJEZXB0aC5fc2hhZGVyO1xuXG5cdFx0Ly9ORUFSIEFORCBGQVIgUExBTkVTXG5cdFx0dmFyIHBsYW5lcyA9IG51bGw7XG5cdFx0aWYgKHRleC5uZWFyX2Zhcl9wbGFuZXMpIHtcblx0XHRcdHBsYW5lcyA9IHRleC5uZWFyX2Zhcl9wbGFuZXM7XG5cdFx0fSBlbHNlIGlmICh3aW5kb3cuTFMgJiYgTFMuUmVuZGVyZXIuX21haW5fY2FtZXJhKSB7XG5cdFx0XHRwbGFuZXMgPSBMUy5SZW5kZXJlci5fbWFpbl9jYW1lcmEuX3VuaWZvcm1zLnVfY2FtZXJhX3BsYW5lcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGxhbmVzID0gWzAuMSwgMTAwMF07XG5cdFx0fSAvL2hhcmRjb2RlZFxuXHRcdHVuaWZvcm1zLnVfY2FtZXJhX3BsYW5lcyA9IHBsYW5lcztcblx0XHQvL3VuaWZvcm1zLnVfaXJlcy5zZXQoWzEvdGV4LndpZHRoLCAxL3RleC5oZWlnaHRdKTtcblx0XHR1bmlmb3Jtcy51X2lyZXMuc2V0KFswLDBdKTtcblxuXHRcdHRoaXMuX3RlbXBfdGV4dHVyZS5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHR0ZXguYmluZCgwKTtcblx0XHRcdHNoYWRlci51bmlmb3Jtcyh1bmlmb3JtcykuZHJhdyhtZXNoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX3RlbXBfdGV4dHVyZS5uZWFyX2Zhcl9wbGFuZXMgPSBwbGFuZXM7XG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RlbXBfdGV4dHVyZSk7XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUxpbmVhckRlcHRoLnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjMiB1X2NhbWVyYV9wbGFuZXM7XFxuXFxcblx0XHR1bmlmb3JtIGludCB1X2ludmVydDtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjMiB1X2lyZXM7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0ZmxvYXQgek5lYXIgPSB1X2NhbWVyYV9wbGFuZXMueDtcXG5cXFxuXHRcdFx0ZmxvYXQgekZhciA9IHVfY2FtZXJhX3BsYW5lcy55O1xcblxcXG5cdFx0XHRmbG9hdCBkZXB0aCA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQgKyB1X2lyZXMqMC41KS54ICogMi4wIC0gMS4wO1xcblxcXG5cdFx0XHRmbG9hdCBmID0gek5lYXIgKiAoZGVwdGggKyAxLjApIC8gKHpGYXIgKyB6TmVhciAtIGRlcHRoICogKHpGYXIgLSB6TmVhcikpO1xcblxcXG5cdFx0XHRpZiggdV9pbnZlcnQgPT0gMSApXFxuXFxcblx0XHRcdFx0ZiA9IDEuMCAtIGY7XFxuXFxcblx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQodmVjMyhmKSwxLjApO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwidGV4dHVyZS9saW5lYXJfZGVwdGhcIiwgTEdyYXBoVGV4dHVyZUxpbmVhckRlcHRoICk7XG5cblx0Ly8gVGV4dHVyZSBCbHVyICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVCbHVyKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiSXRlcmF0aW9uc1wiLCBcIm51bWJlclwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiSW50ZW5zaXR5XCIsIFwibnVtYmVyXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwiQmx1cnJlZFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0aW50ZW5zaXR5OiAxLFxuXHRcdFx0aXRlcmF0aW9uczogMSxcblx0XHRcdHByZXNlcnZlX2FzcGVjdDogZmFsc2UsXG5cdFx0XHRzY2FsZTogWzEsIDFdLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFRcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUJsdXIudGl0bGUgPSBcIkJsdXJcIjtcblx0TEdyYXBoVGV4dHVyZUJsdXIuZGVzYyA9IFwiQmx1ciBhIHRleHR1cmVcIjtcblxuXHRMR3JhcGhUZXh0dXJlQmx1ci53aWRnZXRzX2luZm8gPSB7XG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVCbHVyLm1heF9pdGVyYXRpb25zID0gMjA7XG5cblx0TEdyYXBoVGV4dHVyZUJsdXIucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHR2YXIgdGVtcCA9IHRoaXMuX2ZpbmFsX3RleHR1cmU7XG5cblx0XHRpZiAoXG5cdFx0XHQhdGVtcCB8fFxuXHRcdFx0dGVtcC53aWR0aCAhPSB0ZXgud2lkdGggfHxcblx0XHRcdHRlbXAuaGVpZ2h0ICE9IHRleC5oZWlnaHQgfHxcblx0XHRcdHRlbXAudHlwZSAhPSB0ZXgudHlwZVxuXHRcdCkge1xuXHRcdFx0Ly93ZSBuZWVkIHR3byB0ZXh0dXJlcyB0byBkbyB0aGUgYmx1cnJpbmdcblx0XHRcdC8vdGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoIHRleC53aWR0aCwgdGV4LmhlaWdodCwgeyB0eXBlOiB0ZXgudHlwZSwgZm9ybWF0OiBnbC5SR0JBLCBmaWx0ZXI6IGdsLkxJTkVBUiB9KTtcblx0XHRcdHRlbXAgPSB0aGlzLl9maW5hbF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoXG5cdFx0XHRcdHRleC53aWR0aCxcblx0XHRcdFx0dGV4LmhlaWdodCxcblx0XHRcdFx0eyB0eXBlOiB0ZXgudHlwZSwgZm9ybWF0OiBnbC5SR0JBLCBmaWx0ZXI6IGdsLkxJTkVBUiB9XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vaXRlcmF0aW9uc1xuXHRcdHZhciBpdGVyYXRpb25zID0gdGhpcy5wcm9wZXJ0aWVzLml0ZXJhdGlvbnM7XG5cdFx0aWYgKHRoaXMuaXNJbnB1dENvbm5lY3RlZCgxKSkge1xuXHRcdFx0aXRlcmF0aW9ucyA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLml0ZXJhdGlvbnMgPSBpdGVyYXRpb25zO1xuXHRcdH1cblx0XHRpdGVyYXRpb25zID0gTWF0aC5taW4oXG5cdFx0XHRNYXRoLmZsb29yKGl0ZXJhdGlvbnMpLFxuXHRcdFx0TEdyYXBoVGV4dHVyZUJsdXIubWF4X2l0ZXJhdGlvbnNcblx0XHQpO1xuXHRcdGlmIChpdGVyYXRpb25zID09IDApIHtcblx0XHRcdC8vc2tpcCBibHVycmluZ1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGludGVuc2l0eSA9IHRoaXMucHJvcGVydGllcy5pbnRlbnNpdHk7XG5cdFx0aWYgKHRoaXMuaXNJbnB1dENvbm5lY3RlZCgyKSkge1xuXHRcdFx0aW50ZW5zaXR5ID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMuaW50ZW5zaXR5ID0gaW50ZW5zaXR5O1xuXHRcdH1cblxuXHRcdC8vYmx1ciBzb21ldGltZXMgbmVlZHMgYW4gYXNwZWN0IGNvcnJlY3Rpb25cblx0XHR2YXIgYXNwZWN0ID0gTGl0ZUdyYXBoLmNhbWVyYV9hc3BlY3Q7XG5cdFx0aWYgKCFhc3BlY3QgJiYgd2luZG93LmdsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGFzcGVjdCA9IGdsLmNhbnZhcy5oZWlnaHQgLyBnbC5jYW52YXMud2lkdGg7XG5cdFx0fVxuXHRcdGlmICghYXNwZWN0KSB7XG5cdFx0XHRhc3BlY3QgPSAxO1xuXHRcdH1cblx0XHRhc3BlY3QgPSB0aGlzLnByb3BlcnRpZXMucHJlc2VydmVfYXNwZWN0ID8gYXNwZWN0IDogMTtcblxuXHRcdHZhciBzY2FsZSA9IHRoaXMucHJvcGVydGllcy5zY2FsZSB8fCBbMSwgMV07XG5cdFx0dGV4LmFwcGx5Qmx1cihhc3BlY3QgKiBzY2FsZVswXSwgc2NhbGVbMV0sIGludGVuc2l0eSwgdGVtcCk7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBpdGVyYXRpb25zOyArK2kpIHtcblx0XHRcdHRlbXAuYXBwbHlCbHVyKFxuXHRcdFx0XHRhc3BlY3QgKiBzY2FsZVswXSAqIChpICsgMSksXG5cdFx0XHRcdHNjYWxlWzFdICogKGkgKyAxKSxcblx0XHRcdFx0aW50ZW5zaXR5XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZW1wKTtcblx0fTtcblxuXHQvKlxuTEdyYXBoVGV4dHVyZUJsdXIucGl4ZWxfc2hhZGVyID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjMiB1X29mZnNldDtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9pbnRlbnNpdHk7XFxuXFxcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHQgICB2ZWM0IHN1bSA9IHZlYzQoMC4wKTtcXG5cXFxuXHRcdCAgIHZlYzQgY2VudGVyID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCk7XFxuXFxcblx0XHQgICBzdW0gKz0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCArIHVfb2Zmc2V0ICogLTQuMCkgKiAwLjA1LzAuOTg7XFxuXFxcblx0XHQgICBzdW0gKz0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCArIHVfb2Zmc2V0ICogLTMuMCkgKiAwLjA5LzAuOTg7XFxuXFxcblx0XHQgICBzdW0gKz0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCArIHVfb2Zmc2V0ICogLTIuMCkgKiAwLjEyLzAuOTg7XFxuXFxcblx0XHQgICBzdW0gKz0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCArIHVfb2Zmc2V0ICogLTEuMCkgKiAwLjE1LzAuOTg7XFxuXFxcblx0XHQgICBzdW0gKz0gY2VudGVyICogMC4xNi8wLjk4O1xcblxcXG5cdFx0ICAgc3VtICs9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQgKyB1X29mZnNldCAqIDQuMCkgKiAwLjA1LzAuOTg7XFxuXFxcblx0XHQgICBzdW0gKz0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCArIHVfb2Zmc2V0ICogMy4wKSAqIDAuMDkvMC45ODtcXG5cXFxuXHRcdCAgIHN1bSArPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkICsgdV9vZmZzZXQgKiAyLjApICogMC4xMi8wLjk4O1xcblxcXG5cdFx0ICAgc3VtICs9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQgKyB1X29mZnNldCAqIDEuMCkgKiAwLjE1LzAuOTg7XFxuXFxcblx0XHQgICBnbF9GcmFnQ29sb3IgPSB1X2ludGVuc2l0eSAqIHN1bTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFwiO1xuKi9cblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvYmx1clwiLCBMR3JhcGhUZXh0dXJlQmx1cik7XG5cblx0Ly9JbmRlcGVuZGVudCBnbG93IEZYXG5cdC8vYmFzZWQgb24gaHR0cHM6Ly9jYXRsaWtlY29kaW5nLmNvbS91bml0eS90dXRvcmlhbHMvYWR2YW5jZWQtcmVuZGVyaW5nL2Jsb29tL1xuXHRmdW5jdGlvbiBGWEdsb3coKVxuXHR7XG5cdFx0dGhpcy5pbnRlbnNpdHkgPSAwLjU7XG5cdFx0dGhpcy5wZXJzaXN0ZW5jZSA9IDAuNjtcblx0XHR0aGlzLml0ZXJhdGlvbnMgPSA4O1xuXHRcdHRoaXMudGhyZXNob2xkID0gMC44O1xuXHRcdHRoaXMuc2NhbGUgPSAxO1xuXG5cdFx0dGhpcy5kaXJ0X3RleHR1cmUgPSBudWxsO1xuXHRcdHRoaXMuZGlydF9mYWN0b3IgPSAwLjU7XG5cblx0XHR0aGlzLl90ZXh0dXJlcyA9IFtdO1xuXHRcdHRoaXMuX3VuaWZvcm1zID0ge1xuXHRcdFx0dV9pbnRlbnNpdHk6IDEsXG5cdFx0XHR1X3RleHR1cmU6IDAsXG5cdFx0XHR1X2dsb3dfdGV4dHVyZTogMSxcblx0XHRcdHVfdGhyZXNob2xkOiAwLFxuXHRcdFx0dV90ZXhlbF9zaXplOiB2ZWMyLmNyZWF0ZSgpXG5cdFx0fTtcblx0fVxuXG5cdEZYR2xvdy5wcm90b3R5cGUuYXBwbHlGWCA9IGZ1bmN0aW9uKCB0ZXgsIG91dHB1dF90ZXh0dXJlLCBnbG93X3RleHR1cmUsIGF2ZXJhZ2VfdGV4dHVyZSApIHtcblxuXHRcdHZhciB3aWR0aCA9IHRleC53aWR0aDtcblx0XHR2YXIgaGVpZ2h0ID0gdGV4LmhlaWdodDtcblxuXHRcdHZhciB0ZXh0dXJlX2luZm8gPSB7XG5cdFx0XHRmb3JtYXQ6IHRleC5mb3JtYXQsXG5cdFx0XHR0eXBlOiB0ZXgudHlwZSxcblx0XHRcdG1pbkZpbHRlcjogR0wuTElORUFSLFxuXHRcdFx0bWFnRmlsdGVyOiBHTC5MSU5FQVIsXG5cdFx0XHR3cmFwOiBnbC5DTEFNUF9UT19FREdFXG5cdFx0fTtcblxuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXHRcdHZhciB0ZXh0dXJlcyA9IHRoaXMuX3RleHR1cmVzO1xuXG5cdFx0Ly9jdXRcblx0XHR2YXIgc2hhZGVyID0gRlhHbG93Ll9jdXRfc2hhZGVyO1xuXHRcdGlmICghc2hhZGVyKSB7XG5cdFx0XHRzaGFkZXIgPSBGWEdsb3cuX2N1dF9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdEZYR2xvdy5jdXRfcGl4ZWxfc2hhZGVyXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cblx0XHR1bmlmb3Jtcy51X3RocmVzaG9sZCA9IHRoaXMudGhyZXNob2xkO1xuXHRcdHZhciBjdXJyZW50RGVzdGluYXRpb24gPSAodGV4dHVyZXNbMF0gPSBHTC5UZXh0dXJlLmdldFRlbXBvcmFyeShcblx0XHRcdHdpZHRoLFxuXHRcdFx0aGVpZ2h0LFxuXHRcdFx0dGV4dHVyZV9pbmZvXG5cdFx0KSk7XG5cdFx0dGV4LmJsaXQoIGN1cnJlbnREZXN0aW5hdGlvbiwgc2hhZGVyLnVuaWZvcm1zKHVuaWZvcm1zKSApO1xuXHRcdHZhciBjdXJyZW50U291cmNlID0gY3VycmVudERlc3RpbmF0aW9uO1xuXG5cdFx0dmFyIGl0ZXJhdGlvbnMgPSB0aGlzLml0ZXJhdGlvbnM7XG5cdFx0aXRlcmF0aW9ucyA9IGNsYW1wKGl0ZXJhdGlvbnMsIDEsIDE2KSB8IDA7XG5cdFx0dmFyIHRleGVsX3NpemUgPSB1bmlmb3Jtcy51X3RleGVsX3NpemU7XG5cdFx0dmFyIGludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuXG5cdFx0dW5pZm9ybXMudV9pbnRlbnNpdHkgPSAxO1xuXHRcdHVuaWZvcm1zLnVfZGVsdGEgPSB0aGlzLnNjYWxlOyAvLzFcblxuXHRcdC8vZG93bnNjYWxlL3Vwc2NhbGUgc2hhZGVyXG5cdFx0dmFyIHNoYWRlciA9IEZYR2xvdy5fc2hhZGVyO1xuXHRcdGlmICghc2hhZGVyKSB7XG5cdFx0XHRzaGFkZXIgPSBGWEdsb3cuX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0RlhHbG93LnNjYWxlX3BpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR2YXIgaSA9IDE7XG5cdFx0Ly9kb3duc2NhbGVcblx0XHRmb3IgKDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuXHRcdFx0d2lkdGggPSB3aWR0aCA+PiAxO1xuXHRcdFx0aWYgKChoZWlnaHQgfCAwKSA+IDEpIHtcblx0XHRcdFx0aGVpZ2h0ID0gaGVpZ2h0ID4+IDE7XG5cdFx0XHR9XG5cdFx0XHRpZiAod2lkdGggPCAyKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudERlc3RpbmF0aW9uID0gdGV4dHVyZXNbaV0gPSBHTC5UZXh0dXJlLmdldFRlbXBvcmFyeShcblx0XHRcdFx0d2lkdGgsXG5cdFx0XHRcdGhlaWdodCxcblx0XHRcdFx0dGV4dHVyZV9pbmZvXG5cdFx0XHQpO1xuXHRcdFx0dGV4ZWxfc2l6ZVswXSA9IDEgLyBjdXJyZW50U291cmNlLndpZHRoO1xuXHRcdFx0dGV4ZWxfc2l6ZVsxXSA9IDEgLyBjdXJyZW50U291cmNlLmhlaWdodDtcblx0XHRcdGN1cnJlbnRTb3VyY2UuYmxpdChcblx0XHRcdFx0Y3VycmVudERlc3RpbmF0aW9uLFxuXHRcdFx0XHRzaGFkZXIudW5pZm9ybXModW5pZm9ybXMpXG5cdFx0XHQpO1xuXHRcdFx0Y3VycmVudFNvdXJjZSA9IGN1cnJlbnREZXN0aW5hdGlvbjtcblx0XHR9XG5cblx0XHQvL2F2ZXJhZ2Vcblx0XHRpZiAoYXZlcmFnZV90ZXh0dXJlKSB7XG5cdFx0XHR0ZXhlbF9zaXplWzBdID0gMSAvIGN1cnJlbnRTb3VyY2Uud2lkdGg7XG5cdFx0XHR0ZXhlbF9zaXplWzFdID0gMSAvIGN1cnJlbnRTb3VyY2UuaGVpZ2h0O1xuXHRcdFx0dW5pZm9ybXMudV9pbnRlbnNpdHkgPSBpbnRlbnNpdHk7XG5cdFx0XHR1bmlmb3Jtcy51X2RlbHRhID0gMTtcblx0XHRcdGN1cnJlbnRTb3VyY2UuYmxpdChhdmVyYWdlX3RleHR1cmUsIHNoYWRlci51bmlmb3Jtcyh1bmlmb3JtcykpO1xuXHRcdH1cblxuXHRcdC8vdXBzY2FsZSBhbmQgYmxlbmRcblx0XHRnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXHRcdGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORSk7XG5cdFx0dW5pZm9ybXMudV9pbnRlbnNpdHkgPSB0aGlzLnBlcnNpc3RlbmNlO1xuXHRcdHVuaWZvcm1zLnVfZGVsdGEgPSAwLjU7XG5cblx0XHQvLyBpLT0yID0+IC0xIHRvIHBvaW50IHRvIGxhc3QgZWxlbWVudCBpbiBhcnJheSwgLTEgdG8gZ28gdG8gdGV4dHVyZSBhYm92ZVxuXHRcdGZvciAoIGkgLT0gMjsgaSA+PSAwOyBpLS0gKSBcblx0XHR7XG5cdFx0XHRjdXJyZW50RGVzdGluYXRpb24gPSB0ZXh0dXJlc1tpXTtcblx0XHRcdHRleHR1cmVzW2ldID0gbnVsbDtcblx0XHRcdHRleGVsX3NpemVbMF0gPSAxIC8gY3VycmVudFNvdXJjZS53aWR0aDtcblx0XHRcdHRleGVsX3NpemVbMV0gPSAxIC8gY3VycmVudFNvdXJjZS5oZWlnaHQ7XG5cdFx0XHRjdXJyZW50U291cmNlLmJsaXQoXG5cdFx0XHRcdGN1cnJlbnREZXN0aW5hdGlvbixcblx0XHRcdFx0c2hhZGVyLnVuaWZvcm1zKHVuaWZvcm1zKVxuXHRcdFx0KTtcblx0XHRcdEdMLlRleHR1cmUucmVsZWFzZVRlbXBvcmFyeShjdXJyZW50U291cmNlKTtcblx0XHRcdGN1cnJlbnRTb3VyY2UgPSBjdXJyZW50RGVzdGluYXRpb247XG5cdFx0fVxuXHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXG5cdFx0Ly9nbG93XG5cdFx0aWYgKGdsb3dfdGV4dHVyZSkge1xuXHRcdFx0Y3VycmVudFNvdXJjZS5ibGl0KGdsb3dfdGV4dHVyZSk7XG5cdFx0fVxuXG5cdFx0Ly9maW5hbCBjb21wb3NpdGlvblxuXHRcdGlmICggb3V0cHV0X3RleHR1cmUgKSB7XG5cdFx0XHR2YXIgZmluYWxfdGV4dHVyZSA9IG91dHB1dF90ZXh0dXJlO1xuXHRcdFx0dmFyIGRpcnRfdGV4dHVyZSA9IHRoaXMuZGlydF90ZXh0dXJlO1xuXHRcdFx0dmFyIGRpcnRfZmFjdG9yID0gdGhpcy5kaXJ0X2ZhY3Rvcjtcblx0XHRcdHVuaWZvcm1zLnVfaW50ZW5zaXR5ID0gaW50ZW5zaXR5O1xuXG5cdFx0XHRzaGFkZXIgPSBkaXJ0X3RleHR1cmVcblx0XHRcdFx0PyBGWEdsb3cuX2RpcnRfZmluYWxfc2hhZGVyXG5cdFx0XHRcdDogRlhHbG93Ll9maW5hbF9zaGFkZXI7XG5cdFx0XHRpZiAoIXNoYWRlcikge1xuXHRcdFx0XHRpZiAoZGlydF90ZXh0dXJlKSB7XG5cdFx0XHRcdFx0c2hhZGVyID0gRlhHbG93Ll9kaXJ0X2ZpbmFsX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdFx0XHRHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdFx0XHRGWEdsb3cuZmluYWxfcGl4ZWxfc2hhZGVyLFxuXHRcdFx0XHRcdFx0eyBVU0VfRElSVDogXCJcIiB9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzaGFkZXIgPSBGWEdsb3cuX2ZpbmFsX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdFx0XHRHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdFx0XHRGWEdsb3cuZmluYWxfcGl4ZWxfc2hhZGVyXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmaW5hbF90ZXh0dXJlLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHRcdGN1cnJlbnRTb3VyY2UuYmluZCgxKTtcblx0XHRcdFx0aWYgKGRpcnRfdGV4dHVyZSkge1xuXHRcdFx0XHRcdHNoYWRlci5zZXRVbmlmb3JtKFwidV9kaXJ0X2ZhY3RvclwiLCBkaXJ0X2ZhY3Rvcik7XG5cdFx0XHRcdFx0c2hhZGVyLnNldFVuaWZvcm0oXG5cdFx0XHRcdFx0XHRcInVfZGlydF90ZXh0dXJlXCIsXG5cdFx0XHRcdFx0XHRkaXJ0X3RleHR1cmUuYmluZCgyKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2hhZGVyLnRvVmlld3BvcnQodW5pZm9ybXMpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0R0wuVGV4dHVyZS5yZWxlYXNlVGVtcG9yYXJ5KGN1cnJlbnRTb3VyY2UpO1xuXHR9O1xuXG5cdEZYR2xvdy5jdXRfcGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0dW5pZm9ybSBmbG9hdCB1X3RocmVzaG9sZDtcXG5cXFxuXHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRnbF9GcmFnQ29sb3IgPSBtYXgoIHRleHR1cmUyRCggdV90ZXh0dXJlLCB2X2Nvb3JkICkgLSB2ZWM0KCB1X3RocmVzaG9sZCApLCB2ZWM0KDAuMCkgKTtcXG5cXFxuXHR9XCI7XG5cblx0RlhHbG93LnNjYWxlX3BpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdHVuaWZvcm0gdmVjMiB1X3RleGVsX3NpemU7XFxuXFxcblx0dW5pZm9ybSBmbG9hdCB1X2RlbHRhO1xcblxcXG5cdHVuaWZvcm0gZmxvYXQgdV9pbnRlbnNpdHk7XFxuXFxcblx0XFxuXFxcblx0dmVjNCBzYW1wbGVCb3godmVjMiB1dikge1xcblxcXG5cdFx0dmVjNCBvID0gdV90ZXhlbF9zaXplLnh5eHkgKiB2ZWMyKC11X2RlbHRhLCB1X2RlbHRhKS54eHl5O1xcblxcXG5cdFx0dmVjNCBzID0gdGV4dHVyZTJEKCB1X3RleHR1cmUsIHV2ICsgby54eSApICsgdGV4dHVyZTJEKCB1X3RleHR1cmUsIHV2ICsgby56eSkgKyB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgdXYgKyBvLnh3KSArIHRleHR1cmUyRCggdV90ZXh0dXJlLCB1diArIG8uencpO1xcblxcXG5cdFx0cmV0dXJuIHMgKiAwLjI1O1xcblxcXG5cdH1cXG5cXFxuXHR2b2lkIG1haW4oKSB7XFxuXFxcblx0XHRnbF9GcmFnQ29sb3IgPSB1X2ludGVuc2l0eSAqIHNhbXBsZUJveCggdl9jb29yZCApO1xcblxcXG5cdH1cIjtcblxuXHRGWEdsb3cuZmluYWxfcGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0dW5pZm9ybSBzYW1wbGVyMkQgdV9nbG93X3RleHR1cmU7XFxuXFxcblx0I2lmZGVmIFVTRV9ESVJUXFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X2RpcnRfdGV4dHVyZTtcXG5cXFxuXHQjZW5kaWZcXG5cXFxuXHR1bmlmb3JtIHZlYzIgdV90ZXhlbF9zaXplO1xcblxcXG5cdHVuaWZvcm0gZmxvYXQgdV9kZWx0YTtcXG5cXFxuXHR1bmlmb3JtIGZsb2F0IHVfaW50ZW5zaXR5O1xcblxcXG5cdHVuaWZvcm0gZmxvYXQgdV9kaXJ0X2ZhY3RvcjtcXG5cXFxuXHRcXG5cXFxuXHR2ZWM0IHNhbXBsZUJveCh2ZWMyIHV2KSB7XFxuXFxcblx0XHR2ZWM0IG8gPSB1X3RleGVsX3NpemUueHl4eSAqIHZlYzIoLXVfZGVsdGEsIHVfZGVsdGEpLnh4eXk7XFxuXFxcblx0XHR2ZWM0IHMgPSB0ZXh0dXJlMkQoIHVfZ2xvd190ZXh0dXJlLCB1diArIG8ueHkgKSArIHRleHR1cmUyRCggdV9nbG93X3RleHR1cmUsIHV2ICsgby56eSkgKyB0ZXh0dXJlMkQoIHVfZ2xvd190ZXh0dXJlLCB1diArIG8ueHcpICsgdGV4dHVyZTJEKCB1X2dsb3dfdGV4dHVyZSwgdXYgKyBvLnp3KTtcXG5cXFxuXHRcdHJldHVybiBzICogMC4yNTtcXG5cXFxuXHR9XFxuXFxcblx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0dmVjNCBnbG93ID0gc2FtcGxlQm94KCB2X2Nvb3JkICk7XFxuXFxcblx0XHQjaWZkZWYgVVNFX0RJUlRcXG5cXFxuXHRcdFx0Z2xvdyA9IG1peCggZ2xvdywgZ2xvdyAqIHRleHR1cmUyRCggdV9kaXJ0X3RleHR1cmUsIHZfY29vcmQgKSwgdV9kaXJ0X2ZhY3RvciApO1xcblxcXG5cdFx0I2VuZGlmXFxuXFxcblx0XHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgdl9jb29yZCApICsgdV9pbnRlbnNpdHkgKiBnbG93O1xcblxcXG5cdH1cIjtcblxuXG5cdC8vIFRleHR1cmUgR2xvdyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlR2xvdygpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJkaXJ0XCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJnbG93XCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0aW50ZW5zaXR5OiAxLFxuXHRcdFx0cGVyc2lzdGVuY2U6IDAuOTksXG5cdFx0XHRpdGVyYXRpb25zOiAxNixcblx0XHRcdHRocmVzaG9sZDogMCxcblx0XHRcdHNjYWxlOiAxLFxuXHRcdFx0ZGlydF9mYWN0b3I6IDAuNSxcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXG5cdFx0fTtcblxuXHRcdHRoaXMuZnggPSBuZXcgRlhHbG93KCk7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlR2xvdy50aXRsZSA9IFwiR2xvd1wiO1xuXHRMR3JhcGhUZXh0dXJlR2xvdy5kZXNjID0gXCJGaWx0ZXJzIGEgdGV4dHVyZSBnaXZpbmcgaXQgYSBnbG93IGVmZmVjdFwiO1xuXG5cdExHcmFwaFRleHR1cmVHbG93LndpZGdldHNfaW5mbyA9IHtcblx0XHRpdGVyYXRpb25zOiB7XG5cdFx0XHR0eXBlOiBcIm51bWJlclwiLFxuXHRcdFx0bWluOiAwLFxuXHRcdFx0bWF4OiAxNixcblx0XHRcdHN0ZXA6IDEsXG5cdFx0XHRwcmVjaXNpb246IDBcblx0XHR9LFxuXHRcdHRocmVzaG9sZDoge1xuXHRcdFx0dHlwZTogXCJudW1iZXJcIixcblx0XHRcdG1pbjogMCxcblx0XHRcdG1heDogMTAsXG5cdFx0XHRzdGVwOiAwLjAxLFxuXHRcdFx0cHJlY2lzaW9uOiAyXG5cdFx0fSxcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUdsb3cucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdFtcImVuYWJsZWRcIiwgXCJib29sZWFuXCJdLFxuXHRcdFx0W1widGhyZXNob2xkXCIsIFwibnVtYmVyXCJdLFxuXHRcdFx0W1wiaW50ZW5zaXR5XCIsIFwibnVtYmVyXCJdLFxuXHRcdFx0W1wicGVyc2lzdGVuY2VcIiwgXCJudW1iZXJcIl0sXG5cdFx0XHRbXCJpdGVyYXRpb25zXCIsIFwibnVtYmVyXCJdLFxuXHRcdFx0W1wiZGlydF9mYWN0b3JcIiwgXCJudW1iZXJcIl1cblx0XHRdO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVHbG93LnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gW1tcImF2ZXJhZ2VcIiwgXCJUZXh0dXJlXCJdXTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlR2xvdy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzQW55T3V0cHV0Q29ubmVjdGVkKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vc2F2ZXMgd29ya1xuXG5cdFx0aWYgKFxuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5QQVNTX1RIUk9VR0ggfHxcblx0XHRcdHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwiZW5hYmxlZFwiKSA9PT0gZmFsc2Vcblx0XHQpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB3aWR0aCA9IHRleC53aWR0aDtcblx0XHR2YXIgaGVpZ2h0ID0gdGV4LmhlaWdodDtcblxuXHRcdHZhciBmeCA9IHRoaXMuZng7XG5cdFx0ZngudGhyZXNob2xkID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJ0aHJlc2hvbGRcIik7XG5cdFx0ZnguaXRlcmF0aW9ucyA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwiaXRlcmF0aW9uc1wiKTtcblx0XHRmeC5pbnRlbnNpdHkgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcImludGVuc2l0eVwiKTtcblx0XHRmeC5wZXJzaXN0ZW5jZSA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwicGVyc2lzdGVuY2VcIik7XG5cdFx0ZnguZGlydF90ZXh0dXJlID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cdFx0ZnguZGlydF9mYWN0b3IgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcImRpcnRfZmFjdG9yXCIpO1xuXHRcdGZ4LnNjYWxlID0gdGhpcy5wcm9wZXJ0aWVzLnNjYWxlO1xuXG5cdFx0dmFyIHR5cGUgPSBMR3JhcGhUZXh0dXJlLmdldFRleHR1cmVUeXBlKCB0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uLCB0ZXggKTtcblxuXHRcdHZhciBhdmVyYWdlX3RleHR1cmUgPSBudWxsO1xuXHRcdGlmICh0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDIpKSB7XG5cdFx0XHRhdmVyYWdlX3RleHR1cmUgPSB0aGlzLl9hdmVyYWdlX3RleHR1cmU7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCFhdmVyYWdlX3RleHR1cmUgfHxcblx0XHRcdFx0YXZlcmFnZV90ZXh0dXJlLnR5cGUgIT0gdGV4LnR5cGUgfHxcblx0XHRcdFx0YXZlcmFnZV90ZXh0dXJlLmZvcm1hdCAhPSB0ZXguZm9ybWF0XG5cdFx0XHQpIHtcblx0XHRcdFx0YXZlcmFnZV90ZXh0dXJlID0gdGhpcy5fYXZlcmFnZV90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoXG5cdFx0XHRcdFx0MSxcblx0XHRcdFx0XHQxLFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHR5cGU6IHRleC50eXBlLFxuXHRcdFx0XHRcdFx0Zm9ybWF0OiB0ZXguZm9ybWF0LFxuXHRcdFx0XHRcdFx0ZmlsdGVyOiBnbC5MSU5FQVJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGdsb3dfdGV4dHVyZSA9IG51bGw7XG5cdFx0aWYgKHRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMSkpIHtcblx0XHRcdGdsb3dfdGV4dHVyZSA9IHRoaXMuX2dsb3dfdGV4dHVyZTtcblx0XHRcdGlmIChcblx0XHRcdFx0IWdsb3dfdGV4dHVyZSB8fFxuXHRcdFx0XHRnbG93X3RleHR1cmUud2lkdGggIT0gdGV4LndpZHRoIHx8XG5cdFx0XHRcdGdsb3dfdGV4dHVyZS5oZWlnaHQgIT0gdGV4LmhlaWdodCB8fFxuXHRcdFx0XHRnbG93X3RleHR1cmUudHlwZSAhPSB0eXBlIHx8XG5cdFx0XHRcdGdsb3dfdGV4dHVyZS5mb3JtYXQgIT0gdGV4LmZvcm1hdFxuXHRcdFx0KSB7XG5cdFx0XHRcdGdsb3dfdGV4dHVyZSA9IHRoaXMuX2dsb3dfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKFxuXHRcdFx0XHRcdHRleC53aWR0aCxcblx0XHRcdFx0XHR0ZXguaGVpZ2h0LFxuXHRcdFx0XHRcdHsgdHlwZTogdHlwZSwgZm9ybWF0OiB0ZXguZm9ybWF0LCBmaWx0ZXI6IGdsLkxJTkVBUiB9XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGZpbmFsX3RleHR1cmUgPSBudWxsO1xuXHRcdGlmICh0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRmaW5hbF90ZXh0dXJlID0gdGhpcy5fZmluYWxfdGV4dHVyZTtcblx0XHRcdGlmIChcblx0XHRcdFx0IWZpbmFsX3RleHR1cmUgfHxcblx0XHRcdFx0ZmluYWxfdGV4dHVyZS53aWR0aCAhPSB0ZXgud2lkdGggfHxcblx0XHRcdFx0ZmluYWxfdGV4dHVyZS5oZWlnaHQgIT0gdGV4LmhlaWdodCB8fFxuXHRcdFx0XHRmaW5hbF90ZXh0dXJlLnR5cGUgIT0gdHlwZSB8fFxuXHRcdFx0XHRmaW5hbF90ZXh0dXJlLmZvcm1hdCAhPSB0ZXguZm9ybWF0XG5cdFx0XHQpIHtcblx0XHRcdFx0ZmluYWxfdGV4dHVyZSA9IHRoaXMuX2ZpbmFsX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZShcblx0XHRcdFx0XHR0ZXgud2lkdGgsXG5cdFx0XHRcdFx0dGV4LmhlaWdodCxcblx0XHRcdFx0XHR7IHR5cGU6IHR5cGUsIGZvcm1hdDogdGV4LmZvcm1hdCwgZmlsdGVyOiBnbC5MSU5FQVIgfVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9hcHBseSBGWFxuXHRcdGZ4LmFwcGx5RlgodGV4LCBmaW5hbF90ZXh0dXJlLCBnbG93X3RleHR1cmUsIGF2ZXJhZ2VfdGV4dHVyZSApO1xuXG5cdFx0aWYgKHRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgZmluYWxfdGV4dHVyZSk7XG5cblx0XHRpZiAodGhpcy5pc091dHB1dENvbm5lY3RlZCgxKSlcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgxLCBhdmVyYWdlX3RleHR1cmUpO1xuXG5cdFx0aWYgKHRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMikpXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMiwgZ2xvd190ZXh0dXJlKTtcblx0fTtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvZ2xvd1wiLCBMR3JhcGhUZXh0dXJlR2xvdyk7XG5cblx0Ly8gVGV4dHVyZSBGaWx0ZXIgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZUt1d2FoYXJhRmlsdGVyKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIkZpbHRlcmVkXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IGludGVuc2l0eTogMSwgcmFkaXVzOiA1IH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlS3V3YWhhcmFGaWx0ZXIudGl0bGUgPSBcIkt1d2FoYXJhIEZpbHRlclwiO1xuXHRMR3JhcGhUZXh0dXJlS3V3YWhhcmFGaWx0ZXIuZGVzYyA9XG5cdFx0XCJGaWx0ZXJzIGEgdGV4dHVyZSBnaXZpbmcgYW4gYXJ0aXN0aWMgb2lsIGNhbnZhcyBwYWludGluZ1wiO1xuXG5cdExHcmFwaFRleHR1cmVLdXdhaGFyYUZpbHRlci5tYXhfcmFkaXVzID0gMTA7XG5cdExHcmFwaFRleHR1cmVLdXdhaGFyYUZpbHRlci5fc2hhZGVycyA9IFtdO1xuXG5cdExHcmFwaFRleHR1cmVLdXdhaGFyYUZpbHRlci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXG5cdFx0aWYgKFxuXHRcdFx0IXRlbXAgfHxcblx0XHRcdHRlbXAud2lkdGggIT0gdGV4LndpZHRoIHx8XG5cdFx0XHR0ZW1wLmhlaWdodCAhPSB0ZXguaGVpZ2h0IHx8XG5cdFx0XHR0ZW1wLnR5cGUgIT0gdGV4LnR5cGVcblx0XHQpIHtcblx0XHRcdHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKHRleC53aWR0aCwgdGV4LmhlaWdodCwge1xuXHRcdFx0XHR0eXBlOiB0ZXgudHlwZSxcblx0XHRcdFx0Zm9ybWF0OiBnbC5SR0JBLFxuXHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly9pdGVyYXRpb25zXG5cdFx0dmFyIHJhZGl1cyA9IHRoaXMucHJvcGVydGllcy5yYWRpdXM7XG5cdFx0cmFkaXVzID0gTWF0aC5taW4oXG5cdFx0XHRNYXRoLmZsb29yKHJhZGl1cyksXG5cdFx0XHRMR3JhcGhUZXh0dXJlS3V3YWhhcmFGaWx0ZXIubWF4X3JhZGl1c1xuXHRcdCk7XG5cdFx0aWYgKHJhZGl1cyA9PSAwKSB7XG5cdFx0XHQvL3NraXAgYmx1cnJpbmdcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpbnRlbnNpdHkgPSB0aGlzLnByb3BlcnRpZXMuaW50ZW5zaXR5O1xuXG5cdFx0Ly9ibHVyIHNvbWV0aW1lcyBuZWVkcyBhbiBhc3BlY3QgY29ycmVjdGlvblxuXHRcdHZhciBhc3BlY3QgPSBMaXRlR3JhcGguY2FtZXJhX2FzcGVjdDtcblx0XHRpZiAoIWFzcGVjdCAmJiB3aW5kb3cuZ2wgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0YXNwZWN0ID0gZ2wuY2FudmFzLmhlaWdodCAvIGdsLmNhbnZhcy53aWR0aDtcblx0XHR9XG5cdFx0aWYgKCFhc3BlY3QpIHtcblx0XHRcdGFzcGVjdCA9IDE7XG5cdFx0fVxuXHRcdGFzcGVjdCA9IHRoaXMucHJvcGVydGllcy5wcmVzZXJ2ZV9hc3BlY3QgPyBhc3BlY3QgOiAxO1xuXG5cdFx0aWYgKCFMR3JhcGhUZXh0dXJlS3V3YWhhcmFGaWx0ZXIuX3NoYWRlcnNbcmFkaXVzXSkge1xuXHRcdFx0TEdyYXBoVGV4dHVyZUt1d2FoYXJhRmlsdGVyLl9zaGFkZXJzW3JhZGl1c10gPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdExHcmFwaFRleHR1cmVLdXdhaGFyYUZpbHRlci5waXhlbF9zaGFkZXIsXG5cdFx0XHRcdHsgUkFESVVTOiByYWRpdXMudG9GaXhlZCgwKSB9XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhUZXh0dXJlS3V3YWhhcmFGaWx0ZXIuX3NoYWRlcnNbcmFkaXVzXTtcblx0XHR2YXIgbWVzaCA9IEdMLk1lc2guZ2V0U2NyZWVuUXVhZCgpO1xuXHRcdHRleC5iaW5kKDApO1xuXG5cdFx0dGhpcy5fdGVtcF90ZXh0dXJlLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdHNoYWRlclxuXHRcdFx0XHQudW5pZm9ybXMoe1xuXHRcdFx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdFx0XHR1X2ludGVuc2l0eTogaW50ZW5zaXR5LFxuXHRcdFx0XHRcdHVfcmVzb2x1dGlvbjogW3RleC53aWR0aCwgdGV4LmhlaWdodF0sXG5cdFx0XHRcdFx0dV9pUmVzb2x1dGlvbjogWzEgLyB0ZXgud2lkdGgsIDEgLyB0ZXguaGVpZ2h0XVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuZHJhdyhtZXNoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZW1wX3RleHR1cmUpO1xuXHR9O1xuXG5cdC8vZnJvbSBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvTXNYU3o0XG5cdExHcmFwaFRleHR1cmVLdXdhaGFyYUZpbHRlci5waXhlbF9zaGFkZXIgPVxuXHRcdFwiXFxuXFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxudmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxudW5pZm9ybSBmbG9hdCB1X2ludGVuc2l0eTtcXG5cXFxudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcXG5cXFxudW5pZm9ybSB2ZWMyIHVfaVJlc29sdXRpb247XFxuXFxcbiNpZm5kZWYgUkFESVVTXFxuXFxcblx0I2RlZmluZSBSQURJVVMgN1xcblxcXG4jZW5kaWZcXG5cXFxudm9pZCBtYWluKCkge1xcblxcXG5cXG5cXFxuXHRjb25zdCBpbnQgcmFkaXVzID0gUkFESVVTO1xcblxcXG5cdHZlYzIgZnJhZ0Nvb3JkID0gdl9jb29yZDtcXG5cXFxuXHR2ZWMyIHNyY19zaXplID0gdV9pUmVzb2x1dGlvbjtcXG5cXFxuXHR2ZWMyIHV2ID0gdl9jb29yZDtcXG5cXFxuXHRmbG9hdCBuID0gZmxvYXQoKHJhZGl1cyArIDEpICogKHJhZGl1cyArIDEpKTtcXG5cXFxuXHRpbnQgaTtcXG5cXFxuXHRpbnQgajtcXG5cXFxuXHR2ZWMzIG0wID0gdmVjMygwLjApOyB2ZWMzIG0xID0gdmVjMygwLjApOyB2ZWMzIG0yID0gdmVjMygwLjApOyB2ZWMzIG0zID0gdmVjMygwLjApO1xcblxcXG5cdHZlYzMgczAgPSB2ZWMzKDAuMCk7IHZlYzMgczEgPSB2ZWMzKDAuMCk7IHZlYzMgczIgPSB2ZWMzKDAuMCk7IHZlYzMgczMgPSB2ZWMzKDAuMCk7XFxuXFxcblx0dmVjMyBjO1xcblxcXG5cdFxcblxcXG5cdGZvciAoaW50IGogPSAtcmFkaXVzOyBqIDw9IDA7ICsraikgIHtcXG5cXFxuXHRcdGZvciAoaW50IGkgPSAtcmFkaXVzOyBpIDw9IDA7ICsraSkgIHtcXG5cXFxuXHRcdFx0YyA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2ICsgdmVjMihpLGopICogc3JjX3NpemUpLnJnYjtcXG5cXFxuXHRcdFx0bTAgKz0gYztcXG5cXFxuXHRcdFx0czAgKz0gYyAqIGM7XFxuXFxcblx0XHR9XFxuXFxcblx0fVxcblxcXG5cdFxcblxcXG5cdGZvciAoaW50IGogPSAtcmFkaXVzOyBqIDw9IDA7ICsraikgIHtcXG5cXFxuXHRcdGZvciAoaW50IGkgPSAwOyBpIDw9IHJhZGl1czsgKytpKSAge1xcblxcXG5cdFx0XHRjID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdXYgKyB2ZWMyKGksaikgKiBzcmNfc2l6ZSkucmdiO1xcblxcXG5cdFx0XHRtMSArPSBjO1xcblxcXG5cdFx0XHRzMSArPSBjICogYztcXG5cXFxuXHRcdH1cXG5cXFxuXHR9XFxuXFxcblx0XFxuXFxcblx0Zm9yIChpbnQgaiA9IDA7IGogPD0gcmFkaXVzOyArK2opICB7XFxuXFxcblx0XHRmb3IgKGludCBpID0gMDsgaSA8PSByYWRpdXM7ICsraSkgIHtcXG5cXFxuXHRcdFx0YyA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2ICsgdmVjMihpLGopICogc3JjX3NpemUpLnJnYjtcXG5cXFxuXHRcdFx0bTIgKz0gYztcXG5cXFxuXHRcdFx0czIgKz0gYyAqIGM7XFxuXFxcblx0XHR9XFxuXFxcblx0fVxcblxcXG5cdFxcblxcXG5cdGZvciAoaW50IGogPSAwOyBqIDw9IHJhZGl1czsgKytqKSAge1xcblxcXG5cdFx0Zm9yIChpbnQgaSA9IC1yYWRpdXM7IGkgPD0gMDsgKytpKSAge1xcblxcXG5cdFx0XHRjID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdXYgKyB2ZWMyKGksaikgKiBzcmNfc2l6ZSkucmdiO1xcblxcXG5cdFx0XHRtMyArPSBjO1xcblxcXG5cdFx0XHRzMyArPSBjICogYztcXG5cXFxuXHRcdH1cXG5cXFxuXHR9XFxuXFxcblx0XFxuXFxcblx0ZmxvYXQgbWluX3NpZ21hMiA9IDFlKzI7XFxuXFxcblx0bTAgLz0gbjtcXG5cXFxuXHRzMCA9IGFicyhzMCAvIG4gLSBtMCAqIG0wKTtcXG5cXFxuXHRcXG5cXFxuXHRmbG9hdCBzaWdtYTIgPSBzMC5yICsgczAuZyArIHMwLmI7XFxuXFxcblx0aWYgKHNpZ21hMiA8IG1pbl9zaWdtYTIpIHtcXG5cXFxuXHRcdG1pbl9zaWdtYTIgPSBzaWdtYTI7XFxuXFxcblx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KG0wLCAxLjApO1xcblxcXG5cdH1cXG5cXFxuXHRcXG5cXFxuXHRtMSAvPSBuO1xcblxcXG5cdHMxID0gYWJzKHMxIC8gbiAtIG0xICogbTEpO1xcblxcXG5cdFxcblxcXG5cdHNpZ21hMiA9IHMxLnIgKyBzMS5nICsgczEuYjtcXG5cXFxuXHRpZiAoc2lnbWEyIDwgbWluX3NpZ21hMikge1xcblxcXG5cdFx0bWluX3NpZ21hMiA9IHNpZ21hMjtcXG5cXFxuXHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQobTEsIDEuMCk7XFxuXFxcblx0fVxcblxcXG5cdFxcblxcXG5cdG0yIC89IG47XFxuXFxcblx0czIgPSBhYnMoczIgLyBuIC0gbTIgKiBtMik7XFxuXFxcblx0XFxuXFxcblx0c2lnbWEyID0gczIuciArIHMyLmcgKyBzMi5iO1xcblxcXG5cdGlmIChzaWdtYTIgPCBtaW5fc2lnbWEyKSB7XFxuXFxcblx0XHRtaW5fc2lnbWEyID0gc2lnbWEyO1xcblxcXG5cdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChtMiwgMS4wKTtcXG5cXFxuXHR9XFxuXFxcblx0XFxuXFxcblx0bTMgLz0gbjtcXG5cXFxuXHRzMyA9IGFicyhzMyAvIG4gLSBtMyAqIG0zKTtcXG5cXFxuXHRcXG5cXFxuXHRzaWdtYTIgPSBzMy5yICsgczMuZyArIHMzLmI7XFxuXFxcblx0aWYgKHNpZ21hMiA8IG1pbl9zaWdtYTIpIHtcXG5cXFxuXHRcdG1pbl9zaWdtYTIgPSBzaWdtYTI7XFxuXFxcblx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KG0zLCAxLjApO1xcblxcXG5cdH1cXG5cXFxufVxcblxcXG5cIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcblx0XHRcInRleHR1cmUva3V3YWhhcmFcIixcblx0XHRMR3JhcGhUZXh0dXJlS3V3YWhhcmFGaWx0ZXJcblx0KTtcblxuXHQvLyBUZXh0dXJlICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlWERvR0ZpbHRlcigpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJGaWx0ZXJlZFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0c2lnbWE6IDEuNCxcblx0XHRcdGs6IDEuNixcblx0XHRcdHA6IDIxLjcsXG5cdFx0XHRlcHNpbG9uOiA3OSxcblx0XHRcdHBoaTogMC4wMTdcblx0XHR9O1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZVhEb0dGaWx0ZXIudGl0bGUgPSBcIlhEb0cgRmlsdGVyXCI7XG5cdExHcmFwaFRleHR1cmVYRG9HRmlsdGVyLmRlc2MgPVxuXHRcdFwiRmlsdGVycyBhIHRleHR1cmUgZ2l2aW5nIGFuIGFydGlzdGljIGluayBzdHlsZVwiO1xuXG5cdExHcmFwaFRleHR1cmVYRG9HRmlsdGVyLm1heF9yYWRpdXMgPSAxMDtcblx0TEdyYXBoVGV4dHVyZVhEb0dGaWx0ZXIuX3NoYWRlcnMgPSBbXTtcblxuXHRMR3JhcGhUZXh0dXJlWERvR0ZpbHRlci5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXHRcdGlmIChcblx0XHRcdCF0ZW1wIHx8XG5cdFx0XHR0ZW1wLndpZHRoICE9IHRleC53aWR0aCB8fFxuXHRcdFx0dGVtcC5oZWlnaHQgIT0gdGV4LmhlaWdodCB8fFxuXHRcdFx0dGVtcC50eXBlICE9IHRleC50eXBlXG5cdFx0KSB7XG5cdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSh0ZXgud2lkdGgsIHRleC5oZWlnaHQsIHtcblx0XHRcdFx0dHlwZTogdGV4LnR5cGUsXG5cdFx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdFx0ZmlsdGVyOiBnbC5MSU5FQVJcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICghTEdyYXBoVGV4dHVyZVhEb0dGaWx0ZXIuX3hkb2dfc2hhZGVyKSB7XG5cdFx0XHRMR3JhcGhUZXh0dXJlWERvR0ZpbHRlci5feGRvZ19zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdExHcmFwaFRleHR1cmVYRG9HRmlsdGVyLnhkb2dfcGl4ZWxfc2hhZGVyXG5cdFx0XHQpO1xuXHRcdH1cblx0XHR2YXIgc2hhZGVyID0gTEdyYXBoVGV4dHVyZVhEb0dGaWx0ZXIuX3hkb2dfc2hhZGVyO1xuXHRcdHZhciBtZXNoID0gR0wuTWVzaC5nZXRTY3JlZW5RdWFkKCk7XG5cblx0XHR2YXIgc2lnbWEgPSB0aGlzLnByb3BlcnRpZXMuc2lnbWE7XG5cdFx0dmFyIGsgPSB0aGlzLnByb3BlcnRpZXMuaztcblx0XHR2YXIgcCA9IHRoaXMucHJvcGVydGllcy5wO1xuXHRcdHZhciBlcHNpbG9uID0gdGhpcy5wcm9wZXJ0aWVzLmVwc2lsb247XG5cdFx0dmFyIHBoaSA9IHRoaXMucHJvcGVydGllcy5waGk7XG5cdFx0dGV4LmJpbmQoMCk7XG5cdFx0dGhpcy5fdGVtcF90ZXh0dXJlLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdHNoYWRlclxuXHRcdFx0XHQudW5pZm9ybXMoe1xuXHRcdFx0XHRcdHNyYzogMCxcblx0XHRcdFx0XHRzaWdtYTogc2lnbWEsXG5cdFx0XHRcdFx0azogayxcblx0XHRcdFx0XHRwOiBwLFxuXHRcdFx0XHRcdGVwc2lsb246IGVwc2lsb24sXG5cdFx0XHRcdFx0cGhpOiBwaGksXG5cdFx0XHRcdFx0Y3ZzV2lkdGg6IHRleC53aWR0aCxcblx0XHRcdFx0XHRjdnNIZWlnaHQ6IHRleC5oZWlnaHRcblx0XHRcdFx0fSlcblx0XHRcdFx0LmRyYXcobWVzaCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGVtcF90ZXh0dXJlKTtcblx0fTtcblxuXHQvL2Zyb20gaHR0cHM6Ly9naXRodWIuY29tL1JheW1vbmRNY0d1aXJlL0dQVS1CYXNlZC1JbWFnZS1Qcm9jZXNzaW5nLVRvb2xzL2Jsb2IvbWFzdGVyL2xpYl93ZWJnbC9zY3JpcHRzL21haW4uanNcblx0TEdyYXBoVGV4dHVyZVhEb0dGaWx0ZXIueGRvZ19waXhlbF9zaGFkZXIgPVxuXHRcdFwiXFxuXFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxudW5pZm9ybSBzYW1wbGVyMkQgc3JjO1xcblxcblxcXG51bmlmb3JtIGZsb2F0IGN2c0hlaWdodDtcXG5cXFxudW5pZm9ybSBmbG9hdCBjdnNXaWR0aDtcXG5cXG5cXFxudW5pZm9ybSBmbG9hdCBzaWdtYTtcXG5cXFxudW5pZm9ybSBmbG9hdCBrO1xcblxcXG51bmlmb3JtIGZsb2F0IHA7XFxuXFxcbnVuaWZvcm0gZmxvYXQgZXBzaWxvbjtcXG5cXFxudW5pZm9ybSBmbG9hdCBwaGk7XFxuXFxcbnZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcblxcXG5mbG9hdCBjb3NoKGZsb2F0IHZhbClcXG5cXFxue1xcblxcXG5cdGZsb2F0IHRtcCA9IGV4cCh2YWwpO1xcblxcXG5cdGZsb2F0IGNvc0ggPSAodG1wICsgMS4wIC8gdG1wKSAvIDIuMDtcXG5cXFxuXHRyZXR1cm4gY29zSDtcXG5cXFxufVxcblxcblxcXG5mbG9hdCB0YW5oKGZsb2F0IHZhbClcXG5cXFxue1xcblxcXG5cdGZsb2F0IHRtcCA9IGV4cCh2YWwpO1xcblxcXG5cdGZsb2F0IHRhbkggPSAodG1wIC0gMS4wIC8gdG1wKSAvICh0bXAgKyAxLjAgLyB0bXApO1xcblxcXG5cdHJldHVybiB0YW5IO1xcblxcXG59XFxuXFxuXFxcbmZsb2F0IHNpbmgoZmxvYXQgdmFsKVxcblxcXG57XFxuXFxcblx0ZmxvYXQgdG1wID0gZXhwKHZhbCk7XFxuXFxcblx0ZmxvYXQgc2luSCA9ICh0bXAgLSAxLjAgLyB0bXApIC8gMi4wO1xcblxcXG5cdHJldHVybiBzaW5IO1xcblxcXG59XFxuXFxuXFxcbnZvaWQgbWFpbih2b2lkKXtcXG5cXFxuXHR2ZWMzIGRlc3RDb2xvciA9IHZlYzMoMC4wKTtcXG5cXFxuXHRmbG9hdCB0RnJhZyA9IDEuMCAvIGN2c0hlaWdodDtcXG5cXFxuXHRmbG9hdCBzRnJhZyA9IDEuMCAvIGN2c1dpZHRoO1xcblxcXG5cdHZlYzIgRnJhZyA9IHZlYzIoc0ZyYWcsdEZyYWcpO1xcblxcXG5cdHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQuc3Q7XFxuXFxcblx0ZmxvYXQgdHdvU2lnbWFFU3F1YXJlZCA9IDIuMCAqIHNpZ21hICogc2lnbWE7XFxuXFxcblx0ZmxvYXQgdHdvU2lnbWFSU3F1YXJlZCA9IHR3b1NpZ21hRVNxdWFyZWQgKiBrICogaztcXG5cXFxuXHRpbnQgaGFsZldpZHRoID0gaW50KGNlaWwoIDEuMCAqIHNpZ21hICogayApKTtcXG5cXG5cXFxuXHRjb25zdCBpbnQgTUFYX05VTV9JVEVSQVRJT04gPSA5OTk5OTtcXG5cXFxuXHR2ZWMyIHN1bSA9IHZlYzIoMC4wKTtcXG5cXFxuXHR2ZWMyIG5vcm0gPSB2ZWMyKDAuMCk7XFxuXFxuXFxcblx0Zm9yKGludCBjbnQ9MDtjbnQ8TUFYX05VTV9JVEVSQVRJT047Y250Kyspe1xcblxcXG5cdFx0aWYoY250ID4gKDIqaGFsZldpZHRoKzEpKigyKmhhbGZXaWR0aCsxKSl7YnJlYWs7fVxcblxcXG5cdFx0aW50IGkgPSBpbnQoY250IC8gKDIqaGFsZldpZHRoKzEpKSAtIGhhbGZXaWR0aDtcXG5cXFxuXHRcdGludCBqID0gY250IC0gaGFsZldpZHRoIC0gaW50KGNudCAvICgyKmhhbGZXaWR0aCsxKSkgKiAoMipoYWxmV2lkdGgrMSk7XFxuXFxuXFxcblx0XHRmbG9hdCBkID0gbGVuZ3RoKHZlYzIoaSxqKSk7XFxuXFxcblx0XHR2ZWMyIGtlcm5lbCA9IHZlYzIoIGV4cCggLWQgKiBkIC8gdHdvU2lnbWFFU3F1YXJlZCApLCBcXG5cXFxuXHRcdFx0XHRcdFx0XHRleHAoIC1kICogZCAvIHR3b1NpZ21hUlNxdWFyZWQgKSk7XFxuXFxuXFxcblx0XHR2ZWMyIEwgPSB0ZXh0dXJlMkQoc3JjLCAodXYgKyB2ZWMyKGksaikpICogRnJhZykueHg7XFxuXFxuXFxcblx0XHRub3JtICs9IGtlcm5lbDtcXG5cXFxuXHRcdHN1bSArPSBrZXJuZWwgKiBMO1xcblxcXG5cdH1cXG5cXG5cXFxuXHRzdW0gLz0gbm9ybTtcXG5cXG5cXFxuXHRmbG9hdCBIID0gMTAwLjAgKiAoKDEuMCArIHApICogc3VtLnggLSBwICogc3VtLnkpO1xcblxcXG5cdGZsb2F0IGVkZ2UgPSAoIEggPiBlcHNpbG9uICk/IDEuMCA6IDEuMCArIHRhbmgoIHBoaSAqIChIIC0gZXBzaWxvbikpO1xcblxcXG5cdGRlc3RDb2xvciA9IHZlYzMoZWRnZSk7XFxuXFxcblx0Z2xfRnJhZ0NvbG9yID0gdmVjNChkZXN0Q29sb3IsIDEuMCk7XFxuXFxcbn1cIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUveERvR1wiLCBMR3JhcGhUZXh0dXJlWERvR0ZpbHRlcik7XG5cblx0Ly8gVGV4dHVyZSBXZWJjYW0gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZVdlYmNhbSgpIHtcblx0XHR0aGlzLmFkZE91dHB1dChcIldlYmNhbVwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyB0ZXh0dXJlX25hbWU6IFwiXCIsIGZhY2luZ01vZGU6IFwidXNlclwiIH07XG5cdFx0dGhpcy5ib3hjb2xvciA9IFwiYmxhY2tcIjtcblx0XHR0aGlzLnZlcnNpb24gPSAwO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZVdlYmNhbS50aXRsZSA9IFwiV2ViY2FtXCI7XG5cdExHcmFwaFRleHR1cmVXZWJjYW0uZGVzYyA9IFwiV2ViY2FtIHRleHR1cmVcIjtcblxuXHRMR3JhcGhUZXh0dXJlV2ViY2FtLmlzX3dlYmNhbV9vcGVuID0gZmFsc2U7XG5cblx0TEdyYXBoVGV4dHVyZVdlYmNhbS5wcm90b3R5cGUub3BlblN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghbmF2aWdhdG9yLmdldFVzZXJNZWRpYSkge1xuXHRcdFx0Ly9jb25zb2xlLmxvZygnZ2V0VXNlck1lZGlhKCkgaXMgbm90IHN1cHBvcnRlZCBpbiB5b3VyIGJyb3dzZXIsIHVzZSBjaHJvbWUgYW5kIGVuYWJsZSBXZWJSVEMgZnJvbSBhYm91dDovL2ZsYWdzJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fd2FpdGluZ19jb25maXJtYXRpb24gPSB0cnVlO1xuXG5cdFx0Ly8gTm90IHNob3dpbmcgdmVuZG9yIHByZWZpeGVzLlxuXHRcdHZhciBjb25zdHJhaW50cyA9IHtcblx0XHRcdGF1ZGlvOiBmYWxzZSxcblx0XHRcdHZpZGVvOiB7IGZhY2luZ01vZGU6IHRoaXMucHJvcGVydGllcy5mYWNpbmdNb2RlIH1cblx0XHR9O1xuXHRcdG5hdmlnYXRvci5tZWRpYURldmljZXNcblx0XHRcdC5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG5cdFx0XHQudGhlbih0aGlzLnN0cmVhbVJlYWR5LmJpbmQodGhpcykpXG5cdFx0XHQuY2F0Y2gob25GYWlsU29IYXJkKTtcblxuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRmdW5jdGlvbiBvbkZhaWxTb0hhcmQoZSkge1xuXHRcdFx0TEdyYXBoVGV4dHVyZVdlYmNhbS5pc193ZWJjYW1fb3BlbiA9IGZhbHNlO1xuXHRcdFx0Y29uc29sZS5sb2coXCJXZWJjYW0gcmVqZWN0ZWRcIiwgZSk7XG5cdFx0XHR0aGF0Ll93ZWJjYW1fc3RyZWFtID0gZmFsc2U7XG5cdFx0XHR0aGF0LmJveGNvbG9yID0gXCJyZWRcIjtcblx0XHRcdHRoYXQudHJpZ2dlcihcInN0cmVhbV9lcnJvclwiKTtcblx0XHR9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVdlYmNhbS5wcm90b3R5cGUuY2xvc2VTdHJlYW0gPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fd2ViY2FtX3N0cmVhbSkge1xuXHRcdFx0dmFyIHRyYWNrcyA9IHRoaXMuX3dlYmNhbV9zdHJlYW0uZ2V0VHJhY2tzKCk7XG5cdFx0XHRpZiAodHJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdHRyYWNrc1tpXS5zdG9wKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdExHcmFwaFRleHR1cmVXZWJjYW0uaXNfd2ViY2FtX29wZW4gPSBmYWxzZTtcblx0XHRcdHRoaXMuX3dlYmNhbV9zdHJlYW0gPSBudWxsO1xuXHRcdFx0dGhpcy5fdmlkZW8gPSBudWxsO1xuXHRcdFx0dGhpcy5ib3hjb2xvciA9IFwiYmxhY2tcIjtcblx0XHRcdHRoaXMudHJpZ2dlcihcInN0cmVhbV9jbG9zZWRcIik7XG5cdFx0fVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVXZWJjYW0ucHJvdG90eXBlLnN0cmVhbVJlYWR5ID0gZnVuY3Rpb24obG9jYWxNZWRpYVN0cmVhbSkge1xuXHRcdHRoaXMuX3dlYmNhbV9zdHJlYW0gPSBsb2NhbE1lZGlhU3RyZWFtO1xuXHRcdC8vdGhpcy5fd2FpdGluZ19jb25maXJtYXRpb24gPSBmYWxzZTtcblx0XHR0aGlzLmJveGNvbG9yID0gXCJncmVlblwiO1xuXHRcdHZhciB2aWRlbyA9IHRoaXMuX3ZpZGVvO1xuXHRcdGlmICghdmlkZW8pIHtcblx0XHRcdHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuXHRcdFx0dmlkZW8uYXV0b3BsYXkgPSB0cnVlO1xuXHRcdFx0dmlkZW8uc3JjT2JqZWN0ID0gbG9jYWxNZWRpYVN0cmVhbTtcblx0XHRcdHRoaXMuX3ZpZGVvID0gdmlkZW87XG5cdFx0XHQvL2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIHZpZGVvICk7IC8vZGVidWdcblx0XHRcdC8vd2hlbiB2aWRlbyBpbmZvIGlzIGxvYWRlZCAoc2l6ZSBhbmQgc28pXG5cdFx0XHR2aWRlby5vbmxvYWRlZG1ldGFkYXRhID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHQvLyBSZWFkeSB0byBnby4gRG8gc29tZSBzdHVmZi5cblx0XHRcdFx0TEdyYXBoVGV4dHVyZVdlYmNhbS5pc193ZWJjYW1fb3BlbiA9IHRydWU7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGUpO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0dGhpcy50cmlnZ2VyKFwic3RyZWFtX3JlYWR5XCIsIHZpZGVvKTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlV2ViY2FtLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKFxuXHRcdG5hbWUsXG5cdFx0dmFsdWVcblx0KSB7XG5cdFx0aWYgKG5hbWUgPT0gXCJmYWNpbmdNb2RlXCIpIHtcblx0XHRcdHRoaXMucHJvcGVydGllcy5mYWNpbmdNb2RlID0gdmFsdWU7XG5cdFx0XHR0aGlzLmNsb3NlU3RyZWFtKCk7XG5cdFx0XHR0aGlzLm9wZW5TdHJlYW0oKTtcblx0XHR9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZVdlYmNhbS5wcm90b3R5cGUub25SZW1vdmVkID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl93ZWJjYW1fc3RyZWFtKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRyYWNrcyA9IHRoaXMuX3dlYmNhbV9zdHJlYW0uZ2V0VHJhY2tzKCk7XG5cdFx0aWYgKHRyYWNrcy5sZW5ndGgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRyYWNrc1tpXS5zdG9wKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fd2ViY2FtX3N0cmVhbSA9IG51bGw7XG5cdFx0dGhpcy5fdmlkZW8gPSBudWxsO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVXZWJjYW0ucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRpZiAodGhpcy5mbGFncy5jb2xsYXBzZWQgfHwgdGhpcy5zaXplWzFdIDw9IDIwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl92aWRlbykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vcmVuZGVyIHRvIGdyYXBoIGNhbnZhc1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0aWYgKCFjdHgud2ViZ2wpIHtcblx0XHRcdC8vcmV2ZXJzZSBpbWFnZVxuXHRcdFx0Y3R4LmRyYXdJbWFnZSh0aGlzLl92aWRlbywgMCwgMCwgdGhpcy5zaXplWzBdLCB0aGlzLnNpemVbMV0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodGhpcy5fdmlkZW9fdGV4dHVyZSkge1xuXHRcdFx0XHRjdHguZHJhd0ltYWdlKFxuXHRcdFx0XHRcdHRoaXMuX3ZpZGVvX3RleHR1cmUsXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdHRoaXMuc2l6ZVswXSxcblx0XHRcdFx0XHR0aGlzLnNpemVbMV1cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlV2ViY2FtLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fd2ViY2FtX3N0cmVhbSA9PSBudWxsICYmICF0aGlzLl93YWl0aW5nX2NvbmZpcm1hdGlvbikge1xuXHRcdFx0dGhpcy5vcGVuU3RyZWFtKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl92aWRlbyB8fCAhdGhpcy5fdmlkZW8udmlkZW9XaWR0aCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB3aWR0aCA9IHRoaXMuX3ZpZGVvLnZpZGVvV2lkdGg7XG5cdFx0dmFyIGhlaWdodCA9IHRoaXMuX3ZpZGVvLnZpZGVvSGVpZ2h0O1xuXG5cdFx0dmFyIHRlbXAgPSB0aGlzLl92aWRlb190ZXh0dXJlO1xuXHRcdGlmICghdGVtcCB8fCB0ZW1wLndpZHRoICE9IHdpZHRoIHx8IHRlbXAuaGVpZ2h0ICE9IGhlaWdodCkge1xuXHRcdFx0dGhpcy5fdmlkZW9fdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKHdpZHRoLCBoZWlnaHQsIHtcblx0XHRcdFx0Zm9ybWF0OiBnbC5SR0IsXG5cdFx0XHRcdGZpbHRlcjogZ2wuTElORUFSXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLl92aWRlb190ZXh0dXJlLnVwbG9hZEltYWdlKHRoaXMuX3ZpZGVvKTtcblx0XHR0aGlzLl92aWRlb190ZXh0dXJlLnZlcnNpb24gPSArK3RoaXMudmVyc2lvbjtcblxuXHRcdGlmICh0aGlzLnByb3BlcnRpZXMudGV4dHVyZV9uYW1lKSB7XG5cdFx0XHR2YXIgY29udGFpbmVyID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlc0NvbnRhaW5lcigpO1xuXHRcdFx0Y29udGFpbmVyW3RoaXMucHJvcGVydGllcy50ZXh0dXJlX25hbWVdID0gdGhpcy5fdmlkZW9fdGV4dHVyZTtcblx0XHR9XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdmlkZW9fdGV4dHVyZSk7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdGlmICghdGhpcy5vdXRwdXRzW2ldKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0c3dpdGNoICh0aGlzLm91dHB1dHNbaV0ubmFtZSkge1xuXHRcdFx0XHRjYXNlIFwid2lkdGhcIjpcblx0XHRcdFx0XHR0aGlzLnNldE91dHB1dERhdGEoaSwgdGhpcy5fdmlkZW8udmlkZW9XaWR0aCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJoZWlnaHRcIjpcblx0XHRcdFx0XHR0aGlzLnNldE91dHB1dERhdGEoaSwgdGhpcy5fdmlkZW8udmlkZW9IZWlnaHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlV2ViY2FtLnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0W1wid2lkdGhcIiwgXCJudW1iZXJcIl0sXG5cdFx0XHRbXCJoZWlnaHRcIiwgXCJudW1iZXJcIl0sXG5cdFx0XHRbXCJzdHJlYW1fcmVhZHlcIiwgTGl0ZUdyYXBoLkVWRU5UXSxcblx0XHRcdFtcInN0cmVhbV9jbG9zZWRcIiwgTGl0ZUdyYXBoLkVWRU5UXSxcblx0XHRcdFtcInN0cmVhbV9lcnJvclwiLCBMaXRlR3JhcGguRVZFTlRdXG5cdFx0XTtcblx0fTtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvd2ViY2FtXCIsIExHcmFwaFRleHR1cmVXZWJjYW0pO1xuXG5cdC8vZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc3BpdGUvV2FnbmVyXG5cdGZ1bmN0aW9uIExHcmFwaExlbnNGWCgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJmXCIsIFwibnVtYmVyXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0ZmFjdG9yOiAxLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkxPV1xuXHRcdH07XG5cblx0XHR0aGlzLl91bmlmb3JtcyA9IHsgdV90ZXh0dXJlOiAwLCB1X2ZhY3RvcjogMSB9O1xuXHR9XG5cblx0TEdyYXBoTGVuc0ZYLnRpdGxlID0gXCJMZW5zIEZYXCI7XG5cdExHcmFwaExlbnNGWC5kZXNjID0gXCJkaXN0b3J0aW9uIGFuZCBjaHJvbWF0aWMgYWJlcnJhdGlvblwiO1xuXG5cdExHcmFwaExlbnNGWC53aWRnZXRzX2luZm8gPSB7XG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaExlbnNGWC5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gW1tcImVuYWJsZWRcIiwgXCJib29sZWFuXCJdXTtcblx0fTtcblxuXHRMR3JhcGhMZW5zRlgucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoIXRleCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHRpZiAoXG5cdFx0XHR0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLlBBU1NfVEhST1VHSCB8fFxuXHRcdFx0dGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJlbmFibGVkXCIpID09PSBmYWxzZVxuXHRcdCkge1xuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRlbXAgPSB0aGlzLl90ZW1wX3RleHR1cmU7XG5cdFx0aWYgKFxuXHRcdFx0IXRlbXAgfHxcblx0XHRcdHRlbXAud2lkdGggIT0gdGV4LndpZHRoIHx8XG5cdFx0XHR0ZW1wLmhlaWdodCAhPSB0ZXguaGVpZ2h0IHx8XG5cdFx0XHR0ZW1wLnR5cGUgIT0gdGV4LnR5cGVcblx0XHQpIHtcblx0XHRcdHRlbXAgPSB0aGlzLl90ZW1wX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZShcblx0XHRcdFx0dGV4LndpZHRoLFxuXHRcdFx0XHR0ZXguaGVpZ2h0LFxuXHRcdFx0XHR7IHR5cGU6IHRleC50eXBlLCBmb3JtYXQ6IGdsLlJHQkEsIGZpbHRlcjogZ2wuTElORUFSIH1cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dmFyIHNoYWRlciA9IExHcmFwaExlbnNGWC5fc2hhZGVyO1xuXHRcdGlmICghc2hhZGVyKSB7XG5cdFx0XHRzaGFkZXIgPSBMR3JhcGhMZW5zRlguX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoTGVuc0ZYLnBpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR2YXIgZmFjdG9yID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XG5cdFx0aWYgKGZhY3RvciA9PSBudWxsKSB7XG5cdFx0XHRmYWN0b3IgPSB0aGlzLnByb3BlcnRpZXMuZmFjdG9yO1xuXHRcdH1cblxuXHRcdHZhciB1bmlmb3JtcyA9IHRoaXMuX3VuaWZvcm1zO1xuXHRcdHVuaWZvcm1zLnVfZmFjdG9yID0gZmFjdG9yO1xuXG5cdFx0Ly9hcHBseSBzaGFkZXJcblx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdHRlbXAuZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHRzaGFkZXIudW5pZm9ybXModW5pZm9ybXMpLmRyYXcoR0wuTWVzaC5nZXRTY3JlZW5RdWFkKCkpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRlbXApO1xuXHR9O1xuXG5cdExHcmFwaExlbnNGWC5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfZmFjdG9yO1xcblxcXG5cdFx0dmVjMiBiYXJyZWxEaXN0b3J0aW9uKHZlYzIgY29vcmQsIGZsb2F0IGFtdCkge1xcblxcXG5cdFx0XHR2ZWMyIGNjID0gY29vcmQgLSAwLjU7XFxuXFxcblx0XHRcdGZsb2F0IGRpc3QgPSBkb3QoY2MsIGNjKTtcXG5cXFxuXHRcdFx0cmV0dXJuIGNvb3JkICsgY2MgKiBkaXN0ICogYW10O1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XFxuXFxcblx0XHRmbG9hdCBzYXQoIGZsb2F0IHQgKVxcblxcXG5cdFx0e1xcblxcXG5cdFx0XHRyZXR1cm4gY2xhbXAoIHQsIDAuMCwgMS4wICk7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcXG5cXFxuXHRcdGZsb2F0IGxpbnRlcnAoIGZsb2F0IHQgKSB7XFxuXFxcblx0XHRcdHJldHVybiBzYXQoIDEuMCAtIGFicyggMi4wKnQgLSAxLjAgKSApO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XFxuXFxcblx0XHRmbG9hdCByZW1hcCggZmxvYXQgdCwgZmxvYXQgYSwgZmxvYXQgYiApIHtcXG5cXFxuXHRcdFx0cmV0dXJuIHNhdCggKHQgLSBhKSAvIChiIC0gYSkgKTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFxcblxcXG5cdFx0dmVjNCBzcGVjdHJ1bV9vZmZzZXQoIGZsb2F0IHQgKSB7XFxuXFxcblx0XHRcdHZlYzQgcmV0O1xcblxcXG5cdFx0XHRmbG9hdCBsbyA9IHN0ZXAodCwwLjUpO1xcblxcXG5cdFx0XHRmbG9hdCBoaSA9IDEuMC1sbztcXG5cXFxuXHRcdFx0ZmxvYXQgdyA9IGxpbnRlcnAoIHJlbWFwKCB0LCAxLjAvNi4wLCA1LjAvNi4wICkgKTtcXG5cXFxuXHRcdFx0cmV0ID0gdmVjNChsbywxLjAsaGksIDEuKSAqIHZlYzQoMS4wLXcsIHcsIDEuMC13LCAxLik7XFxuXFxcblx0XHRcXG5cXFxuXHRcdFx0cmV0dXJuIHBvdyggcmV0LCB2ZWM0KDEuMC8yLjIpICk7XFxuXFxcblx0XHR9XFxuXFxcblx0XHRcXG5cXFxuXHRcdGNvbnN0IGZsb2F0IG1heF9kaXN0b3J0ID0gMi4yO1xcblxcXG5cdFx0Y29uc3QgaW50IG51bV9pdGVyID0gMTI7XFxuXFxcblx0XHRjb25zdCBmbG9hdCByZWNpX251bV9pdGVyX2YgPSAxLjAgLyBmbG9hdChudW1faXRlcik7XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpXFxuXFxcblx0XHR7XHRcXG5cXFxuXHRcdFx0dmVjMiB1dj12X2Nvb3JkO1xcblxcXG5cdFx0XHR2ZWM0IHN1bWNvbCA9IHZlYzQoMC4wKTtcXG5cXFxuXHRcdFx0dmVjNCBzdW13ID0gdmVjNCgwLjApO1x0XFxuXFxcblx0XHRcdGZvciAoIGludCBpPTA7IGk8bnVtX2l0ZXI7KytpIClcXG5cXFxuXHRcdFx0e1xcblxcXG5cdFx0XHRcdGZsb2F0IHQgPSBmbG9hdChpKSAqIHJlY2lfbnVtX2l0ZXJfZjtcXG5cXFxuXHRcdFx0XHR2ZWM0IHcgPSBzcGVjdHJ1bV9vZmZzZXQoIHQgKTtcXG5cXFxuXHRcdFx0XHRzdW13ICs9IHc7XFxuXFxcblx0XHRcdFx0c3VtY29sICs9IHcgKiB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgYmFycmVsRGlzdG9ydGlvbih1diwgLjYgKiBtYXhfZGlzdG9ydCp0ICogdV9mYWN0b3IgKSApO1xcblxcXG5cdFx0XHR9XFxuXFxcblx0XHRcdGdsX0ZyYWdDb2xvciA9IHN1bWNvbCAvIHN1bXc7XFxuXFxcblx0XHR9XCI7XG5cblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJ0ZXh0dXJlL2xlbnNmeFwiLCBMR3JhcGhMZW5zRlgpO1xuXG5cblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZUZyb21EYXRhKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIlwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5MT1csIHdpZHRoOiAwLCBoZWlnaHQ6IDAsIGNoYW5uZWxzOiAxIH07XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJUZXh0dXJlXCIpO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUZyb21EYXRhLnRpdGxlID0gXCJEYXRhLT5UZXhcIjtcblx0TEdyYXBoVGV4dHVyZUZyb21EYXRhLmRlc2MgPSBcIkdlbmVyYXRlcyBvciBhcHBsaWVzIGEgY3VydmUgdG8gYSB0ZXh0dXJlXCI7XG5cdExHcmFwaFRleHR1cmVGcm9tRGF0YS53aWRnZXRzX2luZm8gPSB7XG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVGcm9tRGF0YS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdHZhciBkYXRhID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cdFx0aWYoIWRhdGEpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR2YXIgY2hhbm5lbHMgPSB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbHM7XG5cdFx0dmFyIHcgPSB0aGlzLnByb3BlcnRpZXMud2lkdGg7XG5cdFx0dmFyIGggPSB0aGlzLnByb3BlcnRpZXMuaGVpZ2h0O1xuXHRcdGlmKCF3IHx8ICFoKVxuXHRcdHtcblx0XHRcdHcgPSBNYXRoLmZsb29yKGRhdGEubGVuZ3RoIC8gY2hhbm5lbHMpO1xuXHRcdFx0aCA9IDE7XG5cdFx0fVxuXHRcdHZhciBmb3JtYXQgPSBnbC5SR0JBO1xuXHRcdGlmKCBjaGFubmVscyA9PSAzIClcblx0XHRcdGZvcm1hdCA9IGdsLlJHQjtcblx0XHRlbHNlIGlmKCBjaGFubmVscyA9PSAxIClcblx0XHRcdGZvcm1hdCA9IGdsLkxVTUlOQU5DRTtcblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXHRcdHZhciB0eXBlID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlVHlwZSggdGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiApO1xuXHRcdGlmICggIXRlbXAgfHwgdGVtcC53aWR0aCAhPSB3IHx8IHRlbXAuaGVpZ2h0ICE9IGggfHwgdGVtcC50eXBlICE9IHR5cGUgKSB7XG5cdFx0XHR0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoIHcsIGgsIHsgdHlwZTogdHlwZSwgZm9ybWF0OiBmb3JtYXQsIGZpbHRlcjogZ2wuTElORUFSIH0gKTtcblx0XHR9XG5cblx0XHR0ZW1wLnVwbG9hZERhdGEoIGRhdGEgKTtcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGVtcCk7XG5cdH1cblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvZnJvbWRhdGFcIiwgTEdyYXBoVGV4dHVyZUZyb21EYXRhKTtcblxuXHQvL2FwcGxpZXMgYSBjdXJ2ZSAob3IgZ2VuZXJhdGVzIG9uZSlcblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZUN1cnZlKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJUZXh0dXJlXCIpO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgcHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkxPVywgc3BsaXRfY2hhbm5lbHM6IGZhbHNlIH07XG5cdFx0dGhpcy5fdmFsdWVzID0gbmV3IFVpbnQ4QXJyYXkoMjU2KjQpO1xuXHRcdHRoaXMuX3ZhbHVlcy5maWxsKDI1NSk7XG5cdFx0dGhpcy5fY3VydmVfdGV4dHVyZSA9IG51bGw7XG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7IHVfdGV4dHVyZTogMCwgdV9jdXJ2ZTogMSwgdV9yYW5nZTogMS4wIH07XG5cdFx0dGhpcy5fbXVzdF91cGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3BvaW50cyA9IHtcblx0XHRcdFJHQjogW1swLDBdLFsxLDFdXSxcblx0XHRcdFI6IFtbMCwwXSxbMSwxXV0sXG5cdFx0XHRHOiBbWzAsMF0sWzEsMV1dLFxuXHRcdFx0QjogW1swLDBdLFsxLDFdXVxuXHRcdH07XG5cdFx0dGhpcy5jdXJ2ZV9lZGl0b3IgPSBudWxsO1xuXHRcdHRoaXMuYWRkV2lkZ2V0KFwidG9nZ2xlXCIsXCJTcGxpdCBDaGFubmVsc1wiLGZhbHNlLFwic3BsaXRfY2hhbm5lbHNcIik7XG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJjb21ib1wiLFwiQ2hhbm5lbFwiLFwiUkdCXCIseyB2YWx1ZXM6W1wiUkdCXCIsXCJSXCIsXCJHXCIsXCJCXCJdfSk7XG5cdFx0dGhpcy5jdXJ2ZV9vZmZzZXQgPSA2ODtcblx0XHR0aGlzLnNpemUgPSBbIDI0MCwgMTYwIF07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlQ3VydmUudGl0bGUgPSBcIkN1cnZlXCI7XG5cdExHcmFwaFRleHR1cmVDdXJ2ZS5kZXNjID0gXCJHZW5lcmF0ZXMgb3IgYXBwbGllcyBhIGN1cnZlIHRvIGEgdGV4dHVyZVwiO1xuXHRMR3JhcGhUZXh0dXJlQ3VydmUud2lkZ2V0c19pbmZvID0ge1xuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlQ3VydmUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cblx0XHR2YXIgdGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblx0XHRpZighdGV4KSAvL2dlbmVyYXRlIG9uZSB0ZXh0dXJlLCBub3RoaW5nIGVsc2Vcblx0XHR7XG5cdFx0XHRpZih0aGlzLl9tdXN0X3VwZGF0ZSB8fCAhdGhpcy5fY3VydmVfdGV4dHVyZSApXG5cdFx0XHRcdHRoaXMudXBkYXRlQ3VydmUoKTtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl9jdXJ2ZV90ZXh0dXJlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdHlwZSA9IExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZVR5cGUoIHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24sIHRleCApO1xuXHRcdFxuXHRcdC8vYXBwbHkgY3VydmUgdG8gaW5wdXQgdGV4dHVyZVxuXHRcdGlmICggIXRlbXAgfHwgdGVtcC50eXBlICE9IHR5cGUgfHwgdGVtcC53aWR0aCAhPSB0ZXgud2lkdGggfHwgdGVtcC5oZWlnaHQgIT0gdGV4LmhlaWdodCB8fCB0ZW1wLmZvcm1hdCAhPSB0ZXguZm9ybWF0KVxuXHRcdFx0dGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKCB0ZXgud2lkdGgsIHRleC5oZWlnaHQsIHsgdHlwZTogdHlwZSwgZm9ybWF0OiB0ZXguZm9ybWF0LCBmaWx0ZXI6IGdsLkxJTkVBUiB9ICk7XG5cblx0XHR2YXIgc2hhZGVyID0gTEdyYXBoVGV4dHVyZUN1cnZlLl9zaGFkZXI7XG5cdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdHNoYWRlciA9IExHcmFwaFRleHR1cmVDdXJ2ZS5fc2hhZGVyID0gbmV3IEdMLlNoYWRlciggR0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLCBMR3JhcGhUZXh0dXJlQ3VydmUucGl4ZWxfc2hhZGVyICk7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5fbXVzdF91cGRhdGUgfHwgIXRoaXMuX2N1cnZlX3RleHR1cmUgKVxuXHRcdFx0dGhpcy51cGRhdGVDdXJ2ZSgpO1xuXG5cdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XG5cdFx0dmFyIGN1cnZlX3RleHR1cmUgPSB0aGlzLl9jdXJ2ZV90ZXh0dXJlO1xuXG5cdFx0Ly9hcHBseSBzaGFkZXJcblx0XHR0ZW1wLmRyYXdUbyhmdW5jdGlvbigpIHtcblx0XHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0XHR0ZXguYmluZCgwKTtcblx0XHRcdGN1cnZlX3RleHR1cmUuYmluZCgxKTtcblx0XHRcdHNoYWRlci51bmlmb3Jtcyh1bmlmb3JtcykuZHJhdyhHTC5NZXNoLmdldFNjcmVlblF1YWQoKSk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGVtcCk7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlQ3VydmUucHJvdG90eXBlLnNhbXBsZUN1cnZlID0gZnVuY3Rpb24oZixwb2ludHMpXG5cdHtcblx0XHR2YXIgcG9pbnRzID0gcG9pbnRzIHx8IHRoaXMuX3BvaW50cy5SR0I7XG5cdFx0aWYoIXBvaW50cylcblx0XHRcdHJldHVybjtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7ICsraSlcblx0XHR7XG5cdFx0XHR2YXIgcCA9IHBvaW50c1tpXTtcblx0XHRcdHZhciBwbiA9IHBvaW50c1tpKzFdO1xuXHRcdFx0aWYocG5bMF0gPCBmKVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdHZhciByID0gKHBuWzBdIC0gcFswXSk7XG5cdFx0XHRpZiggTWF0aC5hYnMocikgPCAwLjAwMDAxIClcblx0XHRcdFx0cmV0dXJuIHBbMV07XG5cdFx0XHR2YXIgbG9jYWxfZiA9IChmIC0gcFswXSkgLyByO1xuXHRcdFx0cmV0dXJuIHBbMV0gKiAoMS4wIC0gbG9jYWxfZikgKyBwblsxXSAqIGxvY2FsX2Y7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUN1cnZlLnByb3RvdHlwZS51cGRhdGVDdXJ2ZSA9IGZ1bmN0aW9uKClcblx0e1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG5cdFx0dmFyIG51bSA9IHZhbHVlcy5sZW5ndGggLyA0O1xuXHRcdHZhciBzcGxpdCA9IHRoaXMucHJvcGVydGllcy5zcGxpdF9jaGFubmVscztcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbnVtOyArK2kpXG5cdFx0e1xuXHRcdFx0aWYoc3BsaXQpXG5cdFx0XHR7XG5cdFx0XHRcdHZhbHVlc1tpKjRdID0gY2xhbXAoIHRoaXMuc2FtcGxlQ3VydmUoaS9udW0sdGhpcy5fcG9pbnRzLlIpKjI1NSwwLDI1NSk7XG5cdFx0XHRcdHZhbHVlc1tpKjQrMV0gPSBjbGFtcCggdGhpcy5zYW1wbGVDdXJ2ZShpL251bSx0aGlzLl9wb2ludHMuRykqMjU1LDAsMjU1KTtcblx0XHRcdFx0dmFsdWVzW2kqNCsyXSA9IGNsYW1wKCB0aGlzLnNhbXBsZUN1cnZlKGkvbnVtLHRoaXMuX3BvaW50cy5CKSoyNTUsMCwyNTUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgdiA9IHRoaXMuc2FtcGxlQ3VydmUoaS9udW0pOy8vc2FtcGxlIGN1cnZlXG5cdFx0XHRcdHZhbHVlc1tpKjRdID0gdmFsdWVzW2kqNCsxXSA9IHZhbHVlc1tpKjQrMl0gPSBjbGFtcCh2KjI1NSwwLDI1NSk7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZXNbaSo0KzNdID0gMjU1OyAvL2FscGhhIGZpeGVkXG5cdFx0fVxuXHRcdGlmKCF0aGlzLl9jdXJ2ZV90ZXh0dXJlKVxuXHRcdFx0dGhpcy5fY3VydmVfdGV4dHVyZSA9IG5ldyBHTC5UZXh0dXJlKDI1NiwxLHsgZm9ybWF0OiBnbC5SR0JBLCBtYWdGaWx0ZXI6IGdsLkxJTkVBUiwgd3JhcDogZ2wuQ0xBTVBfVE9fRURHRSB9KTtcblx0XHR0aGlzLl9jdXJ2ZV90ZXh0dXJlLnVwbG9hZERhdGEodmFsdWVzLG51bGwsdHJ1ZSk7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlQ3VydmUucHJvdG90eXBlLm9uU2VyaWFsaXplID0gZnVuY3Rpb24obylcblx0e1xuXHRcdHZhciBjdXJ2ZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgaW4gdGhpcy5fcG9pbnRzKVxuXHRcdFx0Y3VydmVzW2ldID0gdGhpcy5fcG9pbnRzW2ldLmNvbmNhdCgpO1xuXHRcdG8uY3VydmVzID0gY3VydmVzO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUN1cnZlLnByb3RvdHlwZS5vbkNvbmZpZ3VyZSA9IGZ1bmN0aW9uKG8pXG5cdHtcblx0XHR0aGlzLl9wb2ludHMgPSBvLmN1cnZlcztcblx0XHRpZih0aGlzLmN1cnZlX2VkaXRvcilcblx0XHRcdGN1cnZlX2VkaXRvci5wb2ludHMgPSB0aGlzLl9wb2ludHM7XG5cdFx0dGhpcy5fbXVzdF91cGRhdGUgPSB0cnVlO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUN1cnZlLnByb3RvdHlwZS5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKGUsIGxvY2FscG9zLCBncmFwaGNhbnZhcylcblx0e1xuXHRcdGlmKHRoaXMuY3VydmVfZWRpdG9yKVxuXHRcdHtcblx0XHRcdHZhciByID0gdGhpcy5jdXJ2ZV9lZGl0b3Iub25Nb3VzZURvd24oW2xvY2FscG9zWzBdLGxvY2FscG9zWzFdLXRoaXMuY3VydmVfb2Zmc2V0XSwgZ3JhcGhjYW52YXMpO1xuXHRcdFx0aWYocilcblx0XHRcdFx0dGhpcy5jYXB0dXJlSW5wdXQodHJ1ZSk7XG5cdFx0XHRyZXR1cm4gcjtcblx0XHR9XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlQ3VydmUucHJvdG90eXBlLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24oZSwgbG9jYWxwb3MsIGdyYXBoY2FudmFzKVxuXHR7XG5cdFx0aWYodGhpcy5jdXJ2ZV9lZGl0b3IpXG5cdFx0XHRyZXR1cm4gdGhpcy5jdXJ2ZV9lZGl0b3Iub25Nb3VzZU1vdmUoW2xvY2FscG9zWzBdLGxvY2FscG9zWzFdLXRoaXMuY3VydmVfb2Zmc2V0XSwgZ3JhcGhjYW52YXMpO1xuXHR9XG5cblx0TEdyYXBoVGV4dHVyZUN1cnZlLnByb3RvdHlwZS5vbk1vdXNlVXAgPSBmdW5jdGlvbihlLCBsb2NhbHBvcywgZ3JhcGhjYW52YXMpXG5cdHtcblx0XHRpZih0aGlzLmN1cnZlX2VkaXRvcilcblx0XHRcdHJldHVybiB0aGlzLmN1cnZlX2VkaXRvci5vbk1vdXNlVXAoW2xvY2FscG9zWzBdLGxvY2FscG9zWzFdLXRoaXMuY3VydmVfb2Zmc2V0XSwgZ3JhcGhjYW52YXMpO1xuXHRcdHRoaXMuY2FwdHVyZUlucHV0KGZhbHNlKTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVDdXJ2ZS5jaGFubmVsX2xpbmVfY29sb3JzID0geyBcIlJHQlwiOlwiIzY2NlwiLFwiUlwiOlwiI0YzM1wiLFwiR1wiOlwiIzNGM1wiLFwiQlwiOlwiIzMzRlwiIH07XG5cblx0TEdyYXBoVGV4dHVyZUN1cnZlLnByb3RvdHlwZS5vbkRyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY3R4LCBncmFwaGNhbnZhcylcblx0e1xuXHRcdGlmKHRoaXMuZmxhZ3MuY29sbGFwc2VkKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0aWYoIXRoaXMuY3VydmVfZWRpdG9yKVxuXHRcdFx0dGhpcy5jdXJ2ZV9lZGl0b3IgPSBuZXcgTGl0ZUdyYXBoLkN1cnZlRWRpdG9yKHRoaXMuX3BvaW50cy5SKTtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC50cmFuc2xhdGUoMCx0aGlzLmN1cnZlX29mZnNldCk7XG5cdFx0dmFyIGNoYW5uZWwgPSB0aGlzLndpZGdldHNbMV0udmFsdWU7XG5cblx0XHRpZih0aGlzLnByb3BlcnRpZXMuc3BsaXRfY2hhbm5lbHMpXG5cdFx0e1xuXHRcdFx0aWYoY2hhbm5lbCA9PSBcIlJHQlwiKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLndpZGdldHNbMV0udmFsdWUgPSBjaGFubmVsID0gXCJSXCI7XG5cdFx0XHRcdHRoaXMud2lkZ2V0c1sxXS5kaXNhYmxlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5jdXJ2ZV9lZGl0b3IucG9pbnRzID0gdGhpcy5fcG9pbnRzLlI7XG5cdFx0XHR0aGlzLmN1cnZlX2VkaXRvci5kcmF3KCBjdHgsIFt0aGlzLnNpemVbMF0sdGhpcy5zaXplWzFdIC0gdGhpcy5jdXJ2ZV9vZmZzZXRdLCBncmFwaGNhbnZhcywgXCIjMTExXCIsIExHcmFwaFRleHR1cmVDdXJ2ZS5jaGFubmVsX2xpbmVfY29sb3JzLlIsIHRydWUgKTtcblx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImxpZ2h0ZW5cIjtcblx0XHRcdHRoaXMuY3VydmVfZWRpdG9yLnBvaW50cyA9IHRoaXMuX3BvaW50cy5HO1xuXHRcdFx0dGhpcy5jdXJ2ZV9lZGl0b3IuZHJhdyggY3R4LCBbdGhpcy5zaXplWzBdLHRoaXMuc2l6ZVsxXSAtIHRoaXMuY3VydmVfb2Zmc2V0XSwgZ3JhcGhjYW52YXMsIG51bGwsIExHcmFwaFRleHR1cmVDdXJ2ZS5jaGFubmVsX2xpbmVfY29sb3JzLkcsIHRydWUgKTtcblx0XHRcdHRoaXMuY3VydmVfZWRpdG9yLnBvaW50cyA9IHRoaXMuX3BvaW50cy5CO1xuXHRcdFx0dGhpcy5jdXJ2ZV9lZGl0b3IuZHJhdyggY3R4LCBbdGhpcy5zaXplWzBdLHRoaXMuc2l6ZVsxXSAtIHRoaXMuY3VydmVfb2Zmc2V0XSwgZ3JhcGhjYW52YXMsIG51bGwsIExHcmFwaFRleHR1cmVDdXJ2ZS5jaGFubmVsX2xpbmVfY29sb3JzLkIsIHRydWUgKTtcblx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHR0aGlzLndpZGdldHNbMV0udmFsdWUgPSBjaGFubmVsID0gXCJSR0JcIjtcblx0XHRcdHRoaXMud2lkZ2V0c1sxXS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0dGhpcy5jdXJ2ZV9lZGl0b3IucG9pbnRzID0gdGhpcy5fcG9pbnRzW2NoYW5uZWxdO1xuXHRcdHRoaXMuY3VydmVfZWRpdG9yLmRyYXcoIGN0eCwgW3RoaXMuc2l6ZVswXSx0aGlzLnNpemVbMV0gLSB0aGlzLmN1cnZlX29mZnNldF0sIGdyYXBoY2FudmFzLCB0aGlzLnByb3BlcnRpZXMuc3BsaXRfY2hhbm5lbHMgPyBudWxsIDogXCIjMTExXCIsIExHcmFwaFRleHR1cmVDdXJ2ZS5jaGFubmVsX2xpbmVfY29sb3JzW2NoYW5uZWxdICApO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlQ3VydmUucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV9jdXJ2ZTtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9yYW5nZTtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKCB1X3RleHR1cmUsIHZfY29vcmQgKSAqIHVfcmFuZ2U7XFxuXFxcblx0XHRcdGNvbG9yLnggPSB0ZXh0dXJlMkQoIHVfY3VydmUsIHZlYzIoIGNvbG9yLngsIDAuNSApICkueDtcXG5cXFxuXHRcdFx0Y29sb3IueSA9IHRleHR1cmUyRCggdV9jdXJ2ZSwgdmVjMiggY29sb3IueSwgMC41ICkgKS55O1xcblxcXG5cdFx0XHRjb2xvci56ID0gdGV4dHVyZTJEKCB1X2N1cnZlLCB2ZWMyKCBjb2xvci56LCAwLjUgKSApLno7XFxuXFxcblx0XHRcdC8vY29sb3IudyA9IHRleHR1cmUyRCggdV9jdXJ2ZSwgdmVjMiggY29sb3IudywgMC41ICkgKS53O1xcblxcXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cXFxuXHRcdH1cIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvY3VydmVcIiwgTEdyYXBoVGV4dHVyZUN1cnZlKTtcblxuXHQvL3NpbXBsZSBleHBvc2l0aW9uLCBidXQgcGxhbiB0byBleHBhbmQgaXQgdG8gc3VwcG9ydCBkaWZmZXJlbnQgZ2FtbWEgY3VydmVzXG5cdGZ1bmN0aW9uIExHcmFwaEV4cG9zaXRpb24oKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLmFkZElucHV0KFwiZXhwXCIsIFwibnVtYmVyXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IGV4cG9zaXRpb246IDEsIHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5MT1cgfTtcblx0XHR0aGlzLl91bmlmb3JtcyA9IHsgdV90ZXh0dXJlOiAwLCB1X2V4cG9zaXRpb246IDEgfTtcblx0fVxuXG5cdExHcmFwaEV4cG9zaXRpb24udGl0bGUgPSBcIkV4cG9zaXRpb25cIjtcblx0TEdyYXBoRXhwb3NpdGlvbi5kZXNjID0gXCJDb250cm9scyB0ZXh0dXJlIGV4cG9zaXRpb25cIjtcblxuXHRMR3JhcGhFeHBvc2l0aW9uLndpZGdldHNfaW5mbyA9IHtcblx0XHRleHBvc2l0aW9uOiB7IHdpZGdldDogXCJzbGlkZXJcIiwgbWluOiAwLCBtYXg6IDMgfSxcblx0XHRwcmVjaXNpb246IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoVGV4dHVyZS5NT0RFX1ZBTFVFUyB9XG5cdH07XG5cblx0TEdyYXBoRXhwb3NpdGlvbi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXHRcdGlmIChcblx0XHRcdCF0ZW1wIHx8XG5cdFx0XHR0ZW1wLndpZHRoICE9IHRleC53aWR0aCB8fFxuXHRcdFx0dGVtcC5oZWlnaHQgIT0gdGV4LmhlaWdodCB8fFxuXHRcdFx0dGVtcC50eXBlICE9IHRleC50eXBlXG5cdFx0KSB7XG5cdFx0XHR0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoXG5cdFx0XHRcdHRleC53aWR0aCxcblx0XHRcdFx0dGV4LmhlaWdodCxcblx0XHRcdFx0eyB0eXBlOiB0ZXgudHlwZSwgZm9ybWF0OiBnbC5SR0JBLCBmaWx0ZXI6IGdsLkxJTkVBUiB9XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhFeHBvc2l0aW9uLl9zaGFkZXI7XG5cdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdHNoYWRlciA9IExHcmFwaEV4cG9zaXRpb24uX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoRXhwb3NpdGlvbi5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dmFyIGV4cCA9IHRoaXMucHJvcGVydGllcy5leHBvc2l0aW9uO1xuXHRcdHZhciBleHBfaW5wdXQgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcblx0XHRpZiAoZXhwX2lucHV0ICE9IG51bGwpIHtcblx0XHRcdGV4cCA9IHRoaXMucHJvcGVydGllcy5leHBvc2l0aW9uID0gZXhwX2lucHV0O1xuXHRcdH1cblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3JtcztcblxuXHRcdC8vYXBwbHkgc2hhZGVyXG5cdFx0dGVtcC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHRzaGFkZXIudW5pZm9ybXModW5pZm9ybXMpLmRyYXcoR0wuTWVzaC5nZXRTY3JlZW5RdWFkKCkpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRlbXApO1xuXHR9O1xuXG5cdExHcmFwaEV4cG9zaXRpb24ucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2V4cG9zaXRpb247XFxuXFxcblx0XHRcXG5cXFxuXHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCggdV90ZXh0dXJlLCB2X2Nvb3JkICk7XFxuXFxcblx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yLnh5eiAqIHVfZXhwb3NpdGlvbiwgY29sb3IuYSApO1xcblxcXG5cdFx0fVwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9leHBvc2l0aW9uXCIsIExHcmFwaEV4cG9zaXRpb24pO1xuXG5cdGZ1bmN0aW9uIExHcmFwaFRvbmVNYXBwaW5nKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcImF2Z1wiLCBcIm51bWJlcixUZXh0dXJlXCIpO1xuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0c2NhbGU6IDEsXG5cdFx0XHRnYW1tYTogMSxcblx0XHRcdGF2ZXJhZ2VfbHVtOiAxLFxuXHRcdFx0bHVtX3doaXRlOiAxLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkxPV1xuXHRcdH07XG5cblx0XHR0aGlzLl91bmlmb3JtcyA9IHtcblx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdHVfbHVtd2hpdGUyOiAxLFxuXHRcdFx0dV9pZ2FtbWE6IDEsXG5cdFx0XHR1X3NjYWxlOiAxLFxuXHRcdFx0dV9hdmVyYWdlX2x1bTogMVxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhUb25lTWFwcGluZy50aXRsZSA9IFwiVG9uZSBNYXBwaW5nXCI7XG5cdExHcmFwaFRvbmVNYXBwaW5nLmRlc2MgPVxuXHRcdFwiQXBwbGllcyBUb25lIE1hcHBpbmcgdG8gY29udmVydCBmcm9tIGhpZ2ggdG8gbG93XCI7XG5cblx0TEdyYXBoVG9uZU1hcHBpbmcud2lkZ2V0c19pbmZvID0ge1xuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUb25lTWFwcGluZy5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gW1tcImVuYWJsZWRcIiwgXCJib29sZWFuXCJdXTtcblx0fTtcblxuXHRMR3JhcGhUb25lTWFwcGluZy5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSAvL3NhdmVzIHdvcmtcblxuXHRcdGlmIChcblx0XHRcdHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuUEFTU19USFJPVUdIIHx8XG5cdFx0XHR0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcImVuYWJsZWRcIikgPT09IGZhbHNlXG5cdFx0KSB7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdGVtcCA9IHRoaXMuX3RlbXBfdGV4dHVyZTtcblxuXHRcdGlmIChcblx0XHRcdCF0ZW1wIHx8XG5cdFx0XHR0ZW1wLndpZHRoICE9IHRleC53aWR0aCB8fFxuXHRcdFx0dGVtcC5oZWlnaHQgIT0gdGV4LmhlaWdodCB8fFxuXHRcdFx0dGVtcC50eXBlICE9IHRleC50eXBlXG5cdFx0KSB7XG5cdFx0XHR0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoXG5cdFx0XHRcdHRleC53aWR0aCxcblx0XHRcdFx0dGV4LmhlaWdodCxcblx0XHRcdFx0eyB0eXBlOiB0ZXgudHlwZSwgZm9ybWF0OiBnbC5SR0JBLCBmaWx0ZXI6IGdsLkxJTkVBUiB9XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHZhciBhdmcgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcblx0XHRpZiAoYXZnID09IG51bGwpIHtcblx0XHRcdGF2ZyA9IHRoaXMucHJvcGVydGllcy5hdmVyYWdlX2x1bTtcblx0XHR9XG5cblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3Jtcztcblx0XHR2YXIgc2hhZGVyID0gbnVsbDtcblxuXHRcdGlmIChhdmcuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLmF2ZXJhZ2VfbHVtID0gYXZnO1xuXHRcdFx0dW5pZm9ybXMudV9hdmVyYWdlX2x1bSA9IHRoaXMucHJvcGVydGllcy5hdmVyYWdlX2x1bTtcblx0XHRcdHNoYWRlciA9IExHcmFwaFRvbmVNYXBwaW5nLl9zaGFkZXI7XG5cdFx0XHRpZiAoIXNoYWRlcikge1xuXHRcdFx0XHRzaGFkZXIgPSBMR3JhcGhUb25lTWFwcGluZy5fc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcblx0XHRcdFx0XHRHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXG5cdFx0XHRcdFx0TEdyYXBoVG9uZU1hcHBpbmcucGl4ZWxfc2hhZGVyXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChhdmcuY29uc3RydWN0b3IgPT09IEdMLlRleHR1cmUpIHtcblx0XHRcdHVuaWZvcm1zLnVfYXZlcmFnZV90ZXh0dXJlID0gYXZnLmJpbmQoMSk7XG5cdFx0XHRzaGFkZXIgPSBMR3JhcGhUb25lTWFwcGluZy5fc2hhZGVyX3RleHR1cmU7XG5cdFx0XHRpZiAoIXNoYWRlcikge1xuXHRcdFx0XHRzaGFkZXIgPSBMR3JhcGhUb25lTWFwcGluZy5fc2hhZGVyX3RleHR1cmUgPSBuZXcgR0wuU2hhZGVyKFxuXHRcdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0XHRMR3JhcGhUb25lTWFwcGluZy5waXhlbF9zaGFkZXIsXG5cdFx0XHRcdFx0eyBBVkdfVEVYVFVSRTogXCJcIiB9XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dW5pZm9ybXMudV9sdW13aGl0ZTIgPVxuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLmx1bV93aGl0ZSAqIHRoaXMucHJvcGVydGllcy5sdW1fd2hpdGU7XG5cdFx0dW5pZm9ybXMudV9zY2FsZSA9IHRoaXMucHJvcGVydGllcy5zY2FsZTtcblx0XHR1bmlmb3Jtcy51X2lnYW1tYSA9IDEgLyB0aGlzLnByb3BlcnRpZXMuZ2FtbWE7XG5cblx0XHQvL2FwcGx5IHNoYWRlclxuXHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0dGVtcC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHR0ZXguYmluZCgwKTtcblx0XHRcdHNoYWRlci51bmlmb3Jtcyh1bmlmb3JtcykuZHJhdyhHTC5NZXNoLmdldFNjcmVlblF1YWQoKSk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGVtcF90ZXh0dXJlKTtcblx0fTtcblxuXHRMR3JhcGhUb25lTWFwcGluZy5waXhlbF9zaGFkZXIgPVxuXHRcdFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfc2NhbGU7XFxuXFxcblx0XHQjaWZkZWYgQVZHX1RFWFRVUkVcXG5cXFxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV9hdmVyYWdlX3RleHR1cmU7XFxuXFxcblx0XHQjZWxzZVxcblxcXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfYXZlcmFnZV9sdW07XFxuXFxcblx0XHQjZW5kaWZcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9sdW13aGl0ZTI7XFxuXFxcblx0XHR1bmlmb3JtIGZsb2F0IHVfaWdhbW1hO1xcblxcXG5cdFx0dmVjMyBSR0IyeHlZICh2ZWMzIHJnYilcXG5cXFxuXHRcdHtcXG5cXFxuXHRcdFx0IGNvbnN0IG1hdDMgUkdCMlhZWiA9IG1hdDMoMC40MTI0LCAwLjM1NzYsIDAuMTgwNSxcXG5cXFxuXHRcdFx0XHRcdFx0XHRcdFx0ICAgMC4yMTI2LCAwLjcxNTIsIDAuMDcyMixcXG5cXFxuXHRcdFx0XHRcdFx0XHRcdFx0ICAgMC4wMTkzLCAwLjExOTIsIDAuOTUwNSk7XFxuXFxcblx0XHRcdHZlYzMgWFlaID0gUkdCMlhZWiAqIHJnYjtcXG5cXFxuXHRcdFx0XFxuXFxcblx0XHRcdGZsb2F0IGYgPSAoWFlaLnggKyBYWVoueSArIFhZWi56KTtcXG5cXFxuXHRcdFx0cmV0dXJuIHZlYzMoWFlaLnggLyBmLFxcblxcXG5cdFx0XHRcdFx0XHRYWVoueSAvIGYsXFxuXFxcblx0XHRcdFx0XHRcdFhZWi55KTtcXG5cXFxuXHRcdH1cXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKCB1X3RleHR1cmUsIHZfY29vcmQgKTtcXG5cXFxuXHRcdFx0dmVjMyByZ2IgPSBjb2xvci54eXo7XFxuXFxcblx0XHRcdGZsb2F0IGF2ZXJhZ2VfbHVtID0gMC4wO1xcblxcXG5cdFx0XHQjaWZkZWYgQVZHX1RFWFRVUkVcXG5cXFxuXHRcdFx0XHR2ZWMzIHBpeGVsID0gdGV4dHVyZTJEKHVfYXZlcmFnZV90ZXh0dXJlLHZlYzIoMC41KSkueHl6O1xcblxcXG5cdFx0XHRcdGF2ZXJhZ2VfbHVtID0gKHBpeGVsLnggKyBwaXhlbC55ICsgcGl4ZWwueikgLyAzLjA7XFxuXFxcblx0XHRcdCNlbHNlXFxuXFxcblx0XHRcdFx0YXZlcmFnZV9sdW0gPSB1X2F2ZXJhZ2VfbHVtO1xcblxcXG5cdFx0XHQjZW5kaWZcXG5cXFxuXHRcdFx0Ly9MZCAtIHRoaXMgcGFydCBvZiB0aGUgY29kZSBpcyB0aGUgc2FtZSBmb3IgYm90aCB2ZXJzaW9uc1xcblxcXG5cdFx0XHRmbG9hdCBsdW0gPSBkb3QocmdiLCB2ZWMzKDAuMjEyNiwgMC43MTUyLCAwLjA3MjIpKTtcXG5cXFxuXHRcdFx0ZmxvYXQgTCA9ICh1X3NjYWxlIC8gYXZlcmFnZV9sdW0pICogbHVtO1xcblxcXG5cdFx0XHRmbG9hdCBMZCA9IChMICogKDEuMCArIEwgLyB1X2x1bXdoaXRlMikpIC8gKDEuMCArIEwpO1xcblxcXG5cdFx0XHQvL2ZpcnN0XFxuXFxcblx0XHRcdC8vdmVjMyB4eVkgPSBSR0IyeHlZKHJnYik7XFxuXFxcblx0XHRcdC8veHlZLnogKj0gTGQ7XFxuXFxcblx0XHRcdC8vcmdiID0geHlZdG9SR0IoeHlZKTtcXG5cXFxuXHRcdFx0Ly9zZWNvbmRcXG5cXFxuXHRcdFx0cmdiID0gKHJnYiAvIGx1bSkgKiBMZDtcXG5cXFxuXHRcdFx0cmdiID0gbWF4KHJnYix2ZWMzKDAuMDAxKSk7XFxuXFxcblx0XHRcdHJnYiA9IHBvdyggcmdiLCB2ZWMzKCB1X2lnYW1tYSApICk7XFxuXFxcblx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHJnYiwgY29sb3IuYSApO1xcblxcXG5cdFx0fVwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS90b25lbWFwcGluZ1wiLCBMR3JhcGhUb25lTWFwcGluZyk7XG5cblx0ZnVuY3Rpb24gTEdyYXBoVGV4dHVyZVBlcmxpbigpIHtcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0d2lkdGg6IDUxMixcblx0XHRcdGhlaWdodDogNTEyLFxuXHRcdFx0c2VlZDogMCxcblx0XHRcdHBlcnNpc3RlbmNlOiAwLjEsXG5cdFx0XHRvY3RhdmVzOiA4LFxuXHRcdFx0c2NhbGU6IDEsXG5cdFx0XHRvZmZzZXQ6IFswLCAwXSxcblx0XHRcdGFtcGxpdHVkZTogMSxcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXG5cdFx0fTtcblx0XHR0aGlzLl9rZXkgPSAwO1xuXHRcdHRoaXMuX3RleHR1cmUgPSBudWxsO1xuXHRcdHRoaXMuX3VuaWZvcm1zID0ge1xuXHRcdFx0dV9wZXJzaXN0ZW5jZTogMC4xLFxuXHRcdFx0dV9zZWVkOiAwLFxuXHRcdFx0dV9vZmZzZXQ6IHZlYzIuY3JlYXRlKCksXG5cdFx0XHR1X3NjYWxlOiAxLFxuXHRcdFx0dV92aWV3cG9ydDogdmVjMi5jcmVhdGUoKVxuXHRcdH07XG5cdH1cblxuXHRMR3JhcGhUZXh0dXJlUGVybGluLnRpdGxlID0gXCJQZXJsaW5cIjtcblx0TEdyYXBoVGV4dHVyZVBlcmxpbi5kZXNjID0gXCJHZW5lcmF0ZXMgYSBwZXJsaW4gbm9pc2UgdGV4dHVyZVwiO1xuXG5cdExHcmFwaFRleHR1cmVQZXJsaW4ud2lkZ2V0c19pbmZvID0ge1xuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH0sXG5cdFx0d2lkdGg6IHsgdHlwZTogXCJudW1iZXJcIiwgcHJlY2lzaW9uOiAwLCBzdGVwOiAxIH0sXG5cdFx0aGVpZ2h0OiB7IHR5cGU6IFwibnVtYmVyXCIsIHByZWNpc2lvbjogMCwgc3RlcDogMSB9LFxuXHRcdG9jdGF2ZXM6IHsgdHlwZTogXCJudW1iZXJcIiwgcHJlY2lzaW9uOiAwLCBzdGVwOiAxLCBtaW46IDEsIG1heDogNTAgfVxuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVQZXJsaW4ucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdFtcInNlZWRcIiwgXCJudW1iZXJcIl0sXG5cdFx0XHRbXCJwZXJzaXN0ZW5jZVwiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcIm9jdGF2ZXNcIiwgXCJudW1iZXJcIl0sXG5cdFx0XHRbXCJzY2FsZVwiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcImFtcGxpdHVkZVwiLCBcIm51bWJlclwiXSxcblx0XHRcdFtcIm9mZnNldFwiLCBcInZlYzJcIl1cblx0XHRdO1xuXHR9O1xuXG5cdExHcmFwaFRleHR1cmVQZXJsaW4ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHR2YXIgdyA9IHRoaXMucHJvcGVydGllcy53aWR0aCB8IDA7XG5cdFx0dmFyIGggPSB0aGlzLnByb3BlcnRpZXMuaGVpZ2h0IHwgMDtcblx0XHRpZiAodyA9PSAwKSB7XG5cdFx0XHR3ID0gZ2wudmlld3BvcnRfZGF0YVsyXTtcblx0XHR9IC8vMCBtZWFucyBkZWZhdWx0XG5cdFx0aWYgKGggPT0gMCkge1xuXHRcdFx0aCA9IGdsLnZpZXdwb3J0X2RhdGFbM107XG5cdFx0fSAvLzAgbWVhbnMgZGVmYXVsdFxuXHRcdHZhciB0eXBlID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlVHlwZSh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uKTtcblxuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGV4dHVyZTtcblx0XHRpZiAoXG5cdFx0XHQhdGVtcCB8fFxuXHRcdFx0dGVtcC53aWR0aCAhPSB3IHx8XG5cdFx0XHR0ZW1wLmhlaWdodCAhPSBoIHx8XG5cdFx0XHR0ZW1wLnR5cGUgIT0gdHlwZVxuXHRcdCkge1xuXHRcdFx0dGVtcCA9IHRoaXMuX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSh3LCBoLCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGZvcm1hdDogZ2wuUkdCLFxuXHRcdFx0XHRmaWx0ZXI6IGdsLkxJTkVBUlxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIHBlcnNpc3RlbmNlID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJwZXJzaXN0ZW5jZVwiKTtcblx0XHR2YXIgb2N0YXZlcyA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwib2N0YXZlc1wiKTtcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJvZmZzZXRcIik7XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJzY2FsZVwiKTtcblx0XHR2YXIgYW1wbGl0dWRlID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJhbXBsaXR1ZGVcIik7XG5cdFx0dmFyIHNlZWQgPSB0aGlzLmdldElucHV0T3JQcm9wZXJ0eShcInNlZWRcIik7XG5cblx0XHQvL3JldXNpbmcgb2xkIHRleHR1cmVcblx0XHR2YXIga2V5ID1cblx0XHRcdFwiXCIgK1xuXHRcdFx0dyArXG5cdFx0XHRoICtcblx0XHRcdHR5cGUgK1xuXHRcdFx0cGVyc2lzdGVuY2UgK1xuXHRcdFx0b2N0YXZlcyArXG5cdFx0XHRzY2FsZSArXG5cdFx0XHRzZWVkICtcblx0XHRcdG9mZnNldFswXSArXG5cdFx0XHRvZmZzZXRbMV0gK1xuXHRcdFx0YW1wbGl0dWRlO1xuXHRcdGlmIChrZXkgPT0gdGhpcy5fa2V5KSB7XG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGVtcCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuX2tleSA9IGtleTtcblxuXHRcdC8vZ2F0aGVyIHVuaWZvcm1zXG5cdFx0dmFyIHVuaWZvcm1zID0gdGhpcy5fdW5pZm9ybXM7XG5cdFx0dW5pZm9ybXMudV9wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xuXHRcdHVuaWZvcm1zLnVfb2N0YXZlcyA9IG9jdGF2ZXM7XG5cdFx0dW5pZm9ybXMudV9vZmZzZXQuc2V0KG9mZnNldCk7XG5cdFx0dW5pZm9ybXMudV9zY2FsZSA9IHNjYWxlO1xuXHRcdHVuaWZvcm1zLnVfYW1wbGl0dWRlID0gYW1wbGl0dWRlO1xuXHRcdHVuaWZvcm1zLnVfc2VlZCA9IHNlZWQgKiAxMjg7XG5cdFx0dW5pZm9ybXMudV92aWV3cG9ydFswXSA9IHc7XG5cdFx0dW5pZm9ybXMudV92aWV3cG9ydFsxXSA9IGg7XG5cblx0XHQvL3JlbmRlclxuXHRcdHZhciBzaGFkZXIgPSBMR3JhcGhUZXh0dXJlUGVybGluLl9zaGFkZXI7XG5cdFx0aWYgKCFzaGFkZXIpIHtcblx0XHRcdHNoYWRlciA9IExHcmFwaFRleHR1cmVQZXJsaW4uX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoVGV4dHVyZVBlcmxpbi5waXhlbF9zaGFkZXJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Z2wuZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblxuXHRcdHRlbXAuZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0c2hhZGVyLnVuaWZvcm1zKHVuaWZvcm1zKS5kcmF3KEdMLk1lc2guZ2V0U2NyZWVuUXVhZCgpKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZW1wKTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlUGVybGluLnBpeGVsX3NoYWRlciA9XG5cdFx0XCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxuXHRcdHVuaWZvcm0gdmVjMiB1X29mZnNldDtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9zY2FsZTtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9wZXJzaXN0ZW5jZTtcXG5cXFxuXHRcdHVuaWZvcm0gaW50IHVfb2N0YXZlcztcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9hbXBsaXR1ZGU7XFxuXFxcblx0XHR1bmlmb3JtIHZlYzIgdV92aWV3cG9ydDtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9zZWVkO1xcblxcXG5cdFx0I2RlZmluZSBNX1BJIDMuMTQxNTkyNjUzNTg5NzkzMjM4NDZcXG5cXFxuXHRcdFxcblxcXG5cdFx0ZmxvYXQgcmFuZCh2ZWMyIGMpe1x0cmV0dXJuIGZyYWN0KHNpbihkb3QoYy54eSAsdmVjMiggMTIuOTg5OCArIHVfc2VlZCw3OC4yMzMgKyB1X3NlZWQpKSkgKiA0Mzc1OC41NDUzKTsgfVxcblxcXG5cdFx0XFxuXFxcblx0XHRmbG9hdCBub2lzZSh2ZWMyIHAsIGZsb2F0IGZyZXEgKXtcXG5cXFxuXHRcdFx0ZmxvYXQgdW5pdCA9IHVfdmlld3BvcnQueC9mcmVxO1xcblxcXG5cdFx0XHR2ZWMyIGlqID0gZmxvb3IocC91bml0KTtcXG5cXFxuXHRcdFx0dmVjMiB4eSA9IG1vZChwLHVuaXQpL3VuaXQ7XFxuXFxcblx0XHRcdC8veHkgPSAzLip4eSp4eS0yLip4eSp4eSp4eTtcXG5cXFxuXHRcdFx0eHkgPSAuNSooMS4tY29zKE1fUEkqeHkpKTtcXG5cXFxuXHRcdFx0ZmxvYXQgYSA9IHJhbmQoKGlqK3ZlYzIoMC4sMC4pKSk7XFxuXFxcblx0XHRcdGZsb2F0IGIgPSByYW5kKChpait2ZWMyKDEuLDAuKSkpO1xcblxcXG5cdFx0XHRmbG9hdCBjID0gcmFuZCgoaWordmVjMigwLiwxLikpKTtcXG5cXFxuXHRcdFx0ZmxvYXQgZCA9IHJhbmQoKGlqK3ZlYzIoMS4sMS4pKSk7XFxuXFxcblx0XHRcdGZsb2F0IHgxID0gbWl4KGEsIGIsIHh5LngpO1xcblxcXG5cdFx0XHRmbG9hdCB4MiA9IG1peChjLCBkLCB4eS54KTtcXG5cXFxuXHRcdFx0cmV0dXJuIG1peCh4MSwgeDIsIHh5LnkpO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0XFxuXFxcblx0XHRmbG9hdCBwTm9pc2UodmVjMiBwLCBpbnQgcmVzKXtcXG5cXFxuXHRcdFx0ZmxvYXQgcGVyc2lzdGFuY2UgPSB1X3BlcnNpc3RlbmNlO1xcblxcXG5cdFx0XHRmbG9hdCBuID0gMC47XFxuXFxcblx0XHRcdGZsb2F0IG5vcm1LID0gMC47XFxuXFxcblx0XHRcdGZsb2F0IGYgPSA0LjtcXG5cXFxuXHRcdFx0ZmxvYXQgYW1wID0gMS4wO1xcblxcXG5cdFx0XHRpbnQgaUNvdW50ID0gMDtcXG5cXFxuXHRcdFx0Zm9yIChpbnQgaSA9IDA7IGk8NTA7IGkrKyl7XFxuXFxcblx0XHRcdFx0bis9YW1wKm5vaXNlKHAsIGYpO1xcblxcXG5cdFx0XHRcdGYqPTIuO1xcblxcXG5cdFx0XHRcdG5vcm1LKz1hbXA7XFxuXFxcblx0XHRcdFx0YW1wKj1wZXJzaXN0YW5jZTtcXG5cXFxuXHRcdFx0XHRpZiAoaUNvdW50ID49IHJlcylcXG5cXFxuXHRcdFx0XHRcdGJyZWFrO1xcblxcXG5cdFx0XHRcdGlDb3VudCsrO1xcblxcXG5cdFx0XHR9XFxuXFxcblx0XHRcdGZsb2F0IG5mID0gbi9ub3JtSztcXG5cXFxuXHRcdFx0cmV0dXJuIG5mKm5mKm5mKm5mO1xcblxcXG5cdFx0fVxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWMyIHV2ID0gdl9jb29yZCAqIHVfc2NhbGUgKiB1X3ZpZXdwb3J0ICsgdV9vZmZzZXQgKiB1X3NjYWxlO1xcblxcXG5cdFx0XHR2ZWM0IGNvbG9yID0gdmVjNCggcE5vaXNlKCB1diwgdV9vY3RhdmVzICkgKiB1X2FtcGxpdHVkZSApO1xcblxcXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cXFxuXHRcdH1cIjtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcInRleHR1cmUvcGVybGluXCIsIExHcmFwaFRleHR1cmVQZXJsaW4pO1xuXG5cdGZ1bmN0aW9uIExHcmFwaFRleHR1cmVDYW52YXMyRCgpIHtcblx0XHR0aGlzLmFkZElucHV0KFwidlwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIlRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0Y29kZTogTEdyYXBoVGV4dHVyZUNhbnZhczJELmRlZmF1bHRfY29kZSxcblx0XHRcdHdpZHRoOiA1MTIsXG5cdFx0XHRoZWlnaHQ6IDUxMixcblx0XHRcdGNsZWFyOiB0cnVlLFxuXHRcdFx0cHJlY2lzaW9uOiBMR3JhcGhUZXh0dXJlLkRFRkFVTFQsXG5cdFx0XHR1c2VfaHRtbF9jYW52YXM6IGZhbHNlXG5cdFx0fTtcblx0XHR0aGlzLl9mdW5jID0gbnVsbDtcblx0XHR0aGlzLl90ZW1wX3RleHR1cmUgPSBudWxsO1xuXHRcdHRoaXMuY29tcGlsZUNvZGUoKTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVDYW52YXMyRC50aXRsZSA9IFwiQ2FudmFzMkRcIjtcblx0TEdyYXBoVGV4dHVyZUNhbnZhczJELmRlc2MgPSBcIkV4ZWN1dGVzIENhbnZhczJEIGNvZGUgaW5zaWRlIGEgdGV4dHVyZSBvciB0aGUgdmlld3BvcnQuXCI7XG5cdExHcmFwaFRleHR1cmVDYW52YXMyRC5oZWxwID0gXCJTZXQgd2lkdGggYW5kIGhlaWdodCB0byAwIHRvIG1hdGNoIHZpZXdwb3J0IHNpemUuXCI7XG5cblx0TEdyYXBoVGV4dHVyZUNhbnZhczJELmRlZmF1bHRfY29kZSA9IFwiLy92YXJzOiBjYW52YXMsY3R4LHRpbWVcXG5jdHguZmlsbFN0eWxlPSdyZWQnO1xcbmN0eC5maWxsUmVjdCgwLDAsNTAsNTApO1xcblwiO1xuXG5cdExHcmFwaFRleHR1cmVDYW52YXMyRC53aWRnZXRzX2luZm8gPSB7XG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfSxcblx0XHRjb2RlOiB7IHR5cGU6IFwiY29kZVwiIH0sXG5cdFx0d2lkdGg6IHsgdHlwZTogXCJudW1iZXJcIiwgcHJlY2lzaW9uOiAwLCBzdGVwOiAxIH0sXG5cdFx0aGVpZ2h0OiB7IHR5cGU6IFwibnVtYmVyXCIsIHByZWNpc2lvbjogMCwgc3RlcDogMSB9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUNhbnZhczJELnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRpZiAobmFtZSA9PSBcImNvZGVcIiApXG5cdFx0XHR0aGlzLmNvbXBpbGVDb2RlKCB2YWx1ZSApO1xuXHR9XG5cdFxuXHRMR3JhcGhUZXh0dXJlQ2FudmFzMkQucHJvdG90eXBlLmNvbXBpbGVDb2RlID0gZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0dGhpcy5fZnVuYyA9IG51bGw7XG5cdFx0aWYoICFMaXRlR3JhcGguYWxsb3dfc2NyaXB0cyApXG5cdFx0XHRyZXR1cm47XG5cblx0XHR0cnkge1xuXHRcdFx0dGhpcy5fZnVuYyA9IG5ldyBGdW5jdGlvbiggXCJjYW52YXNcIiwgXCJjdHhcIiwgXCJ0aW1lXCIsIFwic2NyaXB0XCIsXCJ2XCIsIGNvZGUgKTtcblx0XHRcdHRoaXMuYm94Y29sb3IgPSBcIiMwMEZGMDBcIjtcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHRoaXMuYm94Y29sb3IgPSBcIiNGRjAwMDBcIjtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwYXJzaW5nIHNjcmlwdFwiKTtcblx0XHRcdGNvbnNvbGUuZXJyb3IoZXJyKTtcblx0XHR9XG5cdH07XG5cblx0TEdyYXBoVGV4dHVyZUNhbnZhczJELnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgZnVuYyA9IHRoaXMuX2Z1bmM7XG5cdFx0aWYgKCFmdW5jIHx8ICF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuZXhlY3V0ZURyYXcoIGZ1bmMgKTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVDYW52YXMyRC5wcm90b3R5cGUuZXhlY3V0ZURyYXcgPSBmdW5jdGlvbiggZnVuY19jb250ZXh0ICkge1xuXG5cdFx0dmFyIHdpZHRoID0gdGhpcy5wcm9wZXJ0aWVzLndpZHRoIHx8IGdsLmNhbnZhcy53aWR0aDtcblx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5wcm9wZXJ0aWVzLmhlaWdodCB8fCBnbC5jYW52YXMuaGVpZ2h0O1xuXHRcdHZhciB0ZW1wID0gdGhpcy5fdGVtcF90ZXh0dXJlO1xuXHRcdHZhciB0eXBlID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlVHlwZSggdGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiApO1xuXHRcdGlmICghdGVtcCB8fCB0ZW1wLndpZHRoICE9IHdpZHRoIHx8IHRlbXAuaGVpZ2h0ICE9IGhlaWdodCB8fCB0ZW1wLnR5cGUgIT0gdHlwZSApIHtcblx0XHRcdHRlbXAgPSB0aGlzLl90ZW1wX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSh3aWR0aCwgaGVpZ2h0LCB7XG5cdFx0XHRcdGZvcm1hdDogZ2wuUkdCQSxcblx0XHRcdFx0ZmlsdGVyOiBnbC5MSU5FQVIsXG5cdFx0XHRcdHR5cGU6IHR5cGVcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cblx0XHR2YXIgcHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcztcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dmFyIHRpbWUgPSB0aGlzLmdyYXBoLmdldFRpbWUoKTtcblx0XHR2YXIgY3R4ID0gZ2w7XG5cdFx0dmFyIGNhbnZhcyA9IGdsLmNhbnZhcztcblx0XHRpZiggdGhpcy5wcm9wZXJ0aWVzLnVzZV9odG1sX2NhbnZhcyB8fCAhZ2xvYmFsLmVuYWJsZVdlYkdMQ2FudmFzIClcblx0XHR7XG5cdFx0XHRpZighdGhpcy5fY2FudmFzKVxuXHRcdFx0e1xuXHRcdFx0XHRjYW52YXMgPSB0aGlzLl9jYW52YXMgPSBjcmVhdGVDYW52YXMod2lkdGguaGVpZ2h0KTtcblx0XHRcdFx0Y3R4ID0gdGhpcy5fY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0Y2FudmFzID0gdGhpcy5fY2FudmFzO1xuXHRcdFx0XHRjdHggPSB0aGlzLl9jdHg7XG5cdFx0XHR9XG5cdFx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0fVxuXG5cdFx0aWYoY3R4ID09IGdsKSAvL3VzaW5nIENhbnZhczJEdG9XZWJHTFxuXHRcdFx0dGVtcC5kcmF3VG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGdsLnN0YXJ0MkQoKTtcblx0XHRcdFx0aWYocHJvcGVydGllcy5jbGVhcilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGdsLmNsZWFyQ29sb3IoMCwwLDAsMCk7XG5cdFx0XHRcdFx0Z2wuY2xlYXIoIGdsLkNPTE9SX0JVRkZFUl9CSVQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKGZ1bmNfY29udGV4dC5kcmF3KSB7XG5cdFx0XHRcdFx0XHRmdW5jX2NvbnRleHQuZHJhdy5jYWxsKHRoYXQsIGNhbnZhcywgY3R4LCB0aW1lLCBmdW5jX2NvbnRleHQsIHYpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmdW5jX2NvbnRleHQuY2FsbCh0aGF0LCBjYW52YXMsIGN0eCwgdGltZSwgZnVuY19jb250ZXh0LHYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGF0LmJveGNvbG9yID0gXCIjMDBGRjAwXCI7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdHRoYXQuYm94Y29sb3IgPSBcIiNGRjAwMDBcIjtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgZXhlY3V0aW5nIHNjcmlwdFwiKTtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGVycik7XG5cdFx0XHRcdH1cblx0XHRcdFx0Z2wuZmluaXNoMkQoKTtcblx0XHRcdH0pO1xuXHRcdGVsc2UgLy9yZW5kZXJpbmcgdG8gb2Zmc2NyZWVuIGNhbnZhcyBhbmQgdXBsb2FkaW5nIHRvIHRleHR1cmVcblx0XHR7XG5cdFx0XHRpZihwcm9wZXJ0aWVzLmNsZWFyKVxuXHRcdFx0XHRjdHguY2xlYXJSZWN0KDAsMCxjYW52YXMud2lkdGgsY2FudmFzLmhlaWdodCk7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmIChmdW5jX2NvbnRleHQuZHJhdykge1xuXHRcdFx0XHRcdGZ1bmNfY29udGV4dC5kcmF3LmNhbGwodGhpcywgY2FudmFzLCBjdHgsIHRpbWUsIGZ1bmNfY29udGV4dCwgdik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZnVuY19jb250ZXh0LmNhbGwodGhpcywgY2FudmFzLCBjdHgsIHRpbWUsIGZ1bmNfY29udGV4dCx2KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmJveGNvbG9yID0gXCIjMDBGRjAwXCI7XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0dGhpcy5ib3hjb2xvciA9IFwiI0ZGMDAwMFwiO1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgZXhlY3V0aW5nIHNjcmlwdFwiKTtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihlcnIpO1xuXHRcdFx0fVxuXHRcdFx0dGVtcC51cGxvYWRJbWFnZSggY2FudmFzICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRlbXApO1xuXHR9O1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9jYW52YXMyRFwiLCBMR3JhcGhUZXh0dXJlQ2FudmFzMkQpO1xuXG5cdC8vIFRvIGRvIGNocm9tYSBrZXlpbmcgKioqKioqKioqKioqKioqKipcblxuXHRmdW5jdGlvbiBMR3JhcGhUZXh0dXJlTWF0dGUoKSB7XG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsIFwiVGV4dHVyZVwiKTtcblxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiVGV4dHVyZVwiKTtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRrZXlfY29sb3I6IHZlYzMuZnJvbVZhbHVlcygwLCAxLCAwKSxcblx0XHRcdHRocmVzaG9sZDogMC44LFxuXHRcdFx0c2xvcGU6IDAuMixcblx0XHRcdHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXG5cdFx0fTtcblx0fVxuXG5cdExHcmFwaFRleHR1cmVNYXR0ZS50aXRsZSA9IFwiTWF0dGVcIjtcblx0TEdyYXBoVGV4dHVyZU1hdHRlLmRlc2MgPSBcIkV4dHJhY3RzIGJhY2tncm91bmRcIjtcblxuXHRMR3JhcGhUZXh0dXJlTWF0dGUud2lkZ2V0c19pbmZvID0ge1xuXHRcdGtleV9jb2xvcjogeyB3aWRnZXQ6IFwiY29sb3JcIiB9LFxuXHRcdHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlTWF0dGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy9zYXZlcyB3b3JrXG5cblx0XHR2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XG5cblx0XHRpZiAodGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvbiA9PT0gTEdyYXBoVGV4dHVyZS5QQVNTX1RIUk9VR0gpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0ZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGV4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fdGV4ID0gTEdyYXBoVGV4dHVyZS5nZXRUYXJnZXRUZXh0dXJlKFxuXHRcdFx0dGV4LFxuXHRcdFx0dGhpcy5fdGV4LFxuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvblxuXHRcdCk7XG5cblx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXG5cdFx0aWYgKCF0aGlzLl91bmlmb3Jtcykge1xuXHRcdFx0dGhpcy5fdW5pZm9ybXMgPSB7XG5cdFx0XHRcdHVfdGV4dHVyZTogMCxcblx0XHRcdFx0dV9rZXlfY29sb3I6IHRoaXMucHJvcGVydGllcy5rZXlfY29sb3IsXG5cdFx0XHRcdHVfdGhyZXNob2xkOiAxLFxuXHRcdFx0XHR1X3Nsb3BlOiAxXG5cdFx0XHR9O1xuXHRcdH1cblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3JtcztcblxuXHRcdHZhciBtZXNoID0gTWVzaC5nZXRTY3JlZW5RdWFkKCk7XG5cdFx0dmFyIHNoYWRlciA9IExHcmFwaFRleHR1cmVNYXR0ZS5fc2hhZGVyO1xuXHRcdGlmICghc2hhZGVyKSB7XG5cdFx0XHRzaGFkZXIgPSBMR3JhcGhUZXh0dXJlTWF0dGUuX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXG5cdFx0XHRcdEdMLlNoYWRlci5TQ1JFRU5fVkVSVEVYX1NIQURFUixcblx0XHRcdFx0TEdyYXBoVGV4dHVyZU1hdHRlLnBpeGVsX3NoYWRlclxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR1bmlmb3Jtcy51X2tleV9jb2xvciA9IHRoaXMucHJvcGVydGllcy5rZXlfY29sb3I7XG5cdFx0dW5pZm9ybXMudV90aHJlc2hvbGQgPSB0aGlzLnByb3BlcnRpZXMudGhyZXNob2xkO1xuXHRcdHVuaWZvcm1zLnVfc2xvcGUgPSB0aGlzLnByb3BlcnRpZXMuc2xvcGU7XG5cblx0XHR0aGlzLl90ZXguZHJhd1RvKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGV4LmJpbmQoMCk7XG5cdFx0XHRzaGFkZXIudW5pZm9ybXModW5pZm9ybXMpLmRyYXcobWVzaCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGV4KTtcblx0fTtcblxuXHRMR3JhcGhUZXh0dXJlTWF0dGUucGl4ZWxfc2hhZGVyID1cblx0XHRcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXG5cdFx0dW5pZm9ybSB2ZWMzIHVfa2V5X2NvbG9yO1xcblxcXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3RocmVzaG9sZDtcXG5cXFxuXHRcdHVuaWZvcm0gZmxvYXQgdV9zbG9wZTtcXG5cXFxuXHRcdFxcblxcXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHR2ZWMzIGNvbG9yID0gdGV4dHVyZTJEKCB1X3RleHR1cmUsIHZfY29vcmQgKS54eXo7XFxuXFxcblx0XHRcdGZsb2F0IGRpZmYgPSBsZW5ndGgoIG5vcm1hbGl6ZShjb2xvcikgLSBub3JtYWxpemUodV9rZXlfY29sb3IpICk7XFxuXFxcblx0XHRcdGZsb2F0IGVkZ2UgPSB1X3RocmVzaG9sZCAqICgxLjAgLSB1X3Nsb3BlKTtcXG5cXFxuXHRcdFx0ZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKCBlZGdlLCB1X3RocmVzaG9sZCwgZGlmZik7XFxuXFxcblx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yLCBhbHBoYSApO1xcblxcXG5cdFx0fVwiO1xuXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwidGV4dHVyZS9tYXR0ZVwiLCBMR3JhcGhUZXh0dXJlTWF0dGUpO1xuXG5cdC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ZnVuY3Rpb24gTEdyYXBoQ3ViZW1hcFRvVGV4dHVyZTJEKCkge1xuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcInRleHR1cmVcIik7XG5cdFx0dGhpcy5hZGRJbnB1dChcInlhd1wiLCBcIm51bWJlclwiKTtcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcInRleHR1cmVcIik7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyB5YXc6IDAgfTtcblx0fVxuXG5cdExHcmFwaEN1YmVtYXBUb1RleHR1cmUyRC50aXRsZSA9IFwiQ3ViZW1hcFRvVGV4dHVyZTJEXCI7XG5cdExHcmFwaEN1YmVtYXBUb1RleHR1cmUyRC5kZXNjID0gXCJUcmFuc2Zvcm1zIGEgQ1VCRU1BUCB0ZXh0dXJlIGludG8gYSBURVhUVVJFMkQgaW4gUG9sYXIgUmVwcmVzZW50YXRpb25cIjtcblxuXHRMR3JhcGhDdWJlbWFwVG9UZXh0dXJlMkQucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSlcblx0XHRcdHJldHVybjtcblxuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcblx0XHRpZiAoICF0ZXggfHwgdGV4LnRleHR1cmVfdHlwZSAhPSBHTC5URVhUVVJFX0NVQkVfTUFQIClcblx0XHRcdHJldHVybjtcblx0XHRpZiggdGhpcy5fbGFzdF90ZXggJiYgKCB0aGlzLl9sYXN0X3RleC5oZWlnaHQgIT0gdGV4LmhlaWdodCB8fCB0aGlzLl9sYXN0X3RleC50eXBlICE9IHRleC50eXBlICkpXG5cdFx0XHR0aGlzLl9sYXN0X3RleCA9IG51bGw7XG5cdFx0dmFyIHlhdyA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwieWF3XCIpO1xuXHRcdHRoaXMuX2xhc3RfdGV4ID0gR0wuVGV4dHVyZS5jdWJlbWFwVG9UZXh0dXJlMkQoIHRleCwgdGV4LmhlaWdodCwgdGhpcy5fbGFzdF90ZXgsIHRydWUsIHlhdyApO1xuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgdGhpcy5fbGFzdF90ZXggKTtcblx0fTtcblxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJ0ZXh0dXJlL2N1YmVtYXBUb1RleHR1cmUyRFwiLCBMR3JhcGhDdWJlbWFwVG9UZXh0dXJlMkQgKTtcbn0pKHRoaXMpO1xuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBHTCA9PSBcInVuZGVmaW5lZFwiKVxyXG5cdFx0cmV0dXJuO1xyXG5cclxuICAgIHZhciBMaXRlR3JhcGggPSBnbG9iYWwuTGl0ZUdyYXBoO1xyXG5cdHZhciBMR3JhcGhDYW52YXMgPSBnbG9iYWwuTEdyYXBoQ2FudmFzO1xyXG5cclxuXHR2YXIgU0hBREVSTk9ERVNfQ09MT1IgPSBcIiMzNDVcIjtcclxuXHJcblx0dmFyIExHU2hhZGVycyA9IExpdGVHcmFwaC5TaGFkZXJzID0ge307XHJcblxyXG5cdHZhciBHTFNMX3R5cGVzID0gTEdTaGFkZXJzLkdMU0xfdHlwZXMgPSBbXCJmbG9hdFwiLFwidmVjMlwiLFwidmVjM1wiLFwidmVjNFwiLFwibWF0M1wiLFwibWF0NFwiLFwic2FtcGxlcjJEXCIsXCJzYW1wbGVyQ3ViZVwiXTtcclxuXHR2YXIgR0xTTF90eXBlc19jb25zdCA9IExHU2hhZGVycy5HTFNMX3R5cGVzX2NvbnN0ID0gW1wiZmxvYXRcIixcInZlYzJcIixcInZlYzNcIixcInZlYzRcIl07XHJcblxyXG5cdHZhciBHTFNMX2Z1bmN0aW9uc19kZXNjID0ge1xyXG5cdFx0XCJyYWRpYW5zXCI6IFwiVCByYWRpYW5zKFQgZGVncmVlcylcIixcclxuXHRcdFwiZGVncmVlc1wiOiBcIlQgZGVncmVlcyhUIHJhZGlhbnMpXCIsXHJcblx0XHRcInNpblwiOiBcIlQgc2luKFQgYW5nbGUpXCIsXHJcblx0XHRcImNvc1wiOiBcIlQgY29zKFQgYW5nbGUpXCIsXHJcblx0XHRcInRhblwiOiBcIlQgdGFuKFQgYW5nbGUpXCIsXHJcblx0XHRcImFzaW5cIjogXCJUIGFzaW4oVCB4KVwiLFxyXG5cdFx0XCJhY29zXCI6IFwiVCBhY29zKFQgeClcIixcclxuXHRcdFwiYXRhblwiOiBcIlQgYXRhbihUIHgpXCIsXHJcblx0XHRcImF0YW4yXCI6IFwiVCBhdGFuKFQgeCxUIHkpXCIsXHJcblx0XHRcInBvd1wiOiBcIlQgcG93KFQgeCxUIHkpXCIsXHJcblx0XHRcImV4cFwiOiBcIlQgZXhwKFQgeClcIixcclxuXHRcdFwibG9nXCI6IFwiVCBsb2coVCB4KVwiLFxyXG5cdFx0XCJleHAyXCI6IFwiVCBleHAyKFQgeClcIixcclxuXHRcdFwibG9nMlwiOiBcIlQgbG9nMihUIHgpXCIsXHJcblx0XHRcInNxcnRcIjogXCJUIHNxcnQoVCB4KVwiLFxyXG5cdFx0XCJpbnZlcnNlc3FydFwiOiBcIlQgaW52ZXJzZXNxcnQoVCB4KVwiLFxyXG5cdFx0XCJhYnNcIjogXCJUIGFicyhUIHgpXCIsXHJcblx0XHRcInNpZ25cIjogXCJUIHNpZ24oVCB4KVwiLFxyXG5cdFx0XCJmbG9vclwiOiBcIlQgZmxvb3IoVCB4KVwiLFxyXG5cdFx0XCJyb3VuZFwiOiBcIlQgcm91bmQoVCB4KVwiLFxyXG5cdFx0XCJjZWlsXCI6IFwiVCBjZWlsKFQgeClcIixcclxuXHRcdFwiZnJhY3RcIjogXCJUIGZyYWN0KFQgeClcIixcclxuXHRcdFwibW9kXCI6IFwiVCBtb2QoVCB4LFQgeSlcIiwgLy9cIlQgbW9kKFQgeCxmbG9hdCB5KVwiXHJcblx0XHRcIm1pblwiOiBcIlQgbWluKFQgeCxUIHkpXCIsXHJcblx0XHRcIm1heFwiOiBcIlQgbWF4KFQgeCxUIHkpXCIsXHJcblx0XHRcImNsYW1wXCI6IFwiVCBjbGFtcChUIHgsVCBtaW5WYWwgPSAwLjAsVCBtYXhWYWwgPSAxLjApXCIsXHJcblx0XHRcIm1peFwiOiBcIlQgbWl4KFQgeCxUIHksVCBhKVwiLCAvL1wiVCBtaXgoVCB4LFQgeSxmbG9hdCBhKVwiXHJcblx0XHRcInN0ZXBcIjogXCJUIHN0ZXAoVCBlZGdlLCBUIGVkZ2UyLCBUIHgpXCIsIC8vXCJUIHN0ZXAoZmxvYXQgZWRnZSwgVCB4KVwiXHJcblx0XHRcInNtb290aHN0ZXBcIjogXCJUIHNtb290aHN0ZXAoVCBlZGdlLCBUIGVkZ2UyLCBUIHgpXCIsIC8vXCJUIHNtb290aHN0ZXAoZmxvYXQgZWRnZSwgVCB4KVwiXHJcblx0XHRcImxlbmd0aFwiOlwiZmxvYXQgbGVuZ3RoKFQgeClcIixcclxuXHRcdFwiZGlzdGFuY2VcIjpcImZsb2F0IGRpc3RhbmNlKFQgcDAsIFQgcDEpXCIsXHJcblx0XHRcIm5vcm1hbGl6ZVwiOlwiVCBub3JtYWxpemUoVCB4KVwiLFxyXG5cdFx0XCJkb3RcIjogXCJmbG9hdCBkb3QoVCB4LFQgeSlcIixcclxuXHRcdFwiY3Jvc3NcIjogXCJ2ZWMzIGNyb3NzKHZlYzMgeCx2ZWMzIHkpXCIsXHJcblx0XHRcInJlZmxlY3RcIjogXCJ2ZWMzIHJlZmxlY3QodmVjMyBWLHZlYzMgTilcIixcclxuXHRcdFwicmVmcmFjdFwiOiBcInZlYzMgcmVmcmFjdCh2ZWMzIFYsdmVjMyBOLCBmbG9hdCBJT1IpXCJcclxuXHR9O1xyXG5cclxuXHQvL3BhcnNlIHRoZW1cclxuXHR2YXIgR0xTTF9mdW5jdGlvbnMgPSB7fTtcclxuXHR2YXIgR0xTTF9mdW5jdGlvbnNfbmFtZSA9IFtdO1xyXG5cdHBhcnNlR0xTTERlc2NyaXB0aW9ucygpO1xyXG5cclxuXHRMR1NoYWRlcnMuQUxMX1RZUEVTID0gXCJmbG9hdCx2ZWMyLHZlYzMsdmVjNFwiO1xyXG5cclxuXHRmdW5jdGlvbiBwYXJzZUdMU0xEZXNjcmlwdGlvbnMoKVxyXG5cdHtcclxuXHRcdEdMU0xfZnVuY3Rpb25zX25hbWUubGVuZ3RoID0gMDtcclxuXHJcblx0XHRmb3IodmFyIGkgaW4gR0xTTF9mdW5jdGlvbnNfZGVzYylcclxuXHRcdHtcclxuXHRcdFx0dmFyIG9wID0gR0xTTF9mdW5jdGlvbnNfZGVzY1tpXTtcclxuXHRcdFx0dmFyIGluZGV4ID0gb3AuaW5kZXhPZihcIiBcIik7XHJcblx0XHRcdHZhciByZXR1cm5fdHlwZSA9IG9wLnN1YnN0cigwLGluZGV4KTtcclxuXHRcdFx0dmFyIGluZGV4MiA9IG9wLmluZGV4T2YoXCIoXCIsaW5kZXgpO1xyXG5cdFx0XHR2YXIgZnVuY19uYW1lID0gb3Auc3Vic3RyKGluZGV4LGluZGV4Mi1pbmRleCkudHJpbSgpO1xyXG5cdFx0XHR2YXIgcGFyYW1zID0gb3Auc3Vic3RyKGluZGV4MiArIDEsIG9wLmxlbmd0aCAtIGluZGV4MiAtIDIpLnNwbGl0KFwiLFwiKTtcclxuXHRcdFx0Zm9yKHZhciBqIGluIHBhcmFtcylcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHZhciBwID0gcGFyYW1zW2pdLnNwbGl0KFwiIFwiKS5maWx0ZXIoZnVuY3Rpb24oYSl7IHJldHVybiBhOyB9KTtcclxuXHRcdFx0XHRwYXJhbXNbal0gPSB7IHR5cGU6IHBbMF0udHJpbSgpLCBuYW1lOiBwWzFdLnRyaW0oKSB9O1xyXG5cdFx0XHRcdGlmKHBbMl0gPT0gXCI9XCIpXHJcblx0XHRcdFx0XHRwYXJhbXNbal0udmFsdWUgPSBwWzNdLnRyaW0oKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRHTFNMX2Z1bmN0aW9uc1tpXSA9IHsgcmV0dXJuX3R5cGU6IHJldHVybl90eXBlLCBmdW5jOiBmdW5jX25hbWUsIHBhcmFtczogcGFyYW1zIH07XHJcblx0XHRcdEdMU0xfZnVuY3Rpb25zX25hbWUucHVzaCggZnVuY19uYW1lICk7XHJcblx0XHRcdC8vY29uc29sZS5sb2coIEdMU0xfZnVuY3Rpb25zW2ldICk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvL2NvbW1vbiBhY3Rpb25zIHRvIGFsbCBzaGFkZXIgbm9kZSBjbGFzc2VzXHJcblx0ZnVuY3Rpb24gcmVnaXN0ZXJTaGFkZXJOb2RlKCB0eXBlLCBub2RlX2N0b3IgKVxyXG5cdHtcclxuXHRcdC8vc3RhdGljIGF0dHJpYnV0ZXNcclxuXHRcdG5vZGVfY3Rvci5jb2xvciA9IFNIQURFUk5PREVTX0NPTE9SO1xyXG5cdFx0bm9kZV9jdG9yLmZpbHRlciA9IFwic2hhZGVyXCI7XHJcblxyXG5cdFx0Ly9jb21tb24gbWV0aG9kc1xyXG5cdFx0bm9kZV9jdG9yLnByb3RvdHlwZS5jbGVhckRlc3RpbmF0aW9uID0gZnVuY3Rpb24oKXsgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gPSB7fTsgIH1cclxuXHRcdG5vZGVfY3Rvci5wcm90b3R5cGUucHJvcGFnYXRlRGVzdGluYXRpb24gPSBmdW5jdGlvbiBwcm9wYWdhdGVEZXN0aW5hdGlvbiggZGVzdF9uYW1lIClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5zaGFkZXJfZGVzdGluYXRpb25bIGRlc3RfbmFtZSBdID0gdHJ1ZTtcclxuXHRcdFx0aWYodGhpcy5pbnB1dHMpXHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHZhciBvcmlnaW5fbm9kZSA9IHRoaXMuZ2V0SW5wdXROb2RlKGkpO1xyXG5cdFx0XHRcdGlmKG9yaWdpbl9ub2RlKVxyXG5cdFx0XHRcdFx0b3JpZ2luX25vZGUucHJvcGFnYXRlRGVzdGluYXRpb24oIGRlc3RfbmFtZSApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZighbm9kZV9jdG9yLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZClcclxuXHRcdFx0bm9kZV9jdG9yLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmKHRoaXMuZ3JhcGgpXHJcblx0XHRcdFx0XHQgdGhpcy5ncmFwaC5fdmVyc2lvbisrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0LypcclxuXHRcdGlmKCFub2RlX2N0b3IucHJvdG90eXBlLm9uR2V0Q29kZSlcclxuXHRcdFx0bm9kZV9jdG9yLnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbigpXHJcblx0XHRcdHtcclxuXHRcdFx0XHQvL2NoZWNrIGRlc3RpbmF0aW9uIHRvIGF2b2lkIGxvbmVseSBub2Rlc1xyXG5cdFx0XHRcdGlmKCF0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbilcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHQvL2dyYWIgaW5wdXRzIHdpdGggdHlwZXNcclxuXHRcdFx0XHR2YXIgaW5wdXRzID0gW107XHJcblx0XHRcdFx0aWYodGhpcy5pbnB1dHMpXHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKVxyXG5cdFx0XHRcdFx0aW5wdXRzLnB1c2goeyB0eXBlOiB0aGlzLmdldElucHV0RGF0YShpKSwgbmFtZTogZ2V0SW5wdXRMaW5rSUQodGhpcyxpKSB9KTtcclxuXHRcdFx0XHR2YXIgb3V0cHV0cyA9IFtdO1xyXG5cdFx0XHRcdGlmKHRoaXMub3V0cHV0cylcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpKVxyXG5cdFx0XHRcdFx0b3V0cHV0cy5wdXNoKHsgbmFtZTogZ2V0T3V0cHV0TGlua0lEKHRoaXMsaSkgfSk7XHJcblx0XHRcdFx0Ly9wYXNzIHRvIGNvZGUgZnVuY1xyXG5cdFx0XHRcdHZhciByZXN1bHRzID0gdGhpcy5leHRyYWN0Q29kZShpbnB1dHMpO1xyXG5cdFx0XHRcdC8vZ3JhYiBvdXRwdXQsIHBhc3MgdG8gbmV4dFxyXG5cdFx0XHRcdGlmKHJlc3VsdHMpXHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyArK2kpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0dmFyIHIgPSByZXN1bHRzW2ldO1xyXG5cdFx0XHRcdFx0aWYoIXIpXHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKGksci52YWx1ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHQqL1xyXG5cclxuXHRcdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcInNoYWRlcjo6XCIgKyB0eXBlLCBub2RlX2N0b3IgKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldFNoYWRlck5vZGVWYXJOYW1lKCBub2RlLCBuYW1lIClcclxuXHR7XHJcblx0XHRyZXR1cm4gXCJWQVJfXCIgKyAobmFtZSB8fCBcIlRFTVBcIikgKyBcIl9cIiArIG5vZGUuaWQ7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRJbnB1dExpbmtJRCggbm9kZSwgc2xvdCApXHJcblx0e1xyXG5cdFx0aWYoIW5vZGUuaW5wdXRzKVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdHZhciBsaW5rID0gbm9kZS5nZXRJbnB1dExpbmsoIHNsb3QgKTtcclxuXHRcdGlmKCAhbGluayApXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0dmFyIG9yaWdpbl9ub2RlID0gbm9kZS5ncmFwaC5nZXROb2RlQnlJZCggbGluay5vcmlnaW5faWQgKTtcclxuXHRcdGlmKCAhb3JpZ2luX25vZGUgKVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdGlmKG9yaWdpbl9ub2RlLmdldE91dHB1dFZhck5hbWUpXHJcblx0XHRcdHJldHVybiBvcmlnaW5fbm9kZS5nZXRPdXRwdXRWYXJOYW1lKGxpbmsub3JpZ2luX3Nsb3QpO1xyXG5cdFx0Ly9nZW5lcmF0ZVxyXG5cdFx0cmV0dXJuIFwibGlua19cIiArIG9yaWdpbl9ub2RlLmlkICsgXCJfXCIgKyBsaW5rLm9yaWdpbl9zbG90O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0T3V0cHV0TGlua0lEKCBub2RlLCBzbG90IClcclxuXHR7XHJcblx0XHRpZiAoIW5vZGUuaXNPdXRwdXRDb25uZWN0ZWQoc2xvdCkpXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0cmV0dXJuIFwibGlua19cIiArIG5vZGUuaWQgKyBcIl9cIiArIHNsb3Q7XHJcblx0fVxyXG5cclxuXHRMR1NoYWRlcnMucmVnaXN0ZXJTaGFkZXJOb2RlID0gcmVnaXN0ZXJTaGFkZXJOb2RlO1xyXG5cdExHU2hhZGVycy5nZXRJbnB1dExpbmtJRCA9IGdldElucHV0TGlua0lEO1xyXG5cdExHU2hhZGVycy5nZXRPdXRwdXRMaW5rSUQgPSBnZXRPdXRwdXRMaW5rSUQ7XHJcblx0TEdTaGFkZXJzLmdldFNoYWRlck5vZGVWYXJOYW1lID0gZ2V0U2hhZGVyTm9kZVZhck5hbWU7XHJcblx0TEdTaGFkZXJzLnBhcnNlR0xTTERlc2NyaXB0aW9ucyA9IHBhcnNlR0xTTERlc2NyaXB0aW9ucztcclxuXHJcblx0Ly9naXZlbiBhIGNvbnN0IG51bWJlciwgaXQgdHJhbnNmb3JtIGl0IHRvIGEgc3RyaW5nIHRoYXQgbWF0Y2hlcyBhIHR5cGVcclxuXHR2YXIgdmFsdWVUb0dMU0wgPSBMaXRlR3JhcGgudmFsdWVUb0dMU0wgPSBmdW5jdGlvbiB2YWx1ZVRvR0xTTCggdiwgdHlwZSwgcHJlY2lzaW9uIClcclxuXHR7XHJcblx0XHR2YXIgbiA9IDU7IC8vbnVtIGRlY2ltYWxzXHJcblx0XHRpZihwcmVjaXNpb24gIT0gbnVsbClcclxuXHRcdFx0biA9IHByZWNpc2lvbjtcclxuXHRcdGlmKCF0eXBlKVxyXG5cdFx0e1xyXG5cdFx0XHRpZih2LmNvbnN0cnVjdG9yID09PSBOdW1iZXIpXHJcblx0XHRcdFx0dHlwZSA9IFwiZmxvYXRcIjtcclxuXHRcdFx0ZWxzZSBpZih2Lmxlbmd0aClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHN3aXRjaCh2Lmxlbmd0aClcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRjYXNlIDI6IHR5cGUgPSBcInZlYzJcIjsgYnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIDM6IHR5cGUgPSBcInZlYzNcIjsgYnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIDQ6IHR5cGUgPSBcInZlYzRcIjsgYnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIDk6IHR5cGUgPSBcIm1hdDNcIjsgYnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIDE2OiB0eXBlID0gXCJtYXQ0XCI7IGJyZWFrO1xyXG5cdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0dGhyb3coXCJ1bmtub3duIHR5cGUgZm9yIGdsc2wgdmFsdWUgc2l6ZVwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHRocm93KFwidW5rbm93biB0eXBlIGZvciBnbHNsIHZhbHVlOiBcIiArIHYuY29uc3RydWN0b3IpO1xyXG5cdFx0fVxyXG5cdFx0c3dpdGNoKHR5cGUpXHJcblx0XHR7XHJcblx0XHRcdGNhc2UgJ2Zsb2F0JzogcmV0dXJuIHYudG9GaXhlZChuKTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgJ3ZlYzInOiByZXR1cm4gXCJ2ZWMyKFwiICsgdlswXS50b0ZpeGVkKG4pICsgXCIsXCIgKyB2WzFdLnRvRml4ZWQobikgKyBcIilcIjsgYnJlYWs7XHJcblx0XHRcdGNhc2UgJ2NvbG9yMyc6XHJcblx0XHRcdGNhc2UgJ3ZlYzMnOiByZXR1cm4gXCJ2ZWMzKFwiICsgdlswXS50b0ZpeGVkKG4pICsgXCIsXCIgKyB2WzFdLnRvRml4ZWQobikgKyBcIixcIiArIHZbMl0udG9GaXhlZChuKSArIFwiKVwiOyBicmVhaztcclxuXHRcdFx0Y2FzZSAnY29sb3I0JzpcclxuXHRcdFx0Y2FzZSAndmVjNCc6IHJldHVybiBcInZlYzQoXCIgKyB2WzBdLnRvRml4ZWQobikgKyBcIixcIiArIHZbMV0udG9GaXhlZChuKSArIFwiLFwiICsgdlsyXS50b0ZpeGVkKG4pICsgXCIsXCIgKyB2WzNdLnRvRml4ZWQobikgKyBcIilcIjsgYnJlYWs7XHJcblx0XHRcdGNhc2UgJ21hdDMnOiByZXR1cm4gXCJtYXQzKDEuMCwwLjAsMC4wLDAuMCwxLjAsMC4wLDAuMCwwLjAsMS4wKVwiOyBicmVhazsgLy9ub3QgZnVsbHkgc3VwcG9ydGVkIHlldFxyXG5cdFx0XHRjYXNlICdtYXQ0JzogcmV0dXJuIFwibWF0NCgxLjAsMC4wLDAuMCwwLjAsMC4wLDEuMCwwLjAsMC4wLDAuMCwwLjAsMC4wLDEuMCwwLjAsMC4wLDAuMCwwLjAsMS4wKVwiOyBicmVhazsvL25vdCBmdWxseSBzdXBwb3J0ZWQgeWV0XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0dGhyb3coXCJ1bmtub3duIGdsc2wgdHlwZSBpbiB2YWx1ZVRvR0xTTDpcIiwgdHlwZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFwiXCI7XHJcblx0fVxyXG5cclxuXHQvL21ha2VzIHN1cmUgdGhhdCBhIHZhciBpcyBvZiBhIHR5cGUsIGFuZCBpZiBub3QsIGl0IGNvbnZlcnRzIGl0XHJcblx0dmFyIHZhclRvVHlwZUdMU0wgPSBMaXRlR3JhcGgudmFyVG9UeXBlR0xTTCA9IGZ1bmN0aW9uIHZhclRvVHlwZUdMU0woIHYsIGlucHV0X3R5cGUsIG91dHB1dF90eXBlIClcclxuXHR7XHJcblx0XHRpZihpbnB1dF90eXBlID09IG91dHB1dF90eXBlKVxyXG5cdFx0XHRyZXR1cm4gdjtcclxuXHRcdGlmKHYgPT0gbnVsbClcclxuXHRcdFx0c3dpdGNoKG91dHB1dF90eXBlKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Y2FzZSBcImZsb2F0XCI6IHJldHVybiBcIjAuMFwiO1xyXG5cdFx0XHRcdGNhc2UgXCJ2ZWMyXCI6ICByZXR1cm4gXCJ2ZWMyKDAuMClcIjtcclxuXHRcdFx0XHRjYXNlIFwidmVjM1wiOiAgcmV0dXJuIFwidmVjMygwLjApXCI7XHJcblx0XHRcdFx0Y2FzZSBcInZlYzRcIjogIHJldHVybiBcInZlYzQoMC4wLDAuMCwwLjAsMS4wKVwiO1xyXG5cdFx0XHRcdGRlZmF1bHQ6IC8vbnVsbFxyXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH1cclxuXHJcblx0XHRpZighb3V0cHV0X3R5cGUpXHJcblx0XHRcdHRocm93KFwiZXJyb3I6IG5vIG91dHB1dCB0eXBlIHNwZWNpZmllZFwiKTtcclxuXHRcdGlmKG91dHB1dF90eXBlID09IFwiZmxvYXRcIilcclxuXHRcdHtcclxuXHRcdFx0c3dpdGNoKGlucHV0X3R5cGUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHQvL2Nhc2UgXCJmbG9hdFwiOlxyXG5cdFx0XHRcdGNhc2UgXCJ2ZWMyXCI6XHJcblx0XHRcdFx0Y2FzZSBcInZlYzNcIjpcclxuXHRcdFx0XHRjYXNlIFwidmVjNFwiOlxyXG5cdFx0XHRcdFx0cmV0dXJuIHYgKyBcIi54XCI7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRkZWZhdWx0OiAvL251bGxcclxuXHRcdFx0XHRcdHJldHVybiBcIjAuMFwiO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVsc2UgaWYob3V0cHV0X3R5cGUgPT0gXCJ2ZWMyXCIpXHJcblx0XHR7XHJcblx0XHRcdHN3aXRjaChpbnB1dF90eXBlKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Y2FzZSBcImZsb2F0XCI6XHJcblx0XHRcdFx0XHRyZXR1cm4gXCJ2ZWMyKFwiK3YrXCIpXCI7XHJcblx0XHRcdFx0Ly9jYXNlIFwidmVjMlwiOlxyXG5cdFx0XHRcdGNhc2UgXCJ2ZWMzXCI6XHJcblx0XHRcdFx0Y2FzZSBcInZlYzRcIjpcclxuXHRcdFx0XHRcdHJldHVybiB2ICsgXCIueHlcIjtcclxuXHRcdFx0XHRkZWZhdWx0OiAvL251bGxcclxuXHRcdFx0XHRcdHJldHVybiBcInZlYzIoMC4wKVwiO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKG91dHB1dF90eXBlID09IFwidmVjM1wiKVxyXG5cdFx0e1xyXG5cdFx0XHRzd2l0Y2goaW5wdXRfdHlwZSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGNhc2UgXCJmbG9hdFwiOlxyXG5cdFx0XHRcdFx0cmV0dXJuIFwidmVjMyhcIit2K1wiKVwiO1xyXG5cdFx0XHRcdGNhc2UgXCJ2ZWMyXCI6XHJcblx0XHRcdFx0XHRyZXR1cm4gXCJ2ZWMzKFwiICsgdiArIFwiLDAuMClcIjtcclxuXHRcdFx0XHQvL2Nhc2UgXCJ2ZWMzXCI6XHJcblx0XHRcdFx0Y2FzZSBcInZlYzRcIjpcclxuXHRcdFx0XHRcdHJldHVybiB2ICsgXCIueHl6XCI7XHJcblx0XHRcdFx0ZGVmYXVsdDogLy9udWxsXHJcblx0XHRcdFx0XHRyZXR1cm4gXCJ2ZWMzKDAuMClcIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZihvdXRwdXRfdHlwZSA9PSBcInZlYzRcIilcclxuXHRcdHtcclxuXHRcdFx0c3dpdGNoKGlucHV0X3R5cGUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRjYXNlIFwiZmxvYXRcIjpcclxuXHRcdFx0XHRcdHJldHVybiBcInZlYzQoXCIrditcIilcIjtcclxuXHRcdFx0XHRjYXNlIFwidmVjMlwiOlxyXG5cdFx0XHRcdFx0cmV0dXJuIFwidmVjNChcIiArIHYgKyBcIiwwLjAsMS4wKVwiO1xyXG5cdFx0XHRcdGNhc2UgXCJ2ZWMzXCI6XHJcblx0XHRcdFx0XHRyZXR1cm4gXCJ2ZWM0KFwiICsgdiArIFwiLDEuMClcIjtcclxuXHRcdFx0XHRkZWZhdWx0OiAvL251bGxcclxuXHRcdFx0XHRcdHJldHVybiBcInZlYzQoMC4wLDAuMCwwLjAsMS4wKVwiO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0aHJvdyhcInR5cGUgY2Fubm90IGJlIGNvbnZlcnRlZFwiKTtcclxuXHR9XHJcblxyXG5cclxuXHQvL3VzZWQgdG8gcGx1ZyBpbmNvbXBhdGlibGUgc3R1ZmZcclxuXHR2YXIgY29udmVydFZhclRvR0xTTFR5cGUgPSBMaXRlR3JhcGguY29udmVydFZhclRvR0xTTFR5cGUgPSBmdW5jdGlvbiBjb252ZXJ0VmFyVG9HTFNMVHlwZSggdmFybmFtZSwgdHlwZSwgdGFyZ2V0X3R5cGUgKVxyXG5cdHtcclxuXHRcdGlmKHR5cGUgPT0gdGFyZ2V0X3R5cGUpXHJcblx0XHRcdHJldHVybiB2YXJuYW1lO1xyXG5cdFx0aWYodHlwZSA9PSBcImZsb2F0XCIpXHJcblx0XHRcdHJldHVybiB0YXJnZXRfdHlwZSArIFwiKFwiICsgdmFybmFtZSArIFwiKVwiO1xyXG5cdFx0aWYodGFyZ2V0X3R5cGUgPT0gXCJ2ZWMyXCIpIC8vd29ya3MgZm9yIHZlYzIsdmVjMyBhbmQgdmVjNFxyXG5cdFx0XHRyZXR1cm4gXCJ2ZWMyKFwiICsgdmFybmFtZSArIFwiLnh5KVwiO1xyXG5cdFx0aWYodGFyZ2V0X3R5cGUgPT0gXCJ2ZWMzXCIpIC8vd29ya3MgZm9yIHZlYzIsdmVjMyBhbmQgdmVjNFxyXG5cdFx0e1xyXG5cdFx0XHRpZih0eXBlID09IFwidmVjMlwiKVxyXG5cdFx0XHRcdHJldHVybiBcInZlYzMoXCIgKyB2YXJuYW1lICsgXCIsMC4wKVwiO1xyXG5cdFx0XHRpZih0eXBlID09IFwidmVjNFwiKVxyXG5cdFx0XHRcdHJldHVybiBcInZlYzQoXCIgKyB2YXJuYW1lICsgXCIueHl6KVwiO1xyXG5cdFx0fVxyXG5cdFx0aWYodGFyZ2V0X3R5cGUgPT0gXCJ2ZWM0XCIpXHJcblx0XHR7XHJcblx0XHRcdGlmKHR5cGUgPT0gXCJ2ZWMyXCIpXHJcblx0XHRcdFx0cmV0dXJuIFwidmVjNChcIiArIHZhcm5hbWUgKyBcIiwwLjAsMC4wKVwiO1xyXG5cdFx0XHRpZih0YXJnZXRfdHlwZSA9PSBcInZlYzNcIilcclxuXHRcdFx0XHRyZXR1cm4gXCJ2ZWM0KFwiICsgdmFybmFtZSArIFwiLDEuMClcIjtcclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0Ly91c2VkIHRvIGhvc3QgYSBzaGFkZXIgYm9keSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cdGZ1bmN0aW9uIExHU2hhZGVyQ29udGV4dCgpXHJcblx0e1xyXG5cdFx0Ly90byBzdG9yZSB0aGUgY29kZSB0ZW1wbGF0ZVxyXG5cdFx0dGhpcy52c190ZW1wbGF0ZSA9IFwiXCI7XHJcblx0XHR0aGlzLmZzX3RlbXBsYXRlID0gXCJcIjtcclxuXHJcblx0XHQvL3JlcXVpcmVkIHNvIG5vZGVzIG5vdyB3aGVyZSB0byBmZXRjaCB0aGUgaW5wdXQgZGF0YVxyXG5cdFx0dGhpcy5idWZmZXJfbmFtZXMgPSB7XHJcblx0XHRcdHV2czogXCJ2X2Nvb3JkXCJcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5leHRyYSA9IHt9OyAvL3RvIHN0b3JlIGN1c3RvbSBpbmZvIGZyb20gdGhlIG5vZGVzIChsaWtlIGlmIHRoaXMgc2hhZGVyIHN1cHBvcnRzIGEgZmVhdHVyZSwgZXRjKVxyXG5cclxuXHRcdHRoaXMuX2Z1bmN0aW9ucyA9IHt9O1xyXG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7fTtcclxuXHRcdHRoaXMuX2NvZGVwYXJ0cyA9IHt9O1xyXG5cdFx0dGhpcy5fdW5pZm9ybV92YWx1ZSA9IG51bGw7XHJcblx0fVxyXG5cclxuXHRMR1NoYWRlckNvbnRleHQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdHRoaXMuX3VuaWZvcm1zID0ge307XHJcblx0XHR0aGlzLl9mdW5jdGlvbnMgPSB7fTtcclxuXHRcdHRoaXMuX2NvZGVwYXJ0cyA9IHt9O1xyXG5cdFx0dGhpcy5fdW5pZm9ybV92YWx1ZSA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5leHRyYSA9IHt9O1xyXG5cdH1cclxuXHJcblx0TEdTaGFkZXJDb250ZXh0LnByb3RvdHlwZS5hZGRVbmlmb3JtID0gZnVuY3Rpb24oIG5hbWUsIHR5cGUsIHZhbHVlIClcclxuXHR7XHJcblx0XHR0aGlzLl91bmlmb3Jtc1sgbmFtZSBdID0gdHlwZTtcclxuXHRcdGlmKHZhbHVlICE9IG51bGwpXHJcblx0XHR7XHJcblx0XHRcdGlmKCF0aGlzLl91bmlmb3JtX3ZhbHVlKVxyXG5cdFx0XHRcdHRoaXMuX3VuaWZvcm1fdmFsdWUgPSB7fTtcclxuXHRcdFx0dGhpcy5fdW5pZm9ybV92YWx1ZVtuYW1lXSA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0TEdTaGFkZXJDb250ZXh0LnByb3RvdHlwZS5hZGRGdW5jdGlvbiA9IGZ1bmN0aW9uKCBuYW1lLCBjb2RlIClcclxuXHR7XHJcblx0XHR0aGlzLl9mdW5jdGlvbnNbbmFtZV0gPSBjb2RlO1xyXG5cdH1cclxuXHJcblx0TEdTaGFkZXJDb250ZXh0LnByb3RvdHlwZS5hZGRDb2RlID0gZnVuY3Rpb24oIGhvb2ssIGNvZGUsIGRlc3RpbmF0aW9ucyApXHJcblx0e1xyXG5cdFx0ZGVzdGluYXRpb25zID0gZGVzdGluYXRpb25zIHx8IHtcIlwiOlwiXCJ9O1xyXG5cdFx0Zm9yKHZhciBpIGluIGRlc3RpbmF0aW9ucylcclxuXHRcdHtcclxuXHRcdFx0dmFyIGggPSBpID8gaSArIFwiX1wiICsgaG9vayA6IGhvb2s7XHJcblx0XHRcdGlmKCF0aGlzLl9jb2RlcGFydHNbIGggXSlcclxuXHRcdFx0XHR0aGlzLl9jb2RlcGFydHNbIGggXSA9IGNvZGUgKyBcIlxcblwiO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0dGhpcy5fY29kZXBhcnRzWyBoIF0gKz0gY29kZSArIFwiXFxuXCI7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvL3RoZSBzeXN0ZW0gd29ya3MgYnkgZ3JhYmJpbmcgY29kZSBmcmFnbWVudHMgZnJvbSBldmVyeSBub2RlIGFuZCBjb25jYXRlbmF0aW5nIHRoZW0gaW4gYmxvY2tzIGRlcGVuZGluZyBvbiB3aGVyZSBtdXN0IHRoZXkgYmUgYXR0YWNoZWRcclxuXHRMR1NoYWRlckNvbnRleHQucHJvdG90eXBlLmNvbXB1dGVDb2RlQmxvY2tzID0gZnVuY3Rpb24oIGdyYXBoLCBleHRyYV91bmlmb3JtcyApXHJcblx0e1xyXG5cdFx0Ly9wcmVwYXJlIGNvbnRleHRcclxuXHRcdHRoaXMuY2xlYXIoKTtcclxuXHJcblx0XHQvL2dyYWIgb3V0cHV0IG5vZGVzXHJcblx0XHR2YXIgdmVydGV4b3V0ID0gZ3JhcGguZmluZE5vZGVzQnlUeXBlKFwic2hhZGVyOjpvdXRwdXQvdmVydGV4XCIpO1xyXG5cdFx0dmVydGV4b3V0ID0gdmVydGV4b3V0ICYmIHZlcnRleG91dC5sZW5ndGggPyB2ZXJ0ZXhvdXRbMF0gOiBudWxsO1xyXG5cdFx0dmFyIGZyYWdtZW50b3V0ID0gZ3JhcGguZmluZE5vZGVzQnlUeXBlKFwic2hhZGVyOjpvdXRwdXQvZnJhZ2NvbG9yXCIpO1xyXG5cdFx0ZnJhZ21lbnRvdXQgPSBmcmFnbWVudG91dCAmJiBmcmFnbWVudG91dC5sZW5ndGggPyBmcmFnbWVudG91dFswXSA6IG51bGw7XHJcblx0XHRpZighZnJhZ21lbnRvdXQpIC8vPz9cclxuXHRcdFx0cmV0dXJuIG51bGw7IFxyXG5cclxuXHRcdC8vcHJvcGFnYXRlIGJhY2sgZGVzdGluYXRpb25zXHJcblx0XHRncmFwaC5zZW5kRXZlbnRUb0FsbE5vZGVzKCBcImNsZWFyRGVzdGluYXRpb25cIiApO1xyXG5cdFx0aWYodmVydGV4b3V0KVxyXG5cdFx0XHR2ZXJ0ZXhvdXQucHJvcGFnYXRlRGVzdGluYXRpb24oXCJ2c1wiKTtcclxuXHRcdGlmKGZyYWdtZW50b3V0KVxyXG5cdFx0XHRmcmFnbWVudG91dC5wcm9wYWdhdGVEZXN0aW5hdGlvbihcImZzXCIpO1xyXG5cclxuXHRcdC8vZ2V0cyBjb2RlIGZyb20gZ3JhcGhcclxuXHRcdGdyYXBoLnNlbmRFdmVudFRvQWxsTm9kZXMoXCJvbkdldENvZGVcIiwgdGhpcyApO1xyXG5cclxuXHRcdHZhciB1bmlmb3JtcyA9IFwiXCI7XHJcblx0XHRmb3IodmFyIGkgaW4gdGhpcy5fdW5pZm9ybXMpXHJcblx0XHRcdHVuaWZvcm1zICs9IFwidW5pZm9ybSBcIiArIHRoaXMuX3VuaWZvcm1zW2ldICsgXCIgXCIgKyBpICsgXCI7XFxuXCI7XHJcblx0XHRpZihleHRyYV91bmlmb3JtcylcclxuXHRcdFx0Zm9yKHZhciBpIGluIGV4dHJhX3VuaWZvcm1zKVxyXG5cdFx0XHRcdHVuaWZvcm1zICs9IFwidW5pZm9ybSBcIiArIGV4dHJhX3VuaWZvcm1zW2ldICsgXCIgXCIgKyBpICsgXCI7XFxuXCI7XHJcblxyXG5cdFx0dmFyIGZ1bmN0aW9ucyA9IFwiXCI7XHJcblx0XHRmb3IodmFyIGkgaW4gdGhpcy5fZnVuY3Rpb25zKVxyXG5cdFx0XHRmdW5jdGlvbnMgKz0gXCIvL1wiICsgaSArIFwiXFxuXCIgKyB0aGlzLl9mdW5jdGlvbnNbaV0gKyBcIlxcblwiO1xyXG5cclxuXHRcdHZhciBibG9ja3MgPSB0aGlzLl9jb2RlcGFydHM7XHJcblx0XHRibG9ja3MudW5pZm9ybXMgPSB1bmlmb3JtcztcclxuXHRcdGJsb2Nrcy5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XHJcblx0XHRyZXR1cm4gYmxvY2tzO1xyXG5cdH1cclxuXHJcblx0Ly9yZXBsYWNlcyBibG9ja3MgdXNpbmcgdGhlIHZzIGFuZCBmcyB0ZW1wbGF0ZSBhbmQgcmV0dXJucyB0aGUgZmluYWwgY29kZXNcclxuXHRMR1NoYWRlckNvbnRleHQucHJvdG90eXBlLmNvbXB1dGVTaGFkZXJDb2RlID0gZnVuY3Rpb24oIGdyYXBoIClcclxuXHR7XHJcblx0XHR2YXIgYmxvY2tzID0gdGhpcy5jb21wdXRlQ29kZUJsb2NrcyggZ3JhcGggKTtcclxuXHRcdHZhciB2c19jb2RlID0gR0wuU2hhZGVyLnJlcGxhY2VDb2RlVXNpbmdDb250ZXh0KCB0aGlzLnZzX3RlbXBsYXRlLCBibG9ja3MgKTtcclxuXHRcdHZhciBmc19jb2RlID0gR0wuU2hhZGVyLnJlcGxhY2VDb2RlVXNpbmdDb250ZXh0KCB0aGlzLmZzX3RlbXBsYXRlLCBibG9ja3MgKTtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHZzX2NvZGU6IHZzX2NvZGUsXHJcblx0XHRcdGZzX2NvZGU6IGZzX2NvZGVcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHQvL2dlbmVyYXRlcyB0aGUgc2hhZGVyIGNvZGUgZnJvbSB0aGUgdGVtcGxhdGUgYW5kIHRoZSBcclxuXHRMR1NoYWRlckNvbnRleHQucHJvdG90eXBlLmNvbXB1dGVTaGFkZXIgPSBmdW5jdGlvbiggZ3JhcGgsIHNoYWRlciApXHJcblx0e1xyXG5cdFx0dmFyIGZpbmFsY29kZSA9IHRoaXMuY29tcHV0ZVNoYWRlckNvZGUoIGdyYXBoICk7XHJcblx0XHRjb25zb2xlLmxvZyggZmluYWxjb2RlLnZzX2NvZGUsIGZpbmFsY29kZS5mc19jb2RlICk7XHJcblxyXG5cdFx0aWYoIUxpdGVHcmFwaC5jYXRjaF9leGNlcHRpb25zKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLl9zaGFkZXJfZXJyb3IgPSB0cnVlO1xyXG5cdFx0XHRpZihzaGFkZXIpXHJcblx0XHRcdFx0c2hhZGVyLnVwZGF0ZVNoYWRlciggZmluYWxjb2RlLnZzX2NvZGUsIGZpbmFsY29kZS5mc19jb2RlICk7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRzaGFkZXIgPSBuZXcgR0wuU2hhZGVyKCBmaW5hbGNvZGUudnNfY29kZSwgZmluYWxjb2RlLmZzX2NvZGUgKTtcclxuXHRcdFx0dGhpcy5fc2hhZGVyX2Vycm9yID0gZmFsc2U7XHJcblx0XHRcdHJldHVybiBzaGFkZXI7XHJcblx0XHR9XHJcblxyXG5cdFx0dHJ5XHJcblx0XHR7XHJcblx0XHRcdGlmKHNoYWRlcilcclxuXHRcdFx0XHRzaGFkZXIudXBkYXRlU2hhZGVyKCBmaW5hbGNvZGUudnNfY29kZSwgZmluYWxjb2RlLmZzX2NvZGUgKTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHNoYWRlciA9IG5ldyBHTC5TaGFkZXIoIGZpbmFsY29kZS52c19jb2RlLCBmaW5hbGNvZGUuZnNfY29kZSApO1xyXG5cdFx0XHR0aGlzLl9zaGFkZXJfZXJyb3IgPSBmYWxzZTtcclxuXHRcdFx0cmV0dXJuIHNoYWRlcjtcclxuXHRcdH1cclxuXHRcdGNhdGNoIChlcnIpXHJcblx0XHR7XHJcblx0XHRcdGlmKCF0aGlzLl9zaGFkZXJfZXJyb3IpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKGVycik7XHJcblx0XHRcdFx0aWYoZXJyLmluZGV4T2YoXCJGcmFnbWVudCBzaGFkZXJcIikgIT0gLTEpXHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyggZmluYWxjb2RlLmZzX2NvZGUuc3BsaXQoXCJcXG5cIikubWFwKGZ1bmN0aW9uKHYsaSl7IHJldHVybiBpICsgXCIuLSBcIiArIHY7IH0pLmpvaW4oXCJcXG5cIikgKTtcclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyggZmluYWxjb2RlLnZzX2NvZGUgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9zaGFkZXJfZXJyb3IgPSB0cnVlO1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDsvL25ldmVyIGhlcmVcclxuXHR9XHJcblxyXG5cdExHU2hhZGVyQ29udGV4dC5wcm90b3R5cGUuZ2V0U2hhZGVyID0gZnVuY3Rpb24oIGdyYXBoIClcclxuXHR7XHJcblx0XHQvL2lmIGdyYXBoIG5vdCBjaGFuZ2VkP1xyXG5cdFx0aWYodGhpcy5fc2hhZGVyICYmIHRoaXMuX3NoYWRlci5fdmVyc2lvbiA9PSBncmFwaC5fdmVyc2lvbilcclxuXHRcdFx0cmV0dXJuIHRoaXMuX3NoYWRlcjtcclxuXHJcblx0XHQvL2NvbXBpbGUgc2hhZGVyXHJcblx0XHR2YXIgc2hhZGVyID0gdGhpcy5jb21wdXRlU2hhZGVyKCBncmFwaCwgdGhpcy5fc2hhZGVyICk7XHJcblx0XHRpZighc2hhZGVyKVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFxyXG5cdFx0dGhpcy5fc2hhZGVyID0gc2hhZGVyO1xyXG5cdFx0c2hhZGVyLl92ZXJzaW9uID0gZ3JhcGguX3ZlcnNpb247XHJcblx0XHRyZXR1cm4gc2hhZGVyO1xyXG5cdH1cclxuXHJcblx0Ly9zb21lIHNoYWRlciBub2RlcyBjb3VsZCByZXF1aXJlIHRvIGZpbGwgdGhlIGJveCB3aXRoIHNvbWUgdW5pZm9ybXNcclxuXHRMR1NoYWRlckNvbnRleHQucHJvdG90eXBlLmZpbGxVbmlmb3JtcyA9IGZ1bmN0aW9uKCB1bmlmb3JtcywgcGFyYW0gKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLl91bmlmb3JtX3ZhbHVlKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0Zm9yKHZhciBpIGluIHRoaXMuX3VuaWZvcm1fdmFsdWUpXHJcblx0XHR7XHJcblx0XHRcdHZhciB2ID0gdGhpcy5fdW5pZm9ybV92YWx1ZVtpXTtcclxuXHRcdFx0aWYodiA9PSBudWxsKVxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRpZih2LmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbilcclxuXHRcdFx0XHR1bmlmb3Jtc1tpXSA9IHYuY2FsbCggdGhpcywgcGFyYW0gKTtcclxuXHRcdFx0ZWxzZSBpZih2LmNvbnN0cnVjdG9yID09PSBHTC5UZXh0dXJlKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Ly90b2RvLi4uXHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHVuaWZvcm1zW2ldID0gdjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdExpdGVHcmFwaC5TaGFkZXJDb250ZXh0ID0gTGl0ZUdyYXBoLlNoYWRlcnMuQ29udGV4dCA9IExHU2hhZGVyQ29udGV4dDtcclxuXHJcblx0Ly8gTEdyYXBoU2hhZGVyR3JhcGggKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHQvLyBhcHBsaWVzIGEgc2hhZGVyIGdyYXBoIHRvIHRleHR1cmUsIGl0IGNhbiBiZSB1c2VzIGFzIGFuIGV4YW1wbGVcclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyR3JhcGgoKSB7XHJcblxyXG5cdFx0Ly9iZWZvcmUgaW5wdXRzXHJcbiAgICAgICAgdGhpcy5zdWJncmFwaCA9IG5ldyBMaXRlR3JhcGguTEdyYXBoKCk7XHJcbiAgICAgICAgdGhpcy5zdWJncmFwaC5fc3ViZ3JhcGhfbm9kZSA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5zdWJncmFwaC5faXNfc3ViZ3JhcGggPSB0cnVlO1xyXG5cdFx0dGhpcy5zdWJncmFwaC5maWx0ZXIgPSBcInNoYWRlclwiO1xyXG5cclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcInRleHR1cmVcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcInRleHR1cmVcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAsIGFscGhhOiBmYWxzZSwgcHJlY2lzaW9uOiB0eXBlb2YoTEdyYXBoVGV4dHVyZSkgIT0gXCJ1bmRlZmluZWRcIiA/IExHcmFwaFRleHR1cmUuREVGQVVMVCA6IDIgfTtcclxuXHJcblx0XHR2YXIgaW5wdXROb2RlID0gdGhpcy5zdWJncmFwaC5maW5kTm9kZXNCeVR5cGUoXCJzaGFkZXI6OmlucHV0L3VuaWZvcm1cIilbMF07XHJcblx0XHRpbnB1dE5vZGUucG9zID0gWzIwMCwzMDBdO1xyXG5cclxuXHRcdHZhciBzYW1wbGVyID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUoXCJzaGFkZXI6OnRleHR1cmUvc2FtcGxlcjJEXCIpO1xyXG5cdFx0c2FtcGxlci5wb3MgPSBbNDAwLDMwMF07XHJcblx0XHR0aGlzLnN1YmdyYXBoLmFkZCggc2FtcGxlciApO1xyXG5cclxuXHRcdHZhciBvdXRub2RlID0gTGl0ZUdyYXBoLmNyZWF0ZU5vZGUoXCJzaGFkZXI6Om91dHB1dC9mcmFnY29sb3JcIik7XHJcblx0XHRvdXRub2RlLnBvcyA9IFs2MDAsMzAwXTtcclxuXHRcdHRoaXMuc3ViZ3JhcGguYWRkKCBvdXRub2RlICk7XHJcblxyXG5cdFx0aW5wdXROb2RlLmNvbm5lY3QoIDAsIHNhbXBsZXIgKTtcclxuXHRcdHNhbXBsZXIuY29ubmVjdCggMCwgb3V0bm9kZSApO1xyXG5cclxuXHRcdHRoaXMuc2l6ZSA9IFsxODAsNjBdO1xyXG5cdFx0dGhpcy5yZWRyYXdfb25fbW91c2UgPSB0cnVlOyAvL2ZvcmNlIHJlZHJhd1xyXG5cclxuXHRcdHRoaXMuX3VuaWZvcm1zID0ge307XHJcblx0XHR0aGlzLl9zaGFkZXIgPSBudWxsO1xyXG5cdFx0dGhpcy5fY29udGV4dCA9IG5ldyBMR1NoYWRlckNvbnRleHQoKTtcclxuXHRcdHRoaXMuX2NvbnRleHQudnNfdGVtcGxhdGUgPSBcIiNkZWZpbmUgVkVSVEVYXFxuXCIgKyBHTC5TaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVI7XHJcblx0XHR0aGlzLl9jb250ZXh0LmZzX3RlbXBsYXRlID0gTEdyYXBoU2hhZGVyR3JhcGgudGVtcGxhdGU7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJHcmFwaC50ZW1wbGF0ZSA9IFwiXFxuXFxcclxuI2RlZmluZSBGUkFHTUVOVFxcblxcXHJcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxyXG52YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxyXG57e3Zhcnlpbmd9fVxcblxcXHJcbnt7dW5pZm9ybXN9fVxcblxcXHJcbnt7ZnVuY3Rpb25zfX1cXG5cXFxyXG57e2ZzX2Z1bmN0aW9uc319XFxuXFxcclxudm9pZCBtYWluKCkge1xcblxcblxcXHJcbnZlYzIgdXYgPSB2X2Nvb3JkO1xcblxcXHJcbnZlYzQgZnJhZ2NvbG9yID0gdmVjNCgwLjApO1xcblxcXHJcbnZlYzQgZnJhZ2NvbG9yMSA9IHZlYzQoMC4wKTtcXG5cXFxyXG57e2ZzX2NvZGV9fVxcblxcXHJcbmdsX0ZyYWdDb2xvciA9IGZyYWdjb2xvcjtcXG5cXFxyXG59XFxuXFxcclxuXHRcIjtcclxuXHJcblx0TEdyYXBoU2hhZGVyR3JhcGgud2lkZ2V0c19pbmZvID0ge1xyXG5cdFx0cHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxyXG5cdH07XHJcblxyXG5cdExHcmFwaFNoYWRlckdyYXBoLnRpdGxlID0gXCJTaGFkZXJHcmFwaFwiO1xyXG5cdExHcmFwaFNoYWRlckdyYXBoLmRlc2MgPSBcIkJ1aWxkcyBhIHNoYWRlciB1c2luZyBhIGdyYXBoXCI7XHJcblx0TEdyYXBoU2hhZGVyR3JhcGguaW5wdXRfbm9kZV90eXBlID0gXCJpbnB1dC91bmlmb3JtXCI7XHJcblx0TEdyYXBoU2hhZGVyR3JhcGgub3V0cHV0X25vZGVfdHlwZSA9IFwib3V0cHV0L2ZyYWdjb2xvclwiO1xyXG5cdExHcmFwaFNoYWRlckdyYXBoLnRpdGxlX2NvbG9yID0gU0hBREVSTk9ERVNfQ09MT1I7XHJcblxyXG5cdExHcmFwaFNoYWRlckdyYXBoLnByb3RvdHlwZS5vblNlcmlhbGl6ZSA9IGZ1bmN0aW9uKG8pXHJcblx0e1xyXG5cdFx0by5zdWJncmFwaCA9IHRoaXMuc3ViZ3JhcGguc2VyaWFsaXplKCk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJHcmFwaC5wcm90b3R5cGUub25Db25maWd1cmUgPSBmdW5jdGlvbihvKVxyXG5cdHtcclxuXHRcdHRoaXMuc3ViZ3JhcGguY29uZmlndXJlKG8uc3ViZ3JhcGgpO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyR3JhcGgucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0Ly9yZWFkIGlucHV0IHRleHR1cmVcclxuXHRcdHZhciBpbnRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0aWYoaW50ZXggJiYgaW50ZXguY29uc3RydWN0b3IgIT0gR0wuVGV4dHVyZSlcclxuXHRcdFx0aW50ZXggPSBudWxsO1xyXG5cclxuXHRcdHZhciB3ID0gdGhpcy5wcm9wZXJ0aWVzLndpZHRoIHwgMDtcclxuXHRcdHZhciBoID0gdGhpcy5wcm9wZXJ0aWVzLmhlaWdodCB8IDA7XHJcblx0XHRpZiAodyA9PSAwKSB7XHJcblx0XHRcdHcgPSBpbnRleCA/IGludGV4LndpZHRoIDogZ2wudmlld3BvcnRfZGF0YVsyXTtcclxuXHRcdH0gLy8wIG1lYW5zIGRlZmF1bHRcclxuXHRcdGlmIChoID09IDApIHtcclxuXHRcdFx0aCA9IGludGV4ID8gaW50ZXguaGVpZ2h0IDogZ2wudmlld3BvcnRfZGF0YVszXTtcclxuXHRcdH0gLy8wIG1lYW5zIGRlZmF1bHRcclxuXHJcblx0XHR2YXIgdHlwZSA9IExHcmFwaFRleHR1cmUuZ2V0VGV4dHVyZVR5cGUoIHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24sIGludGV4ICk7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xyXG5cdFx0aWYgKCAhdGV4dHVyZSB8fCB0ZXh0dXJlLndpZHRoICE9IHcgfHwgdGV4dHVyZS5oZWlnaHQgIT0gaCB8fCB0ZXh0dXJlLnR5cGUgIT0gdHlwZSApIHtcclxuXHRcdFx0dGV4dHVyZSA9IHRoaXMuX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSh3LCBoLCB7XHJcblx0XHRcdFx0dHlwZTogdHlwZSxcclxuXHRcdFx0XHRmb3JtYXQ6IHRoaXMuYWxwaGEgPyBnbC5SR0JBIDogZ2wuUkdCLFxyXG5cdFx0XHRcdGZpbHRlcjogZ2wuTElORUFSXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHR2YXIgc2hhZGVyID0gdGhpcy5nZXRTaGFkZXIoIHRoaXMuc3ViZ3JhcGggKTtcclxuXHRcdGlmKCFzaGFkZXIpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgdW5pZm9ybXMgPSB0aGlzLl91bmlmb3JtcztcclxuXHRcdHRoaXMuX2NvbnRleHQuZmlsbFVuaWZvcm1zKCB1bmlmb3JtcyApO1xyXG5cclxuXHRcdHZhciB0ZXhfc2xvdCA9IDA7XHJcblx0XHRpZih0aGlzLmlucHV0cylcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSlcclxuXHRcdHtcclxuXHRcdFx0dmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XHJcblx0XHRcdHZhciBkYXRhID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XHJcblx0XHRcdGlmKGlucHV0LnR5cGUgPT0gXCJ0ZXh0dXJlXCIpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRpZighZGF0YSlcclxuXHRcdFx0XHRcdGRhdGEgPSBHTC5UZXh0dXJlLmdldFdoaXRlVGV4dHVyZSgpO1xyXG5cdFx0XHRcdGRhdGEgPSBkYXRhLmJpbmQodGV4X3Nsb3QrKyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKGRhdGEgIT0gbnVsbClcclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJ1X1wiICsgaW5wdXQubmFtZSBdID0gZGF0YTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbWVzaCA9IEdMLk1lc2guZ2V0U2NyZWVuUXVhZCgpO1xyXG5cclxuXHRcdGdsLmRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcclxuXHRcdGdsLmRpc2FibGUoIGdsLkJMRU5EICk7XHJcblxyXG5cdFx0dGV4dHVyZS5kcmF3VG8oZnVuY3Rpb24oKXtcclxuXHRcdFx0c2hhZGVyLnVuaWZvcm1zKCB1bmlmb3JtcyApO1xyXG5cdFx0XHRzaGFkZXIuZHJhdyggbWVzaCApO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly91c2Ugc3ViZ3JhcGggb3V0cHV0IFxyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleHR1cmUgKTtcclxuXHR9O1xyXG5cclxuXHQvL2FkZCBpbnB1dCBub2RlIGluc2lkZSBzdWJncmFwaFxyXG5cdExHcmFwaFNoYWRlckdyYXBoLnByb3RvdHlwZS5vbklucHV0QWRkZWQgPSBmdW5jdGlvbiggc2xvdF9pbmZvIClcclxuXHR7XHJcblx0XHR2YXIgc3Vibm9kZSA9IExpdGVHcmFwaC5jcmVhdGVOb2RlKFwic2hhZGVyOjppbnB1dC91bmlmb3JtXCIpO1xyXG5cdFx0c3Vibm9kZS5zZXRQcm9wZXJ0eShcIm5hbWVcIixzbG90X2luZm8ubmFtZSk7XHJcblx0XHRzdWJub2RlLnNldFByb3BlcnR5KFwidHlwZVwiLHNsb3RfaW5mby50eXBlKTtcclxuXHRcdHRoaXMuc3ViZ3JhcGguYWRkKCBzdWJub2RlICk7XHJcblx0fVxyXG5cclxuXHQvL3JlbW92ZSBhbGxcclxuXHRMR3JhcGhTaGFkZXJHcmFwaC5wcm90b3R5cGUub25JbnB1dFJlbW92ZWQgPSBmdW5jdGlvbiggc2xvdCwgc2xvdF9pbmZvIClcclxuXHR7XHJcblx0XHR2YXIgbm9kZXMgPSB0aGlzLnN1YmdyYXBoLmZpbmROb2Rlc0J5VHlwZShcInNoYWRlcjo6aW5wdXQvdW5pZm9ybVwiKTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSlcclxuXHRcdHtcclxuXHRcdFx0dmFyIG5vZGUgPSBub2Rlc1tpXTtcclxuXHRcdFx0aWYobm9kZS5wcm9wZXJ0aWVzLm5hbWUgPT0gc2xvdF9pbmZvLm5hbWUgKVxyXG5cdFx0XHRcdHRoaXMuc3ViZ3JhcGgucmVtb3ZlKCBub2RlICk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJHcmFwaC5wcm90b3R5cGUuY29tcHV0ZVNpemUgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0dmFyIG51bV9pbnB1dHMgPSB0aGlzLmlucHV0cyA/IHRoaXMuaW5wdXRzLmxlbmd0aCA6IDA7XHJcblx0XHR2YXIgbnVtX291dHB1dHMgPSB0aGlzLm91dHB1dHMgPyB0aGlzLm91dHB1dHMubGVuZ3RoIDogMDtcclxuXHRcdHJldHVybiBbIDIwMCwgTWF0aC5tYXgobnVtX2lucHV0cyxudW1fb3V0cHV0cykgKiBMaXRlR3JhcGguTk9ERV9TTE9UX0hFSUdIVCArIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCArIDEwXTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlckdyYXBoLnByb3RvdHlwZS5nZXRTaGFkZXIgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0dmFyIHNoYWRlciA9IHRoaXMuX2NvbnRleHQuZ2V0U2hhZGVyKCB0aGlzLnN1YmdyYXBoICk7XHJcblx0XHRpZighc2hhZGVyKVxyXG5cdFx0XHR0aGlzLmJveGNvbG9yID0gXCJyZWRcIjtcclxuXHRcdGVsc2VcclxuXHRcdFx0dGhpcy5ib3hjb2xvciA9IG51bGw7XHJcblx0XHRyZXR1cm4gc2hhZGVyO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyR3JhcGgucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgsIGdyYXBoY2FudmFzLCBjYW52YXMsIHBvcylcclxuXHR7XHJcblx0XHRpZih0aGlzLmZsYWdzLmNvbGxhcHNlZClcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdC8vYWxsb3dzIHRvIHByZXZpZXcgdGhlIG5vZGUgaWYgdGhlIGNhbnZhcyBpcyBhIHdlYmdsIGNhbnZhc1xyXG5cdFx0dmFyIHRleCA9IHRoaXMuZ2V0T3V0cHV0RGF0YSgwKTtcclxuXHRcdHZhciBpbnB1dHNfeSA9IHRoaXMuaW5wdXRzID8gdGhpcy5pbnB1dHMubGVuZ3RoICogTGl0ZUdyYXBoLk5PREVfU0xPVF9IRUlHSFQgOiAwO1xyXG5cdFx0aWYgKHRleCAmJiBjdHggPT0gdGV4LmdsICYmIHRoaXMuc2l6ZVsxXSA+IGlucHV0c195ICsgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICkge1xyXG5cdFx0XHRjdHguZHJhd0ltYWdlKCB0ZXgsIDEwLHksIHRoaXMuc2l6ZVswXSAtIDIwLCB0aGlzLnNpemVbMV0gLSBpbnB1dHNfeSAtIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB5ID0gdGhpcy5zaXplWzFdIC0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICsgMC41O1xyXG5cclxuXHRcdC8vYnV0dG9uXHJcblx0XHR2YXIgb3ZlciA9IExpdGVHcmFwaC5pc0luc2lkZVJlY3RhbmdsZShwb3NbMF0scG9zWzFdLHRoaXMucG9zWzBdLHRoaXMucG9zWzFdICsgeSx0aGlzLnNpemVbMF0sTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUKTtcclxuXHRcdGN0eC5maWxsU3R5bGUgPSBvdmVyID8gXCIjNTU1XCIgOiBcIiMyMjJcIjtcclxuXHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdGlmICh0aGlzLl9zaGFwZSA9PSBMaXRlR3JhcGguQk9YX1NIQVBFKVxyXG5cdFx0XHRjdHgucmVjdCgwLCB5LCB0aGlzLnNpemVbMF0rMSwgTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUKTtcclxuXHRcdGVsc2VcclxuXHRcdFx0Y3R4LnJvdW5kUmVjdCggMCwgeSwgdGhpcy5zaXplWzBdKzEsIExpdGVHcmFwaC5OT0RFX1RJVExFX0hFSUdIVCwgMCwgOCk7XHJcblx0XHRjdHguZmlsbCgpO1xyXG5cclxuXHRcdC8vYnV0dG9uXHJcblx0XHRjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuXHRcdGN0eC5mb250ID0gXCIyNHB4IEFyaWFsXCI7XHJcblx0XHRjdHguZmlsbFN0eWxlID0gb3ZlciA/IFwiI0RERFwiIDogXCIjOTk5XCI7XHJcblx0XHRjdHguZmlsbFRleHQoIFwiK1wiLCB0aGlzLnNpemVbMF0gKiAwLjUsIHkgKyAyNCApO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyR3JhcGgucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24oZSwgbG9jYWxwb3MsIGdyYXBoY2FudmFzKVxyXG5cdHtcclxuXHRcdHZhciB5ID0gdGhpcy5zaXplWzFdIC0gTGl0ZUdyYXBoLk5PREVfVElUTEVfSEVJR0hUICsgMC41O1xyXG5cdFx0aWYobG9jYWxwb3NbMV0gPiB5KVxyXG5cdFx0e1xyXG5cdFx0XHRncmFwaGNhbnZhcy5zaG93U3ViZ3JhcGhQcm9wZXJ0aWVzRGlhbG9nKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyR3JhcGgucHJvdG90eXBlLm9uRHJhd1N1YmdyYXBoQmFja2dyb3VuZCA9IGZ1bmN0aW9uKGdyYXBoY2FudmFzKVxyXG5cdHtcclxuXHRcdC8vVE9ET1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyR3JhcGgucHJvdG90eXBlLmdldEV4dHJhTWVudU9wdGlvbnMgPSBmdW5jdGlvbihncmFwaGNhbnZhcylcclxuXHR7XHJcblx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblx0XHR2YXIgb3B0aW9ucyA9IFt7IGNvbnRlbnQ6IFwiUHJpbnQgQ29kZVwiLCBjYWxsYmFjazogZnVuY3Rpb24oKXtcclxuXHRcdFx0dmFyIGNvZGUgPSB0aGF0Ll9jb250ZXh0LmNvbXB1dGVTaGFkZXJDb2RlKCk7XHJcblx0XHRcdGNvbnNvbGUubG9nKCBjb2RlLnZzX2NvZGUsIGNvZGUuZnNfY29kZSApO1xyXG5cdFx0fX1dO1xyXG5cclxuXHRcdHJldHVybiBvcHRpb25zO1xyXG5cdH1cclxuXHJcblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwidGV4dHVyZS9zaGFkZXJHcmFwaFwiLCBMR3JhcGhTaGFkZXJHcmFwaCApO1xyXG5cclxuXHRmdW5jdGlvbiBzaGFkZXJOb2RlRnJvbUZ1bmN0aW9uKCBjbGFzc25hbWUsIHBhcmFtcywgcmV0dXJuX3R5cGUsIGNvZGUgKVxyXG5cdHtcclxuXHRcdC8vVE9ET1xyXG5cdH1cclxuXHJcblx0Ly9TaGFkZXIgTm9kZXMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcblx0Ly9hcHBsaWVzIGEgc2hhZGVyIGdyYXBoIHRvIGEgY29kZVxyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlclVuaWZvcm0oKSB7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcIlwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgbmFtZTogXCJcIiwgdHlwZTogXCJcIiB9O1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyVW5pZm9ybS50aXRsZSA9IFwiVW5pZm9ybVwiO1xyXG5cdExHcmFwaFNoYWRlclVuaWZvcm0uZGVzYyA9IFwiSW5wdXQgZGF0YSBmb3IgdGhlIHNoYWRlclwiO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJVbmlmb3JtLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHRpZiggdGhpcy5wcm9wZXJ0aWVzLm5hbWUgJiYgdGhpcy5mbGFncy5jb2xsYXBzZWQpXHJcblx0XHRcdHJldHVybiB0aGlzLnByb3BlcnRpZXMudHlwZSArIFwiIFwiICsgdGhpcy5wcm9wZXJ0aWVzLm5hbWU7XHJcblx0XHRyZXR1cm4gXCJVbmlmb3JtXCI7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJVbmlmb3JtLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsdmFsdWUpXHJcblx0e1xyXG5cdFx0dGhpcy5vdXRwdXRzWzBdLm5hbWUgPSB0aGlzLnByb3BlcnRpZXMudHlwZSArIFwiIFwiICsgdGhpcy5wcm9wZXJ0aWVzLm5hbWU7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJVbmlmb3JtLnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbiggY29udGV4dCApXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIHR5cGUgPSB0aGlzLnByb3BlcnRpZXMudHlwZTtcclxuXHRcdGlmKCAhdHlwZSApXHJcblx0XHR7XHJcblx0XHRcdGlmKCAhY29udGV4dC5vbkdldFByb3BlcnR5SW5mbyApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR2YXIgaW5mbyA9IGNvbnRleHQub25HZXRQcm9wZXJ0eUluZm8oIHRoaXMucHJvcGVydHkubmFtZSApO1xyXG5cdFx0XHRpZighaW5mbylcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdHR5cGUgPSBpbmZvLnR5cGU7XHJcblx0XHR9XHJcblx0XHRpZih0eXBlID09IFwibnVtYmVyXCIpXHJcblx0XHRcdHR5cGUgPSBcImZsb2F0XCI7XHJcblx0XHRlbHNlIGlmKHR5cGUgPT0gXCJ0ZXh0dXJlXCIpXHJcblx0XHRcdHR5cGUgPSBcInNhbXBsZXIyRFwiO1xyXG5cdFx0aWYgKCBMR1NoYWRlcnMuR0xTTF90eXBlcy5pbmRleE9mKHR5cGUpID09IC0xIClcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdGNvbnRleHQuYWRkVW5pZm9ybSggXCJ1X1wiICsgdGhpcy5wcm9wZXJ0aWVzLm5hbWUsIHR5cGUgKTtcclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgdHlwZSApO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyVW5pZm9ybS5wcm90b3R5cGUuZ2V0T3V0cHV0VmFyTmFtZSA9IGZ1bmN0aW9uKHNsb3QpXHJcblx0e1xyXG5cdFx0cmV0dXJuIFwidV9cIiArIHRoaXMucHJvcGVydGllcy5uYW1lO1xyXG5cdH1cclxuXHJcblx0cmVnaXN0ZXJTaGFkZXJOb2RlKCBcImlucHV0L3VuaWZvcm1cIiwgTEdyYXBoU2hhZGVyVW5pZm9ybSApO1xyXG5cclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyQXR0cmlidXRlKCkge1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJ2ZWMyXCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBuYW1lOiBcImNvb3JkXCIsIHR5cGU6IFwidmVjMlwiIH07XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJBdHRyaWJ1dGUudGl0bGUgPSBcIkF0dHJpYnV0ZVwiO1xyXG5cdExHcmFwaFNoYWRlckF0dHJpYnV0ZS5kZXNjID0gXCJJbnB1dCBkYXRhIGZyb20gbWVzaCBhdHRyaWJ1dGVcIjtcclxuXHJcblx0TEdyYXBoU2hhZGVyQXR0cmlidXRlLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHRyZXR1cm4gXCJhdHQuIFwiICsgdGhpcy5wcm9wZXJ0aWVzLm5hbWU7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJBdHRyaWJ1dGUucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKCBjb250ZXh0IClcclxuXHR7XHJcblx0XHRpZighdGhpcy5zaGFkZXJfZGVzdGluYXRpb24pXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgdHlwZSA9IHRoaXMucHJvcGVydGllcy50eXBlO1xyXG5cdFx0aWYoICF0eXBlIHx8IExHU2hhZGVycy5HTFNMX3R5cGVzLmluZGV4T2YodHlwZSkgPT0gLTEgKVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHRpZih0eXBlID09IFwibnVtYmVyXCIpXHJcblx0XHRcdHR5cGUgPSBcImZsb2F0XCI7XHJcblx0XHRpZiggdGhpcy5wcm9wZXJ0aWVzLm5hbWUgIT0gXCJjb29yZFwiKVxyXG5cdFx0e1xyXG5cdFx0XHRjb250ZXh0LmFkZENvZGUoIFwidmFyeWluZ1wiLCBcIiB2YXJ5aW5nIFwiICsgdHlwZSArXCIgdl9cIiArIHRoaXMucHJvcGVydGllcy5uYW1lICsgXCI7XCIgKTtcclxuXHRcdFx0Ly9pZiggIWNvbnRleHQudmFyeWluZ3NbIHRoaXMucHJvcGVydGllcy5uYW1lIF0gKVxyXG5cdFx0XHQvL2NvbnRleHQuYWRkQ29kZSggXCJ2c19jb2RlXCIsIFwidl9cIiArIHRoaXMucHJvcGVydGllcy5uYW1lICsgXCIgPSBcIiArIGlucHV0X25hbWUgKyBcIjtcIiApO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCB0eXBlICk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJBdHRyaWJ1dGUucHJvdG90eXBlLmdldE91dHB1dFZhck5hbWUgPSBmdW5jdGlvbihzbG90KVxyXG5cdHtcclxuXHRcdHJldHVybiBcInZfXCIgKyB0aGlzLnByb3BlcnRpZXMubmFtZTtcclxuXHR9XHJcblxyXG5cdHJlZ2lzdGVyU2hhZGVyTm9kZSggXCJpbnB1dC9hdHRyaWJ1dGVcIiwgTEdyYXBoU2hhZGVyQXR0cmlidXRlICk7XHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlclNhbXBsZXIyRCgpIHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ0ZXhcIiwgXCJzYW1wbGVyMkRcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwidXZcIiwgXCJ2ZWMyXCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJyZ2JhXCIsIFwidmVjNFwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwicmdiXCIsIFwidmVjM1wiKTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclNhbXBsZXIyRC50aXRsZSA9IFwiU2FtcGxlcjJEXCI7XHJcblx0TEdyYXBoU2hhZGVyU2FtcGxlcjJELmRlc2MgPSBcIlJlYWRzIGEgcGl4ZWwgZnJvbSBhIHRleHR1cmVcIjtcclxuXHJcblx0TEdyYXBoU2hhZGVyU2FtcGxlcjJELnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbiggY29udGV4dCApXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIHRleG5hbWUgPSBnZXRJbnB1dExpbmtJRCggdGhpcywgMCApO1xyXG5cdFx0dmFyIHZhcm5hbWUgPSBnZXRTaGFkZXJOb2RlVmFyTmFtZSh0aGlzKTtcclxuXHRcdHZhciBjb2RlID0gXCJ2ZWM0IFwiICsgdmFybmFtZSArIFwiID0gdmVjNCgwLjApO1xcblwiO1xyXG5cdFx0aWYodGV4bmFtZSlcclxuXHRcdHtcclxuXHRcdFx0dmFyIHV2bmFtZSA9IGdldElucHV0TGlua0lEKCB0aGlzLCAxICkgfHwgY29udGV4dC5idWZmZXJfbmFtZXMudXZzO1xyXG5cdFx0XHRjb2RlICs9IHZhcm5hbWUgKyBcIiA9IHRleHR1cmUyRChcIit0ZXhuYW1lK1wiLFwiK3V2bmFtZStcIik7XFxuXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxpbmswID0gZ2V0T3V0cHV0TGlua0lEKCB0aGlzLCAwICk7XHJcblx0XHRpZihsaW5rMClcclxuXHRcdFx0Y29kZSArPSBcInZlYzQgXCIgKyBnZXRPdXRwdXRMaW5rSUQoIHRoaXMsIDAgKSArIFwiID0gXCIrdmFybmFtZStcIjtcXG5cIjtcclxuXHJcblx0XHR2YXIgbGluazEgPSBnZXRPdXRwdXRMaW5rSUQoIHRoaXMsIDEgKTtcclxuXHRcdGlmKGxpbmsxKVxyXG5cdFx0XHRjb2RlICs9IFwidmVjMyBcIiArIGdldE91dHB1dExpbmtJRCggdGhpcywgMSApICsgXCIgPSBcIit2YXJuYW1lK1wiLnh5ejtcXG5cIjtcclxuXHJcblx0XHRjb250ZXh0LmFkZENvZGUoIFwiY29kZVwiLCBjb2RlLCB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiApO1xyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCBcInZlYzRcIiApO1xyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAxLCBcInZlYzNcIiApO1xyXG5cdH1cclxuXHJcblx0cmVnaXN0ZXJTaGFkZXJOb2RlKCBcInRleHR1cmUvc2FtcGxlcjJEXCIsIExHcmFwaFNoYWRlclNhbXBsZXIyRCApO1xyXG5cclxuXHQvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJDb25zdGFudCgpXHJcblx0e1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJcIixcImZsb2F0XCIpO1xyXG5cclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcclxuXHRcdFx0dHlwZTogXCJmbG9hdFwiLFxyXG5cdFx0XHR2YWx1ZTogMFxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmFkZFdpZGdldChcImNvbWJvXCIsXCJ0eXBlXCIsXCJmbG9hdFwiLG51bGwsIHsgdmFsdWVzOiBHTFNMX3R5cGVzX2NvbnN0LCBwcm9wZXJ0eTogXCJ0eXBlXCIgfSApO1xyXG5cdFx0dGhpcy51cGRhdGVXaWRnZXRzKCk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJDb25zdGFudC50aXRsZSA9IFwiY29uc3RcIjtcclxuXHJcblx0TEdyYXBoU2hhZGVyQ29uc3RhbnQucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdGlmKHRoaXMuZmxhZ3MuY29sbGFwc2VkKVxyXG5cdFx0XHRyZXR1cm4gdmFsdWVUb0dMU0woIHRoaXMucHJvcGVydGllcy52YWx1ZSwgdGhpcy5wcm9wZXJ0aWVzLnR5cGUsIDIgKTtcclxuXHRcdHJldHVybiBcIkNvbnN0XCI7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJDb25zdGFudC5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLHZhbHVlKVxyXG5cdHtcclxuXHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHRcdGlmKG5hbWUgPT0gXCJ0eXBlXCIpXHJcblx0XHR7XHJcblx0XHRcdGlmKHRoaXMub3V0cHV0c1swXS50eXBlICE9IHZhbHVlKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGhpcy5kaXNjb25uZWN0T3V0cHV0KDApO1xyXG5cdFx0XHRcdHRoaXMub3V0cHV0c1swXS50eXBlID0gdmFsdWU7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy53aWRnZXRzLmxlbmd0aCA9IDE7IC8vcmVtb3ZlIGV4dHJhIHdpZGdldHNcclxuXHRcdFx0dGhpcy51cGRhdGVXaWRnZXRzKCk7XHJcblx0XHR9XHJcblx0XHRpZihuYW1lID09IFwidmFsdWVcIilcclxuXHRcdHtcclxuXHRcdFx0aWYoIXZhbHVlLmxlbmd0aClcclxuXHRcdFx0XHR0aGlzLndpZGdldHNbMV0udmFsdWUgPSB2YWx1ZTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGhpcy53aWRnZXRzWzFdLnZhbHVlID0gdmFsdWVbMV07XHJcblx0XHRcdFx0aWYodmFsdWUubGVuZ3RoID4gMilcclxuXHRcdFx0XHRcdHRoaXMud2lkZ2V0c1syXS52YWx1ZSA9IHZhbHVlWzJdO1xyXG5cdFx0XHRcdGlmKHZhbHVlLmxlbmd0aCA+IDMpXHJcblx0XHRcdFx0XHR0aGlzLndpZGdldHNbM10udmFsdWUgPSB2YWx1ZVszXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyQ29uc3RhbnQucHJvdG90eXBlLnVwZGF0ZVdpZGdldHMgPSBmdW5jdGlvbiggb2xkX3ZhbHVlIClcclxuXHR7XHJcblx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblx0XHR2YXIgb2xkX3ZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzLnZhbHVlO1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB7IHN0ZXA6IDAuMDEgfTtcclxuXHRcdHN3aXRjaCh0aGlzLnByb3BlcnRpZXMudHlwZSlcclxuXHRcdHtcclxuXHRcdFx0Y2FzZSAnZmxvYXQnOiBcclxuXHRcdFx0XHR0aGlzLnByb3BlcnRpZXMudmFsdWUgPSAwO1xyXG5cdFx0XHRcdHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsXCJ2XCIsMCx7IHN0ZXA6MC4wMSwgcHJvcGVydHk6IFwidmFsdWVcIiB9KTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSAndmVjMic6IFxyXG5cdFx0XHRcdHRoaXMucHJvcGVydGllcy52YWx1ZSA9IG9sZF92YWx1ZSAmJiBvbGRfdmFsdWUubGVuZ3RoID09IDIgPyBbb2xkX3ZhbHVlWzBdLG9sZF92YWx1ZVsxXV0gOiBbMCwwLDBdO1xyXG5cdFx0XHRcdHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsXCJ4XCIsdGhpcy5wcm9wZXJ0aWVzLnZhbHVlWzBdLCBmdW5jdGlvbih2KXsgdGhhdC5wcm9wZXJ0aWVzLnZhbHVlWzBdID0gdjsgfSxvcHRpb25zKTsgXHJcblx0XHRcdFx0dGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcInlcIix0aGlzLnByb3BlcnRpZXMudmFsdWVbMV0sIGZ1bmN0aW9uKHYpeyB0aGF0LnByb3BlcnRpZXMudmFsdWVbMV0gPSB2OyB9LG9wdGlvbnMpOyBcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSAndmVjMyc6IFxyXG5cdFx0XHRcdHRoaXMucHJvcGVydGllcy52YWx1ZSA9IG9sZF92YWx1ZSAmJiBvbGRfdmFsdWUubGVuZ3RoID09IDMgPyBbb2xkX3ZhbHVlWzBdLG9sZF92YWx1ZVsxXSxvbGRfdmFsdWVbMl1dIDogWzAsMCwwXTtcclxuXHRcdFx0XHR0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwieFwiLHRoaXMucHJvcGVydGllcy52YWx1ZVswXSwgZnVuY3Rpb24odil7IHRoYXQucHJvcGVydGllcy52YWx1ZVswXSA9IHY7IH0sb3B0aW9ucyk7IFxyXG5cdFx0XHRcdHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsXCJ5XCIsdGhpcy5wcm9wZXJ0aWVzLnZhbHVlWzFdLCBmdW5jdGlvbih2KXsgdGhhdC5wcm9wZXJ0aWVzLnZhbHVlWzFdID0gdjsgfSxvcHRpb25zKTsgXHJcblx0XHRcdFx0dGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcInpcIix0aGlzLnByb3BlcnRpZXMudmFsdWVbMl0sIGZ1bmN0aW9uKHYpeyB0aGF0LnByb3BlcnRpZXMudmFsdWVbMl0gPSB2OyB9LG9wdGlvbnMpOyBcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSAndmVjNCc6IFxyXG5cdFx0XHRcdHRoaXMucHJvcGVydGllcy52YWx1ZSA9IG9sZF92YWx1ZSAmJiBvbGRfdmFsdWUubGVuZ3RoID09IDQgPyBbb2xkX3ZhbHVlWzBdLG9sZF92YWx1ZVsxXSxvbGRfdmFsdWVbMl0sb2xkX3ZhbHVlWzNdXSA6IFswLDAsMCwwXTtcclxuXHRcdFx0XHR0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwieFwiLHRoaXMucHJvcGVydGllcy52YWx1ZVswXSwgZnVuY3Rpb24odil7IHRoYXQucHJvcGVydGllcy52YWx1ZVswXSA9IHY7IH0sb3B0aW9ucyk7IFxyXG5cdFx0XHRcdHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsXCJ5XCIsdGhpcy5wcm9wZXJ0aWVzLnZhbHVlWzFdLCBmdW5jdGlvbih2KXsgdGhhdC5wcm9wZXJ0aWVzLnZhbHVlWzFdID0gdjsgfSxvcHRpb25zKTsgXHJcblx0XHRcdFx0dGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcInpcIix0aGlzLnByb3BlcnRpZXMudmFsdWVbMl0sIGZ1bmN0aW9uKHYpeyB0aGF0LnByb3BlcnRpZXMudmFsdWVbMl0gPSB2OyB9LG9wdGlvbnMpOyBcclxuXHRcdFx0XHR0aGlzLmFkZFdpZGdldChcIm51bWJlclwiLFwid1wiLHRoaXMucHJvcGVydGllcy52YWx1ZVszXSwgZnVuY3Rpb24odil7IHRoYXQucHJvcGVydGllcy52YWx1ZVszXSA9IHY7IH0sb3B0aW9ucyk7IFxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJ1bmtub3duIHR5cGUgZm9yIGNvbnN0YW50XCIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyQ29uc3RhbnQucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKCBjb250ZXh0IClcclxuXHR7XHJcblx0XHRpZighdGhpcy5zaGFkZXJfZGVzdGluYXRpb24pXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgdmFsdWUgPSB2YWx1ZVRvR0xTTCggdGhpcy5wcm9wZXJ0aWVzLnZhbHVlLCB0aGlzLnByb3BlcnRpZXMudHlwZSApO1xyXG5cdFx0dmFyIGxpbmtfbmFtZSA9IGdldE91dHB1dExpbmtJRCh0aGlzLDApO1xyXG5cdFx0aWYoIWxpbmtfbmFtZSkgLy9ub3QgY29ubmVjdGVkXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgY29kZSA9IFwiXHRcIiArIHRoaXMucHJvcGVydGllcy50eXBlICsgXCIgXCIgKyBsaW5rX25hbWUgKyBcIiA9IFwiICsgdmFsdWUgKyBcIjtcIjtcclxuXHRcdGNvbnRleHQuYWRkQ29kZSggXCJjb2RlXCIsIGNvZGUsIHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uICk7XHJcblxyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCB0aGlzLnByb3BlcnRpZXMudHlwZSApO1xyXG5cdH1cclxuXHJcblx0cmVnaXN0ZXJTaGFkZXJOb2RlKCBcImNvbnN0L2NvbnN0XCIsIExHcmFwaFNoYWRlckNvbnN0YW50ICk7XHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlclZlYzIoKVxyXG5cdHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ4eVwiLFwidmVjMlwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ4XCIsXCJmbG9hdFwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ5XCIsXCJmbG9hdFwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwieHlcIixcInZlYzJcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInhcIixcImZsb2F0XCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ5XCIsXCJmbG9hdFwiKTtcclxuXHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclZlYzIudGl0bGUgPSBcInZlYzJcIjtcclxuXHRMR3JhcGhTaGFkZXJWZWMyLnZhcm1vZGVzID0gW1wieHlcIixcInhcIixcInlcIl07XHJcblxyXG5cdExHcmFwaFNoYWRlclZlYzIucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdGlmKHRoaXMuZ3JhcGgpXHJcblx0XHRcdCB0aGlzLmdyYXBoLl92ZXJzaW9uKys7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJWZWMyLnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbiggY29udGV4dCApXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzO1xyXG5cclxuXHRcdHZhciB2YXJuYW1lID0gZ2V0U2hhZGVyTm9kZVZhck5hbWUodGhpcyk7XHJcblx0XHR2YXIgY29kZSA9IFwiXHR2ZWMyIFwiICsgdmFybmFtZSArIFwiID0gXCIgKyB2YWx1ZVRvR0xTTChbcHJvcHMueCxwcm9wcy55XSkgKyBcIjtcXG5cIjtcclxuXHJcblx0XHRmb3IodmFyIGkgPSAwO2kgPCBMR3JhcGhTaGFkZXJWZWMyLnZhcm1vZGVzLmxlbmd0aDsgKytpKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgdmFybW9kZSA9IExHcmFwaFNoYWRlclZlYzIudmFybW9kZXNbaV07XHJcblx0XHRcdHZhciBpbmxpbmsgPSBnZXRJbnB1dExpbmtJRCh0aGlzLGkpO1xyXG5cdFx0XHRpZighaW5saW5rKVxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRjb2RlICs9IFwiXHRcIiArIHZhcm5hbWUgKyBcIi5cIit2YXJtb2RlK1wiID0gXCIgKyBpbmxpbmsgKyBcIjtcXG5cIjtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IodmFyIGkgPSAwO2kgPCBMR3JhcGhTaGFkZXJWZWMyLnZhcm1vZGVzLmxlbmd0aDsgKytpKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgdmFybW9kZSA9IExHcmFwaFNoYWRlclZlYzIudmFybW9kZXNbaV07XHJcblx0XHRcdHZhciBvdXRsaW5rID0gZ2V0T3V0cHV0TGlua0lEKHRoaXMsaSk7XHJcblx0XHRcdGlmKCFvdXRsaW5rKVxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR2YXIgdHlwZSA9IEdMU0xfdHlwZXNfY29uc3RbdmFybW9kZS5sZW5ndGggLSAxXTtcclxuXHRcdFx0Y29kZSArPSBcIlx0XCIrdHlwZStcIiBcIiArIG91dGxpbmsgKyBcIiA9IFwiICsgdmFybmFtZSArIFwiLlwiICsgdmFybW9kZSArIFwiO1xcblwiO1xyXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoIGksIHR5cGUgKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb250ZXh0LmFkZENvZGUoIFwiY29kZVwiLCBjb2RlLCB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiApO1xyXG5cdH1cclxuXHJcblx0cmVnaXN0ZXJTaGFkZXJOb2RlKCBcImNvbnN0L3ZlYzJcIiwgTEdyYXBoU2hhZGVyVmVjMiApO1x0XHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlclZlYzMoKVxyXG5cdHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ4eXpcIixcInZlYzNcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwieFwiLFwiZmxvYXRcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwieVwiLFwiZmxvYXRcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwielwiLFwiZmxvYXRcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwieHlcIixcInZlYzJcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwieHpcIixcInZlYzJcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwieXpcIixcInZlYzJcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInh5elwiLFwidmVjM1wiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwieFwiLFwiZmxvYXRcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInlcIixcImZsb2F0XCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ6XCIsXCJmbG9hdFwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwieHlcIixcInZlYzJcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInh6XCIsXCJ2ZWMyXCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ5elwiLFwidmVjMlwiKTtcclxuXHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IHg6MCwgeTogMCwgejogMCB9O1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyVmVjMy50aXRsZSA9IFwidmVjM1wiO1xyXG5cdExHcmFwaFNoYWRlclZlYzMudmFybW9kZXMgPSBbXCJ4eXpcIixcInhcIixcInlcIixcInpcIixcInh5XCIsXCJ4elwiLFwieXpcIl07XHJcblxyXG5cdExHcmFwaFNoYWRlclZlYzMucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdGlmKHRoaXMuZ3JhcGgpXHJcblx0XHRcdHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclZlYzMucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKCBjb250ZXh0IClcclxuXHR7XHJcblx0XHRpZighdGhpcy5zaGFkZXJfZGVzdGluYXRpb24pXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgcHJvcHMgPSB0aGlzLnByb3BlcnRpZXM7XHJcblxyXG5cdFx0dmFyIHZhcm5hbWUgPSBnZXRTaGFkZXJOb2RlVmFyTmFtZSh0aGlzKTtcclxuXHRcdHZhciBjb2RlID0gXCJ2ZWMzIFwiICsgdmFybmFtZSArIFwiID0gXCIgKyB2YWx1ZVRvR0xTTChbcHJvcHMueCxwcm9wcy55LHByb3BzLnpdKSArIFwiO1xcblwiO1xyXG5cclxuXHRcdGZvcih2YXIgaSA9IDA7aSA8IExHcmFwaFNoYWRlclZlYzMudmFybW9kZXMubGVuZ3RoOyArK2kpXHJcblx0XHR7XHJcblx0XHRcdHZhciB2YXJtb2RlID0gTEdyYXBoU2hhZGVyVmVjMy52YXJtb2Rlc1tpXTtcclxuXHRcdFx0dmFyIGlubGluayA9IGdldElucHV0TGlua0lEKHRoaXMsaSk7XHJcblx0XHRcdGlmKCFpbmxpbmspXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdGNvZGUgKz0gXCJcdFwiICsgdmFybmFtZSArIFwiLlwiK3Zhcm1vZGUrXCIgPSBcIiArIGlubGluayArIFwiO1xcblwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBMR3JhcGhTaGFkZXJWZWMzLnZhcm1vZGVzLmxlbmd0aDsgKytpKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgdmFybW9kZSA9IExHcmFwaFNoYWRlclZlYzMudmFybW9kZXNbaV07XHJcblx0XHRcdHZhciBvdXRsaW5rID0gZ2V0T3V0cHV0TGlua0lEKHRoaXMsaSk7XHJcblx0XHRcdGlmKCFvdXRsaW5rKVxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR2YXIgdHlwZSA9IEdMU0xfdHlwZXNfY29uc3RbdmFybW9kZS5sZW5ndGggLSAxXTtcclxuXHRcdFx0Y29kZSArPSBcIlx0XCIrdHlwZStcIiBcIiArIG91dGxpbmsgKyBcIiA9IFwiICsgdmFybmFtZSArIFwiLlwiICsgdmFybW9kZSArIFwiO1xcblwiO1xyXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoIGksIHR5cGUgKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb250ZXh0LmFkZENvZGUoIFwiY29kZVwiLCBjb2RlLCB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiApO1xyXG5cdH1cclxuXHJcblx0cmVnaXN0ZXJTaGFkZXJOb2RlKCBcImNvbnN0L3ZlYzNcIiwgTEdyYXBoU2hhZGVyVmVjMyApO1x0XHJcblxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJWZWM0KClcclxuXHR7XHJcblx0XHR0aGlzLmFkZElucHV0KFwieHl6d1wiLFwidmVjNFwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ4eXpcIixcInZlYzNcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwieFwiLFwiZmxvYXRcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwieVwiLFwiZmxvYXRcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwielwiLFwiZmxvYXRcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwid1wiLFwiZmxvYXRcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwieHlcIixcInZlYzJcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwieXpcIixcInZlYzJcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiendcIixcInZlYzJcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInh5endcIixcInZlYzRcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInh5elwiLFwidmVjM1wiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwieFwiLFwiZmxvYXRcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInlcIixcImZsb2F0XCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ6XCIsXCJmbG9hdFwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwieHlcIixcInZlYzJcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcInl6XCIsXCJ2ZWMyXCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJ6d1wiLFwidmVjMlwiKTtcclxuXHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IHg6MCwgeTogMCwgejogMCwgdzogMCB9O1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyVmVjNC50aXRsZSA9IFwidmVjNFwiO1xyXG5cdExHcmFwaFNoYWRlclZlYzQudmFybW9kZXMgPSBbXCJ4eXp3XCIsXCJ4eXpcIixcInhcIixcInlcIixcInpcIixcIndcIixcInh5XCIsXCJ5elwiLFwiendcIl07XHJcblxyXG5cdExHcmFwaFNoYWRlclZlYzQucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdGlmKHRoaXMuZ3JhcGgpXHJcblx0XHRcdHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclZlYzQucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKCBjb250ZXh0IClcclxuXHR7XHJcblx0XHRpZighdGhpcy5zaGFkZXJfZGVzdGluYXRpb24pXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgcHJvcHMgPSB0aGlzLnByb3BlcnRpZXM7XHJcblxyXG5cdFx0dmFyIHZhcm5hbWUgPSBnZXRTaGFkZXJOb2RlVmFyTmFtZSh0aGlzKTtcclxuXHRcdHZhciBjb2RlID0gXCJ2ZWM0IFwiICsgdmFybmFtZSArIFwiID0gXCIgKyB2YWx1ZVRvR0xTTChbcHJvcHMueCxwcm9wcy55LHByb3BzLnoscHJvcHMud10pICsgXCI7XFxuXCI7XHJcblxyXG5cdFx0Zm9yKHZhciBpID0gMDtpIDwgTEdyYXBoU2hhZGVyVmVjNC52YXJtb2Rlcy5sZW5ndGg7ICsraSlcclxuXHRcdHtcclxuXHRcdFx0dmFyIHZhcm1vZGUgPSBMR3JhcGhTaGFkZXJWZWM0LnZhcm1vZGVzW2ldO1xyXG5cdFx0XHR2YXIgaW5saW5rID0gZ2V0SW5wdXRMaW5rSUQodGhpcyxpKTtcclxuXHRcdFx0aWYoIWlubGluaylcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0Y29kZSArPSBcIlx0XCIgKyB2YXJuYW1lICsgXCIuXCIrdmFybW9kZStcIiA9IFwiICsgaW5saW5rICsgXCI7XFxuXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yKHZhciBpID0gMDtpIDwgTEdyYXBoU2hhZGVyVmVjNC52YXJtb2Rlcy5sZW5ndGg7ICsraSlcclxuXHRcdHtcclxuXHRcdFx0dmFyIHZhcm1vZGUgPSBMR3JhcGhTaGFkZXJWZWM0LnZhcm1vZGVzW2ldO1xyXG5cdFx0XHR2YXIgb3V0bGluayA9IGdldE91dHB1dExpbmtJRCh0aGlzLGkpO1xyXG5cdFx0XHRpZighb3V0bGluaylcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0dmFyIHR5cGUgPSBHTFNMX3R5cGVzX2NvbnN0W3Zhcm1vZGUubGVuZ3RoIC0gMV07XHJcblx0XHRcdGNvZGUgKz0gXCJcdFwiK3R5cGUrXCIgXCIgKyBvdXRsaW5rICsgXCIgPSBcIiArIHZhcm5hbWUgKyBcIi5cIiArIHZhcm1vZGUgKyBcIjtcXG5cIjtcclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKCBpLCB0eXBlICk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29udGV4dC5hZGRDb2RlKCBcImNvZGVcIiwgY29kZSwgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZWdpc3RlclNoYWRlck5vZGUoIFwiY29uc3QvdmVjNFwiLCBMR3JhcGhTaGFkZXJWZWM0ICk7XHRcclxuXHRcclxuXHQvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJGcmFnQ29sb3IoKSB7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiY29sb3JcIiwgTEdTaGFkZXJzLkFMTF9UWVBFUyApO1xyXG5cdFx0dGhpcy5ibG9ja19kZWxldGUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyRnJhZ0NvbG9yLnRpdGxlID0gXCJGcmFnQ29sb3JcIjtcclxuXHRMR3JhcGhTaGFkZXJGcmFnQ29sb3IuZGVzYyA9IFwiUGl4ZWwgZmluYWwgY29sb3JcIjtcclxuXHJcblx0TEdyYXBoU2hhZGVyRnJhZ0NvbG9yLnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbiggY29udGV4dCApXHJcblx0e1xyXG5cdFx0dmFyIGxpbmtfbmFtZSA9IGdldElucHV0TGlua0lEKCB0aGlzLCAwICk7XHJcblx0XHRpZighbGlua19uYW1lKVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR2YXIgdHlwZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0dmFyIGNvZGUgPSB2YXJUb1R5cGVHTFNMKCBsaW5rX25hbWUsIHR5cGUsIFwidmVjNFwiICk7XHJcblx0XHRjb250ZXh0LmFkZENvZGUoXCJmc19jb2RlXCIsIFwiZnJhZ2NvbG9yID0gXCIgKyBjb2RlICsgXCI7XCIpO1xyXG5cdH1cclxuXHJcblx0cmVnaXN0ZXJTaGFkZXJOb2RlKCBcIm91dHB1dC9mcmFnY29sb3JcIiwgTEdyYXBoU2hhZGVyRnJhZ0NvbG9yICk7XHJcblxyXG5cclxuXHQvKlxyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlckRpc2NhcmQoKVxyXG5cdHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ2XCIsXCJUXCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIm1pblwiLFwiVFwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgbWluX3ZhbHVlOiAwLjAgfTtcclxuXHRcdHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsXCJtaW5cIiwwLHsgc3RlcDogMC4wMSwgcHJvcGVydHk6IFwibWluX3ZhbHVlXCIgfSk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJEaXNjYXJkLnRpdGxlID0gXCJEaXNjYXJkXCI7XHJcblxyXG5cdExHcmFwaFNoYWRlckRpc2NhcmQucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKCBjb250ZXh0IClcclxuXHR7XHJcblx0XHRpZighdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBpbmxpbmsgPSBnZXRJbnB1dExpbmtJRCh0aGlzLDApO1xyXG5cdFx0dmFyIGlubGluazEgPSBnZXRJbnB1dExpbmtJRCh0aGlzLDEpO1xyXG5cclxuXHRcdGlmKCFpbmxpbmsgJiYgIWlubGluazEpIC8vbm90IGNvbm5lY3RlZFxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHRjb250ZXh0LmFkZENvZGUoXCJjb2RlXCIsIHJldHVybl90eXBlICsgXCIgXCIgKyBvdXRsaW5rICsgXCIgPSAoIChcIiArIGlubGluayArIFwiIC0gXCIrbWluditcIikgLyAoXCIrIG1heHYrXCIgLSBcIittaW52K1wiKSApICogKFwiKyBtYXh2MitcIiAtIFwiK21pbnYyK1wiKSArIFwiICsgbWludjIgKyBcIjtcIiwgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gKTtcclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgcmV0dXJuX3R5cGUgKTtcclxuXHR9XHJcblxyXG5cdHJlZ2lzdGVyU2hhZGVyTm9kZSggXCJvdXRwdXQvZGlzY2FyZFwiLCBMR3JhcGhTaGFkZXJEaXNjYXJkICk7XHJcblx0Ki9cclxuXHJcblxyXG5cdC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyT3BlcmF0aW9uKClcclxuXHR7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiQVwiLCBMR1NoYWRlcnMuQUxMX1RZUEVTICk7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiQlwiLCBMR1NoYWRlcnMuQUxMX1RZUEVTICk7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLFwiXCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xyXG5cdFx0XHRvcGVyYXRpb246IFwiKlwiXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJjb21ib1wiLFwib3AuXCIsdGhpcy5wcm9wZXJ0aWVzLm9wZXJhdGlvbix7IHByb3BlcnR5OiBcIm9wZXJhdGlvblwiLCB2YWx1ZXM6IExHcmFwaFNoYWRlck9wZXJhdGlvbi5vcGVyYXRpb25zIH0pO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyT3BlcmF0aW9uLnRpdGxlID0gXCJPcGVyYXRpb25cIjtcclxuXHRMR3JhcGhTaGFkZXJPcGVyYXRpb24ub3BlcmF0aW9ucyA9IFtcIitcIixcIi1cIixcIipcIixcIi9cIl07XHJcblxyXG5cdExHcmFwaFNoYWRlck9wZXJhdGlvbi5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0aWYodGhpcy5mbGFncy5jb2xsYXBzZWQpXHJcblx0XHRcdHJldHVybiBcIkFcIiArIHRoaXMucHJvcGVydGllcy5vcGVyYXRpb24gKyBcIkJcIjtcclxuXHRcdGVsc2VcclxuXHRcdFx0cmV0dXJuIFwiT3BlcmF0aW9uXCI7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJPcGVyYXRpb24ucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKCBjb250ZXh0IClcclxuXHR7XHJcblx0XHRpZighdGhpcy5zaGFkZXJfZGVzdGluYXRpb24pXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHRpZighdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBpbmxpbmtzID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgMzsgKytpKVxyXG5cdFx0XHRpbmxpbmtzLnB1c2goIHsgbmFtZTogZ2V0SW5wdXRMaW5rSUQodGhpcyxpKSwgdHlwZTogdGhpcy5nZXRJbnB1dERhdGEoaSkgfHwgXCJmbG9hdFwiIH0gKTtcclxuXHJcblx0XHR2YXIgb3V0bGluayA9IGdldE91dHB1dExpbmtJRCh0aGlzLDApO1xyXG5cdFx0aWYoIW91dGxpbmspIC8vbm90IGNvbm5lY3RlZFxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0Ly9mdW5jX2Rlc2NcclxuXHRcdHZhciBiYXNlX3R5cGUgPSBpbmxpbmtzWzBdLnR5cGU7XHJcblx0XHR2YXIgcmV0dXJuX3R5cGUgPSBiYXNlX3R5cGU7XHJcblx0XHR2YXIgb3AgPSB0aGlzLnByb3BlcnRpZXMub3BlcmF0aW9uO1xyXG5cclxuXHRcdHZhciBwYXJhbXMgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCAyOyArK2kpXHJcblx0XHR7XHJcblx0XHRcdHZhciBwYXJhbV9jb2RlID0gaW5saW5rc1tpXS5uYW1lO1xyXG5cdFx0XHRpZihwYXJhbV9jb2RlID09IG51bGwpIC8vbm90IHBsdWdnZWRcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHBhcmFtX2NvZGUgPSBwLnZhbHVlICE9IG51bGwgPyBwLnZhbHVlIDogXCIoMS4wKVwiO1xyXG5cdFx0XHRcdGlubGlua3NbaV0udHlwZSA9IFwiZmxvYXRcIjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9jb252ZXJ0XHJcblx0XHRcdGlmKCBpbmxpbmtzW2ldLnR5cGUgIT0gYmFzZV90eXBlICkgXHJcblx0XHRcdHtcclxuXHRcdFx0XHRpZiggaW5saW5rc1tpXS50eXBlID09IFwiZmxvYXRcIiAmJiAob3AgPT0gXCIqXCIgfHwgb3AgPT0gXCIvXCIpIClcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHQvL0kgZmluZCBoYXJkIHRvIGNyZWF0ZSB0aGUgb3Bwb3NpdGUgY29uZGl0aW9uIG5vdywgc28gSSBwcmVmZWVyIGFuIGVsc2VcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0cGFyYW1fY29kZSA9IGNvbnZlcnRWYXJUb0dMU0xUeXBlKCBwYXJhbV9jb2RlLCBpbmxpbmtzW2ldLnR5cGUsIGJhc2VfdHlwZSApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHBhcmFtcy5wdXNoKCBwYXJhbV9jb2RlICk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdGNvbnRleHQuYWRkQ29kZShcImNvZGVcIiwgcmV0dXJuX3R5cGUgKyBcIiBcIiArIG91dGxpbmsgKyBcIiA9IFwiKyBwYXJhbXNbMF0gKyBvcCArIHBhcmFtc1sxXSArIFwiO1wiLCB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiApO1xyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCByZXR1cm5fdHlwZSApO1xyXG5cdH1cclxuXHJcblx0cmVnaXN0ZXJTaGFkZXJOb2RlKCBcIm1hdGgvb3BlcmF0aW9uXCIsIExHcmFwaFNoYWRlck9wZXJhdGlvbiApO1xyXG5cclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyRnVuYygpXHJcblx0e1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIkFcIiwgTEdTaGFkZXJzLkFMTF9UWVBFUyApO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIkJcIiwgTEdTaGFkZXJzLkFMTF9UWVBFUyApO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIixcIlwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcclxuXHRcdFx0ZnVuYzogXCJmbG9vclwiXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5fY3VycmVudCA9IFwiZmxvb3JcIjtcclxuXHRcdHRoaXMuYWRkV2lkZ2V0KFwiY29tYm9cIixcImZ1bmNcIix0aGlzLnByb3BlcnRpZXMuZnVuYyx7IHByb3BlcnR5OiBcImZ1bmNcIiwgdmFsdWVzOiBHTFNMX2Z1bmN0aW9uc19uYW1lIH0pO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyRnVuYy50aXRsZSA9IFwiRnVuY1wiO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJGdW5jLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsdmFsdWUpXHJcblx0e1xyXG5cdFx0aWYodGhpcy5ncmFwaClcclxuXHRcdFx0dGhpcy5ncmFwaC5fdmVyc2lvbisrO1xyXG5cclxuXHRcdGlmKG5hbWUgPT0gXCJmdW5jXCIpXHJcblx0XHR7XHJcblx0XHRcdHZhciBmdW5jX2Rlc2MgPSBHTFNMX2Z1bmN0aW9uc1sgdmFsdWUgXTtcclxuXHRcdFx0aWYoIWZ1bmNfZGVzYylcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHQvL3JlbW92ZSBleHRyYSBpbnB1dHNcclxuXHRcdFx0Zm9yKHZhciBpID0gZnVuY19kZXNjLnBhcmFtcy5sZW5ndGg7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSlcclxuXHRcdFx0XHR0aGlzLnJlbW92ZUlucHV0KGkpO1xyXG5cclxuXHRcdFx0Ly9hZGQgYW5kIHVwZGF0ZSBpbnB1dHNcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGZ1bmNfZGVzYy5wYXJhbXMubGVuZ3RoOyArK2kpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR2YXIgcCA9IGZ1bmNfZGVzYy5wYXJhbXNbaV07XHJcblx0XHRcdFx0aWYoIHRoaXMuaW5wdXRzW2ldIClcclxuXHRcdFx0XHRcdHRoaXMuaW5wdXRzW2ldLm5hbWUgPSBwLm5hbWUgKyAocC52YWx1ZSA/IFwiIChcIiArIHAudmFsdWUgKyBcIilcIiA6IFwiXCIpO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdHRoaXMuYWRkSW5wdXQoIHAubmFtZSwgTEdTaGFkZXJzLkFMTF9UWVBFUyApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJGdW5jLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHRpZih0aGlzLmZsYWdzLmNvbGxhcHNlZClcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJvcGVydGllcy5mdW5jO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRyZXR1cm4gXCJGdW5jXCI7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJGdW5jLnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbiggY29udGV4dCApXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0aWYoIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgaW5saW5rcyA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IDM7ICsraSlcclxuXHRcdFx0aW5saW5rcy5wdXNoKCB7IG5hbWU6IGdldElucHV0TGlua0lEKHRoaXMsaSksIHR5cGU6IHRoaXMuZ2V0SW5wdXREYXRhKGkpIHx8IFwiZmxvYXRcIiB9ICk7XHJcblxyXG5cdFx0dmFyIG91dGxpbmsgPSBnZXRPdXRwdXRMaW5rSUQodGhpcywwKTtcclxuXHRcdGlmKCFvdXRsaW5rKSAvL25vdCBjb25uZWN0ZWRcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBmdW5jX2Rlc2MgPSBHTFNMX2Z1bmN0aW9uc1sgdGhpcy5wcm9wZXJ0aWVzLmZ1bmMgXTtcclxuXHRcdGlmKCFmdW5jX2Rlc2MpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHQvL2Z1bmNfZGVzY1xyXG5cdFx0dmFyIGJhc2VfdHlwZSA9IGlubGlua3NbMF0udHlwZTtcclxuXHRcdHZhciByZXR1cm5fdHlwZSA9IGZ1bmNfZGVzYy5yZXR1cm5fdHlwZTtcclxuXHRcdGlmKCByZXR1cm5fdHlwZSA9PSBcIlRcIiApXHJcblx0XHRcdHJldHVybl90eXBlID0gYmFzZV90eXBlO1xyXG5cclxuXHRcdHZhciBwYXJhbXMgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBmdW5jX2Rlc2MucGFyYW1zLmxlbmd0aDsgKytpKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgcCA9IGZ1bmNfZGVzYy5wYXJhbXNbaV07XHJcblx0XHRcdHZhciBwYXJhbV9jb2RlID0gaW5saW5rc1tpXS5uYW1lO1xyXG5cdFx0XHRpZihwYXJhbV9jb2RlID09IG51bGwpIC8vbm90IHBsdWdnZWRcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHBhcmFtX2NvZGUgPSBwLnZhbHVlICE9IG51bGwgPyBwLnZhbHVlIDogXCIoMS4wKVwiO1xyXG5cdFx0XHRcdGlubGlua3NbaV0udHlwZSA9IFwiZmxvYXRcIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiggKHAudHlwZSA9PSBcIlRcIiAmJiBpbmxpbmtzW2ldLnR5cGUgIT0gYmFzZV90eXBlKSB8fFxyXG5cdFx0XHRcdChwLnR5cGUgIT0gXCJUXCIgJiYgaW5saW5rc1tpXS50eXBlICE9IGJhc2VfdHlwZSkgKVxyXG5cdFx0XHRcdHBhcmFtX2NvZGUgPSBjb252ZXJ0VmFyVG9HTFNMVHlwZSggcGFyYW1fY29kZSwgaW5saW5rc1tpXS50eXBlLCBiYXNlX3R5cGUgKTtcclxuXHRcdFx0cGFyYW1zLnB1c2goIHBhcmFtX2NvZGUgKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Y29udGV4dC5hZGRGdW5jdGlvbihcInJvdW5kXCIsXCJmbG9hdCByb3VuZChmbG9hdCB2KXsgcmV0dXJuIGZsb29yKHYrMC41KTsgfVxcbnZlYzIgcm91bmQodmVjMiB2KXsgcmV0dXJuIGZsb29yKHYrdmVjMigwLjUpKTt9XFxudmVjMyByb3VuZCh2ZWMzIHYpeyByZXR1cm4gZmxvb3Iodit2ZWMzKDAuNSkpO31cXG52ZWM0IHJvdW5kKHZlYzQgdil7IHJldHVybiBmbG9vcih2K3ZlYzQoMC41KSk7IH1cXG5cIik7XHJcblx0XHRjb250ZXh0LmFkZENvZGUoXCJjb2RlXCIsIHJldHVybl90eXBlICsgXCIgXCIgKyBvdXRsaW5rICsgXCIgPSBcIitmdW5jX2Rlc2MuZnVuYytcIihcIitwYXJhbXMuam9pbihcIixcIikrXCIpO1wiLCB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiApO1xyXG5cclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgcmV0dXJuX3R5cGUgKTtcclxuXHR9XHJcblxyXG5cdHJlZ2lzdGVyU2hhZGVyTm9kZSggXCJtYXRoL2Z1bmNcIiwgTEdyYXBoU2hhZGVyRnVuYyApO1xyXG5cclxuXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlclNuaXBwZXQoKVxyXG5cdHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJBXCIsIExHU2hhZGVycy5BTExfVFlQRVMgKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJCXCIsIExHU2hhZGVycy5BTExfVFlQRVMgKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwiQ1wiLFwidmVjNFwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcclxuXHRcdFx0Y29kZTpcIkMgPSBBK0JcIixcclxuXHRcdFx0dHlwZTogXCJ2ZWM0XCJcclxuXHRcdH1cclxuXHRcdHRoaXMuYWRkV2lkZ2V0KFwidGV4dFwiLFwiY29kZVwiLHRoaXMucHJvcGVydGllcy5jb2RlLHsgcHJvcGVydHk6IFwiY29kZVwiIH0pO1xyXG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJjb21ib1wiLFwidHlwZVwiLHRoaXMucHJvcGVydGllcy50eXBlLHsgdmFsdWVzOltcImZsb2F0XCIsXCJ2ZWMyXCIsXCJ2ZWMzXCIsXCJ2ZWM0XCJdLCBwcm9wZXJ0eTogXCJ0eXBlXCIgfSk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJTbmlwcGV0LnRpdGxlID0gXCJTbmlwcGV0XCI7XHJcblxyXG5cdExHcmFwaFNoYWRlclNuaXBwZXQucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSx2YWx1ZSlcclxuXHR7XHJcblx0XHRpZih0aGlzLmdyYXBoKVxyXG5cdFx0XHR0aGlzLmdyYXBoLl92ZXJzaW9uKys7XHJcblxyXG5cdFx0aWYobmFtZSA9PSBcInR5cGVcIiYmIHRoaXMub3V0cHV0c1swXS50eXBlICE9IHZhbHVlKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLmRpc2Nvbm5lY3RPdXRwdXQoMCk7XHJcblx0XHRcdHRoaXMub3V0cHV0c1swXS50eXBlID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJTbmlwcGV0LnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHRpZih0aGlzLmZsYWdzLmNvbGxhcHNlZClcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJvcGVydGllcy5jb2RlO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRyZXR1cm4gXCJTbmlwcGV0XCI7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJTbmlwcGV0LnByb3RvdHlwZS5vbkdldENvZGUgPSBmdW5jdGlvbiggY29udGV4dCApXHJcblx0e1xyXG5cdFx0aWYoIXRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uIHx8ICF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIGlubGlua0EgPSBnZXRJbnB1dExpbmtJRCh0aGlzLDApO1xyXG5cdFx0aWYoIWlubGlua0EpXHJcblx0XHRcdGlubGlua0EgPSBcIjEuMFwiO1xyXG5cdFx0dmFyIGlubGlua0IgPSBnZXRJbnB1dExpbmtJRCh0aGlzLDEpO1xyXG5cdFx0aWYoIWlubGlua0IpXHJcblx0XHRcdGlubGlua0IgPSBcIjEuMFwiO1xyXG5cdFx0dmFyIG91dGxpbmsgPSBnZXRPdXRwdXRMaW5rSUQodGhpcywwKTtcclxuXHRcdGlmKCFvdXRsaW5rKSAvL25vdCBjb25uZWN0ZWRcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBpbkFfdHlwZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApIHx8IFwiZmxvYXRcIjtcclxuXHRcdHZhciBpbkJfdHlwZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpIHx8IFwiZmxvYXRcIjtcclxuXHRcdHZhciByZXR1cm5fdHlwZSA9IHRoaXMucHJvcGVydGllcy50eXBlO1xyXG5cclxuXHRcdC8vY2Fubm90IHJlc29sdmUgaW5wdXRcclxuXHRcdGlmKGluQV90eXBlID09IFwiVFwiIHx8IGluQl90eXBlID09IFwiVFwiKVxyXG5cdFx0e1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZnVuY25hbWUgPSBcImZ1bmNTbmlwcGV0XCIgKyB0aGlzLmlkO1xyXG5cclxuXHRcdHZhciBmdW5jX2NvZGUgPSBcIlxcblwiICsgcmV0dXJuX3R5cGUgKyBcIiBcIiArIGZ1bmNuYW1lICsgXCIoIFwiICsgaW5BX3R5cGUgKyBcIiBBLCBcIiArIGluQl90eXBlICsgXCIgQikge1xcblwiO1xyXG5cdFx0ZnVuY19jb2RlICs9IFwiXHRcIiArIHJldHVybl90eXBlICsgXCIgQyA9IFwiICsgcmV0dXJuX3R5cGUgKyBcIigwLjApO1xcblwiO1xyXG5cdFx0ZnVuY19jb2RlICs9IFwiXHRcIiArIHRoaXMucHJvcGVydGllcy5jb2RlICsgXCI7XFxuXCI7XHJcblx0XHRmdW5jX2NvZGUgKz0gXCJcdHJldHVybiBDO1xcbn1cXG5cIjtcclxuXHJcblx0XHRjb250ZXh0LmFkZENvZGUoXCJmdW5jdGlvbnNcIiwgZnVuY19jb2RlLCB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiApO1xyXG5cdFx0Y29udGV4dC5hZGRDb2RlKFwiY29kZVwiLCByZXR1cm5fdHlwZSArIFwiIFwiICsgb3V0bGluayArIFwiID0gXCIrZnVuY25hbWUrXCIoXCIraW5saW5rQStcIixcIitpbmxpbmtCK1wiKTtcIiwgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gKTtcclxuXHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIHJldHVybl90eXBlICk7XHJcblx0fVxyXG5cclxuXHRyZWdpc3RlclNoYWRlck5vZGUoIFwidXRpbHMvc25pcHBldFwiLCBMR3JhcGhTaGFkZXJTbmlwcGV0ICk7XHJcblxyXG5cdC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlclJhbmQoKVxyXG5cdHtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsXCJmbG9hdFwiKTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclJhbmQudGl0bGUgPSBcIlJhbmRcIjtcclxuXHJcblx0TEdyYXBoU2hhZGVyUmFuZC5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oIGNvbnRleHQgKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiB8fCAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBvdXRsaW5rID0gZ2V0T3V0cHV0TGlua0lEKHRoaXMsMCk7XHJcblxyXG5cdFx0Y29udGV4dC5hZGRVbmlmb3JtKCBcInVfcmFuZFwiICsgdGhpcy5pZCwgXCJmbG9hdFwiLCBmdW5jdGlvbigpeyByZXR1cm4gTWF0aC5yYW5kb20oKTsgfSk7XHJcblx0XHRjb250ZXh0LmFkZENvZGUoXCJjb2RlXCIsIFwiZmxvYXQgXCIgKyBvdXRsaW5rICsgXCIgPSB1X3JhbmRcIiArIHRoaXMuaWQgK1wiO1wiLCB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiApO1xyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCBcImZsb2F0XCIgKTtcclxuXHR9XHJcblxyXG5cdHJlZ2lzdGVyU2hhZGVyTm9kZSggXCJpbnB1dC9yYW5kXCIsIExHcmFwaFNoYWRlclJhbmQgKTtcclxuXHJcblx0Ly9ub2lzZVxyXG5cdC8vaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF0cmljaW9nb256YWxlenZpdm8vNjcwYzIyZjM5NjZlNjYyZDJmODNcclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJOb2lzZSgpXHJcblx0e1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIm91dFwiLCBMR1NoYWRlcnMuQUxMX1RZUEVTICk7XHJcblx0XHR0aGlzLmFkZElucHV0KFwic2NhbGVcIiwgXCJmbG9hdFwiICk7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLFwiZmxvYXRcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XHJcblx0XHRcdHR5cGU6IFwibm9pc2VcIixcclxuXHRcdFx0c2NhbGU6IDFcclxuXHRcdH07XHJcblx0XHR0aGlzLmFkZFdpZGdldChcImNvbWJvXCIsXCJ0eXBlXCIsIHRoaXMucHJvcGVydGllcy50eXBlLCB7IHByb3BlcnR5OiBcInR5cGVcIiwgdmFsdWVzOiBMR3JhcGhTaGFkZXJOb2lzZS5OT0lTRV9UWVBFUyB9KTtcclxuXHRcdHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsXCJzY2FsZVwiLCB0aGlzLnByb3BlcnRpZXMuc2NhbGUsIHsgcHJvcGVydHk6IFwic2NhbGVcIiB9KTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlck5vaXNlLk5PSVNFX1RZUEVTID0gW1wibm9pc2VcIixcInJhbmRcIl07XHJcblxyXG5cdExHcmFwaFNoYWRlck5vaXNlLnRpdGxlID0gXCJub2lzZVwiO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJOb2lzZS5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oIGNvbnRleHQgKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiB8fCAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBpbmxpbmsgPSBnZXRJbnB1dExpbmtJRCh0aGlzLDApO1xyXG5cdFx0dmFyIG91dGxpbmsgPSBnZXRPdXRwdXRMaW5rSUQodGhpcywwKTtcclxuXHJcblx0XHR2YXIgaW50eXBlID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRpZighaW5saW5rKVxyXG5cdFx0e1xyXG5cdFx0XHRpbnR5cGUgPSBcInZlYzJcIjtcclxuXHRcdFx0aW5saW5rID0gY29udGV4dC5idWZmZXJfbmFtZXMudXZzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnRleHQuYWRkRnVuY3Rpb24oXCJub2lzZVwiLExHcmFwaFNoYWRlck5vaXNlLnNoYWRlcl9mdW5jdGlvbnMpO1xyXG5cdFx0Y29udGV4dC5hZGRVbmlmb3JtKCBcInVfbm9pc2Vfc2NhbGVcIiArIHRoaXMuaWQsIFwiZmxvYXRcIiwgdGhpcy5wcm9wZXJ0aWVzLnNjYWxlICk7XHJcblx0XHRpZiggaW50eXBlID09IFwiZmxvYXRcIiApXHJcblx0XHRcdGNvbnRleHQuYWRkQ29kZShcImNvZGVcIiwgXCJmbG9hdCBcIiArIG91dGxpbmsgKyBcIiA9IHNub2lzZSggdmVjMihcIiArIGlubGluayArXCIpICogdV9ub2lzZV9zY2FsZVwiICsgdGhpcy5pZCArXCIpO1wiLCB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiApO1xyXG5cdFx0ZWxzZSBpZiggaW50eXBlID09IFwidmVjMlwiIHx8IGludHlwZSA9PSBcInZlYzNcIiApXHJcblx0XHRcdGNvbnRleHQuYWRkQ29kZShcImNvZGVcIiwgXCJmbG9hdCBcIiArIG91dGxpbmsgKyBcIiA9IHNub2lzZShcIiArIGlubGluayArXCIgKiB1X25vaXNlX3NjYWxlXCIgKyB0aGlzLmlkICtcIik7XCIsIHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uICk7XHJcblx0XHRlbHNlIGlmKCBpbnR5cGUgPT0gXCJ2ZWM0XCIgKVxyXG5cdFx0XHRjb250ZXh0LmFkZENvZGUoXCJjb2RlXCIsIFwiZmxvYXQgXCIgKyBvdXRsaW5rICsgXCIgPSBzbm9pc2UoXCIgKyBpbmxpbmsgK1wiLnh5eiAqIHVfbm9pc2Vfc2NhbGVcIiArIHRoaXMuaWQgK1wiKTtcIiwgdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gKTtcclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgXCJmbG9hdFwiICk7XHJcblx0fVxyXG5cclxuXHRyZWdpc3RlclNoYWRlck5vZGUoIFwibWF0aC9ub2lzZVwiLCBMR3JhcGhTaGFkZXJOb2lzZSApO1xyXG5cclxuTEdyYXBoU2hhZGVyTm9pc2Uuc2hhZGVyX2Z1bmN0aW9ucyA9IFwiXFxuXFxcclxudmVjMyBwZXJtdXRlKHZlYzMgeCkgeyByZXR1cm4gbW9kKCgoeCozNC4wKSsxLjApKngsIDI4OS4wKTsgfVxcblxcXHJcblxcblxcXHJcbmZsb2F0IHNub2lzZSh2ZWMyIHYpe1xcblxcXHJcbiAgY29uc3QgdmVjNCBDID0gdmVjNCgwLjIxMTMyNDg2NTQwNTE4NywgMC4zNjYwMjU0MDM3ODQ0MzksLTAuNTc3MzUwMjY5MTg5NjI2LCAwLjAyNDM5MDI0MzkwMjQzOSk7XFxuXFxcclxuICB2ZWMyIGkgID0gZmxvb3IodiArIGRvdCh2LCBDLnl5KSApO1xcblxcXHJcbiAgdmVjMiB4MCA9IHYgLSAgIGkgKyBkb3QoaSwgQy54eCk7XFxuXFxcclxuICB2ZWMyIGkxO1xcblxcXHJcbiAgaTEgPSAoeDAueCA+IHgwLnkpID8gdmVjMigxLjAsIDAuMCkgOiB2ZWMyKDAuMCwgMS4wKTtcXG5cXFxyXG4gIHZlYzQgeDEyID0geDAueHl4eSArIEMueHh6ejtcXG5cXFxyXG4gIHgxMi54eSAtPSBpMTtcXG5cXFxyXG4gIGkgPSBtb2QoaSwgMjg5LjApO1xcblxcXHJcbiAgdmVjMyBwID0gcGVybXV0ZSggcGVybXV0ZSggaS55ICsgdmVjMygwLjAsIGkxLnksIDEuMCApKVxcblxcXHJcbiAgKyBpLnggKyB2ZWMzKDAuMCwgaTEueCwgMS4wICkpO1xcblxcXHJcbiAgdmVjMyBtID0gbWF4KDAuNSAtIHZlYzMoZG90KHgwLHgwKSwgZG90KHgxMi54eSx4MTIueHkpLGRvdCh4MTIuencseDEyLnp3KSksIDAuMCk7XFxuXFxcclxuICBtID0gbSptIDtcXG5cXFxyXG4gIG0gPSBtKm0gO1xcblxcXHJcbiAgdmVjMyB4ID0gMi4wICogZnJhY3QocCAqIEMud3d3KSAtIDEuMDtcXG5cXFxyXG4gIHZlYzMgaCA9IGFicyh4KSAtIDAuNTtcXG5cXFxyXG4gIHZlYzMgb3ggPSBmbG9vcih4ICsgMC41KTtcXG5cXFxyXG4gIHZlYzMgYTAgPSB4IC0gb3g7XFxuXFxcclxuICBtICo9IDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogKCBhMCphMCArIGgqaCApO1xcblxcXHJcbiAgdmVjMyBnO1xcblxcXHJcbiAgZy54ICA9IGEwLnggICogeDAueCAgKyBoLnggICogeDAueTtcXG5cXFxyXG4gIGcueXogPSBhMC55eiAqIHgxMi54eiArIGgueXogKiB4MTIueXc7XFxuXFxcclxuICByZXR1cm4gMTMwLjAgKiBkb3QobSwgZyk7XFxuXFxcclxufVxcblxcXHJcbnZlYzQgcGVybXV0ZSh2ZWM0IHgpe3JldHVybiBtb2QoKCh4KjM0LjApKzEuMCkqeCwgMjg5LjApO31cXG5cXFxyXG52ZWM0IHRheWxvckludlNxcnQodmVjNCByKXtyZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO31cXG5cXFxyXG5cXG5cXFxyXG5mbG9hdCBzbm9pc2UodmVjMyB2KXsgXFxuXFxcclxuICBjb25zdCB2ZWMyICBDID0gdmVjMigxLjAvNi4wLCAxLjAvMy4wKSA7XFxuXFxcclxuICBjb25zdCB2ZWM0ICBEID0gdmVjNCgwLjAsIDAuNSwgMS4wLCAyLjApO1xcblxcXHJcblxcblxcXHJcbi8vIEZpcnN0IGNvcm5lclxcblxcXHJcbiAgdmVjMyBpICA9IGZsb29yKHYgKyBkb3QodiwgQy55eXkpICk7XFxuXFxcclxuICB2ZWMzIHgwID0gICB2IC0gaSArIGRvdChpLCBDLnh4eCkgO1xcblxcXHJcblxcblxcXHJcbi8vIE90aGVyIGNvcm5lcnNcXG5cXFxyXG4gIHZlYzMgZyA9IHN0ZXAoeDAueXp4LCB4MC54eXopO1xcblxcXHJcbiAgdmVjMyBsID0gMS4wIC0gZztcXG5cXFxyXG4gIHZlYzMgaTEgPSBtaW4oIGcueHl6LCBsLnp4eSApO1xcblxcXHJcbiAgdmVjMyBpMiA9IG1heCggZy54eXosIGwuenh5ICk7XFxuXFxcclxuXFxuXFxcclxuICAvLyAgeDAgPSB4MCAtIDAuICsgMC4wICogQyBcXG5cXFxyXG4gIHZlYzMgeDEgPSB4MCAtIGkxICsgMS4wICogQy54eHg7XFxuXFxcclxuICB2ZWMzIHgyID0geDAgLSBpMiArIDIuMCAqIEMueHh4O1xcblxcXHJcbiAgdmVjMyB4MyA9IHgwIC0gMS4gKyAzLjAgKiBDLnh4eDtcXG5cXFxyXG5cXG5cXFxyXG4vLyBQZXJtdXRhdGlvbnNcXG5cXFxyXG4gIGkgPSBtb2QoaSwgMjg5LjAgKTsgXFxuXFxcclxuICB2ZWM0IHAgPSBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlKCBcXG5cXFxyXG4gICAgICAgICAgICAgaS56ICsgdmVjNCgwLjAsIGkxLnosIGkyLnosIDEuMCApKVxcblxcXHJcbiAgICAgICAgICAgKyBpLnkgKyB2ZWM0KDAuMCwgaTEueSwgaTIueSwgMS4wICkpIFxcblxcXHJcbiAgICAgICAgICAgKyBpLnggKyB2ZWM0KDAuMCwgaTEueCwgaTIueCwgMS4wICkpO1xcblxcXHJcblxcblxcXHJcbi8vIEdyYWRpZW50c1xcblxcXHJcbi8vICggTipOIHBvaW50cyB1bmlmb3JtbHkgb3ZlciBhIHNxdWFyZSwgbWFwcGVkIG9udG8gYW4gb2N0YWhlZHJvbi4pXFxuXFxcclxuICBmbG9hdCBuXyA9IDEuMC83LjA7IC8vIE49N1xcblxcXHJcbiAgdmVjMyAgbnMgPSBuXyAqIEQud3l6IC0gRC54eng7XFxuXFxcclxuXFxuXFxcclxuICB2ZWM0IGogPSBwIC0gNDkuMCAqIGZsb29yKHAgKiBucy56ICpucy56KTsgIC8vICBtb2QocCxOKk4pXFxuXFxcclxuXFxuXFxcclxuICB2ZWM0IHhfID0gZmxvb3IoaiAqIG5zLnopO1xcblxcXHJcbiAgdmVjNCB5XyA9IGZsb29yKGogLSA3LjAgKiB4XyApOyAgICAvLyBtb2QoaixOKVxcblxcXHJcblxcblxcXHJcbiAgdmVjNCB4ID0geF8gKm5zLnggKyBucy55eXl5O1xcblxcXHJcbiAgdmVjNCB5ID0geV8gKm5zLnggKyBucy55eXl5O1xcblxcXHJcbiAgdmVjNCBoID0gMS4wIC0gYWJzKHgpIC0gYWJzKHkpO1xcblxcXHJcblxcblxcXHJcbiAgdmVjNCBiMCA9IHZlYzQoIHgueHksIHkueHkgKTtcXG5cXFxyXG4gIHZlYzQgYjEgPSB2ZWM0KCB4Lnp3LCB5Lnp3ICk7XFxuXFxcclxuXFxuXFxcclxuICB2ZWM0IHMwID0gZmxvb3IoYjApKjIuMCArIDEuMDtcXG5cXFxyXG4gIHZlYzQgczEgPSBmbG9vcihiMSkqMi4wICsgMS4wO1xcblxcXHJcbiAgdmVjNCBzaCA9IC1zdGVwKGgsIHZlYzQoMC4wKSk7XFxuXFxcclxuXFxuXFxcclxuICB2ZWM0IGEwID0gYjAueHp5dyArIHMwLnh6eXcqc2gueHh5eSA7XFxuXFxcclxuICB2ZWM0IGExID0gYjEueHp5dyArIHMxLnh6eXcqc2guenp3dyA7XFxuXFxcclxuXFxuXFxcclxuICB2ZWMzIHAwID0gdmVjMyhhMC54eSxoLngpO1xcblxcXHJcbiAgdmVjMyBwMSA9IHZlYzMoYTAuencsaC55KTtcXG5cXFxyXG4gIHZlYzMgcDIgPSB2ZWMzKGExLnh5LGgueik7XFxuXFxcclxuICB2ZWMzIHAzID0gdmVjMyhhMS56dyxoLncpO1xcblxcXHJcblxcblxcXHJcbi8vTm9ybWFsaXNlIGdyYWRpZW50c1xcblxcXHJcbiAgdmVjNCBub3JtID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChwMCxwMCksIGRvdChwMSxwMSksIGRvdChwMiwgcDIpLCBkb3QocDMscDMpKSk7XFxuXFxcclxuICBwMCAqPSBub3JtLng7XFxuXFxcclxuICBwMSAqPSBub3JtLnk7XFxuXFxcclxuICBwMiAqPSBub3JtLno7XFxuXFxcclxuICBwMyAqPSBub3JtLnc7XFxuXFxcclxuXFxuXFxcclxuLy8gTWl4IGZpbmFsIG5vaXNlIHZhbHVlXFxuXFxcclxuICB2ZWM0IG0gPSBtYXgoMC42IC0gdmVjNChkb3QoeDAseDApLCBkb3QoeDEseDEpLCBkb3QoeDIseDIpLCBkb3QoeDMseDMpKSwgMC4wKTtcXG5cXFxyXG4gIG0gPSBtICogbTtcXG5cXFxyXG4gIHJldHVybiA0Mi4wICogZG90KCBtKm0sIHZlYzQoIGRvdChwMCx4MCksIGRvdChwMSx4MSksZG90KHAyLHgyKSwgZG90KHAzLHgzKSApICk7XFxuXFxcclxufVxcblxcXHJcblxcblxcXHJcbnZlYzMgaGFzaDMoIHZlYzIgcCApe1xcblxcXHJcbiAgICB2ZWMzIHEgPSB2ZWMzKCBkb3QocCx2ZWMyKDEyNy4xLDMxMS43KSksIFxcblxcXHJcblx0XHRcdFx0ICAgZG90KHAsdmVjMigyNjkuNSwxODMuMykpLCBcXG5cXFxyXG5cdFx0XHRcdCAgIGRvdChwLHZlYzIoNDE5LjIsMzcxLjkpKSApO1xcblxcXHJcblx0cmV0dXJuIGZyYWN0KHNpbihxKSo0Mzc1OC41NDUzKTtcXG5cXFxyXG59XFxuXFxcclxudmVjNCBoYXNoNCggdmVjMyBwICl7XFxuXFxcclxuICAgIHZlYzQgcSA9IHZlYzQoIGRvdChwLHZlYzMoMTI3LjEsMzExLjcsMjU3LjMpKSwgXFxuXFxcclxuXHRcdFx0XHQgICBkb3QocCx2ZWMzKDI2OS41LDE4My4zLDMzNS4xKSksIFxcblxcXHJcblx0XHRcdFx0ICAgZG90KHAsdmVjMygzMTQuNSwyMzUuMSw0NjcuMykpLCBcXG5cXFxyXG5cdFx0XHRcdCAgIGRvdChwLHZlYzMoNDE5LjIsMzcxLjksMTE0LjkpKSApO1xcblxcXHJcblx0cmV0dXJuIGZyYWN0KHNpbihxKSo0Mzc1OC41NDUzKTtcXG5cXFxyXG59XFxuXFxcclxuXFxuXFxcclxuZmxvYXQgaXFub2lzZSggaW4gdmVjMiB4LCBmbG9hdCB1LCBmbG9hdCB2ICl7XFxuXFxcclxuICAgIHZlYzIgcCA9IGZsb29yKHgpO1xcblxcXHJcbiAgICB2ZWMyIGYgPSBmcmFjdCh4KTtcXG5cXFxyXG5cdFxcblxcXHJcblx0ZmxvYXQgayA9IDEuMCs2My4wKnBvdygxLjAtdiw0LjApO1xcblxcXHJcblx0XFxuXFxcclxuXHRmbG9hdCB2YSA9IDAuMDtcXG5cXFxyXG5cdGZsb2F0IHd0ID0gMC4wO1xcblxcXHJcbiAgICBmb3IoIGludCBqPS0yOyBqPD0yOyBqKysgKVxcblxcXHJcbiAgICBmb3IoIGludCBpPS0yOyBpPD0yOyBpKysgKVxcblxcXHJcbiAgICB7XFxuXFxcclxuICAgICAgICB2ZWMyIGcgPSB2ZWMyKCBmbG9hdChpKSxmbG9hdChqKSApO1xcblxcXHJcblx0XHR2ZWMzIG8gPSBoYXNoMyggcCArIGcgKSp2ZWMzKHUsdSwxLjApO1xcblxcXHJcblx0XHR2ZWMyIHIgPSBnIC0gZiArIG8ueHk7XFxuXFxcclxuXHRcdGZsb2F0IGQgPSBkb3QocixyKTtcXG5cXFxyXG5cdFx0ZmxvYXQgd3cgPSBwb3coIDEuMC1zbW9vdGhzdGVwKDAuMCwxLjQxNCxzcXJ0KGQpKSwgayApO1xcblxcXHJcblx0XHR2YSArPSBvLnoqd3c7XFxuXFxcclxuXHRcdHd0ICs9IHd3O1xcblxcXHJcbiAgICB9XFxuXFxcclxuXHRcXG5cXFxyXG4gICAgcmV0dXJuIHZhL3d0O1xcblxcXHJcbn1cXG5cXFxyXG5cIlxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhTaGFkZXJUaW1lKClcclxuXHR7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLFwiZmxvYXRcIik7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJUaW1lLnRpdGxlID0gXCJUaW1lXCI7XHJcblxyXG5cdExHcmFwaFNoYWRlclRpbWUucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKCBjb250ZXh0IClcclxuXHR7XHJcblx0XHRpZighdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gfHwgIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgb3V0bGluayA9IGdldE91dHB1dExpbmtJRCh0aGlzLDApO1xyXG5cclxuXHRcdGNvbnRleHQuYWRkVW5pZm9ybSggXCJ1X3RpbWVcIiArIHRoaXMuaWQsIFwiZmxvYXRcIiwgZnVuY3Rpb24oKXsgcmV0dXJuIGdldFRpbWUoKSAqIDAuMDAxOyB9KTtcclxuXHRcdGNvbnRleHQuYWRkQ29kZShcImNvZGVcIiwgXCJmbG9hdCBcIiArIG91dGxpbmsgKyBcIiA9IHVfdGltZVwiICsgdGhpcy5pZCArXCI7XCIsIHRoaXMuc2hhZGVyX2Rlc3RpbmF0aW9uICk7XHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoIDAsIFwiZmxvYXRcIiApO1xyXG5cdH1cclxuXHJcblx0cmVnaXN0ZXJTaGFkZXJOb2RlKCBcImlucHV0L3RpbWVcIiwgTEdyYXBoU2hhZGVyVGltZSApO1xyXG5cclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoU2hhZGVyRGl0aGVyKClcclxuXHR7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIixcIlRcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLFwiZmxvYXRcIik7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJEaXRoZXIudGl0bGUgPSBcIkRpdGhlclwiO1xyXG5cclxuXHRMR3JhcGhTaGFkZXJEaXRoZXIucHJvdG90eXBlLm9uR2V0Q29kZSA9IGZ1bmN0aW9uKCBjb250ZXh0IClcclxuXHR7XHJcblx0XHRpZighdGhpcy5zaGFkZXJfZGVzdGluYXRpb24gfHwgIXRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMCkpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgaW5saW5rID0gZ2V0SW5wdXRMaW5rSUQodGhpcywwKTtcclxuXHRcdHZhciByZXR1cm5fdHlwZSA9IFwiZmxvYXRcIjtcclxuXHRcdHZhciBvdXRsaW5rID0gZ2V0T3V0cHV0TGlua0lEKHRoaXMsMCk7XHJcblx0XHR2YXIgaW50eXBlID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRpbmxpbmsgPSB2YXJUb1R5cGVHTFNMKCBpbmxpbmssIGludHlwZSwgXCJmbG9hdFwiICk7XHJcblx0XHRjb250ZXh0LmFkZEZ1bmN0aW9uKFwiZGl0aGVyOHg4XCIsIExHcmFwaFNoYWRlckRpdGhlci5kaXRoZXJfZnVuYyk7XHJcblx0XHRjb250ZXh0LmFkZENvZGUoXCJjb2RlXCIsIHJldHVybl90eXBlICsgXCIgXCIgKyBvdXRsaW5rICsgXCIgPSBkaXRoZXI4eDgoXCIrIGlubGluayArXCIpO1wiLCB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiApO1xyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCByZXR1cm5fdHlwZSApO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoU2hhZGVyRGl0aGVyLmRpdGhlcl92YWx1ZXMgPSBbMC41MTU2MjUsMC4xNDA2MjUsMC42NDA2MjUsMC4wNDY4NzUsMC41NDY4NzUsMC4xNzE4NzUsMC42NzE4NzUsMC43NjU2MjUsMC4yNjU2MjUsMC44OTA2MjUsMC4zOTA2MjUsMC43OTY4NzUsMC4yOTY4NzUsMC45MjE4NzUsMC40MjE4NzUsMC4yMDMxMjUsMC43MDMxMjUsMC4wNzgxMjUsMC41NzgxMjUsMC4yMzQzNzUsMC43MzQzNzUsMC4xMDkzNzUsMC42MDkzNzUsMC45NTMxMjUsMC40NTMxMjUsMC44MjgxMjUsMC4zMjgxMjUsMC45ODQzNzUsMC40ODQzNzUsMC44NTkzNzUsMC4zNTkzNzUsMC4wNjI1LDAuNTYyNSwwLjE4NzUsMC42ODc1LDAuMDMxMjUsMC41MzEyNSwwLjE1NjI1LDAuNjU2MjUsMC44MTI1LDAuMzEyNSwwLjkzNzUsMC40Mzc1LDAuNzgxMjUsMC4yODEyNSwwLjkwNjI1LDAuNDA2MjUsMC4yNSwwLjc1LDAuMTI1LDAuNjI1LDAuMjE4NzUsMC43MTg3NSwwLjA5Mzc1LDAuNTkzNzUsMS4wMDAxLDAuNSwwLjg3NSwwLjM3NSwwLjk2ODc1LDAuNDY4NzUsMC44NDM3NSwwLjM0Mzc1XTtcclxuXHRcclxuXHRMR3JhcGhTaGFkZXJEaXRoZXIuZGl0aGVyX2Z1bmMgPSBcIlxcblxcXHJcblx0XHRmbG9hdCBkaXRoZXI4eDgoZmxvYXQgYnJpZ2h0bmVzcykge1xcblxcXHJcblx0XHQgIHZlYzIgcG9zaXRpb24gPSB2ZWMyKDAuMCk7XFxuXFxcclxuXHRcdCAgI2lmZGVmIEZSQUdNRU5UXFxuXFxcclxuXHRcdFx0cG9zaXRpb24gPSBnbF9GcmFnQ29vcmQueHk7XFxuXFxcclxuXHRcdCAgI2VuZGlmXFxuXFxcclxuXHRcdCAgaW50IHggPSBpbnQobW9kKHBvc2l0aW9uLngsIDguMCkpO1xcblxcXHJcblx0XHQgIGludCB5ID0gaW50KG1vZChwb3NpdGlvbi55LCA4LjApKTtcXG5cXFxyXG5cdFx0ICBpbnQgaW5kZXggPSB4ICsgeSAqIDg7XFxuXFxcclxuXHRcdCAgZmxvYXQgbGltaXQgPSAwLjA7XFxuXFxcclxuXHRcdCAgaWYgKHggPCA4KSB7XFxuXFxcclxuXHRcdFx0aWYoaW5kZXg9PTApIGxpbWl0ID0gMC4wMTU2MjU7XFxuXFxcclxuXHRcdFx0XCIrKExHcmFwaFNoYWRlckRpdGhlci5kaXRoZXJfdmFsdWVzLm1hcCggZnVuY3Rpb24odixpKXsgcmV0dXJuIFwiZWxzZSBpZihpbmRleD09IFwiKyhpKzEpK1wiKSBsaW1pdCA9IFwiICsgdiArIFwiO1wifSkuam9pbihcIlxcblwiKSkrXCJcXG5cXFxyXG5cdFx0ICB9XFxuXFxcclxuXHRcdCAgcmV0dXJuIGJyaWdodG5lc3MgPCBsaW1pdCA/IDAuMCA6IDEuMDtcXG5cXFxyXG5cdFx0fVxcblwiLFxyXG5cclxuXHRyZWdpc3RlclNoYWRlck5vZGUoIFwibWF0aC9kaXRoZXJcIiwgTEdyYXBoU2hhZGVyRGl0aGVyICk7XHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFNoYWRlclJlbWFwKClcclxuXHR7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiXCIsIExHU2hhZGVycy5BTExfVFlQRVMgKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwiXCIsXCJcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XHJcblx0XHRcdG1pbl92YWx1ZTogMCxcclxuXHRcdFx0bWF4X3ZhbHVlOiAxLFxyXG5cdFx0XHRtaW5fdmFsdWUyOiAwLFxyXG5cdFx0XHRtYXhfdmFsdWUyOiAxXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcIm1pblwiLDAseyBzdGVwOiAwLjEsIHByb3BlcnR5OiBcIm1pbl92YWx1ZVwiIH0pO1xyXG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcIm1heFwiLDEseyBzdGVwOiAwLjEsIHByb3BlcnR5OiBcIm1heF92YWx1ZVwiIH0pO1xyXG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJudW1iZXJcIixcIm1pbjJcIiwwLHsgc3RlcDogMC4xLCBwcm9wZXJ0eTogXCJtaW5fdmFsdWUyXCJ9KTtcclxuXHRcdHRoaXMuYWRkV2lkZ2V0KFwibnVtYmVyXCIsXCJtYXgyXCIsMSx7IHN0ZXA6IDAuMSwgcHJvcGVydHk6IFwibWF4X3ZhbHVlMlwifSk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJSZW1hcC50aXRsZSA9IFwiUmVtYXBcIjtcclxuXHJcblx0TEdyYXBoU2hhZGVyUmVtYXAucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdGlmKHRoaXMuZ3JhcGgpXHJcblx0XHRcdHRoaXMuZ3JhcGguX3ZlcnNpb24rKztcclxuXHR9XHJcblxyXG5cdExHcmFwaFNoYWRlclJlbWFwLnByb3RvdHlwZS5vbkNvbm5lY3Rpb25zQ2hhbmdlID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdHZhciByZXR1cm5fdHlwZSA9IHRoaXMuZ2V0SW5wdXREYXRhVHlwZSgwKTtcclxuXHRcdHRoaXMub3V0cHV0c1swXS50eXBlID0gcmV0dXJuX3R5cGUgfHwgXCJUXCI7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhTaGFkZXJSZW1hcC5wcm90b3R5cGUub25HZXRDb2RlID0gZnVuY3Rpb24oIGNvbnRleHQgKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiB8fCAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBpbmxpbmsgPSBnZXRJbnB1dExpbmtJRCh0aGlzLDApO1xyXG5cdFx0dmFyIG91dGxpbmsgPSBnZXRPdXRwdXRMaW5rSUQodGhpcywwKTtcclxuXHRcdGlmKCFpbmxpbmsgJiYgIW91dGxpbmspIC8vbm90IGNvbm5lY3RlZFxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIHJldHVybl90eXBlID0gdGhpcy5nZXRJbnB1dERhdGFUeXBlKDApO1xyXG5cdFx0dGhpcy5vdXRwdXRzWzBdLnR5cGUgPSByZXR1cm5fdHlwZTtcclxuXHRcdGlmKHJldHVybl90eXBlID09IFwiVFwiKVxyXG5cdFx0e1xyXG5cdFx0XHRjb25zb2xlLndhcm4oXCJub2RlIHR5cGUgaXMgVCBhbmQgY2Fubm90IGJlIHJlc29sdmVkXCIpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoIWlubGluaylcclxuXHRcdHtcclxuXHRcdFx0Y29udGV4dC5hZGRDb2RlKFwiY29kZVwiLFwiXHRcIiArIHJldHVybl90eXBlICsgXCIgXCIgKyBvdXRsaW5rICsgXCIgPSBcIiArIHJldHVybl90eXBlICsgXCIoMC4wKTtcXG5cIik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbWludiA9IHZhbHVlVG9HTFNMKCB0aGlzLnByb3BlcnRpZXMubWluX3ZhbHVlICk7XHJcblx0XHR2YXIgbWF4diA9IHZhbHVlVG9HTFNMKCB0aGlzLnByb3BlcnRpZXMubWF4X3ZhbHVlICk7XHJcblx0XHR2YXIgbWludjIgPSB2YWx1ZVRvR0xTTCggdGhpcy5wcm9wZXJ0aWVzLm1pbl92YWx1ZTIgKTtcclxuXHRcdHZhciBtYXh2MiA9IHZhbHVlVG9HTFNMKCB0aGlzLnByb3BlcnRpZXMubWF4X3ZhbHVlMiApO1xyXG5cclxuXHRcdGNvbnRleHQuYWRkQ29kZShcImNvZGVcIiwgcmV0dXJuX3R5cGUgKyBcIiBcIiArIG91dGxpbmsgKyBcIiA9ICggKFwiICsgaW5saW5rICsgXCIgLSBcIittaW52K1wiKSAvIChcIisgbWF4ditcIiAtIFwiK21pbnYrXCIpICkgKiAoXCIrIG1heHYyK1wiIC0gXCIrbWludjIrXCIpICsgXCIgKyBtaW52MiArIFwiO1wiLCB0aGlzLnNoYWRlcl9kZXN0aW5hdGlvbiApO1xyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCByZXR1cm5fdHlwZSApO1xyXG5cdH1cclxuXHJcblx0cmVnaXN0ZXJTaGFkZXJOb2RlKCBcIm1hdGgvcmVtYXBcIiwgTEdyYXBoU2hhZGVyUmVtYXAgKTtcclxuXHJcbn0pKHRoaXMpO1xyXG5cclxuXHJcblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xyXG4gICAgdmFyIExpdGVHcmFwaCA9IGdsb2JhbC5MaXRlR3JhcGg7XHJcblxyXG5cdHZhciB2aWV3X21hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cdHZhciBwcm9qZWN0aW9uX21hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cdHZhciB2aWV3cHJvamVjdGlvbl9tYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcclxuXHR2YXIgbW9kZWxfbWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblx0dmFyIGdsb2JhbF91bmlmb3JtcyA9IHtcclxuXHRcdHVfdmlldzogdmlld19tYXRyaXgsXHJcblx0XHR1X3Byb2plY3Rpb246IHByb2plY3Rpb25fbWF0cml4LFxyXG5cdFx0dV92aWV3cHJvamVjdGlvbjogdmlld3Byb2plY3Rpb25fbWF0cml4LFxyXG5cdFx0dV9tb2RlbDogbW9kZWxfbWF0cml4IFxyXG5cdH07XHJcblxyXG5cdExpdGVHcmFwaC5MR3JhcGhSZW5kZXIgPSB7XHJcblx0XHRvblJlcXVlc3RDYW1lcmFNYXRyaWNlczogbnVsbCAvL292ZXJ3cml0ZSB3aXRoIHlvdXIgM0QgZW5naW5lIHNwZWNpZmljcywgaXQgd2lsbCByZWNlaXZlICh2aWV3X21hdHJpeCwgcHJvamVjdGlvbl9tYXRyaXgsdmlld3Byb2plY3Rpb25fbWF0cml4KSBhbmQgbXVzdCBiZSBmaWxsZWRcclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBnZW5lcmF0ZUdlb21ldHJ5SWQoKSB7XHJcblx0XHRyZXR1cm4gKE1hdGgucmFuZG9tKCkgKiAxMDAwMDApfDA7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhQb2ludHMzRCgpIHtcclxuXHJcblx0XHR0aGlzLmFkZElucHV0KFwib2JqXCIsIFwiXCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInJhZGl1c1wiLCBcIm51bWJlclwiKTtcclxuXHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImdlb21ldHJ5XCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJwb2ludHNcIiwgXCJbdmVjM11cIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XHJcblx0XHRcdHJhZGl1czogMSxcclxuXHRcdFx0bnVtX3BvaW50czogNDA5NixcclxuXHRcdFx0Z2VuZXJhdGVfbm9ybWFsczogdHJ1ZSxcclxuXHRcdFx0cmVndWxhcjogZmFsc2UsXHJcblx0XHRcdG1vZGU6IExHcmFwaFBvaW50czNELlNQSEVSRSxcclxuXHRcdFx0Zm9yY2VfdXBkYXRlOiBmYWxzZVxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMucHJvcGVydGllcy5udW1fcG9pbnRzICogMyApO1xyXG5cdFx0dGhpcy5ub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5wcm9wZXJ0aWVzLm51bV9wb2ludHMgKiAzICk7XHJcblx0XHR0aGlzLm11c3RfdXBkYXRlID0gdHJ1ZTtcclxuXHRcdHRoaXMudmVyc2lvbiA9IDA7XHJcblxyXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cdFx0dGhpcy5hZGRXaWRnZXQoXCJidXR0b25cIixcInVwZGF0ZVwiLG51bGwsIGZ1bmN0aW9uKCl7IHRoYXQubXVzdF91cGRhdGUgPSB0cnVlOyB9KTtcclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5ID0ge1xyXG5cdFx0XHR2ZXJ0aWNlczogbnVsbCxcclxuXHRcdFx0X2lkOiBnZW5lcmF0ZUdlb21ldHJ5SWQoKVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX29sZF9vYmogPSBudWxsO1xyXG5cdFx0dGhpcy5fbGFzdF9yYWRpdXMgPSBudWxsO1xyXG5cdH1cclxuXHJcblx0Z2xvYmFsLkxHcmFwaFBvaW50czNEID0gTEdyYXBoUG9pbnRzM0Q7XHJcblxyXG5cdExHcmFwaFBvaW50czNELlJFQ1RBTkdMRSA9IDE7XHJcblx0TEdyYXBoUG9pbnRzM0QuQ0lSQ0xFID0gMjtcclxuXHJcblx0TEdyYXBoUG9pbnRzM0QuQ1VCRSA9IDEwO1xyXG5cdExHcmFwaFBvaW50czNELlNQSEVSRSA9IDExO1xyXG5cdExHcmFwaFBvaW50czNELkhFTUlTUEhFUkUgPSAxMjtcclxuXHRMR3JhcGhQb2ludHMzRC5JTlNJREVfU1BIRVJFID0gMTM7XHJcblxyXG5cdExHcmFwaFBvaW50czNELk9CSkVDVCA9IDIwO1xyXG5cdExHcmFwaFBvaW50czNELk9CSkVDVF9VTklGT1JNTFkgPSAyMTtcclxuXHRMR3JhcGhQb2ludHMzRC5PQkpFQ1RfSU5TSURFID0gMjI7XHJcblxyXG5cdExHcmFwaFBvaW50czNELk1PREVfVkFMVUVTID0geyBcInJlY3RhbmdsZVwiOkxHcmFwaFBvaW50czNELlJFQ1RBTkdMRSwgXCJjaXJjbGVcIjpMR3JhcGhQb2ludHMzRC5DSVJDTEUsIFwiY3ViZVwiOkxHcmFwaFBvaW50czNELkNVQkUsIFwic3BoZXJlXCI6TEdyYXBoUG9pbnRzM0QuU1BIRVJFLCBcImhlbWlzcGhlcmVcIjpMR3JhcGhQb2ludHMzRC5IRU1JU1BIRVJFLCBcImluc2lkZV9zcGhlcmVcIjpMR3JhcGhQb2ludHMzRC5JTlNJREVfU1BIRVJFLCBcIm9iamVjdFwiOkxHcmFwaFBvaW50czNELk9CSkVDVCwgXCJvYmplY3RfdW5pZm9ybWx5XCI6TEdyYXBoUG9pbnRzM0QuT0JKRUNUX1VOSUZPUk1MWSwgXCJvYmplY3RfaW5zaWRlXCI6TEdyYXBoUG9pbnRzM0QuT0JKRUNUX0lOU0lERSB9O1xyXG5cclxuXHRMR3JhcGhQb2ludHMzRC53aWRnZXRzX2luZm8gPSB7XHJcblx0XHRtb2RlOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFBvaW50czNELk1PREVfVkFMVUVTIH1cclxuXHR9O1xyXG5cclxuXHRMR3JhcGhQb2ludHMzRC50aXRsZSA9IFwibGlzdCBvZiBwb2ludHNcIjtcclxuXHRMR3JhcGhQb2ludHMzRC5kZXNjID0gXCJyZXR1cm5zIGFuIGFycmF5IG9mIHBvaW50c1wiO1xyXG5cclxuXHRMR3JhcGhQb2ludHMzRC5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLHZhbHVlKVxyXG5cdHtcclxuXHRcdHRoaXMubXVzdF91cGRhdGUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoUG9pbnRzM0QucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdGlmKCBvYmogIT0gdGhpcy5fb2xkX29iaiB8fCAob2JqICYmIG9iai5fdmVyc2lvbiAhPSB0aGlzLl9vbGRfb2JqX3ZlcnNpb24pIClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5fb2xkX29iaiA9IG9iajtcclxuXHRcdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHJhZGl1cyA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG5cdFx0aWYocmFkaXVzID09IG51bGwpXHJcblx0XHRcdHJhZGl1cyA9IHRoaXMucHJvcGVydGllcy5yYWRpdXM7XHJcblx0XHRpZiggdGhpcy5fbGFzdF9yYWRpdXMgIT0gcmFkaXVzIClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5fbGFzdF9yYWRpdXMgPSByYWRpdXM7XHJcblx0XHRcdHRoaXMubXVzdF91cGRhdGUgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHRoaXMubXVzdF91cGRhdGUgfHwgdGhpcy5wcm9wZXJ0aWVzLmZvcmNlX3VwZGF0ZSApXHJcblx0XHR7XHJcblx0XHRcdHRoaXMubXVzdF91cGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy51cGRhdGVQb2ludHMoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5LnZlcnRpY2VzID0gdGhpcy5wb2ludHM7XHJcblx0XHR0aGlzLmdlb21ldHJ5Lm5vcm1hbHMgPSB0aGlzLm5vcm1hbHM7XHJcblx0XHR0aGlzLmdlb21ldHJ5Ll92ZXJzaW9uID0gdGhpcy52ZXJzaW9uO1xyXG5cclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgdGhpcy5nZW9tZXRyeSApO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoUG9pbnRzM0QucHJvdG90eXBlLnVwZGF0ZVBvaW50cyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG51bV9wb2ludHMgPSB0aGlzLnByb3BlcnRpZXMubnVtX3BvaW50c3wwO1xyXG5cdFx0aWYobnVtX3BvaW50cyA8IDEpXHJcblx0XHRcdG51bV9wb2ludHMgPSAxO1xyXG5cclxuXHRcdGlmKCF0aGlzLnBvaW50cyB8fCB0aGlzLnBvaW50cy5sZW5ndGggIT0gbnVtX3BvaW50cyAqIDMpXHJcblx0XHRcdHRoaXMucG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtX3BvaW50cyAqIDMgKTtcclxuXHJcblx0XHRpZih0aGlzLnByb3BlcnRpZXMuZ2VuZXJhdGVfbm9ybWFscylcclxuXHRcdHtcclxuXHRcdFx0aWYgKCF0aGlzLm5vcm1hbHMgfHwgdGhpcy5ub3JtYWxzLmxlbmd0aCAhPSB0aGlzLnBvaW50cy5sZW5ndGgpXHJcblx0XHRcdFx0dGhpcy5ub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5wb2ludHMubGVuZ3RoICk7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHRcdHRoaXMubm9ybWFscyA9IG51bGw7XHJcblxyXG5cdFx0dmFyIHJhZGl1cyA9IHRoaXMuX2xhc3RfcmFkaXVzIHx8IHRoaXMucHJvcGVydGllcy5yYWRpdXM7XHJcblx0XHR2YXIgbW9kZSA9IHRoaXMucHJvcGVydGllcy5tb2RlO1xyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdHRoaXMuX29sZF9vYmpfdmVyc2lvbiA9IG9iaiA/IG9iai5fdmVyc2lvbiA6IG51bGw7XHJcblxyXG5cdFx0dGhpcy5wb2ludHMgPSBMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZVBvaW50cyggcmFkaXVzLCBudW1fcG9pbnRzLCBtb2RlLCB0aGlzLnBvaW50cywgdGhpcy5ub3JtYWxzLCB0aGlzLnByb3BlcnRpZXMucmVndWxhciwgb2JqICk7XHJcblxyXG5cdFx0dGhpcy52ZXJzaW9uKys7XHJcblx0fVxyXG5cclxuXHQvL2dsb2JhbFxyXG5cdExHcmFwaFBvaW50czNELmdlbmVyYXRlUG9pbnRzID0gZnVuY3Rpb24oIHJhZGl1cywgbnVtX3BvaW50cywgbW9kZSwgcG9pbnRzLCBub3JtYWxzLCByZWd1bGFyLCBvYmogKVxyXG5cdHtcclxuXHRcdHZhciBzaXplID0gbnVtX3BvaW50cyAqIDM7XHJcblx0XHRpZighcG9pbnRzIHx8IHBvaW50cy5sZW5ndGggIT0gc2l6ZSlcclxuXHRcdFx0cG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSggc2l6ZSApO1xyXG5cdFx0dmFyIHRlbXAgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xyXG5cdFx0dmFyIFVQID0gbmV3IEZsb2F0MzJBcnJheShbMCwxLDBdKTtcclxuXHJcblx0XHRpZihyZWd1bGFyKVxyXG5cdFx0e1xyXG5cdFx0XHRpZiggbW9kZSA9PSBMR3JhcGhQb2ludHMzRC5SRUNUQU5HTEUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR2YXIgc2lkZSA9IE1hdGguZmxvb3IoTWF0aC5zcXJ0KG51bV9wb2ludHMpKTtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2lkZTsgKytpKVxyXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBzaWRlOyArK2opXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0dmFyIHBvcyA9IGkqMyArIGoqMypzaWRlO1xyXG5cdFx0XHRcdFx0cG9pbnRzW3Bvc10gPSAoKGkvc2lkZSkgLSAwLjUpICogcmFkaXVzICogMjtcclxuXHRcdFx0XHRcdHBvaW50c1twb3MrMV0gPSAwO1xyXG5cdFx0XHRcdFx0cG9pbnRzW3BvcysyXSA9ICgoai9zaWRlKSAtIDAuNSkgKiByYWRpdXMgKiAyO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRwb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KCBwb2ludHMuc3ViYXJyYXkoMCxzaWRlKnNpZGUqMykgKTtcclxuXHRcdFx0XHRpZihub3JtYWxzKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBub3JtYWxzLmxlbmd0aDsgaSs9MylcclxuXHRcdFx0XHRcdFx0bm9ybWFscy5zZXQoVVAsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmKCBtb2RlID09IExHcmFwaFBvaW50czNELlNQSEVSRSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHZhciBzaWRlID0gTWF0aC5mbG9vcihNYXRoLnNxcnQobnVtX3BvaW50cykpO1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzaWRlOyArK2kpXHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IHNpZGU7ICsrailcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHR2YXIgcG9zID0gaSozICsgaiozKnNpZGU7XHJcblx0XHRcdFx0XHRwb2xhclRvQ2FydGVzaWFuKCB0ZW1wLCAoaS9zaWRlKSAqIDIgKiBNYXRoLlBJLCAoKGovc2lkZSkgLSAwLjUpICogMiAqIE1hdGguUEksIHJhZGl1cyApO1xyXG5cdFx0XHRcdFx0cG9pbnRzW3Bvc10gPSB0ZW1wWzBdO1xyXG5cdFx0XHRcdFx0cG9pbnRzW3BvcysxXSA9IHRlbXBbMV07XHJcblx0XHRcdFx0XHRwb2ludHNbcG9zKzJdID0gdGVtcFsyXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSggcG9pbnRzLnN1YmFycmF5KDAsc2lkZSpzaWRlKjMpICk7XHJcblx0XHRcdFx0aWYobm9ybWFscylcclxuXHRcdFx0XHRcdExHcmFwaFBvaW50czNELmdlbmVyYXRlU3BoZXJpY2FsTm9ybWFscyggcG9pbnRzLCBub3JtYWxzICk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiggbW9kZSA9PSBMR3JhcGhQb2ludHMzRC5DSVJDTEUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSs9MylcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHR2YXIgYW5nbGUgPSAyICogTWF0aC5QSSAqIChpL3NpemUpO1xyXG5cdFx0XHRcdFx0cG9pbnRzW2ldID0gTWF0aC5jb3MoIGFuZ2xlICkgKiByYWRpdXM7XHJcblx0XHRcdFx0XHRwb2ludHNbaSsxXSA9IDA7XHJcblx0XHRcdFx0XHRwb2ludHNbaSsyXSA9IE1hdGguc2luKCBhbmdsZSApICogcmFkaXVzO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihub3JtYWxzKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBub3JtYWxzLmxlbmd0aDsgaSs9MylcclxuXHRcdFx0XHRcdFx0bm9ybWFscy5zZXQoVVAsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSAvL25vbiByZWd1bGFyXHJcblx0XHR7XHJcblx0XHRcdGlmKCBtb2RlID09IExHcmFwaFBvaW50czNELlJFQ1RBTkdMRSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKz0zKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHBvaW50c1tpXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHJhZGl1cyAqIDI7XHJcblx0XHRcdFx0XHRwb2ludHNbaSsxXSA9IDA7XHJcblx0XHRcdFx0XHRwb2ludHNbaSsyXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHJhZGl1cyAqIDI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKG5vcm1hbHMpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG5vcm1hbHMubGVuZ3RoOyBpKz0zKVxyXG5cdFx0XHRcdFx0XHRub3JtYWxzLnNldChVUCwgaSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYoIG1vZGUgPT0gTEdyYXBoUG9pbnRzM0QuQ1VCRSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKz0zKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHBvaW50c1tpXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHJhZGl1cyAqIDI7XHJcblx0XHRcdFx0XHRwb2ludHNbaSsxXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHJhZGl1cyAqIDI7XHJcblx0XHRcdFx0XHRwb2ludHNbaSsyXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHJhZGl1cyAqIDI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKG5vcm1hbHMpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG5vcm1hbHMubGVuZ3RoOyBpKz0zKVxyXG5cdFx0XHRcdFx0XHRub3JtYWxzLnNldChVUCwgaSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYoIG1vZGUgPT0gTEdyYXBoUG9pbnRzM0QuU1BIRVJFKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVTcGhlcmUoIHBvaW50cywgc2l6ZSwgcmFkaXVzICk7XHJcblx0XHRcdFx0aWYobm9ybWFscylcclxuXHRcdFx0XHRcdExHcmFwaFBvaW50czNELmdlbmVyYXRlU3BoZXJpY2FsTm9ybWFscyggcG9pbnRzLCBub3JtYWxzICk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiggbW9kZSA9PSBMR3JhcGhQb2ludHMzRC5IRU1JU1BIRVJFKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVIZW1pc3BoZXJlKCBwb2ludHMsIHNpemUsIHJhZGl1cyApO1xyXG5cdFx0XHRcdGlmKG5vcm1hbHMpXHJcblx0XHRcdFx0XHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZVNwaGVyaWNhbE5vcm1hbHMoIHBvaW50cywgbm9ybWFscyApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYoIG1vZGUgPT0gTEdyYXBoUG9pbnRzM0QuQ0lSQ0xFKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVJbnNpZGVDaXJjbGUoIHBvaW50cywgc2l6ZSwgcmFkaXVzICk7XHJcblx0XHRcdFx0aWYobm9ybWFscylcclxuXHRcdFx0XHRcdExHcmFwaFBvaW50czNELmdlbmVyYXRlU3BoZXJpY2FsTm9ybWFscyggcG9pbnRzLCBub3JtYWxzICk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiggbW9kZSA9PSBMR3JhcGhQb2ludHMzRC5JTlNJREVfU1BIRVJFKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVJbnNpZGVTcGhlcmUoIHBvaW50cywgc2l6ZSwgcmFkaXVzICk7XHJcblx0XHRcdFx0aWYobm9ybWFscylcclxuXHRcdFx0XHRcdExHcmFwaFBvaW50czNELmdlbmVyYXRlU3BoZXJpY2FsTm9ybWFscyggcG9pbnRzLCBub3JtYWxzICk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiggbW9kZSA9PSBMR3JhcGhQb2ludHMzRC5PQkpFQ1QpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZUZyb21PYmplY3QoIHBvaW50cywgbm9ybWFscywgc2l6ZSwgb2JqLCBmYWxzZSApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYoIG1vZGUgPT0gTEdyYXBoUG9pbnRzM0QuT0JKRUNUX1VOSUZPUk1MWSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdExHcmFwaFBvaW50czNELmdlbmVyYXRlRnJvbU9iamVjdCggcG9pbnRzLCBub3JtYWxzLCBzaXplLCBvYmosIHRydWUgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmKCBtb2RlID09IExHcmFwaFBvaW50czNELk9CSkVDVF9JTlNJREUpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZUZyb21JbnNpZGVPYmplY3QoIHBvaW50cywgc2l6ZSwgb2JqICk7XHJcblx0XHRcdFx0Ly9pZihub3JtYWxzKVxyXG5cdFx0XHRcdC8vXHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZVNwaGVyaWNhbE5vcm1hbHMoIHBvaW50cywgbm9ybWFscyApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oXCJ3cm9uZyBtb2RlIGluIExHcmFwaFBvaW50czNEXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwb2ludHM7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZVNwaGVyaWNhbE5vcm1hbHMgPSBmdW5jdGlvbihwb2ludHMsIG5vcm1hbHMpXHJcblx0e1xyXG5cdFx0dmFyIHRlbXAgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG5vcm1hbHMubGVuZ3RoOyBpKz0zKVxyXG5cdFx0e1xyXG5cdFx0XHR0ZW1wWzBdID0gcG9pbnRzW2ldO1xyXG5cdFx0XHR0ZW1wWzFdID0gcG9pbnRzW2krMV07XHJcblx0XHRcdHRlbXBbMl0gPSBwb2ludHNbaSsyXTtcclxuXHRcdFx0dmVjMy5ub3JtYWxpemUodGVtcCx0ZW1wKTtcclxuXHRcdFx0bm9ybWFscy5zZXQodGVtcCxpKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdExHcmFwaFBvaW50czNELmdlbmVyYXRlU3BoZXJlID0gZnVuY3Rpb24gKHBvaW50cywgc2l6ZSwgcmFkaXVzKVxyXG5cdHtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKz0zKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgcjEgPSBNYXRoLnJhbmRvbSgpO1xyXG5cdFx0XHR2YXIgcjIgPSBNYXRoLnJhbmRvbSgpO1xyXG5cdFx0XHR2YXIgeCA9IDIgKiBNYXRoLmNvcyggMiAqIE1hdGguUEkgKiByMSApICogTWF0aC5zcXJ0KCByMiAqICgxLXIyKSApO1xyXG5cdFx0XHR2YXIgeSA9IDEgLSAyICogcjI7XHJcblx0XHRcdHZhciB6ID0gMiAqIE1hdGguc2luKCAyICogTWF0aC5QSSAqIHIxICkgKiBNYXRoLnNxcnQoIHIyICogKDEtcjIpICk7XHJcblx0XHRcdHBvaW50c1tpXSA9IHggKiByYWRpdXM7XHJcblx0XHRcdHBvaW50c1tpKzFdID0geSAqIHJhZGl1cztcclxuXHRcdFx0cG9pbnRzW2krMl0gPSB6ICogcmFkaXVzO1xyXG5cdFx0fVx0XHRcdFxyXG5cdH1cclxuXHJcblx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVIZW1pc3BoZXJlID0gZnVuY3Rpb24gKHBvaW50cywgc2l6ZSwgcmFkaXVzKVxyXG5cdHtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKz0zKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgcjEgPSBNYXRoLnJhbmRvbSgpO1xyXG5cdFx0XHR2YXIgcjIgPSBNYXRoLnJhbmRvbSgpO1xyXG5cdFx0XHR2YXIgeCA9IE1hdGguY29zKCAyICogTWF0aC5QSSAqIHIxICkgKiBNYXRoLnNxcnQoMSAtIHIyKnIyICk7XHJcblx0XHRcdHZhciB5ID0gcjI7XHJcblx0XHRcdHZhciB6ID0gTWF0aC5zaW4oIDIgKiBNYXRoLlBJICogcjEgKSAqIE1hdGguc3FydCgxIC0gcjIqcjIgKTtcclxuXHRcdFx0cG9pbnRzW2ldID0geCAqIHJhZGl1cztcclxuXHRcdFx0cG9pbnRzW2krMV0gPSB5ICogcmFkaXVzO1xyXG5cdFx0XHRwb2ludHNbaSsyXSA9IHogKiByYWRpdXM7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZUluc2lkZUNpcmNsZSA9IGZ1bmN0aW9uIChwb2ludHMsIHNpemUsIHJhZGl1cylcclxuXHR7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSs9MylcclxuXHRcdHtcclxuXHRcdFx0dmFyIHIxID0gTWF0aC5yYW5kb20oKTtcclxuXHRcdFx0dmFyIHIyID0gTWF0aC5yYW5kb20oKTtcclxuXHRcdFx0dmFyIHggPSBNYXRoLmNvcyggMiAqIE1hdGguUEkgKiByMSApICogTWF0aC5zcXJ0KDEgLSByMipyMiApO1xyXG5cdFx0XHR2YXIgeSA9IHIyO1xyXG5cdFx0XHR2YXIgeiA9IE1hdGguc2luKCAyICogTWF0aC5QSSAqIHIxICkgKiBNYXRoLnNxcnQoMSAtIHIyKnIyICk7XHJcblx0XHRcdHBvaW50c1tpXSA9IHggKiByYWRpdXM7XHJcblx0XHRcdHBvaW50c1tpKzFdID0gMDtcclxuXHRcdFx0cG9pbnRzW2krMl0gPSB6ICogcmFkaXVzO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0TEdyYXBoUG9pbnRzM0QuZ2VuZXJhdGVJbnNpZGVTcGhlcmUgPSBmdW5jdGlvbiAocG9pbnRzLCBzaXplLCByYWRpdXMpXHJcblx0e1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrPTMpXHJcblx0XHR7XHJcblx0XHRcdHZhciB1ID0gTWF0aC5yYW5kb20oKTtcclxuXHRcdFx0dmFyIHYgPSBNYXRoLnJhbmRvbSgpO1xyXG5cdFx0XHR2YXIgdGhldGEgPSB1ICogMi4wICogTWF0aC5QSTtcclxuXHRcdFx0dmFyIHBoaSA9IE1hdGguYWNvcygyLjAgKiB2IC0gMS4wKTtcclxuXHRcdFx0dmFyIHIgPSBNYXRoLmNicnQoTWF0aC5yYW5kb20oKSkgKiByYWRpdXM7XHJcblx0XHRcdHZhciBzaW5UaGV0YSA9IE1hdGguc2luKHRoZXRhKTtcclxuXHRcdFx0dmFyIGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xyXG5cdFx0XHR2YXIgc2luUGhpID0gTWF0aC5zaW4ocGhpKTtcclxuXHRcdFx0dmFyIGNvc1BoaSA9IE1hdGguY29zKHBoaSk7XHJcblx0XHRcdHBvaW50c1tpXSA9IHIgKiBzaW5QaGkgKiBjb3NUaGV0YTtcclxuXHRcdFx0cG9pbnRzW2krMV0gPSByICogc2luUGhpICogc2luVGhldGE7XHJcblx0XHRcdHBvaW50c1tpKzJdID0gciAqIGNvc1BoaTtcclxuXHRcdH1cdFxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZmluZFJhbmRvbVRyaWFuZ2xlKCBhcmVhcywgZiApXHJcblx0e1xyXG5cdFx0dmFyIGwgPSBhcmVhcy5sZW5ndGg7XHJcblx0XHR2YXIgaW1pbiA9IDA7XHJcblx0XHR2YXIgaW1pZCA9IDA7XHJcblx0XHR2YXIgaW1heCA9IGw7XHJcblxyXG5cdFx0aWYobCA9PSAwKVxyXG5cdFx0XHRyZXR1cm4gLTE7XHJcblx0XHRpZihsID09IDEpXHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0Ly9kaWNob3RvbWljIHNlYXJjaFxyXG5cdFx0d2hpbGUgKGltYXggPj0gaW1pbilcclxuXHRcdHtcclxuXHRcdFx0aW1pZCA9ICgoaW1heCArIGltaW4pKjAuNSl8MDtcclxuXHRcdFx0dmFyIHQgPSBhcmVhc1sgaW1pZCBdO1xyXG5cdFx0XHRpZiggdCA9PSBmIClcclxuXHRcdFx0XHRyZXR1cm4gaW1pZDsgXHJcblx0XHRcdGlmKCBpbWluID09IChpbWF4IC0gMSkgKVxyXG5cdFx0XHRcdHJldHVybiBpbWluO1xyXG5cdFx0XHRpZiAodCA8IGYpXHJcblx0XHRcdFx0aW1pbiA9IGltaWQ7XHJcblx0XHRcdGVsc2UgICAgICAgICBcclxuXHRcdFx0XHRpbWF4ID0gaW1pZDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBpbWlkO1x0XHRcclxuXHR9XHJcblxyXG5cdExHcmFwaFBvaW50czNELmdlbmVyYXRlRnJvbU9iamVjdCA9IGZ1bmN0aW9uKCBwb2ludHMsIG5vcm1hbHMsIHNpemUsIG9iaiwgZXZlbmx5IClcclxuXHR7XHJcblx0XHRpZighb2JqKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gbnVsbDtcclxuXHRcdHZhciBtZXNoX25vcm1hbHMgPSBudWxsO1xyXG5cdFx0dmFyIGluZGljZXMgPSBudWxsO1xyXG5cdFx0dmFyIGFyZWFzID0gbnVsbDtcclxuXHRcdGlmKCBvYmouY29uc3RydWN0b3IgPT09IEdMLk1lc2ggKVxyXG5cdFx0e1xyXG5cdFx0XHR2ZXJ0aWNlcyA9IG9iai52ZXJ0ZXhCdWZmZXJzLnZlcnRpY2VzLmRhdGE7XHJcblx0XHRcdG1lc2hfbm9ybWFscyA9IG9iai52ZXJ0ZXhCdWZmZXJzLm5vcm1hbHMgPyBvYmoudmVydGV4QnVmZmVycy5ub3JtYWxzLmRhdGEgOiBudWxsO1xyXG5cdFx0XHRpbmRpY2VzID0gb2JqLmluZGV4QnVmZmVycy5pbmRpY2VzID8gb2JqLmluZGV4QnVmZmVycy5pbmRpY2VzLmRhdGEgOiBudWxsO1xyXG5cdFx0XHRpZighaW5kaWNlcylcclxuXHRcdFx0XHRpbmRpY2VzID0gb2JqLmluZGV4QnVmZmVycy50cmlhbmdsZXMgPyBvYmouaW5kZXhCdWZmZXJzLnRyaWFuZ2xlcy5kYXRhIDogbnVsbDtcclxuXHRcdH1cclxuXHRcdGlmKCF2ZXJ0aWNlcylcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR2YXIgbnVtX3RyaWFuZ2xlcyA9IGluZGljZXMgPyBpbmRpY2VzLmxlbmd0aCAvIDMgOiB2ZXJ0aWNlcy5sZW5ndGggLyAoMyozKTtcclxuXHRcdHZhciB0b3RhbF9hcmVhID0gMDsgLy9zdW0gb2YgYXJlYXMgb2YgYWxsIHRyaWFuZ2xlc1xyXG5cclxuXHRcdGlmKGV2ZW5seSlcclxuXHRcdHtcclxuXHRcdFx0YXJlYXMgPSBuZXcgRmxvYXQzMkFycmF5KG51bV90cmlhbmdsZXMpOyAvL2FjY3VtXHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBudW1fdHJpYW5nbGVzOyArK2kpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRpZihpbmRpY2VzKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGEgPSBpbmRpY2VzW2kqM10qMztcclxuXHRcdFx0XHRcdGIgPSBpbmRpY2VzW2kqMysxXSozO1xyXG5cdFx0XHRcdFx0YyA9IGluZGljZXNbaSozKzJdKjM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRhID0gaSo5O1xyXG5cdFx0XHRcdFx0YiA9IGkqOSszO1xyXG5cdFx0XHRcdFx0YyA9IGkqOSs2O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgUDEgPSB2ZXJ0aWNlcy5zdWJhcnJheShhLGErMyk7XHJcblx0XHRcdFx0dmFyIFAyID0gdmVydGljZXMuc3ViYXJyYXkoYixiKzMpO1xyXG5cdFx0XHRcdHZhciBQMyA9IHZlcnRpY2VzLnN1YmFycmF5KGMsYyszKTtcclxuXHRcdFx0XHR2YXIgYUwgPSB2ZWMzLmRpc3RhbmNlKCBQMSwgUDIgKTtcclxuXHRcdFx0XHR2YXIgYkwgPSB2ZWMzLmRpc3RhbmNlKCBQMiwgUDMgKTtcclxuXHRcdFx0XHR2YXIgY0wgPSB2ZWMzLmRpc3RhbmNlKCBQMywgUDEgKTtcclxuXHRcdFx0XHR2YXIgcyA9IChhTCArIGJMKyBjTCkgLyAyO1xyXG5cdFx0XHRcdHRvdGFsX2FyZWEgKz0gTWF0aC5zcXJ0KHMgKiAocyAtIGFMKSAqIChzIC0gYkwpICogKHMgLSBjTCkpO1xyXG5cdFx0XHRcdGFyZWFzW2ldID0gdG90YWxfYXJlYTtcclxuXHRcdFx0fVx0XHRcdFxyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbnVtX3RyaWFuZ2xlczsgKytpKSAvL25vcm1hbGl6ZVxyXG5cdFx0XHRcdGFyZWFzW2ldIC89IHRvdGFsX2FyZWE7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrPTMpXHJcblx0XHR7XHJcblx0XHRcdHZhciByID0gTWF0aC5yYW5kb20oKTtcclxuXHRcdFx0dmFyIGluZGV4ID0gZXZlbmx5ID8gZmluZFJhbmRvbVRyaWFuZ2xlKCBhcmVhcywgciApIDogTWF0aC5mbG9vcihyICogbnVtX3RyaWFuZ2xlcyApO1xyXG5cdFx0XHQvL2dldCByYW5kb20gdHJpYW5nbGVcclxuXHRcdFx0dmFyIGEgPSAwO1xyXG5cdFx0XHR2YXIgYiA9IDA7XHJcblx0XHRcdHZhciBjID0gMDtcclxuXHRcdFx0aWYoaW5kaWNlcylcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGEgPSBpbmRpY2VzW2luZGV4KjNdKjM7XHJcblx0XHRcdFx0YiA9IGluZGljZXNbaW5kZXgqMysxXSozO1xyXG5cdFx0XHRcdGMgPSBpbmRpY2VzW2luZGV4KjMrMl0qMztcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdHtcclxuXHRcdFx0XHRhID0gaW5kZXgqOTtcclxuXHRcdFx0XHRiID0gaW5kZXgqOSszO1xyXG5cdFx0XHRcdGMgPSBpbmRleCo5KzY7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIHMgPSBNYXRoLnJhbmRvbSgpO1xyXG5cdFx0XHR2YXIgdCA9IE1hdGgucmFuZG9tKCk7XHJcblx0XHRcdHZhciBzcXJ0X3MgPSBNYXRoLnNxcnQocyk7XHJcblx0XHRcdHZhciBhZiA9IDEgLSBzcXJ0X3M7XHJcblx0XHRcdHZhciBiZiA9IHNxcnRfcyAqICggMSAtIHQpO1xyXG5cdFx0XHR2YXIgY2YgPSB0ICogc3FydF9zO1xyXG5cdFx0XHRwb2ludHNbaV0gPSBhZiAqIHZlcnRpY2VzW2FdICsgYmYqdmVydGljZXNbYl0gKyBjZip2ZXJ0aWNlc1tjXTtcclxuXHRcdFx0cG9pbnRzW2krMV0gPSBhZiAqIHZlcnRpY2VzW2ErMV0gKyBiZip2ZXJ0aWNlc1tiKzFdICsgY2YqdmVydGljZXNbYysxXTtcclxuXHRcdFx0cG9pbnRzW2krMl0gPSBhZiAqIHZlcnRpY2VzW2ErMl0gKyBiZip2ZXJ0aWNlc1tiKzJdICsgY2YqdmVydGljZXNbYysyXTtcclxuXHRcdFx0aWYobm9ybWFscyAmJiBtZXNoX25vcm1hbHMpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRub3JtYWxzW2ldID0gYWYgKiBtZXNoX25vcm1hbHNbYV0gKyBiZiptZXNoX25vcm1hbHNbYl0gKyBjZiptZXNoX25vcm1hbHNbY107XHJcblx0XHRcdFx0bm9ybWFsc1tpKzFdID0gYWYgKiBtZXNoX25vcm1hbHNbYSsxXSArIGJmKm1lc2hfbm9ybWFsc1tiKzFdICsgY2YqbWVzaF9ub3JtYWxzW2MrMV07XHJcblx0XHRcdFx0bm9ybWFsc1tpKzJdID0gYWYgKiBtZXNoX25vcm1hbHNbYSsyXSArIGJmKm1lc2hfbm9ybWFsc1tiKzJdICsgY2YqbWVzaF9ub3JtYWxzW2MrMl07XHJcblx0XHRcdFx0dmFyIE4gPSBub3JtYWxzLnN1YmFycmF5KGksaSszKTtcclxuXHRcdFx0XHR2ZWMzLm5vcm1hbGl6ZShOLE4pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRMR3JhcGhQb2ludHMzRC5nZW5lcmF0ZUZyb21JbnNpZGVPYmplY3QgPSBmdW5jdGlvbiggcG9pbnRzLCBzaXplLCBtZXNoIClcclxuXHR7XHJcblx0XHRpZighbWVzaCB8fCBtZXNoLmNvbnN0cnVjdG9yICE9PSBHTC5NZXNoKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIGFhYmIgPSBtZXNoLmdldEJvdW5kaW5nQm94KCk7XHJcblx0XHRpZighbWVzaC5vY3RyZWUpXHJcblx0XHRcdG1lc2gub2N0cmVlID0gbmV3IEdMLk9jdHJlZSggbWVzaCApO1xyXG5cdFx0dmFyIG9jdHJlZSA9IG1lc2gub2N0cmVlO1xyXG5cdFx0dmFyIG9yaWdpbiA9IHZlYzMuY3JlYXRlKCk7XHJcblx0XHR2YXIgZGlyZWN0aW9uID0gdmVjMy5mcm9tVmFsdWVzKDEsMCwwKTtcclxuXHRcdHZhciB0ZW1wID0gdmVjMy5jcmVhdGUoKTtcclxuXHRcdHZhciBpID0gMDtcclxuXHRcdHZhciB0cmllcyA9IDA7XHJcblx0XHR3aGlsZShpIDwgc2l6ZSAmJiB0cmllcyA8IHBvaW50cy5sZW5ndGggKiAxMCkgLy9saW1pdCB0byBhdm9pZCBwcm9ibGVtc1xyXG5cdFx0e1xyXG5cdFx0XHR0cmllcyArPSAxXHJcblx0XHRcdHZhciByID0gdmVjMy5yYW5kb20odGVtcCk7IC8vcmFuZG9tIHBvaW50IGluc2lkZSB0aGUgYWFiYlxyXG5cdFx0XHRyWzBdID0gKHJbMF0gKiAyIC0gMSkgKiBhYWJiWzNdICsgYWFiYlswXTtcclxuXHRcdFx0clsxXSA9IChyWzFdICogMiAtIDEpICogYWFiYls0XSArIGFhYmJbMV07XHJcblx0XHRcdHJbMl0gPSAoclsyXSAqIDIgLSAxKSAqIGFhYmJbNV0gKyBhYWJiWzJdO1xyXG5cdFx0XHRvcmlnaW4uc2V0KHIpO1xyXG5cdFx0XHR2YXIgaGl0ID0gb2N0cmVlLnRlc3RSYXkoIG9yaWdpbiwgZGlyZWN0aW9uLCAwLCAxMDAwMCwgdHJ1ZSwgR0wuT2N0cmVlLkFMTCApO1xyXG5cdFx0XHRpZighaGl0IHx8IGhpdC5sZW5ndGggJSAyID09IDApIC8vbm90IGluc2lkZVxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRwb2ludHMuc2V0KCByLCBpICk7XHJcblx0XHRcdGkrPTM7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJnZW9tZXRyeS9wb2ludHMzRFwiLCBMR3JhcGhQb2ludHMzRCApO1xyXG5cclxuXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFBvaW50c1RvSW5zdGFuY2VzKCkge1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInBvaW50c1wiLCBcImdlb21ldHJ5XCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJpbnN0YW5jZXNcIiwgXCJbbWF0NF1cIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XHJcblx0XHRcdG1vZGU6IDEsXHJcblx0XHRcdGF1dG91cGRhdGU6IHRydWVcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IHRydWU7XHJcblx0XHR0aGlzLm1hdHJpY2VzID0gW107XHJcblx0XHR0aGlzLmZpcnN0X3RpbWUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMuTk9STUFMID0gMDtcclxuXHRMR3JhcGhQb2ludHNUb0luc3RhbmNlcy5WRVJUSUNBTCA9IDE7XHJcblx0TEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMuU1BIRVJJQ0FMID0gMjtcclxuXHRMR3JhcGhQb2ludHNUb0luc3RhbmNlcy5SQU5ET00gPSAzO1xyXG5cdExHcmFwaFBvaW50c1RvSW5zdGFuY2VzLlJBTkRPTV9WRVJUSUNBTCA9IDQ7XHJcblxyXG5cdExHcmFwaFBvaW50c1RvSW5zdGFuY2VzLm1vZGVzID0ge1wibm9ybWFsXCI6MCxcInZlcnRpY2FsXCI6MSxcInNwaGVyaWNhbFwiOjIsXCJyYW5kb21cIjozLFwicmFuZG9tX3ZlcnRpY2FsXCI6NH07XHJcblx0TEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMud2lkZ2V0c19pbmZvID0ge1xyXG5cdFx0bW9kZTogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhQb2ludHNUb0luc3RhbmNlcy5tb2RlcyB9XHJcblx0fTtcclxuXHJcblx0TEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMudGl0bGUgPSBcInBvaW50cyB0byBpbnN0XCI7XHJcblxyXG5cdExHcmFwaFBvaW50c1RvSW5zdGFuY2VzLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0dmFyIGdlbyA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0aWYoICFnZW8gKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCxudWxsKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKCAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSApXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgaGFzX2NoYW5nZWQgPSAoZ2VvLl92ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24gfHwgZ2VvLl9pZCAhPSB0aGlzLl9nZW9tZXRyeV9pZCk7XHJcblxyXG5cdFx0aWYoIGhhc19jaGFuZ2VkICYmIHRoaXMucHJvcGVydGllcy5hdXRvdXBkYXRlIHx8IHRoaXMuZmlyc3RfdGltZSApXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuZmlyc3RfdGltZSA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZUluc3RhbmNlcyggZ2VvICk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCB0aGlzLm1hdHJpY2VzICk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhQb2ludHNUb0luc3RhbmNlcy5wcm90b3R5cGUudXBkYXRlSW5zdGFuY2VzID0gZnVuY3Rpb24oIGdlb21ldHJ5IClcclxuXHR7XHJcblx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuXHRcdGlmKCF2ZXJ0aWNlcylcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR2YXIgbm9ybWFscyA9IGdlb21ldHJ5Lm5vcm1hbHM7XHJcblxyXG5cdFx0dmFyIG1hdHJpY2VzID0gdGhpcy5tYXRyaWNlcztcclxuXHRcdHZhciBudW1fcG9pbnRzID0gdmVydGljZXMubGVuZ3RoIC8gMztcclxuXHRcdGlmKCBtYXRyaWNlcy5sZW5ndGggIT0gbnVtX3BvaW50cylcclxuXHRcdFx0bWF0cmljZXMubGVuZ3RoID0gbnVtX3BvaW50cztcclxuXHRcdHZhciBpZGVudGl0eSA9IG1hdDQuY3JlYXRlKCk7XHJcblx0XHR2YXIgdGVtcCA9IHZlYzMuY3JlYXRlKCk7XHJcblx0XHR2YXIgemVybyA9IHZlYzMuY3JlYXRlKCk7XHJcblx0XHR2YXIgVVAgPSB2ZWMzLmZyb21WYWx1ZXMoMCwxLDApO1xyXG5cdFx0dmFyIEZST05UID0gdmVjMy5mcm9tVmFsdWVzKDAsMCwtMSk7XHJcblx0XHR2YXIgUklHSFQgPSB2ZWMzLmZyb21WYWx1ZXMoMSwwLDApO1xyXG5cdFx0dmFyIFIgPSBxdWF0LmNyZWF0ZSgpO1xyXG5cclxuXHRcdHZhciBmcm9udCA9IHZlYzMuY3JlYXRlKCk7XHJcblx0XHR2YXIgcmlnaHQgPSB2ZWMzLmNyZWF0ZSgpO1xyXG5cdFx0dmFyIHRvcCA9IHZlYzMuY3JlYXRlKCk7XHJcblxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSArPSAzKVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgaW5kZXggPSBpLzM7XHJcblx0XHRcdHZhciBtID0gbWF0cmljZXNbaW5kZXhdO1xyXG5cdFx0XHRpZighbSlcclxuXHRcdFx0XHRtID0gbWF0cmljZXNbaW5kZXhdID0gbWF0NC5jcmVhdGUoKTtcclxuXHRcdFx0bS5zZXQoIGlkZW50aXR5ICk7XHJcblx0XHRcdHZhciBwb2ludCA9IHZlcnRpY2VzLnN1YmFycmF5KGksaSszKTtcclxuXHJcblx0XHRcdHN3aXRjaCh0aGlzLnByb3BlcnRpZXMubW9kZSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGNhc2UgTEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMuTk9STUFMOiBcclxuXHRcdFx0XHRcdG1hdDQuc2V0VHJhbnNsYXRpb24oIG0sIHBvaW50ICk7XHJcblx0XHRcdFx0XHRpZihub3JtYWxzKVxyXG5cdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHR2YXIgbm9ybWFsID0gbm9ybWFscy5zdWJhcnJheShpLGkrMyk7XHJcblx0XHRcdFx0XHRcdHRvcC5zZXQoIG5vcm1hbCApO1xyXG5cdFx0XHRcdFx0XHR2ZWMzLm5vcm1hbGl6ZSggdG9wLCB0b3AgKTtcclxuXHRcdFx0XHRcdFx0dmVjMy5jcm9zcyggcmlnaHQsIEZST05ULCB0b3AgKTtcclxuXHRcdFx0XHRcdFx0dmVjMy5ub3JtYWxpemUoIHJpZ2h0LCByaWdodCApO1xyXG5cdFx0XHRcdFx0XHR2ZWMzLmNyb3NzKCBmcm9udCwgcmlnaHQsIHRvcCApO1xyXG5cdFx0XHRcdFx0XHR2ZWMzLm5vcm1hbGl6ZSggZnJvbnQsIGZyb250ICk7XHJcblx0XHRcdFx0XHRcdG0uc2V0KHJpZ2h0LDApO1xyXG5cdFx0XHRcdFx0XHRtLnNldCh0b3AsNCk7XHJcblx0XHRcdFx0XHRcdG0uc2V0KGZyb250LDgpO1xyXG5cdFx0XHRcdFx0XHRtYXQ0LnNldFRyYW5zbGF0aW9uKCBtLCBwb2ludCApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBMR3JhcGhQb2ludHNUb0luc3RhbmNlcy5WRVJUSUNBTDogXHJcblx0XHRcdFx0XHRtYXQ0LnNldFRyYW5zbGF0aW9uKCBtLCBwb2ludCApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBMR3JhcGhQb2ludHNUb0luc3RhbmNlcy5TUEhFUklDQUw6IFxyXG5cdFx0XHRcdFx0ZnJvbnQuc2V0KCBwb2ludCApO1xyXG5cdFx0XHRcdFx0dmVjMy5ub3JtYWxpemUoIGZyb250LCBmcm9udCApO1xyXG5cdFx0XHRcdFx0dmVjMy5jcm9zcyggcmlnaHQsIFVQLCBmcm9udCApO1xyXG5cdFx0XHRcdFx0dmVjMy5ub3JtYWxpemUoIHJpZ2h0LCByaWdodCApO1xyXG5cdFx0XHRcdFx0dmVjMy5jcm9zcyggdG9wLCBmcm9udCwgcmlnaHQgKTtcclxuXHRcdFx0XHRcdHZlYzMubm9ybWFsaXplKCB0b3AsIHRvcCApO1xyXG5cdFx0XHRcdFx0bS5zZXQocmlnaHQsMCk7XHJcblx0XHRcdFx0XHRtLnNldCh0b3AsNCk7XHJcblx0XHRcdFx0XHRtLnNldChmcm9udCw4KTtcclxuXHRcdFx0XHRcdG1hdDQuc2V0VHJhbnNsYXRpb24oIG0sIHBvaW50ICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIExHcmFwaFBvaW50c1RvSW5zdGFuY2VzLlJBTkRPTTpcclxuXHRcdFx0XHRcdHRlbXBbMF0gPSBNYXRoLnJhbmRvbSgpKjIgLSAxO1xyXG5cdFx0XHRcdFx0dGVtcFsxXSA9IE1hdGgucmFuZG9tKCkqMiAtIDE7XHJcblx0XHRcdFx0XHR0ZW1wWzJdID0gTWF0aC5yYW5kb20oKSoyIC0gMTtcclxuXHRcdFx0XHRcdHZlYzMubm9ybWFsaXplKCB0ZW1wLCB0ZW1wICk7XHJcblx0XHRcdFx0XHRxdWF0LnNldEF4aXNBbmdsZSggUiwgdGVtcCwgTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJICk7XHJcblx0XHRcdFx0XHRtYXQ0LmZyb21RdWF0KG0sIFIpO1xyXG5cdFx0XHRcdFx0bWF0NC5zZXRUcmFuc2xhdGlvbiggbSwgcG9pbnQgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgTEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMuUkFORE9NX1ZFUlRJQ0FMOlxyXG5cdFx0XHRcdFx0cXVhdC5zZXRBeGlzQW5nbGUoIFIsIFVQLCBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEkgKTtcclxuXHRcdFx0XHRcdG1hdDQuZnJvbVF1YXQobSwgUik7XHJcblx0XHRcdFx0XHRtYXQ0LnNldFRyYW5zbGF0aW9uKCBtLCBwb2ludCApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl92ZXJzaW9uID0gZ2VvbWV0cnkuX3ZlcnNpb247XHJcblx0XHR0aGlzLl9nZW9tZXRyeV9pZCA9IGdlb21ldHJ5Ll9pZDtcclxuXHR9XHJcblxyXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcImdlb21ldHJ5L3BvaW50c190b19pbnN0YW5jZXNcIiwgTEdyYXBoUG9pbnRzVG9JbnN0YW5jZXMgKTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaEdlb21ldHJ5VHJhbnNmb3JtKCkge1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsIFwiZ2VvbWV0cnksW21hdDRdXCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIm1hdDRcIiwgXCJtYXQ0XCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJnZW9tZXRyeVwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHt9O1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkgPSB7XHJcblx0XHRcdHR5cGU6IFwidHJpYW5nbGVzXCIsXHJcblx0XHRcdHZlcnRpY2VzOiBudWxsLFxyXG5cdFx0XHRfaWQ6IGdlbmVyYXRlR2VvbWV0cnlJZCgpLFxyXG5cdFx0XHRfdmVyc2lvbjogMFxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLl9sYXN0X2dlb21ldHJ5X2lkID0gLTE7XHJcblx0XHR0aGlzLl9sYXN0X3ZlcnNpb24gPSAtMTtcclxuXHRcdHRoaXMuX2xhc3Rfa2V5ID0gXCJcIjtcclxuXHJcblx0XHR0aGlzLm11c3RfdXBkYXRlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5VHJhbnNmb3JtLnRpdGxlID0gXCJUcmFuc2Zvcm1cIjtcclxuXHJcblx0TEdyYXBoR2VvbWV0cnlUcmFuc2Zvcm0ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciBpbnB1dCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0dmFyIG1vZGVsID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcblxyXG5cdFx0aWYoIWlucHV0KVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0Ly9hcnJheSBvZiBtYXRyaWNlc1xyXG5cdFx0aWYoaW5wdXQuY29uc3RydWN0b3IgPT09IEFycmF5KVxyXG5cdFx0e1xyXG5cdFx0XHRpZihpbnB1dC5sZW5ndGggPT0gMClcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdHRoaXMub3V0cHV0c1swXS50eXBlID0gXCJbbWF0NF1cIjtcclxuXHRcdFx0aWYoICF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApIClcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRpZighbW9kZWwpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCxpbnB1dCk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZighdGhpcy5fb3V0cHV0KVxyXG5cdFx0XHRcdHRoaXMuX291dHB1dCA9IG5ldyBBcnJheSgpO1xyXG5cdFx0XHRpZih0aGlzLl9vdXRwdXQubGVuZ3RoICE9IGlucHV0Lmxlbmd0aClcclxuXHRcdFx0XHR0aGlzLl9vdXRwdXQubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyArK2kpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR2YXIgbSA9IHRoaXMuX291dHB1dFtpXTtcclxuXHRcdFx0XHRpZighbSlcclxuXHRcdFx0XHRcdG0gPSB0aGlzLl9vdXRwdXRbaV0gPSBtYXQ0LmNyZWF0ZSgpO1xyXG5cdFx0XHRcdG1hdDQubXVsdGlwbHkobSxpbnB1dFtpXSxtb2RlbCk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsdGhpcy5fb3V0cHV0KTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vZ2VvbWV0cnlcclxuXHRcdGlmKCFpbnB1dC52ZXJ0aWNlcyB8fCAhaW5wdXQudmVydGljZXMubGVuZ3RoKVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR2YXIgZ2VvID0gaW5wdXQ7XHJcblx0XHR0aGlzLm91dHB1dHNbMF0udHlwZSA9IFwiZ2VvbWV0cnlcIjtcclxuXHRcdGlmKCAhdGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSApXHJcblx0XHRcdHJldHVybjtcclxuXHRcdGlmKCFtb2RlbClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsZ2VvKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBrZXkgPSB0eXBlZEFycmF5VG9BcnJheShtb2RlbCkuam9pbihcIixcIik7XHJcblxyXG5cdFx0aWYoIHRoaXMubXVzdF91cGRhdGUgfHwgZ2VvLl9pZCAhPSB0aGlzLl9sYXN0X2dlb21ldHJ5X2lkIHx8IGdlby5fdmVyc2lvbiAhPSB0aGlzLl9sYXN0X3ZlcnNpb24gfHwga2V5ICE9IHRoaXMuX2xhc3Rfa2V5IClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy51cGRhdGVHZW9tZXRyeShnZW8sIG1vZGVsKTtcclxuXHRcdFx0dGhpcy5fbGFzdF9rZXkgPSBrZXk7XHJcblx0XHRcdHRoaXMuX2xhc3RfdmVyc2lvbiA9IGdlby5fdmVyc2lvbjtcclxuXHRcdFx0dGhpcy5fbGFzdF9nZW9tZXRyeV9pZCA9IGdlby5faWQ7XHJcblx0XHRcdHRoaXMubXVzdF91cGRhdGUgPSBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCx0aGlzLmdlb21ldHJ5KTtcclxuXHR9XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5VHJhbnNmb3JtLnByb3RvdHlwZS51cGRhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uKGdlb21ldHJ5LCBtb2RlbCkge1xyXG5cdFx0dmFyIG9sZF92ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cdFx0dmFyIHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS52ZXJ0aWNlcztcclxuXHRcdGlmKCAhdmVydGljZXMgfHwgdmVydGljZXMubGVuZ3RoICE9IG9sZF92ZXJ0aWNlcy5sZW5ndGggKVxyXG5cdFx0XHR2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBvbGRfdmVydGljZXMubGVuZ3RoICk7XHJcblx0XHR2YXIgdGVtcCA9IHZlYzMuY3JlYXRlKCk7XHJcblxyXG5cdFx0Zm9yKHZhciBpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkrPTMpXHJcblx0XHR7XHJcblx0XHRcdHRlbXBbMF0gPSBvbGRfdmVydGljZXNbaV07IHRlbXBbMV0gPSBvbGRfdmVydGljZXNbaSsxXTsgdGVtcFsyXSA9IG9sZF92ZXJ0aWNlc1tpKzJdOyBcclxuXHRcdFx0bWF0NC5tdWx0aXBseVZlYzMoIHRlbXAsIG1vZGVsLCB0ZW1wICk7XHJcblx0XHRcdHZlcnRpY2VzW2ldID0gdGVtcFswXTsgdmVydGljZXNbaSsxXSA9IHRlbXBbMV07IHZlcnRpY2VzW2krMl0gPSB0ZW1wWzJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKGdlb21ldHJ5Lm5vcm1hbHMpXHJcblx0XHR7XHJcblx0XHRcdGlmKCAhdGhpcy5nZW9tZXRyeS5ub3JtYWxzIHx8IHRoaXMuZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggIT0gZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggKVxyXG5cdFx0XHRcdHRoaXMuZ2VvbWV0cnkubm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoICk7XHJcblx0XHRcdHZhciBub3JtYWxzID0gdGhpcy5nZW9tZXRyeS5ub3JtYWxzO1xyXG5cdFx0XHR2YXIgbm9ybWFsX21vZGVsID0gbWF0NC5pbnZlcnQobWF0NC5jcmVhdGUoKSwgbW9kZWwpO1xyXG5cdFx0XHRpZihub3JtYWxfbW9kZWwpXHJcblx0XHRcdFx0bWF0NC50cmFuc3Bvc2Uobm9ybWFsX21vZGVsLCBub3JtYWxfbW9kZWwpO1xyXG5cdFx0XHR2YXIgb2xkX25vcm1hbHMgPSBnZW9tZXRyeS5ub3JtYWxzO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwLCBsID0gbm9ybWFscy5sZW5ndGg7IGkgPCBsOyBpKz0zKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGVtcFswXSA9IG9sZF9ub3JtYWxzW2ldOyB0ZW1wWzFdID0gb2xkX25vcm1hbHNbaSsxXTsgdGVtcFsyXSA9IG9sZF9ub3JtYWxzW2krMl07IFxyXG5cdFx0XHRcdG1hdDQubXVsdGlwbHlWZWMzKCB0ZW1wLCBub3JtYWxfbW9kZWwsIHRlbXAgKTtcclxuXHRcdFx0XHRub3JtYWxzW2ldID0gdGVtcFswXTsgbm9ybWFsc1tpKzFdID0gdGVtcFsxXTsgbm9ybWFsc1tpKzJdID0gdGVtcFsyXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkudHlwZSA9IGdlb21ldHJ5LnR5cGU7XHJcblx0XHR0aGlzLmdlb21ldHJ5Ll92ZXJzaW9uKys7XHJcblx0fVxyXG5cclxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJnZW9tZXRyeS90cmFuc2Zvcm1cIiwgTEdyYXBoR2VvbWV0cnlUcmFuc2Zvcm0gKTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaEdlb21ldHJ5UG9seWdvbigpIHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJzaWRlc1wiLCBcIm51bWJlclwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJyYWRpdXNcIiwgXCJudW1iZXJcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImdlb21ldHJ5XCIpO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0geyBzaWRlczogNiwgcmFkaXVzOiAxLCB1dnM6IGZhbHNlIH1cclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5ID0ge1xyXG5cdFx0XHR0eXBlOiBcImxpbmVfbG9vcFwiLFxyXG5cdFx0XHR2ZXJ0aWNlczogbnVsbCxcclxuXHRcdFx0X2lkOiBnZW5lcmF0ZUdlb21ldHJ5SWQoKVxyXG5cdFx0fTtcclxuXHRcdHRoaXMuZ2VvbWV0cnlfaWQgPSAtMTtcclxuXHRcdHRoaXMudmVyc2lvbiA9IC0xO1xyXG5cdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5sYXN0X2luZm8gPSB7IHNpZGVzOiAtMSwgcmFkaXVzOiAtMSB9O1xyXG5cdH1cclxuXHJcblx0TEdyYXBoR2VvbWV0cnlQb2x5Z29uLnRpdGxlID0gXCJQb2x5Z29uXCI7XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5UG9seWdvbi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0aWYoICF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApIClcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBzaWRlcyA9IHRoaXMuZ2V0SW5wdXRPclByb3BlcnR5KFwic2lkZXNcIik7XHJcblx0XHR2YXIgcmFkaXVzID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJyYWRpdXNcIik7XHJcblx0XHRzaWRlcyA9IE1hdGgubWF4KDMsc2lkZXMpfDA7XHJcblxyXG5cdFx0Ly91cGRhdGVcclxuXHRcdGlmKCB0aGlzLmxhc3RfaW5mby5zaWRlcyAhPSBzaWRlcyB8fCB0aGlzLmxhc3RfaW5mby5yYWRpdXMgIT0gcmFkaXVzIClcclxuXHRcdFx0dGhpcy51cGRhdGVHZW9tZXRyeShzaWRlcywgcmFkaXVzKTtcclxuXHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCx0aGlzLmdlb21ldHJ5KTtcclxuXHR9XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5UG9seWdvbi5wcm90b3R5cGUudXBkYXRlR2VvbWV0cnkgPSBmdW5jdGlvbihzaWRlcywgcmFkaXVzKSB7XHJcblx0XHR2YXIgbnVtID0gMypzaWRlcztcclxuXHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkudmVydGljZXM7XHJcblx0XHRpZiggIXZlcnRpY2VzIHx8IHZlcnRpY2VzLmxlbmd0aCAhPSBudW0gKVxyXG5cdFx0XHR2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCAzKnNpZGVzICk7XHJcblx0XHR2YXIgZGVsdGEgPSAoTWF0aC5QSSAqIDIpIC8gc2lkZXM7XHJcblx0XHR2YXIgZ2VuX3V2cyA9IHRoaXMucHJvcGVydGllcy51dnM7XHJcblx0XHRpZihnZW5fdXZzKVxyXG5cdFx0e1xyXG5cdFx0XHR1dnMgPSB0aGlzLmdlb21ldHJ5LmNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDMqc2lkZXMgKTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNpZGVzOyArK2kpXHJcblx0XHR7XHJcblx0XHRcdHZhciBhbmdsZSA9IGRlbHRhICogLWk7XHJcblx0XHRcdHZhciB4ID0gTWF0aC5jb3MoIGFuZ2xlICkgKiByYWRpdXM7XHJcblx0XHRcdHZhciB5ID0gMDtcclxuXHRcdFx0dmFyIHogPSBNYXRoLnNpbiggYW5nbGUgKSAqIHJhZGl1cztcclxuXHRcdFx0dmVydGljZXNbaSozXSA9IHg7XHJcblx0XHRcdHZlcnRpY2VzW2kqMysxXSA9IHk7XHJcblx0XHRcdHZlcnRpY2VzW2kqMysyXSA9IHo7XHJcblxyXG5cdFx0XHRpZihnZW5fdXZzKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0aGlzLmdlb21ldHJ5Ll9pZCA9ICsrdGhpcy5nZW9tZXRyeV9pZDtcclxuXHRcdHRoaXMuZ2VvbWV0cnkuX3ZlcnNpb24gPSArK3RoaXMudmVyc2lvbjtcclxuXHRcdHRoaXMubGFzdF9pbmZvLnNpZGVzID0gc2lkZXM7XHJcblx0XHR0aGlzLmxhc3RfaW5mby5yYWRpdXMgPSByYWRpdXM7XHJcblx0fVxyXG5cclxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJnZW9tZXRyeS9wb2x5Z29uXCIsIExHcmFwaEdlb21ldHJ5UG9seWdvbiApO1xyXG5cclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoR2VvbWV0cnlFeHRydWRlKCkge1xyXG5cclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJcIiwgXCJnZW9tZXRyeVwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwiXCIsIFwiZ2VvbWV0cnlcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IHRvcF9jYXA6IHRydWUsIGJvdHRvbV9jYXA6IHRydWUsIG9mZnNldDogWzAsMTAwLDBdIH07XHJcblx0XHR0aGlzLnZlcnNpb24gPSAtMTtcclxuXHJcblx0XHR0aGlzLl9sYXN0X2dlb192ZXJzaW9uID0gLTE7XHJcblx0XHR0aGlzLl9tdXN0X3VwZGF0ZSA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhHZW9tZXRyeUV4dHJ1ZGUudGl0bGUgPSBcImV4dHJ1ZGVcIjtcclxuXHJcblx0TEdyYXBoR2VvbWV0cnlFeHRydWRlLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKVxyXG5cdHtcclxuXHRcdHRoaXMuX211c3RfdXBkYXRlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5RXh0cnVkZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdHZhciBnZW8gPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdGlmKCAhZ2VvIHx8ICF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApIClcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdGlmKGdlby52ZXJzaW9uICE9IHRoaXMuX2xhc3RfZ2VvX3ZlcnNpb24gfHwgdGhpcy5fbXVzdF91cGRhdGUpXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuX2dlbyA9IHRoaXMuZXh0cnVkZUdlb21ldHJ5KCBnZW8sIHRoaXMuX2dlbyApO1xyXG5cdFx0XHRpZih0aGlzLl9nZW8pXHJcblx0XHRcdFx0dGhpcy5fZ2VvLnZlcnNpb24gPSB0aGlzLnZlcnNpb24rKztcclxuXHRcdFx0dGhpcy5fbXVzdF91cGRhdGUgPSBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fZ2VvKTtcclxuXHR9XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5RXh0cnVkZS5wcm90b3R5cGUuZXh0cnVkZUdlb21ldHJ5ID0gZnVuY3Rpb24oIGdlbyApXHJcblx0e1xyXG5cdFx0Ly9mb3IgZXZlcnkgcGFpciBvZiB2ZXJ0aWNlc1xyXG5cdFx0dmFyIHZlcnRpY2VzID0gZ2VvLnZlcnRpY2VzO1xyXG5cdFx0dmFyIG51bV9wb2ludHMgPSB2ZXJ0aWNlcy5sZW5ndGggLyAzO1xyXG5cclxuXHRcdHZhciB0ZW1wQSA9IHZlYzMuY3JlYXRlKCk7XHJcblx0XHR2YXIgdGVtcEIgPSB2ZWMzLmNyZWF0ZSgpO1xyXG5cdFx0dmFyIHRlbXBDID0gdmVjMy5jcmVhdGUoKTtcclxuXHRcdHZhciB0ZW1wRCA9IHZlYzMuY3JlYXRlKCk7XHJcblx0XHR2YXIgb2Zmc2V0ID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5wcm9wZXJ0aWVzLm9mZnNldCApO1xyXG5cclxuXHRcdGlmKGdlby50eXBlID09IFwibGluZV9sb29wXCIpXHJcblx0XHR7XHJcblx0XHRcdHZhciBuZXdfdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1fcG9pbnRzICogNiAqIDMgKTsgLy9ldmVyeSBwb2ludHMgYmVjb21lIDYgKCBjYXBzIG5vdCBpbmNsdWRlZCApXHJcblx0XHRcdHZhciBucG9zID0gMDtcclxuXHRcdFx0Zm9yKHZhciBpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMylcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRlbXBBWzBdID0gdmVydGljZXNbaV07IHRlbXBBWzFdID0gdmVydGljZXNbaSsxXTsgdGVtcEFbMl0gPSB2ZXJ0aWNlc1tpKzJdO1xyXG5cclxuXHRcdFx0XHRpZiggaSszIDwgbCApIC8vbG9vcFxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHRlbXBCWzBdID0gdmVydGljZXNbaSszXTsgdGVtcEJbMV0gPSB2ZXJ0aWNlc1tpKzRdOyB0ZW1wQlsyXSA9IHZlcnRpY2VzW2krNV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHR0ZW1wQlswXSA9IHZlcnRpY2VzWzBdOyB0ZW1wQlsxXSA9IHZlcnRpY2VzWzFdOyB0ZW1wQlsyXSA9IHZlcnRpY2VzWzJdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmVjMy5hZGQoIHRlbXBDLCB0ZW1wQSwgb2Zmc2V0ICk7XHJcblx0XHRcdFx0dmVjMy5hZGQoIHRlbXBELCB0ZW1wQiwgb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHRcdG5ld192ZXJ0aWNlcy5zZXQoIHRlbXBBLCBucG9zICk7IG5wb3MgKz0gMztcclxuXHRcdFx0XHRuZXdfdmVydGljZXMuc2V0KCB0ZW1wQiwgbnBvcyApOyBucG9zICs9IDM7XHJcblx0XHRcdFx0bmV3X3ZlcnRpY2VzLnNldCggdGVtcEMsIG5wb3MgKTsgbnBvcyArPSAzO1xyXG5cclxuXHRcdFx0XHRuZXdfdmVydGljZXMuc2V0KCB0ZW1wQiwgbnBvcyApOyBucG9zICs9IDM7XHJcblx0XHRcdFx0bmV3X3ZlcnRpY2VzLnNldCggdGVtcEQsIG5wb3MgKTsgbnBvcyArPSAzO1xyXG5cdFx0XHRcdG5ld192ZXJ0aWNlcy5zZXQoIHRlbXBDLCBucG9zICk7IG5wb3MgKz0gMztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvdXRfZ2VvID0ge1xyXG5cdFx0XHRfaWQ6IGdlbmVyYXRlR2VvbWV0cnlJZCgpLFxyXG5cdFx0XHR0eXBlOiBcInRyaWFuZ2xlc1wiLFxyXG5cdFx0XHR2ZXJ0aWNlczogbmV3X3ZlcnRpY2VzXHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiBvdXRfZ2VvO1xyXG5cdH1cclxuXHJcblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwiZ2VvbWV0cnkvZXh0cnVkZVwiLCBMR3JhcGhHZW9tZXRyeUV4dHJ1ZGUgKTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaEdlb21ldHJ5RXZhbCgpIHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcImdlb21ldHJ5XCIpO1xyXG5cdFx0dGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJnZW9tZXRyeVwiKTtcclxuXHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XHJcblx0XHRcdGNvZGU6IFwiVlsxXSArPSAwLjAxICogTWF0aC5zaW4oSSArIFQqMC4wMDEpO1wiLFxyXG5cdFx0XHRleGVjdXRlX2V2ZXJ5X2ZyYW1lOiBmYWxzZVxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5ID0gbnVsbDtcclxuXHRcdHRoaXMuZ2VvbWV0cnlfaWQgPSAtMTtcclxuXHRcdHRoaXMudmVyc2lvbiA9IC0xO1xyXG5cdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlcyA9IG51bGw7XHJcblx0XHR0aGlzLmZ1bmMgPSBudWxsO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoR2VvbWV0cnlFdmFsLnRpdGxlID0gXCJnZW9ldmFsXCI7XHJcblx0TEdyYXBoR2VvbWV0cnlFdmFsLmRlc2MgPSBcImV2YWwgY29kZVwiO1xyXG5cclxuXHRMR3JhcGhHZW9tZXRyeUV2YWwud2lkZ2V0c19pbmZvID0ge1xyXG5cdFx0Y29kZTogeyB3aWRnZXQ6IFwiY29kZVwiIH1cclxuXHR9O1xyXG5cclxuXHRMR3JhcGhHZW9tZXRyeUV2YWwucHJvdG90eXBlLm9uQ29uZmlndXJlID0gZnVuY3Rpb24obylcclxuXHR7XHJcblx0XHR0aGlzLmNvbXBpbGVDb2RlKCk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhHZW9tZXRyeUV2YWwucHJvdG90eXBlLmNvbXBpbGVDb2RlID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLnByb3BlcnRpZXMuY29kZSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHRyeVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLmZ1bmMgPSBuZXcgRnVuY3Rpb24oXCJWXCIsXCJJXCIsXCJUXCIsIHRoaXMucHJvcGVydGllcy5jb2RlKTsgXHJcblx0XHRcdHRoaXMuYm94Y29sb3IgPSBcIiNBRkFcIjtcclxuXHRcdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRjYXRjaCAoZXJyKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLmJveGNvbG9yID0gXCJyZWRcIjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5RXZhbC5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSlcclxuXHR7XHJcblx0XHRpZihuYW1lID09IFwiY29kZVwiKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLnByb3BlcnRpZXMuY29kZSA9IHZhbHVlO1xyXG5cdFx0XHR0aGlzLmNvbXBpbGVDb2RlKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRMR3JhcGhHZW9tZXRyeUV2YWwucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRpZighZ2VvbWV0cnkpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHRpZighdGhpcy5mdW5jKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCxnZW9tZXRyeSk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiggdGhpcy5nZW9tZXRyeV9pZCAhPSBnZW9tZXRyeS5faWQgfHwgdGhpcy52ZXJzaW9uICE9IGdlb21ldHJ5Ll92ZXJzaW9uIHx8IHRoaXMubXVzdF91cGRhdGUgfHwgdGhpcy5wcm9wZXJ0aWVzLmV4ZWN1dGVfZXZlcnlfZnJhbWUgKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLm11c3RfdXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuZ2VvbWV0cnlfaWQgPSBnZW9tZXRyeS5faWQ7XHJcblx0XHRcdGlmKHRoaXMucHJvcGVydGllcy5leGVjdXRlX2V2ZXJ5X2ZyYW1lKVxyXG5cdFx0XHRcdHRoaXMudmVyc2lvbisrO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0dGhpcy52ZXJzaW9uID0gZ2VvbWV0cnkuX3ZlcnNpb247XHJcblx0XHRcdHZhciBmdW5jID0gdGhpcy5mdW5jO1xyXG5cdFx0XHR2YXIgVCA9IGdldFRpbWUoKTtcclxuXHJcblx0XHRcdC8vY2xvbmVcclxuXHRcdFx0aWYoIXRoaXMuZ2VvbWV0cnkpXHJcblx0XHRcdFx0dGhpcy5nZW9tZXRyeSA9IHt9O1xyXG5cdFx0XHRmb3IodmFyIGkgaW4gZ2VvbWV0cnkpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRpZihnZW9tZXRyeVtpXSA9PSBudWxsKVxyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0aWYoIGdlb21ldHJ5W2ldLmNvbnN0cnVjdG9yID09IEZsb2F0MzJBcnJheSApXHJcblx0XHRcdFx0XHR0aGlzLmdlb21ldHJ5W2ldID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnlbaV0gKTtcclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHR0aGlzLmdlb21ldHJ5W2ldID0gZ2VvbWV0cnlbaV07XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5nZW9tZXRyeS5faWQgPSBnZW9tZXRyeS5faWQ7XHJcblx0XHRcdGlmKHRoaXMucHJvcGVydGllcy5leGVjdXRlX2V2ZXJ5X2ZyYW1lKVxyXG5cdFx0XHRcdHRoaXMuZ2VvbWV0cnkuX3ZlcnNpb24gPSB0aGlzLnZlcnNpb247XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHR0aGlzLmdlb21ldHJ5Ll92ZXJzaW9uID0gZ2VvbWV0cnkuX3ZlcnNpb24gKyAxO1xyXG5cclxuXHRcdFx0dmFyIFYgPSB2ZWMzLmNyZWF0ZSgpO1xyXG5cdFx0XHR2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG5cdFx0XHRpZighdmVydGljZXMgfHwgdGhpcy52ZXJ0aWNlcy5sZW5ndGggIT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoKVxyXG5cdFx0XHRcdHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICk7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHR2ZXJ0aWNlcy5zZXQoIGdlb21ldHJ5LnZlcnRpY2VzICk7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrPTMpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRWWzBdID0gdmVydGljZXNbaV07XHJcblx0XHRcdFx0VlsxXSA9IHZlcnRpY2VzW2krMV07XHJcblx0XHRcdFx0VlsyXSA9IHZlcnRpY2VzW2krMl07XHJcblx0XHRcdFx0ZnVuYyhWLGkvMyxUKTtcclxuXHRcdFx0XHR2ZXJ0aWNlc1tpXSA9IFZbMF07XHJcblx0XHRcdFx0dmVydGljZXNbaSsxXSA9IFZbMV07XHJcblx0XHRcdFx0dmVydGljZXNbaSsyXSA9IFZbMl07XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5nZW9tZXRyeS52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLHRoaXMuZ2VvbWV0cnkpO1xyXG5cdH1cclxuXHJcblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwiZ2VvbWV0cnkvZXZhbFwiLCBMR3JhcGhHZW9tZXRyeUV2YWwgKTtcclxuXHJcbi8qXHJcbmZ1bmN0aW9uIExHcmFwaEdlb21ldHJ5RGlzcGxhY2UoKSB7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJnZW9tZXRyeVwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJpbWdcIiwgXCJpbWFnZVwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiZ2VvbWV0cnlcIik7XHJcblxyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xyXG5cdFx0XHRncmlkX3NpemU6IDFcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeSA9IG51bGw7XHJcblx0XHR0aGlzLmdlb21ldHJ5X2lkID0gLTE7XHJcblx0XHR0aGlzLnZlcnNpb24gPSAtMTtcclxuXHRcdHRoaXMubXVzdF91cGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudmVydGljZXMgPSBudWxsO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoR2VvbWV0cnlEaXNwbGFjZS50aXRsZSA9IFwiZGlzcGxhY2VcIjtcclxuXHRMR3JhcGhHZW9tZXRyeURpc3BsYWNlLmRlc2MgPSBcImRpc3BsYWNlIHBvaW50c1wiO1xyXG5cclxuXHRMR3JhcGhHZW9tZXRyeURpc3BsYWNlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0dmFyIGltYWdlID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcblx0XHRpZighZ2VvbWV0cnkpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHRpZighaW1hZ2UpXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLGdlb21ldHJ5KTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKCB0aGlzLmdlb21ldHJ5X2lkICE9IGdlb21ldHJ5Ll9pZCB8fCB0aGlzLnZlcnNpb24gIT0gZ2VvbWV0cnkuX3ZlcnNpb24gfHwgdGhpcy5tdXN0X3VwZGF0ZSApXHJcblx0XHR7XHJcblx0XHRcdHRoaXMubXVzdF91cGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5nZW9tZXRyeV9pZCA9IGdlb21ldHJ5Ll9pZDtcclxuXHRcdFx0dGhpcy52ZXJzaW9uID0gZ2VvbWV0cnkuX3ZlcnNpb247XHJcblxyXG5cdFx0XHQvL2NvcHlcclxuXHRcdFx0dGhpcy5nZW9tZXRyeSA9IHt9O1xyXG5cdFx0XHRmb3IodmFyIGkgaW4gZ2VvbWV0cnkpXHJcblx0XHRcdFx0dGhpcy5nZW9tZXRyeVtpXSA9IGdlb21ldHJ5W2ldO1xyXG5cdFx0XHR0aGlzLmdlb21ldHJ5Ll9pZCA9IGdlb21ldHJ5Ll9pZDtcclxuXHRcdFx0dGhpcy5nZW9tZXRyeS5fdmVyc2lvbiA9IGdlb21ldHJ5Ll92ZXJzaW9uICsgMTtcclxuXHJcblx0XHRcdHZhciBncmlkX3NpemUgPSB0aGlzLnByb3BlcnRpZXMuZ3JpZF9zaXplO1xyXG5cdFx0XHRpZihncmlkX3NpemUgIT0gMClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XHJcblx0XHRcdFx0aWYoIXZlcnRpY2VzIHx8IHRoaXMudmVydGljZXMubGVuZ3RoICE9IHRoaXMuZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoKVxyXG5cdFx0XHRcdFx0dmVydGljZXMgPSB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5nZW9tZXRyeS52ZXJ0aWNlcyApO1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrPTMpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0dmVydGljZXNbaV0gPSBNYXRoLnJvdW5kKHZlcnRpY2VzW2ldL2dyaWRfc2l6ZSkgKiBncmlkX3NpemU7XHJcblx0XHRcdFx0XHR2ZXJ0aWNlc1tpKzFdID0gTWF0aC5yb3VuZCh2ZXJ0aWNlc1tpKzFdL2dyaWRfc2l6ZSkgKiBncmlkX3NpemU7XHJcblx0XHRcdFx0XHR2ZXJ0aWNlc1tpKzJdID0gTWF0aC5yb3VuZCh2ZXJ0aWNlc1tpKzJdL2dyaWRfc2l6ZSkgKiBncmlkX3NpemU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMuZ2VvbWV0cnkudmVydGljZXMgPSB2ZXJ0aWNlcztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLHRoaXMuZ2VvbWV0cnkpO1xyXG5cdH1cclxuXHJcblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwiZ2VvbWV0cnkvZGlzcGxhY2VcIiwgTEdyYXBoR2VvbWV0cnlEaXNwbGFjZSApO1xyXG4qL1xyXG5cclxuXHRmdW5jdGlvbiBMR3JhcGhDb25uZWN0UG9pbnRzKCkge1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsIFwiZ2VvbWV0cnlcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImdlb21ldHJ5XCIpO1xyXG5cclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcclxuXHRcdFx0bWluX2Rpc3Q6IDAuNCxcclxuXHRcdFx0bWF4X2Rpc3Q6IDAuNSxcclxuXHRcdFx0bWF4X2Nvbm5lY3Rpb25zOiAwLFxyXG5cdFx0XHRwcm9iYWJpbGl0eTogMVxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5X2lkID0gLTE7XHJcblx0XHR0aGlzLnZlcnNpb24gPSAtMTtcclxuXHRcdHRoaXMubXlfdmVyc2lvbiA9IDE7XHJcblx0XHR0aGlzLm11c3RfdXBkYXRlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdExHcmFwaENvbm5lY3RQb2ludHMudGl0bGUgPSBcImNvbm5lY3QgcG9pbnRzXCI7XHJcblx0TEdyYXBoQ29ubmVjdFBvaW50cy5kZXNjID0gXCJhZGRzIGluZGljZXMgYmV0d2VlbiBuZWFyIHBvaW50c1wiO1xyXG5cclxuXHRMR3JhcGhDb25uZWN0UG9pbnRzLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsdmFsdWUpXHJcblx0e1xyXG5cdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhDb25uZWN0UG9pbnRzLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0aWYoIWdlb21ldHJ5KVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0aWYoIHRoaXMuZ2VvbWV0cnlfaWQgIT0gZ2VvbWV0cnkuX2lkIHx8IHRoaXMudmVyc2lvbiAhPSBnZW9tZXRyeS5fdmVyc2lvbiB8fCB0aGlzLm11c3RfdXBkYXRlIClcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5tdXN0X3VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLmdlb21ldHJ5X2lkID0gZ2VvbWV0cnkuX2lkO1xyXG5cdFx0XHR0aGlzLnZlcnNpb24gPSBnZW9tZXRyeS5fdmVyc2lvbjtcclxuXHJcblx0XHRcdC8vY29weVxyXG5cdFx0XHR0aGlzLmdlb21ldHJ5ID0ge307XHJcblx0XHRcdGZvcih2YXIgaSBpbiBnZW9tZXRyeSlcclxuXHRcdFx0XHR0aGlzLmdlb21ldHJ5W2ldID0gZ2VvbWV0cnlbaV07XHJcblx0XHRcdHRoaXMuZ2VvbWV0cnkuX2lkID0gZ2VuZXJhdGVHZW9tZXRyeUlkKCk7XHJcblx0XHRcdHRoaXMuZ2VvbWV0cnkuX3ZlcnNpb24gPSB0aGlzLm15X3ZlcnNpb24rKztcclxuXHJcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cdFx0XHR2YXIgbCA9IHZlcnRpY2VzLmxlbmd0aDtcclxuXHRcdFx0dmFyIG1pbl9kaXN0ID0gdGhpcy5wcm9wZXJ0aWVzLm1pbl9kaXN0O1xyXG5cdFx0XHR2YXIgbWF4X2Rpc3QgPSB0aGlzLnByb3BlcnRpZXMubWF4X2Rpc3Q7XHJcblx0XHRcdHZhciBwcm9iYWJpbGl0eSA9IHRoaXMucHJvcGVydGllcy5wcm9iYWJpbGl0eTtcclxuXHRcdFx0dmFyIG1heF9jb25uZWN0aW9ucyA9IHRoaXMucHJvcGVydGllcy5tYXhfY29ubmVjdGlvbnM7XHJcblx0XHRcdHZhciBpbmRpY2VzID0gW107XHJcblx0XHRcdFxyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSs9MylcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHZhciB4ID0gdmVydGljZXNbaV07XHJcblx0XHRcdFx0dmFyIHkgPSB2ZXJ0aWNlc1tpKzFdO1xyXG5cdFx0XHRcdHZhciB6ID0gdmVydGljZXNbaSsyXTtcclxuXHRcdFx0XHR2YXIgY29ubmVjdGlvbnMgPSAwO1xyXG5cdFx0XHRcdGZvcih2YXIgaiA9IGkrMzsgaiA8IGw7IGorPTMpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0dmFyIHgyID0gdmVydGljZXNbal07XHJcblx0XHRcdFx0XHR2YXIgeTIgPSB2ZXJ0aWNlc1tqKzFdO1xyXG5cdFx0XHRcdFx0dmFyIHoyID0gdmVydGljZXNbaisyXTtcclxuXHRcdFx0XHRcdHZhciBkaXN0ID0gTWF0aC5zcXJ0KCAoeC14MikqKHgteDIpICsgKHkteTIpKih5LXkyKSArICh6LXoyKSooei16MikpO1xyXG5cdFx0XHRcdFx0aWYoZGlzdCA+IG1heF9kaXN0IHx8IGRpc3QgPCBtaW5fZGlzdCB8fCAocHJvYmFiaWxpdHkgPCAxICYmIHByb2JhYmlsaXR5IDwgTWF0aC5yYW5kb20oKSkgKVxyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdGluZGljZXMucHVzaChpLzMsai8zKTtcclxuXHRcdFx0XHRcdGNvbm5lY3Rpb25zICs9IDE7XHJcblx0XHRcdFx0XHRpZihtYXhfY29ubmVjdGlvbnMgJiYgY29ubmVjdGlvbnMgPiBtYXhfY29ubmVjdGlvbnMpXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmdlb21ldHJ5LmluZGljZXMgPSB0aGlzLmluZGljZXMgPSBuZXcgVWludDMyQXJyYXkoaW5kaWNlcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodGhpcy5pbmRpY2VzICYmIHRoaXMuaW5kaWNlcy5sZW5ndGgpXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuZ2VvbWV0cnkuaW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKCAwLCB0aGlzLmdlb21ldHJ5ICk7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHRcdHRoaXMuc2V0T3V0cHV0RGF0YSggMCwgbnVsbCApO1xyXG5cdH1cclxuXHJcblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwiZ2VvbWV0cnkvY29ubmVjdFBvaW50c1wiLCBMR3JhcGhDb25uZWN0UG9pbnRzICk7XHJcblxyXG4gICAgLy9Xb3JrcyB3aXRoIExpdGVnbC5qcyB0byBjcmVhdGUgV2ViR0wgbm9kZXNcclxuICAgIGlmICh0eXBlb2YgR0wgPT0gXCJ1bmRlZmluZWRcIikgLy9MaXRlR0wgUkVMQVRFRCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblx0XHRyZXR1cm47XHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFRvR2VvbWV0cnkoKSB7XHJcblx0XHR0aGlzLmFkZElucHV0KFwibWVzaFwiLCBcIm1lc2hcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIm91dFwiLCBcImdlb21ldHJ5XCIpO1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkgPSB7fTtcclxuXHRcdHRoaXMubGFzdF9tZXNoID0gbnVsbDtcclxuXHR9XHJcblxyXG5cdExHcmFwaFRvR2VvbWV0cnkudGl0bGUgPSBcInRvIGdlb21ldHJ5XCI7XHJcblx0TEdyYXBoVG9HZW9tZXRyeS5kZXNjID0gXCJjb252ZXJ0cyBhIG1lc2ggdG8gZ2VvbWV0cnlcIjtcclxuXHJcblx0TEdyYXBoVG9HZW9tZXRyeS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWVzaCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0aWYoIW1lc2gpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHRpZihtZXNoICE9IHRoaXMubGFzdF9tZXNoKVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLmxhc3RfbWVzaCA9IG1lc2g7XHJcblx0XHRcdGZvcihpIGluIG1lc2gudmVydGV4QnVmZmVycylcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHZhciBidWZmZXIgPSBtZXNoLnZlcnRleEJ1ZmZlcnNbaV07XHJcblx0XHRcdFx0dGhpcy5nZW9tZXRyeVtpXSA9IGJ1ZmZlci5kYXRhXHJcblx0XHRcdH1cclxuXHRcdFx0aWYobWVzaC5pbmRleEJ1ZmZlcnNbXCJ0cmlhbmdsZXNcIl0pXHJcblx0XHRcdFx0dGhpcy5nZW9tZXRyeS5pbmRpY2VzID0gbWVzaC5pbmRleEJ1ZmZlcnNbXCJ0cmlhbmdsZXNcIl0uZGF0YTtcclxuXHJcblx0XHRcdHRoaXMuZ2VvbWV0cnkuX2lkID0gZ2VuZXJhdGVHZW9tZXRyeUlkKCk7XHJcblx0XHRcdHRoaXMuZ2VvbWV0cnkuX3ZlcnNpb24gPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLHRoaXMuZ2VvbWV0cnkpO1xyXG5cdFx0aWYodGhpcy5nZW9tZXRyeSlcclxuXHRcdFx0dGhpcy5zZXRPdXRwdXREYXRhKDEsdGhpcy5nZW9tZXRyeS52ZXJ0aWNlcyk7XHJcblx0fVxyXG5cclxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJnZW9tZXRyeS90b0dlb21ldHJ5XCIsIExHcmFwaFRvR2VvbWV0cnkgKTtcclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoR2VvbWV0cnlUb01lc2goKSB7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJnZW9tZXRyeVwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwibWVzaFwiLCBcIm1lc2hcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7fTtcclxuXHRcdHRoaXMudmVyc2lvbiA9IC0xO1xyXG5cdFx0dGhpcy5tZXNoID0gbnVsbDtcclxuXHR9XHJcblxyXG5cdExHcmFwaEdlb21ldHJ5VG9NZXNoLnRpdGxlID0gXCJHZW8gdG8gTWVzaFwiO1xyXG5cclxuXHRMR3JhcGhHZW9tZXRyeVRvTWVzaC5wcm90b3R5cGUudXBkYXRlTWVzaCA9IGZ1bmN0aW9uKGdlb21ldHJ5KVxyXG5cdHtcclxuXHRcdGlmKCF0aGlzLm1lc2gpXHJcblx0XHRcdHRoaXMubWVzaCA9IG5ldyBHTC5NZXNoKCk7XHJcblxyXG5cdFx0Zm9yKHZhciBpIGluIGdlb21ldHJ5KVxyXG5cdFx0e1xyXG5cdFx0XHRpZihpWzBdID09IFwiX1wiKVxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0dmFyIGJ1ZmZlcl9kYXRhID0gZ2VvbWV0cnlbaV07XHJcblxyXG5cdFx0XHR2YXIgaW5mbyA9IEdMLk1lc2guY29tbW9uX2J1ZmZlcnNbaV07XHJcblx0XHRcdGlmKCFpbmZvICYmIGkgIT0gXCJpbmRpY2VzXCIpIC8vdW5rbm93biBidWZmZXJcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0dmFyIHNwYWNpbmcgPSBpbmZvID8gaW5mby5zcGFjaW5nIDogMztcclxuXHRcdFx0dmFyIG1lc2hfYnVmZmVyID0gdGhpcy5tZXNoLnZlcnRleEJ1ZmZlcnNbaV07XHJcblxyXG5cdFx0XHRpZighbWVzaF9idWZmZXIgfHwgbWVzaF9idWZmZXIuZGF0YS5sZW5ndGggIT0gYnVmZmVyX2RhdGEubGVuZ3RoKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bWVzaF9idWZmZXIgPSBuZXcgR0wuQnVmZmVyKCBpID09IFwiaW5kaWNlc1wiID8gR0wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgOiBHTC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcl9kYXRhLCBzcGFjaW5nLCBHTC5EWU5BTUlDX0RSQVcgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdHtcclxuXHRcdFx0XHRtZXNoX2J1ZmZlci5kYXRhLnNldCggYnVmZmVyX2RhdGEgKTtcclxuXHRcdFx0XHRtZXNoX2J1ZmZlci51cGxvYWQoR0wuRFlOQU1JQ19EUkFXKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5tZXNoLmFkZEJ1ZmZlciggaSwgbWVzaF9idWZmZXIgKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0aGlzLm1lc2gudmVydGV4QnVmZmVycy5ub3JtYWxzICYmdGhpcy5tZXNoLnZlcnRleEJ1ZmZlcnMubm9ybWFscy5kYXRhLmxlbmd0aCAhPSB0aGlzLm1lc2gudmVydGV4QnVmZmVycy52ZXJ0aWNlcy5kYXRhLmxlbmd0aCApXHJcblx0XHR7XHJcblx0XHRcdHZhciBuID0gbmV3IEZsb2F0MzJBcnJheShbMCwxLDBdKTtcclxuXHRcdFx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLm1lc2gudmVydGV4QnVmZmVycy52ZXJ0aWNlcy5kYXRhLmxlbmd0aCApO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbm9ybWFscy5sZW5ndGg7IGkrPSAzKVxyXG5cdFx0XHRcdG5vcm1hbHMuc2V0KCBuLCBpICk7XHJcblx0XHRcdG1lc2hfYnVmZmVyID0gbmV3IEdMLkJ1ZmZlciggR0wuQVJSQVlfQlVGRkVSLCBub3JtYWxzLCAzICk7XHJcblx0XHRcdHRoaXMubWVzaC5hZGRCdWZmZXIoIFwibm9ybWFsc1wiLCBtZXNoX2J1ZmZlciApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubWVzaC51cGRhdGVCb3VuZGluZ0JveCgpO1xyXG5cdFx0dGhpcy5nZW9tZXRyeV9pZCA9IHRoaXMubWVzaC5pZCA9IGdlb21ldHJ5Ll9pZDtcclxuXHRcdHRoaXMudmVyc2lvbiA9IHRoaXMubWVzaC52ZXJzaW9uID0gZ2VvbWV0cnkuX3ZlcnNpb247XHJcblx0XHRyZXR1cm4gdGhpcy5tZXNoO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoR2VvbWV0cnlUb01lc2gucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cdFx0aWYoIWdlb21ldHJ5KVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHRpZiggdGhpcy52ZXJzaW9uICE9IGdlb21ldHJ5Ll92ZXJzaW9uIHx8IHRoaXMuZ2VvbWV0cnlfaWQgIT0gZ2VvbWV0cnkuX2lkIClcclxuXHRcdFx0dGhpcy51cGRhdGVNZXNoKCBnZW9tZXRyeSApO1xyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMubWVzaCk7XHJcblx0fVxyXG5cclxuXHRMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZSggXCJnZW9tZXRyeS90b01lc2hcIiwgTEdyYXBoR2VvbWV0cnlUb01lc2ggKTtcclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoUmVuZGVyTWVzaCgpIHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJtZXNoXCIsIFwibWVzaFwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJtYXQ0XCIsIFwibWF0NFwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJ0ZXhcIiwgXCJ0ZXh0dXJlXCIpO1xyXG5cclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcclxuXHRcdFx0ZW5hYmxlZDogdHJ1ZSxcclxuXHRcdFx0cHJpbWl0aXZlOiBHTC5UUklBTkdMRVMsXHJcblx0XHRcdGFkZGl0aXZlOiBmYWxzZSxcclxuXHRcdFx0Y29sb3I6IFsxLDEsMV0sXHJcblx0XHRcdG9wYWNpdHk6IDFcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5jb2xvciA9IHZlYzQuY3JlYXRlKFsxLDEsMSwxXSk7XHJcblx0XHR0aGlzLm1vZGVsX21hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XHJcblx0XHR0aGlzLnVuaWZvcm1zID0ge1xyXG5cdFx0XHR1X2NvbG9yOiB0aGlzLmNvbG9yLFxyXG5cdFx0XHR1X21vZGVsOiB0aGlzLm1vZGVsX21hdHJpeFxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdExHcmFwaFJlbmRlck1lc2gudGl0bGUgPSBcIlJlbmRlciBNZXNoXCI7XHJcblx0TEdyYXBoUmVuZGVyTWVzaC5kZXNjID0gXCJyZW5kZXJzIGEgbWVzaCBmbGF0XCI7XHJcblxyXG5cdExHcmFwaFJlbmRlck1lc2guUFJJTUlUSVZFX1ZBTFVFUyA9IHsgXCJwb2ludHNcIjpHTC5QT0lOVFMsIFwibGluZXNcIjpHTC5MSU5FUywgXCJsaW5lX2xvb3BcIjpHTC5MSU5FX0xPT1AsXCJsaW5lX3N0cmlwXCI6R0wuTElORV9TVFJJUCwgXCJ0cmlhbmdsZXNcIjpHTC5UUklBTkdMRVMsIFwidHJpYW5nbGVfZmFuXCI6R0wuVFJJQU5HTEVfRkFOLCBcInRyaWFuZ2xlX3N0cmlwXCI6R0wuVFJJQU5HTEVfU1RSSVAgfTtcclxuXHJcblx0TEdyYXBoUmVuZGVyTWVzaC53aWRnZXRzX2luZm8gPSB7XHJcblx0XHRwcmltaXRpdmU6IHsgd2lkZ2V0OiBcImNvbWJvXCIsIHZhbHVlczogTEdyYXBoUmVuZGVyTWVzaC5QUklNSVRJVkVfVkFMVUVTIH0sXHJcblx0XHRjb2xvcjogeyB3aWRnZXQ6IFwiY29sb3JcIiB9XHJcblx0fTtcclxuXHJcblx0TEdyYXBoUmVuZGVyTWVzaC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0aWYoIXRoaXMucHJvcGVydGllcy5lbmFibGVkKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIG1lc2ggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdGlmKCFtZXNoKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0aWYoIUxpdGVHcmFwaC5MR3JhcGhSZW5kZXIub25SZXF1ZXN0Q2FtZXJhTWF0cmljZXMpXHJcblx0XHR7XHJcblx0XHRcdGNvbnNvbGUud2FybihcImNhbm5vdCByZW5kZXIgZ2VvbWV0cnksIExpdGVHcmFwaC5vblJlcXVlc3RDYW1lcmFNYXRyaWNlcyBpcyBudWxsLCByZW1lbWJlciB0byBmaWxsIHRoaXMgd2l0aCBhIGNhbGxiYWNrKHZpZXdfbWF0cml4LCBwcm9qZWN0aW9uX21hdHJpeCx2aWV3cHJvamVjdGlvbl9tYXRyaXgpIHRvIHVzZSAzRCByZW5kZXJpbmcgZnJvbSB0aGUgZ3JhcGhcIik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRMaXRlR3JhcGguTEdyYXBoUmVuZGVyLm9uUmVxdWVzdENhbWVyYU1hdHJpY2VzKCB2aWV3X21hdHJpeCwgcHJvamVjdGlvbl9tYXRyaXgsdmlld3Byb2plY3Rpb25fbWF0cml4ICk7XHJcblx0XHR2YXIgc2hhZGVyID0gbnVsbDtcclxuXHRcdHZhciB0ZXh0dXJlID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XHJcblx0XHRpZih0ZXh0dXJlKVxyXG5cdFx0e1xyXG5cdFx0XHRzaGFkZXIgPSBnbC5zaGFkZXJzW1widGV4dHVyZWRcIl07XHJcblx0XHRcdGlmKCFzaGFkZXIpXHJcblx0XHRcdFx0c2hhZGVyID0gZ2wuc2hhZGVyc1tcInRleHR1cmVkXCJdID0gbmV3IEdMLlNoYWRlciggTEdyYXBoUmVuZGVyUG9pbnRzLnZlcnRleF9zaGFkZXJfY29kZSwgTEdyYXBoUmVuZGVyUG9pbnRzLmZyYWdtZW50X3NoYWRlcl9jb2RlLCB7IFVTRV9URVhUVVJFOlwiXCIgfSk7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHR7XHJcblx0XHRcdHNoYWRlciA9IGdsLnNoYWRlcnNbXCJmbGF0XCJdO1xyXG5cdFx0XHRpZighc2hhZGVyKVxyXG5cdFx0XHRcdHNoYWRlciA9IGdsLnNoYWRlcnNbXCJmbGF0XCJdID0gbmV3IEdMLlNoYWRlciggTEdyYXBoUmVuZGVyUG9pbnRzLnZlcnRleF9zaGFkZXJfY29kZSwgTEdyYXBoUmVuZGVyUG9pbnRzLmZyYWdtZW50X3NoYWRlcl9jb2RlICk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jb2xvci5zZXQoIHRoaXMucHJvcGVydGllcy5jb2xvciApO1xyXG5cdFx0dGhpcy5jb2xvclszXSA9IHRoaXMucHJvcGVydGllcy5vcGFjaXR5O1xyXG5cclxuXHRcdHZhciBtb2RlbF9tYXRyaXggPSB0aGlzLm1vZGVsX21hdHJpeDtcclxuXHRcdHZhciBtID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcblx0XHRpZihtKVxyXG5cdFx0XHRtb2RlbF9tYXRyaXguc2V0KG0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRtYXQ0LmlkZW50aXR5KCBtb2RlbF9tYXRyaXggKTtcclxuXHJcblx0XHR0aGlzLnVuaWZvcm1zLnVfcG9pbnRfc2l6ZSA9IDE7XHJcblx0XHR2YXIgcHJpbWl0aXZlID0gdGhpcy5wcm9wZXJ0aWVzLnByaW1pdGl2ZTtcclxuXHJcblx0XHRzaGFkZXIudW5pZm9ybXMoIGdsb2JhbF91bmlmb3JtcyApO1xyXG5cdFx0c2hhZGVyLnVuaWZvcm1zKCB0aGlzLnVuaWZvcm1zICk7XHJcblxyXG5cdFx0aWYodGhpcy5wcm9wZXJ0aWVzLm9wYWNpdHkgPj0gMSlcclxuXHRcdFx0Z2wuZGlzYWJsZSggZ2wuQkxFTkQgKTtcclxuXHRcdGVsc2VcclxuXHRcdFx0Z2wuZW5hYmxlKCBnbC5CTEVORCApO1xyXG5cdFx0Z2wuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblx0XHRpZiggdGhpcy5wcm9wZXJ0aWVzLmFkZGl0aXZlIClcclxuXHRcdHtcclxuXHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORSApO1xyXG5cdFx0XHRnbC5kZXB0aE1hc2soIGZhbHNlICk7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XHJcblxyXG5cdFx0dmFyIGluZGljZXMgPSBcImluZGljZXNcIjtcclxuXHRcdGlmKCBtZXNoLmluZGV4QnVmZmVycy50cmlhbmdsZXMgKVxyXG5cdFx0XHRpbmRpY2VzID0gXCJ0cmlhbmdsZXNcIjtcclxuXHRcdHNoYWRlci5kcmF3KCBtZXNoLCBwcmltaXRpdmUsIGluZGljZXMgKTtcclxuXHRcdGdsLmRpc2FibGUoIGdsLkJMRU5EICk7XHJcblx0XHRnbC5kZXB0aE1hc2soIHRydWUgKTtcclxuXHR9XHJcblxyXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcImdlb21ldHJ5L3JlbmRlcl9tZXNoXCIsIExHcmFwaFJlbmRlck1lc2ggKTtcclxuXHJcblx0Ly8qKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuXHJcblx0ZnVuY3Rpb24gTEdyYXBoR2VvbWV0cnlQcmltaXRpdmUoKSB7XHJcblx0XHR0aGlzLmFkZElucHV0KFwic2l6ZVwiLCBcIm51bWJlclwiKTtcclxuXHRcdHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibWVzaFwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHsgdHlwZTogMSwgc2l6ZTogMSwgc3ViZGl2aXNpb25zOiAzMiB9O1xyXG5cclxuXHRcdHRoaXMudmVyc2lvbiA9IChNYXRoLnJhbmRvbSgpICogMTAwMDAwKXwwO1xyXG5cdFx0dGhpcy5sYXN0X2luZm8gPSB7IHR5cGU6IC0xLCBzaXplOiAtMSwgc3ViZGl2aXNpb25zOiAtMSB9O1xyXG5cdH1cclxuXHJcblx0TEdyYXBoR2VvbWV0cnlQcmltaXRpdmUudGl0bGUgPSBcIlByaW1pdGl2ZVwiO1xyXG5cclxuXHRMR3JhcGhHZW9tZXRyeVByaW1pdGl2ZS5WQUxJRCA9IHsgXCJDVUJFXCI6MSwgXCJQTEFORVwiOjIsIFwiQ1lMSU5ERVJcIjozLCBcIlNQSEVSRVwiOjQsIFwiQ0lSQ0xFXCI6NSwgXCJIRU1JU1BIRVJFXCI6NiwgXCJJQ09TQUhFRFJPTlwiOjcsIFwiQ09ORVwiOjgsIFwiUVVBRFwiOjkgfTtcclxuXHRMR3JhcGhHZW9tZXRyeVByaW1pdGl2ZS53aWRnZXRzX2luZm8gPSB7XHJcblx0XHR0eXBlOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaEdlb21ldHJ5UHJpbWl0aXZlLlZBTElEIH1cclxuXHR9O1xyXG5cclxuXHRMR3JhcGhHZW9tZXRyeVByaW1pdGl2ZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0aWYoICF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApIClcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHZhciBzaXplID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJzaXplXCIpO1xyXG5cclxuXHRcdC8vdXBkYXRlXHJcblx0XHRpZiggdGhpcy5sYXN0X2luZm8udHlwZSAhPSB0aGlzLnByb3BlcnRpZXMudHlwZSB8fCB0aGlzLmxhc3RfaW5mby5zaXplICE9IHNpemUgfHwgdGhpcy5sYXN0X2luZm8uc3ViZGl2aXNpb25zICE9IHRoaXMucHJvcGVydGllcy5zdWJkaXZpc2lvbnMgKVxyXG5cdFx0XHR0aGlzLnVwZGF0ZU1lc2goIHRoaXMucHJvcGVydGllcy50eXBlLCBzaXplLCB0aGlzLnByb3BlcnRpZXMuc3ViZGl2aXNpb25zICk7XHJcblxyXG5cdFx0dGhpcy5zZXRPdXRwdXREYXRhKDAsdGhpcy5fbWVzaCk7XHJcblx0fVxyXG5cclxuXHRMR3JhcGhHZW9tZXRyeVByaW1pdGl2ZS5wcm90b3R5cGUudXBkYXRlTWVzaCA9IGZ1bmN0aW9uKHR5cGUsIHNpemUsIHN1YmRpdmlzaW9ucylcclxuXHR7XHJcblx0XHRzdWJkaXZpc2lvbnMgPSBNYXRoLm1heCgwLHN1YmRpdmlzaW9ucyl8MDtcclxuXHJcblx0XHRzd2l0Y2ggKHR5cGUpXHJcblx0XHR7XHJcblx0XHRcdGNhc2UgMTogLy9DVUJFOiBcclxuXHRcdFx0XHR0aGlzLl9tZXNoID0gR0wuTWVzaC5jdWJlKHtzaXplOiBzaXplLCBub3JtYWxzOnRydWUsY29vcmRzOnRydWV9KTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSAyOiAvL1BMQU5FOlxyXG5cdFx0XHRcdHRoaXMuX21lc2ggPSBHTC5NZXNoLnBsYW5lKHtzaXplOiBzaXplLCB4ejogdHJ1ZSwgZGV0YWlsOiBzdWJkaXZpc2lvbnMsIG5vcm1hbHM6dHJ1ZSxjb29yZHM6dHJ1ZX0pO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIDM6IC8vQ1lMSU5ERVI6XHJcblx0XHRcdFx0dGhpcy5fbWVzaCA9IEdMLk1lc2guY3lsaW5kZXIoe3NpemU6IHNpemUsIHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zLCBub3JtYWxzOnRydWUsY29vcmRzOnRydWV9KTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSA0OiAvL1NQSEVSRTpcclxuXHRcdFx0XHR0aGlzLl9tZXNoID0gR0wuTWVzaC5zcGhlcmUoe3NpemU6IHNpemUsIFwibG9uZ1wiOiBzdWJkaXZpc2lvbnMsIGxhdDogc3ViZGl2aXNpb25zLCBub3JtYWxzOnRydWUsY29vcmRzOnRydWV9KTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSA1OiAvL0NJUkNMRTpcclxuXHRcdFx0XHR0aGlzLl9tZXNoID0gR0wuTWVzaC5jaXJjbGUoe3NpemU6IHNpemUsIHNsaWNlczogc3ViZGl2aXNpb25zLCBub3JtYWxzOnRydWUsIGNvb3Jkczp0cnVlfSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgNjogLy9IRU1JU1BIRVJFOlxyXG5cdFx0XHRcdHRoaXMuX21lc2ggPSBHTC5NZXNoLnNwaGVyZSh7c2l6ZTogc2l6ZSwgXCJsb25nXCI6IHN1YmRpdmlzaW9ucywgbGF0OiBzdWJkaXZpc2lvbnMsIG5vcm1hbHM6dHJ1ZSwgY29vcmRzOnRydWUsIGhlbWk6IHRydWV9KTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSA3OiAvL0lDT1NBSEVEUk9OOlxyXG5cdFx0XHRcdHRoaXMuX21lc2ggPSBHTC5NZXNoLmljb3NhaGVkcm9uKHtzaXplOiBzaXplLCBzdWJkaXZpc2lvbnM6c3ViZGl2aXNpb25zIH0pO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIDg6IC8vQ09ORTpcclxuXHRcdFx0XHR0aGlzLl9tZXNoID0gR0wuTWVzaC5jb25lKHtyYWRpdXM6IHNpemUsIGhlaWdodDogc2l6ZSwgc3ViZGl2aXNpb25zOnN1YmRpdmlzaW9ucyB9KTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSA5OiAvL1FVQUQ6XHJcblx0XHRcdFx0dGhpcy5fbWVzaCA9IEdMLk1lc2gucGxhbmUoe3NpemU6IHNpemUsIHh6OiBmYWxzZSwgZGV0YWlsOiBzdWJkaXZpc2lvbnMsIG5vcm1hbHM6dHJ1ZSwgY29vcmRzOnRydWUgfSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5sYXN0X2luZm8udHlwZSA9IHR5cGU7XHJcblx0XHR0aGlzLmxhc3RfaW5mby5zaXplID0gc2l6ZTtcclxuXHRcdHRoaXMubGFzdF9pbmZvLnN1YmRpdmlzaW9ucyA9IHN1YmRpdmlzaW9ucztcclxuXHRcdHRoaXMuX21lc2gudmVyc2lvbiA9IHRoaXMudmVyc2lvbisrO1xyXG5cdH1cclxuXHJcblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoIFwiZ2VvbWV0cnkvbWVzaF9wcmltaXRpdmVcIiwgTEdyYXBoR2VvbWV0cnlQcmltaXRpdmUgKTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIExHcmFwaFJlbmRlclBvaW50cygpIHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcImdlb21ldHJ5XCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcIm1hdDRcIiwgXCJtYXQ0XCIpO1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcInRleFwiLCBcInRleHR1cmVcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XHJcblx0XHRcdGVuYWJsZWQ6IHRydWUsXHJcblx0XHRcdHBvaW50X3NpemU6IDAuMSxcclxuXHRcdFx0Zml4ZWRfc2l6ZTogZmFsc2UsXHJcblx0XHRcdGFkZGl0aXZlOiB0cnVlLFxyXG5cdFx0XHRjb2xvcjogWzEsMSwxXSxcclxuXHRcdFx0b3BhY2l0eTogMVxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmNvbG9yID0gdmVjNC5jcmVhdGUoWzEsMSwxLDFdKTtcclxuXHJcblx0XHR0aGlzLnVuaWZvcm1zID0ge1xyXG5cdFx0XHR1X3BvaW50X3NpemU6IDEsXHJcblx0XHRcdHVfcGVyc3BlY3RpdmU6IDEsXHJcblx0XHRcdHVfcG9pbnRfcGVyc3BlY3RpdmU6IDEsXHJcblx0XHRcdHVfY29sb3I6IHRoaXMuY29sb3JcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeV9pZCA9IC0xO1xyXG5cdFx0dGhpcy52ZXJzaW9uID0gLTE7XHJcblx0XHR0aGlzLm1lc2ggPSBudWxsO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoUmVuZGVyUG9pbnRzLnRpdGxlID0gXCJyZW5kZXJQb2ludHNcIjtcclxuXHRMR3JhcGhSZW5kZXJQb2ludHMuZGVzYyA9IFwicmVuZGVyIHBvaW50cyB3aXRoIGEgdGV4dHVyZVwiO1xyXG5cclxuXHRMR3JhcGhSZW5kZXJQb2ludHMud2lkZ2V0c19pbmZvID0ge1xyXG5cdFx0Y29sb3I6IHsgd2lkZ2V0OiBcImNvbG9yXCIgfVxyXG5cdH07XHJcblxyXG5cdExHcmFwaFJlbmRlclBvaW50cy5wcm90b3R5cGUudXBkYXRlTWVzaCA9IGZ1bmN0aW9uKGdlb21ldHJ5KVxyXG5cdHtcclxuXHRcdHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcclxuXHRcdGlmKCF0aGlzLmJ1ZmZlciB8fCAhdGhpcy5idWZmZXIuZGF0YSB8fCB0aGlzLmJ1ZmZlci5kYXRhLmxlbmd0aCAhPSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGgpXHJcblx0XHRcdHRoaXMuYnVmZmVyID0gbmV3IEdMLkJ1ZmZlciggR0wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeS52ZXJ0aWNlcywzLEdMLkRZTkFNSUNfRFJBVyk7XHJcblx0XHRlbHNlXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuYnVmZmVyLmRhdGEuc2V0KCBnZW9tZXRyeS52ZXJ0aWNlcyApO1xyXG5cdFx0XHR0aGlzLmJ1ZmZlci51cGxvYWQoR0wuRFlOQU1JQ19EUkFXKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZighdGhpcy5tZXNoKVxyXG5cdFx0XHR0aGlzLm1lc2ggPSBuZXcgR0wuTWVzaCgpO1xyXG5cclxuXHRcdHRoaXMubWVzaC5hZGRCdWZmZXIoXCJ2ZXJ0aWNlc1wiLHRoaXMuYnVmZmVyKTtcclxuXHRcdHRoaXMuZ2VvbWV0cnlfaWQgPSB0aGlzLm1lc2guaWQgPSBnZW9tZXRyeS5faWQ7XHJcblx0XHR0aGlzLnZlcnNpb24gPSB0aGlzLm1lc2gudmVyc2lvbiA9IGdlb21ldHJ5Ll92ZXJzaW9uO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoUmVuZGVyUG9pbnRzLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRpZighdGhpcy5wcm9wZXJ0aWVzLmVuYWJsZWQpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdGlmKCFnZW9tZXRyeSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0aWYodGhpcy52ZXJzaW9uICE9IGdlb21ldHJ5Ll92ZXJzaW9uIHx8IHRoaXMuZ2VvbWV0cnlfaWQgIT0gZ2VvbWV0cnkuX2lkIClcclxuXHRcdFx0dGhpcy51cGRhdGVNZXNoKCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdGlmKCFMaXRlR3JhcGguTEdyYXBoUmVuZGVyLm9uUmVxdWVzdENhbWVyYU1hdHJpY2VzKVxyXG5cdFx0e1xyXG5cdFx0XHRjb25zb2xlLndhcm4oXCJjYW5ub3QgcmVuZGVyIGdlb21ldHJ5LCBMaXRlR3JhcGgub25SZXF1ZXN0Q2FtZXJhTWF0cmljZXMgaXMgbnVsbCwgcmVtZW1iZXIgdG8gZmlsbCB0aGlzIHdpdGggYSBjYWxsYmFjayh2aWV3X21hdHJpeCwgcHJvamVjdGlvbl9tYXRyaXgsdmlld3Byb2plY3Rpb25fbWF0cml4KSB0byB1c2UgM0QgcmVuZGVyaW5nIGZyb20gdGhlIGdyYXBoXCIpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0TGl0ZUdyYXBoLkxHcmFwaFJlbmRlci5vblJlcXVlc3RDYW1lcmFNYXRyaWNlcyggdmlld19tYXRyaXgsIHByb2plY3Rpb25fbWF0cml4LHZpZXdwcm9qZWN0aW9uX21hdHJpeCApO1xyXG5cdFx0dmFyIHNoYWRlciA9IG51bGw7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSB0aGlzLmdldElucHV0RGF0YSgyKTtcclxuXHRcdFxyXG5cdFx0aWYodGV4dHVyZSlcclxuXHRcdHtcclxuXHRcdFx0c2hhZGVyID0gZ2wuc2hhZGVyc1tcInRleHR1cmVkX3BvaW50c1wiXTtcclxuXHRcdFx0aWYoIXNoYWRlcilcclxuXHRcdFx0XHRzaGFkZXIgPSBnbC5zaGFkZXJzW1widGV4dHVyZWRfcG9pbnRzXCJdID0gbmV3IEdMLlNoYWRlciggTEdyYXBoUmVuZGVyUG9pbnRzLnZlcnRleF9zaGFkZXJfY29kZSwgTEdyYXBoUmVuZGVyUG9pbnRzLmZyYWdtZW50X3NoYWRlcl9jb2RlLCB7IFVTRV9URVhUVVJFRF9QT0lOVFM6XCJcIiB9KTtcclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdHtcclxuXHRcdFx0c2hhZGVyID0gZ2wuc2hhZGVyc1tcInBvaW50c1wiXTtcclxuXHRcdFx0aWYoIXNoYWRlcilcclxuXHRcdFx0XHRzaGFkZXIgPSBnbC5zaGFkZXJzW1wicG9pbnRzXCJdID0gbmV3IEdMLlNoYWRlciggTEdyYXBoUmVuZGVyUG9pbnRzLnZlcnRleF9zaGFkZXJfY29kZSwgTEdyYXBoUmVuZGVyUG9pbnRzLmZyYWdtZW50X3NoYWRlcl9jb2RlLCB7IFVTRV9QT0lOVFM6IFwiXCIgfSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jb2xvci5zZXQoIHRoaXMucHJvcGVydGllcy5jb2xvciApO1xyXG5cdFx0dGhpcy5jb2xvclszXSA9IHRoaXMucHJvcGVydGllcy5vcGFjaXR5O1xyXG5cclxuXHRcdHZhciBtID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcblx0XHRpZihtKVxyXG5cdFx0XHRtb2RlbF9tYXRyaXguc2V0KG0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRtYXQ0LmlkZW50aXR5KCBtb2RlbF9tYXRyaXggKTtcclxuXHJcblx0XHR0aGlzLnVuaWZvcm1zLnVfcG9pbnRfc2l6ZSA9IHRoaXMucHJvcGVydGllcy5wb2ludF9zaXplO1xyXG5cdFx0dGhpcy51bmlmb3Jtcy51X3BvaW50X3BlcnNwZWN0aXZlID0gdGhpcy5wcm9wZXJ0aWVzLmZpeGVkX3NpemUgPyAwIDogMTtcclxuXHRcdHRoaXMudW5pZm9ybXMudV9wZXJzcGVjdGl2ZSA9IGdsLnZpZXdwb3J0X2RhdGFbM10gKiBwcm9qZWN0aW9uX21hdHJpeFs1XTtcclxuXHJcblx0XHRzaGFkZXIudW5pZm9ybXMoIGdsb2JhbF91bmlmb3JtcyApO1xyXG5cdFx0c2hhZGVyLnVuaWZvcm1zKCB0aGlzLnVuaWZvcm1zICk7XHJcblxyXG5cdFx0aWYodGhpcy5wcm9wZXJ0aWVzLm9wYWNpdHkgPj0gMSlcclxuXHRcdFx0Z2wuZGlzYWJsZSggZ2wuQkxFTkQgKTtcclxuXHRcdGVsc2VcclxuXHRcdFx0Z2wuZW5hYmxlKCBnbC5CTEVORCApO1xyXG5cclxuXHRcdGdsLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cdFx0aWYoIHRoaXMucHJvcGVydGllcy5hZGRpdGl2ZSApXHJcblx0XHR7XHJcblx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkUgKTtcclxuXHRcdFx0Z2wuZGVwdGhNYXNrKCBmYWxzZSApO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xyXG5cclxuXHRcdHNoYWRlci5kcmF3KCB0aGlzLm1lc2gsIEdMLlBPSU5UUyApO1xyXG5cclxuXHRcdGdsLmRpc2FibGUoIGdsLkJMRU5EICk7XHJcblx0XHRnbC5kZXB0aE1hc2soIHRydWUgKTtcclxuXHR9XHJcblxyXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcImdlb21ldHJ5L3JlbmRlcl9wb2ludHNcIiwgTEdyYXBoUmVuZGVyUG9pbnRzICk7XHJcblxyXG5cdExHcmFwaFJlbmRlclBvaW50cy52ZXJ0ZXhfc2hhZGVyX2NvZGUgPSAnXFxcclxuXHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcXHJcblx0XHRhdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleDtcXG5cXFxyXG5cdFx0dmFyeWluZyB2ZWMzIHZfdmVydGV4O1xcblxcXHJcblx0XHRhdHRyaWJ1dGUgdmVjMyBhX25vcm1hbDtcXG5cXFxyXG5cdFx0dmFyeWluZyB2ZWMzIHZfbm9ybWFsO1xcblxcXHJcblx0XHQjaWZkZWYgVVNFX0NPTE9SXFxuXFxcclxuXHRcdFx0YXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5cXFxyXG5cdFx0XHR2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXFxyXG5cdFx0I2VuZGlmXFxuXFxcclxuXHRcdGF0dHJpYnV0ZSB2ZWMyIGFfY29vcmQ7XFxuXFxcclxuXHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXHJcblx0XHQjaWZkZWYgVVNFX1NJWkVcXG5cXFxyXG5cdFx0XHRhdHRyaWJ1dGUgZmxvYXQgYV9leHRyYTtcXG5cXFxyXG5cdFx0I2VuZGlmXFxuXFxcclxuXHRcdCNpZmRlZiBVU0VfSU5TVEFOQ0lOR1xcblxcXHJcblx0XHRcdGF0dHJpYnV0ZSBtYXQ0IHVfbW9kZWw7XFxuXFxcclxuXHRcdCNlbHNlXFxuXFxcclxuXHRcdFx0dW5pZm9ybSBtYXQ0IHVfbW9kZWw7XFxuXFxcclxuXHRcdCNlbmRpZlxcblxcXHJcblx0XHR1bmlmb3JtIG1hdDQgdV92aWV3cHJvamVjdGlvbjtcXG5cXFxyXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3BvaW50X3NpemU7XFxuXFxcclxuXHRcdHVuaWZvcm0gZmxvYXQgdV9wZXJzcGVjdGl2ZTtcXG5cXFxyXG5cdFx0dW5pZm9ybSBmbG9hdCB1X3BvaW50X3BlcnNwZWN0aXZlO1xcblxcXHJcblx0XHRmbG9hdCBjb21wdXRlUG9pbnRTaXplKGZsb2F0IHJhZGl1cywgZmxvYXQgdylcXG5cXFxyXG5cdFx0e1xcblxcXHJcblx0XHRcdGlmKHJhZGl1cyA8IDAuMClcXG5cXFxyXG5cdFx0XHRcdHJldHVybiAtcmFkaXVzO1xcblxcXHJcblx0XHRcdHJldHVybiB1X3BlcnNwZWN0aXZlICogcmFkaXVzIC8gdztcXG5cXFxyXG5cdFx0fVxcblxcXHJcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcclxuXHRcdFx0dl9jb29yZCA9IGFfY29vcmQ7XFxuXFxcclxuXHRcdFx0I2lmZGVmIFVTRV9DT0xPUlxcblxcXHJcblx0XHRcdFx0dl9jb2xvciA9IGFfY29sb3I7XFxuXFxcclxuXHRcdFx0I2VuZGlmXFxuXFxcclxuXHRcdFx0dl92ZXJ0ZXggPSAoIHVfbW9kZWwgKiB2ZWM0KCBhX3ZlcnRleCwgMS4wICkpLnh5ejtcXG5cXFxyXG5cdFx0XHR2X25vcm1hbCA9ICggdV9tb2RlbCAqIHZlYzQoIGFfbm9ybWFsLCAwLjAgKSkueHl6O1xcblxcXHJcblx0XHRcdGdsX1Bvc2l0aW9uID0gdV92aWV3cHJvamVjdGlvbiAqIHZlYzQodl92ZXJ0ZXgsMS4wKTtcXG5cXFxyXG5cdFx0XHRnbF9Qb2ludFNpemUgPSB1X3BvaW50X3NpemU7XFxuXFxcclxuXHRcdFx0I2lmZGVmIFVTRV9TSVpFXFxuXFxcclxuXHRcdFx0XHRnbF9Qb2ludFNpemUgPSBhX2V4dHJhO1xcblxcXHJcblx0XHRcdCNlbmRpZlxcblxcXHJcblx0XHRcdGlmKHVfcG9pbnRfcGVyc3BlY3RpdmUgIT0gMC4wKVxcblxcXHJcblx0XHRcdFx0Z2xfUG9pbnRTaXplID0gY29tcHV0ZVBvaW50U2l6ZSggZ2xfUG9pbnRTaXplLCBnbF9Qb3NpdGlvbi53ICk7XFxuXFxcclxuXHRcdH1cXFxyXG5cdCc7XHJcblxyXG5cdExHcmFwaFJlbmRlclBvaW50cy5mcmFnbWVudF9zaGFkZXJfY29kZSA9ICdcXFxyXG5cdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxcclxuXHRcdHVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcblxcXHJcblx0XHQjaWZkZWYgVVNFX0NPTE9SXFxuXFxcclxuXHRcdFx0dmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxcclxuXHRcdCNlbmRpZlxcblxcXHJcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxyXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXHJcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcclxuXHRcdFx0dmVjNCBjb2xvciA9IHVfY29sb3I7XFxuXFxcclxuXHRcdFx0I2lmZGVmIFVTRV9URVhUVVJFRF9QT0lOVFNcXG5cXFxyXG5cdFx0XHRcdGNvbG9yICo9IHRleHR1cmUyRCh1X3RleHR1cmUsIGdsX1BvaW50Q29vcmQueHkpO1xcblxcXHJcblx0XHRcdCNlbHNlXFxuXFxcclxuXHRcdFx0XHQjaWZkZWYgVVNFX1RFWFRVUkVcXG5cXFxyXG5cdFx0XHRcdCAgY29sb3IgKj0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCk7XFxuXFxcclxuXHRcdFx0XHQgIGlmKGNvbG9yLmEgPCAwLjEpXFxuXFxcclxuXHRcdFx0XHRcdGRpc2NhcmQ7XFxuXFxcclxuXHRcdFx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0XHRcdCNpZmRlZiBVU0VfUE9JTlRTXFxuXFxcclxuXHRcdFx0XHRcdGZsb2F0IGRpc3QgPSBsZW5ndGgoIGdsX1BvaW50Q29vcmQueHkgLSB2ZWMyKDAuNSkgKTtcXG5cXFxyXG5cdFx0XHRcdFx0aWYoIGRpc3QgPiAwLjQ1IClcXG5cXFxyXG5cdFx0XHRcdFx0XHRkaXNjYXJkO1xcblxcXHJcblx0XHRcdFx0I2VuZGlmXFxuXFxcclxuXHRcdFx0I2VuZGlmXFxuXFxcclxuXHRcdFx0I2lmZGVmIFVTRV9DT0xPUlxcblxcXHJcblx0XHRcdFx0Y29sb3IgKj0gdl9jb2xvcjtcXG5cXFxyXG5cdFx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cXFxyXG5cdFx0fVxcXHJcblx0JztcclxuXHJcblx0Ly9iYXNlZCBvbiBodHRwczovL2luY29udmVyZ2VudC5uZXQvMjAxOS9kZXB0aC1vZi1maWVsZC9cclxuXHQvKlxyXG5cdGZ1bmN0aW9uIExHcmFwaFJlbmRlckdlb21ldHJ5RE9GKCkge1xyXG5cdFx0dGhpcy5hZGRJbnB1dChcImluXCIsIFwiZ2VvbWV0cnlcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwibWF0NFwiLCBcIm1hdDRcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwidGV4XCIsIFwidGV4dHVyZVwiKTtcclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcclxuXHRcdFx0ZW5hYmxlZDogdHJ1ZSxcclxuXHRcdFx0bGluZXM6IHRydWUsXHJcblx0XHRcdHBvaW50X3NpemU6IDAuMSxcclxuXHRcdFx0Zml4ZWRfc2l6ZTogZmFsc2UsXHJcblx0XHRcdGFkZGl0aXZlOiB0cnVlLFxyXG5cdFx0XHRjb2xvcjogWzEsMSwxXSxcclxuXHRcdFx0b3BhY2l0eTogMVxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmNvbG9yID0gdmVjNC5jcmVhdGUoWzEsMSwxLDFdKTtcclxuXHJcblx0XHR0aGlzLnVuaWZvcm1zID0ge1xyXG5cdFx0XHR1X3BvaW50X3NpemU6IDEsXHJcblx0XHRcdHVfcGVyc3BlY3RpdmU6IDEsXHJcblx0XHRcdHVfcG9pbnRfcGVyc3BlY3RpdmU6IDEsXHJcblx0XHRcdHVfY29sb3I6IHRoaXMuY29sb3JcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeV9pZCA9IC0xO1xyXG5cdFx0dGhpcy52ZXJzaW9uID0gLTE7XHJcblx0XHR0aGlzLm1lc2ggPSBudWxsO1xyXG5cdH1cclxuXHJcblx0TEdyYXBoUmVuZGVyR2VvbWV0cnlET0Yud2lkZ2V0c19pbmZvID0ge1xyXG5cdFx0Y29sb3I6IHsgd2lkZ2V0OiBcImNvbG9yXCIgfVxyXG5cdH07XHJcblxyXG5cdExHcmFwaFJlbmRlckdlb21ldHJ5RE9GLnByb3RvdHlwZS51cGRhdGVNZXNoID0gZnVuY3Rpb24oZ2VvbWV0cnkpXHJcblx0e1xyXG5cdFx0dmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xyXG5cdFx0aWYoIXRoaXMuYnVmZmVyIHx8IHRoaXMuYnVmZmVyLmRhdGEubGVuZ3RoICE9IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aClcclxuXHRcdFx0dGhpcy5idWZmZXIgPSBuZXcgR0wuQnVmZmVyKCBHTC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5LnZlcnRpY2VzLDMsR0wuRFlOQU1JQ19EUkFXKTtcclxuXHRcdGVsc2VcclxuXHRcdHtcclxuXHRcdFx0dGhpcy5idWZmZXIuZGF0YS5zZXQoIGdlb21ldHJ5LnZlcnRpY2VzICk7XHJcblx0XHRcdHRoaXMuYnVmZmVyLnVwbG9hZChHTC5EWU5BTUlDX0RSQVcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKCF0aGlzLm1lc2gpXHJcblx0XHRcdHRoaXMubWVzaCA9IG5ldyBHTC5NZXNoKCk7XHJcblxyXG5cdFx0dGhpcy5tZXNoLmFkZEJ1ZmZlcihcInZlcnRpY2VzXCIsdGhpcy5idWZmZXIpO1xyXG5cdFx0dGhpcy5nZW9tZXRyeV9pZCA9IHRoaXMubWVzaC5pZCA9IGdlb21ldHJ5Ll9pZDtcclxuXHRcdHRoaXMudmVyc2lvbiA9IHRoaXMubWVzaC52ZXJzaW9uID0gZ2VvbWV0cnkuX3ZlcnNpb247XHJcblx0fVxyXG5cclxuXHRMR3JhcGhSZW5kZXJHZW9tZXRyeURPRi5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0aWYoIXRoaXMucHJvcGVydGllcy5lbmFibGVkKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcblx0XHRpZighZ2VvbWV0cnkpXHJcblx0XHRcdHJldHVybjtcclxuXHRcdGlmKHRoaXMudmVyc2lvbiAhPSBnZW9tZXRyeS5fdmVyc2lvbiB8fCB0aGlzLmdlb21ldHJ5X2lkICE9IGdlb21ldHJ5Ll9pZCApXHJcblx0XHRcdHRoaXMudXBkYXRlTWVzaCggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRpZighTGl0ZUdyYXBoLkxHcmFwaFJlbmRlci5vblJlcXVlc3RDYW1lcmFNYXRyaWNlcylcclxuXHRcdHtcclxuXHRcdFx0Y29uc29sZS53YXJuKFwiY2Fubm90IHJlbmRlciBnZW9tZXRyeSwgTGl0ZUdyYXBoLm9uUmVxdWVzdENhbWVyYU1hdHJpY2VzIGlzIG51bGwsIHJlbWVtYmVyIHRvIGZpbGwgdGhpcyB3aXRoIGEgY2FsbGJhY2sodmlld19tYXRyaXgsIHByb2plY3Rpb25fbWF0cml4LHZpZXdwcm9qZWN0aW9uX21hdHJpeCkgdG8gdXNlIDNEIHJlbmRlcmluZyBmcm9tIHRoZSBncmFwaFwiKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdExpdGVHcmFwaC5MR3JhcGhSZW5kZXIub25SZXF1ZXN0Q2FtZXJhTWF0cmljZXMoIHZpZXdfbWF0cml4LCBwcm9qZWN0aW9uX21hdHJpeCx2aWV3cHJvamVjdGlvbl9tYXRyaXggKTtcclxuXHRcdHZhciBzaGFkZXIgPSBudWxsO1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XHJcblx0XHRcclxuXHRcdGlmKHRleHR1cmUpXHJcblx0XHR7XHJcblx0XHRcdHNoYWRlciA9IGdsLnNoYWRlcnNbXCJ0ZXh0dXJlZF9wb2ludHNcIl07XHJcblx0XHRcdGlmKCFzaGFkZXIpXHJcblx0XHRcdFx0c2hhZGVyID0gZ2wuc2hhZGVyc1tcInRleHR1cmVkX3BvaW50c1wiXSA9IG5ldyBHTC5TaGFkZXIoIExHcmFwaFJlbmRlckdlb21ldHJ5RE9GLnZlcnRleF9zaGFkZXJfY29kZSwgTEdyYXBoUmVuZGVyR2VvbWV0cnlET0YuZnJhZ21lbnRfc2hhZGVyX2NvZGUsIHsgVVNFX1RFWFRVUkVEX1BPSU5UUzpcIlwiIH0pO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0e1xyXG5cdFx0XHRzaGFkZXIgPSBnbC5zaGFkZXJzW1wicG9pbnRzXCJdO1xyXG5cdFx0XHRpZighc2hhZGVyKVxyXG5cdFx0XHRcdHNoYWRlciA9IGdsLnNoYWRlcnNbXCJwb2ludHNcIl0gPSBuZXcgR0wuU2hhZGVyKCBMR3JhcGhSZW5kZXJHZW9tZXRyeURPRi52ZXJ0ZXhfc2hhZGVyX2NvZGUsIExHcmFwaFJlbmRlckdlb21ldHJ5RE9GLmZyYWdtZW50X3NoYWRlcl9jb2RlLCB7IFVTRV9QT0lOVFM6IFwiXCIgfSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jb2xvci5zZXQoIHRoaXMucHJvcGVydGllcy5jb2xvciApO1xyXG5cdFx0dGhpcy5jb2xvclszXSA9IHRoaXMucHJvcGVydGllcy5vcGFjaXR5O1xyXG5cclxuXHRcdHZhciBtID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcblx0XHRpZihtKVxyXG5cdFx0XHRtb2RlbF9tYXRyaXguc2V0KG0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRtYXQ0LmlkZW50aXR5KCBtb2RlbF9tYXRyaXggKTtcclxuXHJcblx0XHR0aGlzLnVuaWZvcm1zLnVfcG9pbnRfc2l6ZSA9IHRoaXMucHJvcGVydGllcy5wb2ludF9zaXplO1xyXG5cdFx0dGhpcy51bmlmb3Jtcy51X3BvaW50X3BlcnNwZWN0aXZlID0gdGhpcy5wcm9wZXJ0aWVzLmZpeGVkX3NpemUgPyAwIDogMTtcclxuXHRcdHRoaXMudW5pZm9ybXMudV9wZXJzcGVjdGl2ZSA9IGdsLnZpZXdwb3J0X2RhdGFbM10gKiBwcm9qZWN0aW9uX21hdHJpeFs1XTtcclxuXHJcblx0XHRzaGFkZXIudW5pZm9ybXMoIGdsb2JhbF91bmlmb3JtcyApO1xyXG5cdFx0c2hhZGVyLnVuaWZvcm1zKCB0aGlzLnVuaWZvcm1zICk7XHJcblxyXG5cdFx0aWYodGhpcy5wcm9wZXJ0aWVzLm9wYWNpdHkgPj0gMSlcclxuXHRcdFx0Z2wuZGlzYWJsZSggZ2wuQkxFTkQgKTtcclxuXHRcdGVsc2VcclxuXHRcdFx0Z2wuZW5hYmxlKCBnbC5CTEVORCApO1xyXG5cclxuXHRcdGdsLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cdFx0aWYoIHRoaXMucHJvcGVydGllcy5hZGRpdGl2ZSApXHJcblx0XHR7XHJcblx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkUgKTtcclxuXHRcdFx0Z2wuZGVwdGhNYXNrKCBmYWxzZSApO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xyXG5cclxuXHRcdHNoYWRlci5kcmF3KCB0aGlzLm1lc2gsIEdMLlBPSU5UUyApO1xyXG5cclxuXHRcdGdsLmRpc2FibGUoIGdsLkJMRU5EICk7XHJcblx0XHRnbC5kZXB0aE1hc2soIHRydWUgKTtcclxuXHR9XHJcblxyXG5cdExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKCBcImdlb21ldHJ5L3JlbmRlcl9kb2ZcIiwgTEdyYXBoUmVuZGVyR2VvbWV0cnlET0YgKTtcclxuXHJcblx0TEdyYXBoUmVuZGVyR2VvbWV0cnlET0YudmVydGV4X3NoYWRlcl9jb2RlID0gJ1xcXHJcblx0XHRwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXFxyXG5cdFx0YXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXg7XFxuXFxcclxuXHRcdHZhcnlpbmcgdmVjMyB2X3ZlcnRleDtcXG5cXFxyXG5cdFx0YXR0cmlidXRlIHZlYzMgYV9ub3JtYWw7XFxuXFxcclxuXHRcdHZhcnlpbmcgdmVjMyB2X25vcm1hbDtcXG5cXFxyXG5cdFx0I2lmZGVmIFVTRV9DT0xPUlxcblxcXHJcblx0XHRcdGF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxuXFxcclxuXHRcdFx0dmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxcclxuXHRcdCNlbmRpZlxcblxcXHJcblx0XHRhdHRyaWJ1dGUgdmVjMiBhX2Nvb3JkO1xcblxcXHJcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxyXG5cdFx0I2lmZGVmIFVTRV9TSVpFXFxuXFxcclxuXHRcdFx0YXR0cmlidXRlIGZsb2F0IGFfZXh0cmE7XFxuXFxcclxuXHRcdCNlbmRpZlxcblxcXHJcblx0XHQjaWZkZWYgVVNFX0lOU1RBTkNJTkdcXG5cXFxyXG5cdFx0XHRhdHRyaWJ1dGUgbWF0NCB1X21vZGVsO1xcblxcXHJcblx0XHQjZWxzZVxcblxcXHJcblx0XHRcdHVuaWZvcm0gbWF0NCB1X21vZGVsO1xcblxcXHJcblx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0dW5pZm9ybSBtYXQ0IHVfdmlld3Byb2plY3Rpb247XFxuXFxcclxuXHRcdHVuaWZvcm0gZmxvYXQgdV9wb2ludF9zaXplO1xcblxcXHJcblx0XHR1bmlmb3JtIGZsb2F0IHVfcGVyc3BlY3RpdmU7XFxuXFxcclxuXHRcdHVuaWZvcm0gZmxvYXQgdV9wb2ludF9wZXJzcGVjdGl2ZTtcXG5cXFxyXG5cdFx0ZmxvYXQgY29tcHV0ZVBvaW50U2l6ZShmbG9hdCByYWRpdXMsIGZsb2F0IHcpXFxuXFxcclxuXHRcdHtcXG5cXFxyXG5cdFx0XHRpZihyYWRpdXMgPCAwLjApXFxuXFxcclxuXHRcdFx0XHRyZXR1cm4gLXJhZGl1cztcXG5cXFxyXG5cdFx0XHRyZXR1cm4gdV9wZXJzcGVjdGl2ZSAqIHJhZGl1cyAvIHc7XFxuXFxcclxuXHRcdH1cXG5cXFxyXG5cdFx0dm9pZCBtYWluKCkge1xcblxcXHJcblx0XHRcdHZfY29vcmQgPSBhX2Nvb3JkO1xcblxcXHJcblx0XHRcdCNpZmRlZiBVU0VfQ09MT1JcXG5cXFxyXG5cdFx0XHRcdHZfY29sb3IgPSBhX2NvbG9yO1xcblxcXHJcblx0XHRcdCNlbmRpZlxcblxcXHJcblx0XHRcdHZfdmVydGV4ID0gKCB1X21vZGVsICogdmVjNCggYV92ZXJ0ZXgsIDEuMCApKS54eXo7XFxuXFxcclxuXHRcdFx0dl9ub3JtYWwgPSAoIHVfbW9kZWwgKiB2ZWM0KCBhX25vcm1hbCwgMC4wICkpLnh5ejtcXG5cXFxyXG5cdFx0XHRnbF9Qb3NpdGlvbiA9IHVfdmlld3Byb2plY3Rpb24gKiB2ZWM0KHZfdmVydGV4LDEuMCk7XFxuXFxcclxuXHRcdFx0Z2xfUG9pbnRTaXplID0gdV9wb2ludF9zaXplO1xcblxcXHJcblx0XHRcdCNpZmRlZiBVU0VfU0laRVxcblxcXHJcblx0XHRcdFx0Z2xfUG9pbnRTaXplID0gYV9leHRyYTtcXG5cXFxyXG5cdFx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0XHRpZih1X3BvaW50X3BlcnNwZWN0aXZlICE9IDAuMClcXG5cXFxyXG5cdFx0XHRcdGdsX1BvaW50U2l6ZSA9IGNvbXB1dGVQb2ludFNpemUoIGdsX1BvaW50U2l6ZSwgZ2xfUG9zaXRpb24udyApO1xcblxcXHJcblx0XHR9XFxcclxuXHQnO1xyXG5cclxuXHRMR3JhcGhSZW5kZXJHZW9tZXRyeURPRi5mcmFnbWVudF9zaGFkZXJfY29kZSA9ICdcXFxyXG5cdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxcclxuXHRcdHVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcblxcXHJcblx0XHQjaWZkZWYgVVNFX0NPTE9SXFxuXFxcclxuXHRcdFx0dmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxcclxuXHRcdCNlbmRpZlxcblxcXHJcblx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxyXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXHJcblx0XHR2b2lkIG1haW4oKSB7XFxuXFxcclxuXHRcdFx0dmVjNCBjb2xvciA9IHVfY29sb3I7XFxuXFxcclxuXHRcdFx0I2lmZGVmIFVTRV9URVhUVVJFRF9QT0lOVFNcXG5cXFxyXG5cdFx0XHRcdGNvbG9yICo9IHRleHR1cmUyRCh1X3RleHR1cmUsIGdsX1BvaW50Q29vcmQueHkpO1xcblxcXHJcblx0XHRcdCNlbHNlXFxuXFxcclxuXHRcdFx0XHQjaWZkZWYgVVNFX1RFWFRVUkVcXG5cXFxyXG5cdFx0XHRcdCAgY29sb3IgKj0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCk7XFxuXFxcclxuXHRcdFx0XHQgIGlmKGNvbG9yLmEgPCAwLjEpXFxuXFxcclxuXHRcdFx0XHRcdGRpc2NhcmQ7XFxuXFxcclxuXHRcdFx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0XHRcdCNpZmRlZiBVU0VfUE9JTlRTXFxuXFxcclxuXHRcdFx0XHRcdGZsb2F0IGRpc3QgPSBsZW5ndGgoIGdsX1BvaW50Q29vcmQueHkgLSB2ZWMyKDAuNSkgKTtcXG5cXFxyXG5cdFx0XHRcdFx0aWYoIGRpc3QgPiAwLjQ1IClcXG5cXFxyXG5cdFx0XHRcdFx0XHRkaXNjYXJkO1xcblxcXHJcblx0XHRcdFx0I2VuZGlmXFxuXFxcclxuXHRcdFx0I2VuZGlmXFxuXFxcclxuXHRcdFx0I2lmZGVmIFVTRV9DT0xPUlxcblxcXHJcblx0XHRcdFx0Y29sb3IgKj0gdl9jb2xvcjtcXG5cXFxyXG5cdFx0XHQjZW5kaWZcXG5cXFxyXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cXFxyXG5cdFx0fVxcXHJcblx0JztcclxuXHQqL1xyXG5cclxuXHJcblxyXG59KSh0aGlzKTtcbihmdW5jdGlvbihnbG9iYWwpIHtcclxuICAgIHZhciBMaXRlR3JhcGggPSBnbG9iYWwuTGl0ZUdyYXBoO1xyXG4gICAgdmFyIExHcmFwaFRleHR1cmUgPSBnbG9iYWwuTEdyYXBoVGV4dHVyZTtcclxuXHJcbiAgICAvL1dvcmtzIHdpdGggTGl0ZWdsLmpzIHRvIGNyZWF0ZSBXZWJHTCBub2Rlc1xyXG4gICAgaWYgKHR5cGVvZiBHTCAhPSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgLy8gVGV4dHVyZSBMZW5zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICAgICAgZnVuY3Rpb24gTEdyYXBoRlhMZW5zKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQoXCJBYmVycmF0aW9uXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0KFwiRGlzdG9ydGlvblwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dChcIkJsdXJcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgICAgIGFiZXJyYXRpb246IDEuMCxcclxuICAgICAgICAgICAgICAgIGRpc3RvcnRpb246IDEuMCxcclxuICAgICAgICAgICAgICAgIGJsdXI6IDEuMCxcclxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAoIUxHcmFwaEZYTGVucy5fc2hhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBMR3JhcGhGWExlbnMuX3NoYWRlciA9IG5ldyBHTC5TaGFkZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgR0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxyXG4gICAgICAgICAgICAgICAgICAgIExHcmFwaEZYTGVucy5waXhlbF9zaGFkZXJcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBMR3JhcGhGWExlbnMuX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSgzLCAxLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBnbC5SR0IsXHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcDogZ2wuQ0xBTVBfVE9fRURHRSxcclxuICAgICAgICAgICAgICAgICAgICBtYWdGaWx0ZXI6IGdsLkxJTkVBUixcclxuICAgICAgICAgICAgICAgICAgICBtaW5GaWx0ZXI6IGdsLkxJTkVBUixcclxuICAgICAgICAgICAgICAgICAgICBwaXhlbF9kYXRhOiBbMjU1LCAwLCAwLCAwLCAyNTUsIDAsIDAsIDAsIDI1NV1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBMR3JhcGhGWExlbnMudGl0bGUgPSBcIkxlbnNcIjtcclxuICAgICAgICBMR3JhcGhGWExlbnMuZGVzYyA9IFwiQ2FtZXJhIExlbnMgZGlzdG9ydGlvblwiO1xyXG4gICAgICAgIExHcmFwaEZYTGVucy53aWRnZXRzX2luZm8gPSB7XHJcbiAgICAgICAgICAgIHByZWNpc2lvbjogeyB3aWRnZXQ6IFwiY29tYm9cIiwgdmFsdWVzOiBMR3JhcGhUZXh0dXJlLk1PREVfVkFMVUVTIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBMR3JhcGhGWExlbnMucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLlBBU1NfVEhST1VHSCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghdGV4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3RleCA9IExHcmFwaFRleHR1cmUuZ2V0VGFyZ2V0VGV4dHVyZShcclxuICAgICAgICAgICAgICAgIHRleCxcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RleCxcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5wcmVjaXNpb25cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhYmVycmF0aW9uID0gdGhpcy5wcm9wZXJ0aWVzLmFiZXJyYXRpb247XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5wdXRDb25uZWN0ZWQoMSkpIHtcclxuICAgICAgICAgICAgICAgIGFiZXJyYXRpb24gPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5hYmVycmF0aW9uID0gYWJlcnJhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRpc3RvcnRpb24gPSB0aGlzLnByb3BlcnRpZXMuZGlzdG9ydGlvbjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnB1dENvbm5lY3RlZCgyKSkge1xyXG4gICAgICAgICAgICAgICAgZGlzdG9ydGlvbiA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmRpc3RvcnRpb24gPSBkaXN0b3J0aW9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgYmx1ciA9IHRoaXMucHJvcGVydGllcy5ibHVyO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0lucHV0Q29ubmVjdGVkKDMpKSB7XHJcbiAgICAgICAgICAgICAgICBibHVyID0gdGhpcy5nZXRJbnB1dERhdGEoMyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuYmx1ciA9IGJsdXI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG4gICAgICAgICAgICB2YXIgbWVzaCA9IE1lc2guZ2V0U2NyZWVuUXVhZCgpO1xyXG4gICAgICAgICAgICB2YXIgc2hhZGVyID0gTEdyYXBoRlhMZW5zLl9zaGFkZXI7XHJcbiAgICAgICAgICAgIC8vdmFyIGNhbWVyYSA9IExTLlJlbmRlcmVyLl9jdXJyZW50X2NhbWVyYTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3RleC5kcmF3VG8oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXguYmluZCgwKTtcclxuICAgICAgICAgICAgICAgIHNoYWRlclxyXG4gICAgICAgICAgICAgICAgICAgIC51bmlmb3Jtcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfdGV4dHVyZTogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV9hYmVycmF0aW9uOiBhYmVycmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X2Rpc3RvcnRpb246IGRpc3RvcnRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfYmx1cjogYmx1clxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmRyYXcobWVzaCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgTEdyYXBoRlhMZW5zLnBpeGVsX3NoYWRlciA9XHJcbiAgICAgICAgICAgIFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXHJcblx0XHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxyXG5cdFx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSB2ZWMyIHVfY2FtZXJhX3BsYW5lcztcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfYWJlcnJhdGlvbjtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfZGlzdG9ydGlvbjtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfYmx1cjtcXG5cXFxyXG5cdFx0XHRcXG5cXFxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XFxuXFxcclxuXHRcdFx0XHR2ZWMyIGNvb3JkID0gdl9jb29yZDtcXG5cXFxyXG5cdFx0XHRcdGZsb2F0IGRpc3QgPSBkaXN0YW5jZSh2ZWMyKDAuNSksIGNvb3JkKTtcXG5cXFxyXG5cdFx0XHRcdHZlYzIgZGlzdF9jb29yZCA9IGNvb3JkIC0gdmVjMigwLjUpO1xcblxcXHJcblx0XHRcdFx0ZmxvYXQgcGVyY2VudCA9IDEuMCArICgoMC41IC0gZGlzdCkgLyAwLjUpICogdV9kaXN0b3J0aW9uO1xcblxcXHJcblx0XHRcdFx0ZGlzdF9jb29yZCAqPSBwZXJjZW50O1xcblxcXHJcblx0XHRcdFx0Y29vcmQgPSBkaXN0X2Nvb3JkICsgdmVjMigwLjUpO1xcblxcXHJcblx0XHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsY29vcmQsIHVfYmx1ciAqIGRpc3QpO1xcblxcXHJcblx0XHRcdFx0Y29sb3IuciA9IHRleHR1cmUyRCh1X3RleHR1cmUsdmVjMigwLjUpICsgZGlzdF9jb29yZCAqICgxLjArMC4wMSp1X2FiZXJyYXRpb24pLCB1X2JsdXIgKiBkaXN0ICkucjtcXG5cXFxyXG5cdFx0XHRcdGNvbG9yLmIgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLHZlYzIoMC41KSArIGRpc3RfY29vcmQgKiAoMS4wLTAuMDEqdV9hYmVycmF0aW9uKSwgdV9ibHVyICogZGlzdCApLmI7XFxuXFxcclxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cXFxyXG5cdFx0XHR9XFxuXFxcclxuXHRcdFx0XCI7XHJcbiAgICAgICAgLypcclxuXHRcdFx0ZmxvYXQgbm9ybWFsaXplZF90dW5hYmxlX3NpZ21vaWQoZmxvYXQgeHMsIGZsb2F0IGspXFxuXFxcclxuXHRcdFx0e1xcblxcXHJcblx0XHRcdFx0eHMgPSB4cyAqIDIuMCAtIDEuMDtcXG5cXFxyXG5cdFx0XHRcdGZsb2F0IHNpZ254ID0gc2lnbih4cyk7XFxuXFxcclxuXHRcdFx0XHRmbG9hdCBhYnN4ID0gYWJzKHhzKTtcXG5cXFxyXG5cdFx0XHRcdHJldHVybiBzaWdueCAqICgoLWsgLSAxLjApKmFic3gpLygyLjAqKC0yLjAqayphYnN4K2stMS4wKSkgKyAwLjU7XFxuXFxcclxuXHRcdFx0fVxcblxcXHJcblx0XHQqL1xyXG5cclxuICAgICAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImZ4L2xlbnNcIiwgTEdyYXBoRlhMZW5zKTtcclxuICAgICAgICBnbG9iYWwuTEdyYXBoRlhMZW5zID0gTEdyYXBoRlhMZW5zO1xyXG5cclxuICAgICAgICAvKiBub3Qgd29ya2luZyB5ZXRcclxuXHRmdW5jdGlvbiBMR3JhcGhEZXB0aE9mRmllbGQoKVxyXG5cdHtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJDb2xvclwiLFwiVGV4dHVyZVwiKTtcclxuXHRcdHRoaXMuYWRkSW5wdXQoXCJMaW5lYXIgRGVwdGhcIixcIlRleHR1cmVcIik7XHJcblx0XHR0aGlzLmFkZElucHV0KFwiQ2FtZXJhXCIsXCJjYW1lcmFcIik7XHJcblx0XHR0aGlzLmFkZE91dHB1dChcIlRleHR1cmVcIixcIlRleHR1cmVcIik7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7IGhpZ2hfcHJlY2lzaW9uOiBmYWxzZSB9O1xyXG5cdH1cclxuXHJcblx0TEdyYXBoRGVwdGhPZkZpZWxkLnRpdGxlID0gXCJEZXB0aCBPZiBGaWVsZFwiO1xyXG5cdExHcmFwaERlcHRoT2ZGaWVsZC5kZXNjID0gXCJBcHBsaWVzIGEgZGVwdGggb2YgZmllbGQgZWZmZWN0XCI7XHJcblxyXG5cdExHcmFwaERlcHRoT2ZGaWVsZC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuXHRcdHZhciBkZXB0aCA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG5cdFx0dmFyIGNhbWVyYSA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xyXG5cclxuXHRcdGlmKCF0ZXggfHwgIWRlcHRoIHx8ICFjYW1lcmEpIFxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmVjaXNpb24gPSBnbC5VTlNJR05FRF9CWVRFO1xyXG5cdFx0aWYodGhpcy5wcm9wZXJ0aWVzLmhpZ2hfcHJlY2lzaW9uKVxyXG5cdFx0XHRwcmVjaXNpb24gPSBnbC5oYWxmX2Zsb2F0X2V4dCA/IGdsLkhBTEZfRkxPQVRfT0VTIDogZ2wuRkxPQVQ7XHRcdFx0XHJcblx0XHRpZighdGhpcy5fdGVtcF90ZXh0dXJlIHx8IHRoaXMuX3RlbXBfdGV4dHVyZS50eXBlICE9IHByZWNpc2lvbiB8fFxyXG5cdFx0XHR0aGlzLl90ZW1wX3RleHR1cmUud2lkdGggIT0gdGV4LndpZHRoIHx8IHRoaXMuX3RlbXBfdGV4dHVyZS5oZWlnaHQgIT0gdGV4LmhlaWdodClcclxuXHRcdFx0dGhpcy5fdGVtcF90ZXh0dXJlID0gbmV3IEdMLlRleHR1cmUoIHRleC53aWR0aCwgdGV4LmhlaWdodCwgeyB0eXBlOiBwcmVjaXNpb24sIGZvcm1hdDogZ2wuUkdCQSwgZmlsdGVyOiBnbC5MSU5FQVIgfSk7XHJcblxyXG5cdFx0dmFyIHNoYWRlciA9IExHcmFwaERlcHRoT2ZGaWVsZC5fc2hhZGVyID0gbmV3IEdMLlNoYWRlciggR0wuU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLCBMR3JhcGhEZXB0aE9mRmllbGQuX3BpeGVsX3NoYWRlciApO1xyXG5cclxuXHRcdHZhciBzY3JlZW5fbWVzaCA9IE1lc2guZ2V0U2NyZWVuUXVhZCgpO1xyXG5cclxuXHRcdGdsLmRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcclxuXHRcdGdsLmRpc2FibGUoIGdsLkJMRU5EICk7XHJcblxyXG5cdFx0dmFyIGNhbWVyYV9wb3NpdGlvbiA9IGNhbWVyYS5nZXRFeWUoKTtcclxuXHRcdHZhciBmb2N1c19wb2ludCA9IGNhbWVyYS5nZXRDZW50ZXIoKTtcclxuXHRcdHZhciBkaXN0YW5jZSA9IHZlYzMuZGlzdGFuY2UoIGNhbWVyYV9wb3NpdGlvbiwgZm9jdXNfcG9pbnQgKTtcclxuXHRcdHZhciBmYXIgPSBjYW1lcmEuZmFyO1xyXG5cdFx0dmFyIGZvY3VzX3JhbmdlID0gZGlzdGFuY2UgKiAwLjU7XHJcblxyXG5cdFx0dGhpcy5fdGVtcF90ZXh0dXJlLmRyYXdUbyggZnVuY3Rpb24oKSB7XHJcblx0XHRcdHRleC5iaW5kKDApO1xyXG5cdFx0XHRkZXB0aC5iaW5kKDEpO1xyXG5cdFx0XHRzaGFkZXIudW5pZm9ybXMoe3VfdGV4dHVyZTowLCB1X2RlcHRoX3RleHR1cmU6MSwgdV9yZXNvbHV0aW9uOiBbMS90ZXgud2lkdGgsIDEvdGV4LmhlaWdodF0sIHVfZmFyOiBmYXIsIHVfZm9jdXNfcG9pbnQ6IGRpc3RhbmNlLCB1X2ZvY3VzX3NjYWxlOiBmb2N1c19yYW5nZSB9KS5kcmF3KHNjcmVlbl9tZXNoKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMuc2V0T3V0cHV0RGF0YSgwLCB0aGlzLl90ZW1wX3RleHR1cmUpO1xyXG5cdH1cclxuXHJcblx0Ly9mcm9tIGh0dHA6Ly90dXhlZG9sYWJzLmJsb2dzcG90LmNvbS5lcy8yMDE4LzA1L2Jva2VoLWRlcHRoLW9mLWZpZWxkLWluLXNpbmdsZS1wYXNzLmh0bWxcclxuXHRMR3JhcGhEZXB0aE9mRmllbGQuX3BpeGVsX3NoYWRlciA9IFwiXFxuXFxcclxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxyXG5cdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcclxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTsgLy9JbWFnZSB0byBiZSBwcm9jZXNzZWRcXG5cXFxyXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV9kZXB0aF90ZXh0dXJlOyAvL0xpbmVhciBkZXB0aCwgd2hlcmUgMS4wID09IGZhciBwbGFuZVxcblxcXHJcblx0XHR1bmlmb3JtIHZlYzIgdV9pcmVzb2x1dGlvbjsgLy9UaGUgc2l6ZSBvZiBhIHBpeGVsOiB2ZWMyKDEuMC93aWR0aCwgMS4wL2hlaWdodClcXG5cXFxyXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2ZhcjsgLy8gRmFyIHBsYW5lXFxuXFxcclxuXHRcdHVuaWZvcm0gZmxvYXQgdV9mb2N1c19wb2ludDtcXG5cXFxyXG5cdFx0dW5pZm9ybSBmbG9hdCB1X2ZvY3VzX3NjYWxlO1xcblxcXHJcblx0XHRcXG5cXFxyXG5cdFx0Y29uc3QgZmxvYXQgR09MREVOX0FOR0xFID0gMi4zOTk5NjMyMztcXG5cXFxyXG5cdFx0Y29uc3QgZmxvYXQgTUFYX0JMVVJfU0laRSA9IDIwLjA7XFxuXFxcclxuXHRcdGNvbnN0IGZsb2F0IFJBRF9TQ0FMRSA9IDAuNTsgLy8gU21hbGxlciA9IG5pY2VyIGJsdXIsIGxhcmdlciA9IGZhc3RlclxcblxcXHJcblx0XHRcXG5cXFxyXG5cdFx0ZmxvYXQgZ2V0Qmx1clNpemUoZmxvYXQgZGVwdGgsIGZsb2F0IGZvY3VzUG9pbnQsIGZsb2F0IGZvY3VzU2NhbGUpXFxuXFxcclxuXHRcdHtcXG5cXFxyXG5cdFx0IGZsb2F0IGNvYyA9IGNsYW1wKCgxLjAgLyBmb2N1c1BvaW50IC0gMS4wIC8gZGVwdGgpKmZvY3VzU2NhbGUsIC0xLjAsIDEuMCk7XFxuXFxcclxuXHRcdCByZXR1cm4gYWJzKGNvYykgKiBNQVhfQkxVUl9TSVpFO1xcblxcXHJcblx0XHR9XFxuXFxcclxuXHRcdFxcblxcXHJcblx0XHR2ZWMzIGRlcHRoT2ZGaWVsZCh2ZWMyIHRleENvb3JkLCBmbG9hdCBmb2N1c1BvaW50LCBmbG9hdCBmb2N1c1NjYWxlKVxcblxcXHJcblx0XHR7XFxuXFxcclxuXHRcdCBmbG9hdCBjZW50ZXJEZXB0aCA9IHRleHR1cmUyRCh1X2RlcHRoX3RleHR1cmUsIHRleENvb3JkKS5yICogdV9mYXI7XFxuXFxcclxuXHRcdCBmbG9hdCBjZW50ZXJTaXplID0gZ2V0Qmx1clNpemUoY2VudGVyRGVwdGgsIGZvY3VzUG9pbnQsIGZvY3VzU2NhbGUpO1xcblxcXHJcblx0XHQgdmVjMyBjb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQpLnJnYjtcXG5cXFxyXG5cdFx0IGZsb2F0IHRvdCA9IDEuMDtcXG5cXFxyXG5cdFx0XFxuXFxcclxuXHRcdCBmbG9hdCByYWRpdXMgPSBSQURfU0NBTEU7XFxuXFxcclxuXHRcdCBmb3IgKGZsb2F0IGFuZyA9IDAuMDsgYW5nIDwgMTAwLjA7IGFuZyArPSBHT0xERU5fQU5HTEUpXFxuXFxcclxuXHRcdCB7XFxuXFxcclxuXHRcdCAgdmVjMiB0YyA9IHRleENvb3JkICsgdmVjMihjb3MoYW5nKSwgc2luKGFuZykpICogdV9pcmVzb2x1dGlvbiAqIHJhZGl1cztcXG5cXFxyXG5cdFx0XHRcXG5cXFxyXG5cdFx0ICB2ZWMzIHNhbXBsZUNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdGMpLnJnYjtcXG5cXFxyXG5cdFx0ICBmbG9hdCBzYW1wbGVEZXB0aCA9IHRleHR1cmUyRCh1X2RlcHRoX3RleHR1cmUsIHRjKS5yICogdV9mYXI7XFxuXFxcclxuXHRcdCAgZmxvYXQgc2FtcGxlU2l6ZSA9IGdldEJsdXJTaXplKCBzYW1wbGVEZXB0aCwgZm9jdXNQb2ludCwgZm9jdXNTY2FsZSApO1xcblxcXHJcblx0XHQgIGlmIChzYW1wbGVEZXB0aCA+IGNlbnRlckRlcHRoKVxcblxcXHJcblx0XHQgICBzYW1wbGVTaXplID0gY2xhbXAoc2FtcGxlU2l6ZSwgMC4wLCBjZW50ZXJTaXplKjIuMCk7XFxuXFxcclxuXHRcdFx0XFxuXFxcclxuXHRcdCAgZmxvYXQgbSA9IHNtb290aHN0ZXAocmFkaXVzLTAuNSwgcmFkaXVzKzAuNSwgc2FtcGxlU2l6ZSk7XFxuXFxcclxuXHRcdCAgY29sb3IgKz0gbWl4KGNvbG9yL3RvdCwgc2FtcGxlQ29sb3IsIG0pO1xcblxcXHJcblx0XHQgIHRvdCArPSAxLjA7XFxuXFxcclxuXHRcdCAgcmFkaXVzICs9IFJBRF9TQ0FMRS9yYWRpdXM7XFxuXFxcclxuXHRcdCAgaWYocmFkaXVzPj1NQVhfQkxVUl9TSVpFKVxcblxcXHJcblx0XHRcdCByZXR1cm4gY29sb3IgLyB0b3Q7XFxuXFxcclxuXHRcdCB9XFxuXFxcclxuXHRcdCByZXR1cm4gY29sb3IgLyB0b3Q7XFxuXFxcclxuXHRcdH1cXG5cXFxyXG5cdFx0dm9pZCBtYWluKClcXG5cXFxyXG5cdFx0e1xcblxcXHJcblx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGRlcHRoT2ZGaWVsZCggdl9jb29yZCwgdV9mb2N1c19wb2ludCwgdV9mb2N1c19zY2FsZSApLCAxLjAgKTtcXG5cXFxyXG5cdFx0XHQvL2dsX0ZyYWdDb2xvciA9IHZlYzQoIHRleHR1cmUyRCh1X2RlcHRoX3RleHR1cmUsIHZfY29vcmQpLnIgKTtcXG5cXFxyXG5cdFx0fVxcblxcXHJcblx0XHRcIjtcclxuXHJcblx0TGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJmeC9ET0ZcIiwgTEdyYXBoRGVwdGhPZkZpZWxkICk7XHJcblx0Z2xvYmFsLkxHcmFwaERlcHRoT2ZGaWVsZCA9IExHcmFwaERlcHRoT2ZGaWVsZDtcclxuXHQqL1xyXG5cclxuICAgICAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gTEdyYXBoRlhCb2tlaCgpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dChcIlRleHR1cmVcIiwgXCJUZXh0dXJlXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0KFwiQmx1cnJlZFwiLCBcIlRleHR1cmVcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQoXCJNYXNrXCIsIFwiVGV4dHVyZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dChcIlRocmVzaG9sZFwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICBzaXplOiAxMCxcclxuICAgICAgICAgICAgICAgIGFscGhhOiAxLjAsXHJcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IDEuMCxcclxuICAgICAgICAgICAgICAgIGhpZ2hfcHJlY2lzaW9uOiBmYWxzZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTEdyYXBoRlhCb2tlaC50aXRsZSA9IFwiQm9rZWhcIjtcclxuICAgICAgICBMR3JhcGhGWEJva2VoLmRlc2MgPSBcImFwcGxpZXMgYW4gQm9rZWggZWZmZWN0XCI7XHJcblxyXG4gICAgICAgIExHcmFwaEZYQm9rZWgud2lkZ2V0c19pbmZvID0geyBzaGFwZTogeyB3aWRnZXQ6IFwidGV4dHVyZVwiIH0gfTtcclxuXHJcbiAgICAgICAgTEdyYXBoRlhCb2tlaC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXggPSB0aGlzLmdldElucHV0RGF0YSgwKTtcclxuICAgICAgICAgICAgdmFyIGJsdXJyZWRfdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgICAgIHZhciBtYXNrX3RleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDIpO1xyXG4gICAgICAgICAgICBpZiAoIXRleCB8fCAhbWFza190ZXggfHwgIXRoaXMucHJvcGVydGllcy5zaGFwZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghYmx1cnJlZF90ZXgpIHtcclxuICAgICAgICAgICAgICAgIGJsdXJyZWRfdGV4ID0gdGV4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc2hhcGVfdGV4ID0gTEdyYXBoVGV4dHVyZS5nZXRUZXh0dXJlKHRoaXMucHJvcGVydGllcy5zaGFwZSk7XHJcbiAgICAgICAgICAgIGlmICghc2hhcGVfdGV4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB0aHJlc2hvbGQgPSB0aGlzLnByb3BlcnRpZXMudGhyZXNob2xkO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0lucHV0Q29ubmVjdGVkKDMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQgPSB0aGlzLmdldElucHV0RGF0YSgzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy50aHJlc2hvbGQgPSB0aHJlc2hvbGQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBwcmVjaXNpb24gPSBnbC5VTlNJR05FRF9CWVRFO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmhpZ2hfcHJlY2lzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBnbC5oYWxmX2Zsb2F0X2V4dCA/IGdsLkhBTEZfRkxPQVRfT0VTIDogZ2wuRkxPQVQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgIXRoaXMuX3RlbXBfdGV4dHVyZSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcF90ZXh0dXJlLnR5cGUgIT0gcHJlY2lzaW9uIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wX3RleHR1cmUud2lkdGggIT0gdGV4LndpZHRoIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wX3RleHR1cmUuaGVpZ2h0ICE9IHRleC5oZWlnaHRcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wX3RleHR1cmUgPSBuZXcgR0wuVGV4dHVyZSh0ZXgud2lkdGgsIHRleC5oZWlnaHQsIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBwcmVjaXNpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBnbC5SR0JBLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZ2wuTElORUFSXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9pdGVyYXRpb25zXHJcbiAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5wcm9wZXJ0aWVzLnNpemU7XHJcblxyXG4gICAgICAgICAgICB2YXIgZmlyc3Rfc2hhZGVyID0gTEdyYXBoRlhCb2tlaC5fZmlyc3Rfc2hhZGVyO1xyXG4gICAgICAgICAgICBpZiAoIWZpcnN0X3NoYWRlcikge1xyXG4gICAgICAgICAgICAgICAgZmlyc3Rfc2hhZGVyID0gTEdyYXBoRlhCb2tlaC5fZmlyc3Rfc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcclxuICAgICAgICAgICAgICAgICAgICBTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXHJcbiAgICAgICAgICAgICAgICAgICAgTEdyYXBoRlhCb2tlaC5fZmlyc3RfcGl4ZWxfc2hhZGVyXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc2Vjb25kX3NoYWRlciA9IExHcmFwaEZYQm9rZWguX3NlY29uZF9zaGFkZXI7XHJcbiAgICAgICAgICAgIGlmICghc2Vjb25kX3NoYWRlcikge1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kX3NoYWRlciA9IExHcmFwaEZYQm9rZWguX3NlY29uZF9zaGFkZXIgPSBuZXcgR0wuU2hhZGVyKFxyXG4gICAgICAgICAgICAgICAgICAgIExHcmFwaEZYQm9rZWguX3NlY29uZF92ZXJ0ZXhfc2hhZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIExHcmFwaEZYQm9rZWguX3NlY29uZF9waXhlbF9zaGFkZXJcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBwb2ludHNfbWVzaCA9IHRoaXMuX3BvaW50c19tZXNoO1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAhcG9pbnRzX21lc2ggfHxcclxuICAgICAgICAgICAgICAgIHBvaW50c19tZXNoLl93aWR0aCAhPSB0ZXgud2lkdGggfHxcclxuICAgICAgICAgICAgICAgIHBvaW50c19tZXNoLl9oZWlnaHQgIT0gdGV4LmhlaWdodCB8fFxyXG4gICAgICAgICAgICAgICAgcG9pbnRzX21lc2guX3NwYWNpbmcgIT0gMlxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHBvaW50c19tZXNoID0gdGhpcy5jcmVhdGVQb2ludHNNZXNoKHRleC53aWR0aCwgdGV4LmhlaWdodCwgMik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzY3JlZW5fbWVzaCA9IE1lc2guZ2V0U2NyZWVuUXVhZCgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHBvaW50X3NpemUgPSB0aGlzLnByb3BlcnRpZXMuc2l6ZTtcclxuICAgICAgICAgICAgdmFyIG1pbl9saWdodCA9IHRoaXMucHJvcGVydGllcy5taW5fbGlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IHRoaXMucHJvcGVydGllcy5hbHBoYTtcclxuXHJcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XHJcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fdGVtcF90ZXh0dXJlLmRyYXdUbyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRleC5iaW5kKDApO1xyXG4gICAgICAgICAgICAgICAgYmx1cnJlZF90ZXguYmluZCgxKTtcclxuICAgICAgICAgICAgICAgIG1hc2tfdGV4LmJpbmQoMik7XHJcbiAgICAgICAgICAgICAgICBmaXJzdF9zaGFkZXJcclxuICAgICAgICAgICAgICAgICAgICAudW5pZm9ybXMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X3RleHR1cmU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfdGV4dHVyZV9ibHVyOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X21hc2s6IDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfdGV4c2l6ZTogW3RleC53aWR0aCwgdGV4LmhlaWdodF1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5kcmF3KHNjcmVlbl9tZXNoKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl90ZW1wX3RleHR1cmUuZHJhd1RvKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLy9jbGVhciBiZWNhdXNlIHdlIHVzZSBibGVuZGluZ1xyXG4gICAgICAgICAgICAgICAgLy9nbC5jbGVhckNvbG9yKDAuMCwwLjAsMC4wLDEuMCk7XHJcbiAgICAgICAgICAgICAgICAvL2dsLmNsZWFyKCBnbC5DT0xPUl9CVUZGRVJfQklUICk7XHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0ZXguYmluZCgwKTtcclxuICAgICAgICAgICAgICAgIHNoYXBlX3RleC5iaW5kKDMpO1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kX3NoYWRlclxyXG4gICAgICAgICAgICAgICAgICAgIC51bmlmb3Jtcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfdGV4dHVyZTogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV9tYXNrOiAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X3NoYXBlOiAzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X2FscGhhOiBhbHBoYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV90aHJlc2hvbGQ6IHRocmVzaG9sZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV9wb2ludFNpemU6IHBvaW50X3NpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfaXRleHNpemU6IFsxLjAgLyB0ZXgud2lkdGgsIDEuMCAvIHRleC5oZWlnaHRdXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuZHJhdyhwb2ludHNfbWVzaCwgZ2wuUE9JTlRTKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGVtcF90ZXh0dXJlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBMR3JhcGhGWEJva2VoLnByb3RvdHlwZS5jcmVhdGVQb2ludHNNZXNoID0gZnVuY3Rpb24oXHJcbiAgICAgICAgICAgIHdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQsXHJcbiAgICAgICAgICAgIHNwYWNpbmdcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdmFyIG53aWR0aCA9IE1hdGgucm91bmQod2lkdGggLyBzcGFjaW5nKTtcclxuICAgICAgICAgICAgdmFyIG5oZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCAvIHNwYWNpbmcpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShud2lkdGggKiBuaGVpZ2h0ICogMik7XHJcblxyXG4gICAgICAgICAgICB2YXIgbnkgPSAtMTtcclxuICAgICAgICAgICAgdmFyIGR4ID0gKDIgLyB3aWR0aCkgKiBzcGFjaW5nO1xyXG4gICAgICAgICAgICB2YXIgZHkgPSAoMiAvIGhlaWdodCkgKiBzcGFjaW5nO1xyXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IG5oZWlnaHQ7ICsreSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG54ID0gLTE7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG53aWR0aDsgKyt4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IHkgKiBud2lkdGggKiAyICsgeCAqIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXNbcG9zXSA9IG54O1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzW3BvcyArIDFdID0gbnk7XHJcbiAgICAgICAgICAgICAgICAgICAgbnggKz0gZHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBueSArPSBkeTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fcG9pbnRzX21lc2ggPSBHTC5NZXNoLmxvYWQoeyB2ZXJ0aWNlczJEOiB2ZXJ0aWNlcyB9KTtcclxuICAgICAgICAgICAgdGhpcy5fcG9pbnRzX21lc2guX3dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvaW50c19tZXNoLl9oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvaW50c19tZXNoLl9zcGFjaW5nID0gc3BhY2luZztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb2ludHNfbWVzaDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKlxyXG5cdExHcmFwaFRleHR1cmVCb2tlaC5fcGl4ZWxfc2hhZGVyID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcclxuXHRcdFx0dmFyeWluZyB2ZWMyIGFfY29vcmQ7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfc2hhcGU7XFxuXFxcclxuXHRcdFx0XFxuXFxcclxuXHRcdFx0dm9pZCBtYWluKCkge1xcblxcXHJcblx0XHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCggdV90ZXh0dXJlLCBnbF9Qb2ludENvb3JkICk7XFxuXFxcclxuXHRcdFx0XHRjb2xvciAqPSB2X2NvbG9yICogdV9hbHBoYTtcXG5cXFxyXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblxcXHJcblx0XHRcdH1cXG5cIjtcclxuXHQqL1xyXG5cclxuICAgICAgICBMR3JhcGhGWEJva2VoLl9maXJzdF9waXhlbF9zaGFkZXIgPVxyXG4gICAgICAgICAgICBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxyXG5cdFx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcclxuXHRcdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZV9ibHVyO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfbWFzaztcXG5cXFxyXG5cdFx0XHRcXG5cXFxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XFxuXFxcclxuXHRcdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCk7XFxuXFxcclxuXHRcdFx0XHR2ZWM0IGJsdXJyZWRfY29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlX2JsdXIsIHZfY29vcmQpO1xcblxcXHJcblx0XHRcdFx0ZmxvYXQgbWFzayA9IHRleHR1cmUyRCh1X21hc2ssIHZfY29vcmQpLng7XFxuXFxcclxuXHRcdFx0ICAgZ2xfRnJhZ0NvbG9yID0gbWl4KGNvbG9yLCBibHVycmVkX2NvbG9yLCBtYXNrKTtcXG5cXFxyXG5cdFx0XHR9XFxuXFxcclxuXHRcdFx0XCI7XHJcblxyXG4gICAgICAgIExHcmFwaEZYQm9rZWguX3NlY29uZF92ZXJ0ZXhfc2hhZGVyID1cclxuICAgICAgICAgICAgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcclxuXHRcdFx0YXR0cmlidXRlIHZlYzIgYV92ZXJ0ZXgyRDtcXG5cXFxyXG5cdFx0XHR2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV9tYXNrO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gdmVjMiB1X2l0ZXhzaXplO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV9wb2ludFNpemU7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCB1X3RocmVzaG9sZDtcXG5cXFxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XFxuXFxcclxuXHRcdFx0XHR2ZWMyIGNvb3JkID0gYV92ZXJ0ZXgyRCAqIDAuNSArIDAuNTtcXG5cXFxyXG5cdFx0XHRcdHZfY29sb3IgPSB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgY29vcmQgKTtcXG5cXFxyXG5cdFx0XHRcdHZfY29sb3IgKz0gdGV4dHVyZTJEKCB1X3RleHR1cmUsIGNvb3JkICsgdmVjMih1X2l0ZXhzaXplLngsIDAuMCkgKTtcXG5cXFxyXG5cdFx0XHRcdHZfY29sb3IgKz0gdGV4dHVyZTJEKCB1X3RleHR1cmUsIGNvb3JkICsgdmVjMigwLjAsIHVfaXRleHNpemUueSkpO1xcblxcXHJcblx0XHRcdFx0dl9jb2xvciArPSB0ZXh0dXJlMkQoIHVfdGV4dHVyZSwgY29vcmQgKyB1X2l0ZXhzaXplKTtcXG5cXFxyXG5cdFx0XHRcdHZfY29sb3IgKj0gMC4yNTtcXG5cXFxyXG5cdFx0XHRcdGZsb2F0IG1hc2sgPSB0ZXh0dXJlMkQodV9tYXNrLCBjb29yZCkueDtcXG5cXFxyXG5cdFx0XHRcdGZsb2F0IGx1bWluYW5jZSA9IGxlbmd0aCh2X2NvbG9yKSAqIG1hc2s7XFxuXFxcclxuXHRcdFx0XHQvKmx1bWluYW5jZSAvPSAodV9wb2ludFNpemUqdV9wb2ludFNpemUpKjAuMDEgKi87XFxuXFxcclxuXHRcdFx0XHRsdW1pbmFuY2UgLT0gdV90aHJlc2hvbGQ7XFxuXFxcclxuXHRcdFx0XHRpZihsdW1pbmFuY2UgPCAwLjApXFxuXFxcclxuXHRcdFx0XHR7XFxuXFxcclxuXHRcdFx0XHRcdGdsX1Bvc2l0aW9uLnggPSAtMTAwLjA7XFxuXFxcclxuXHRcdFx0XHRcdHJldHVybjtcXG5cXFxyXG5cdFx0XHRcdH1cXG5cXFxyXG5cdFx0XHRcdGdsX1BvaW50U2l6ZSA9IHVfcG9pbnRTaXplO1xcblxcXHJcblx0XHRcdFx0Z2xfUG9zaXRpb24gPSB2ZWM0KGFfdmVydGV4MkQsMC4wLDEuMCk7XFxuXFxcclxuXHRcdFx0fVxcblxcXHJcblx0XHRcdFwiO1xyXG5cclxuICAgICAgICBMR3JhcGhGWEJva2VoLl9zZWNvbmRfcGl4ZWxfc2hhZGVyID1cclxuICAgICAgICAgICAgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcclxuXHRcdFx0dmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV9zaGFwZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfYWxwaGE7XFxuXFxcclxuXHRcdFx0XFxuXFxcclxuXHRcdFx0dm9pZCBtYWluKCkge1xcblxcXHJcblx0XHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCggdV9zaGFwZSwgZ2xfUG9pbnRDb29yZCApO1xcblxcXHJcblx0XHRcdFx0Y29sb3IgKj0gdl9jb2xvciAqIHVfYWxwaGE7XFxuXFxcclxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cXFxyXG5cdFx0XHR9XFxuXCI7XHJcblxyXG4gICAgICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZngvYm9rZWhcIiwgTEdyYXBoRlhCb2tlaCk7XHJcbiAgICAgICAgZ2xvYmFsLkxHcmFwaEZYQm9rZWggPSBMR3JhcGhGWEJva2VoO1xyXG5cclxuICAgICAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuICAgICAgICBmdW5jdGlvbiBMR3JhcGhGWEdlbmVyaWMoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dChcInZhbHVlMVwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dChcInZhbHVlMlwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJUZXh0dXJlXCIsIFwiVGV4dHVyZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICAgICAgZng6IFwiaGFsZnRvbmVcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlMTogMSxcclxuICAgICAgICAgICAgICAgIHZhbHVlMjogMSxcclxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogTEdyYXBoVGV4dHVyZS5ERUZBVUxUXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBMR3JhcGhGWEdlbmVyaWMudGl0bGUgPSBcIkZYXCI7XHJcbiAgICAgICAgTEdyYXBoRlhHZW5lcmljLmRlc2MgPSBcImFwcGxpZXMgYW4gRlggZnJvbSBhIGxpc3RcIjtcclxuXHJcbiAgICAgICAgTEdyYXBoRlhHZW5lcmljLndpZGdldHNfaW5mbyA9IHtcclxuICAgICAgICAgICAgZng6IHtcclxuICAgICAgICAgICAgICAgIHdpZGdldDogXCJjb21ib1wiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWVzOiBbXCJoYWxmdG9uZVwiLCBcInBpeGVsYXRlXCIsIFwibG93cGFsZXR0ZVwiLCBcIm5vaXNlXCIsIFwiZ2FtbWFcIl1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgTEdyYXBoRlhHZW5lcmljLnNoYWRlcnMgPSB7fTtcclxuXHJcbiAgICAgICAgTEdyYXBoRlhHZW5lcmljLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzT3V0cHV0Q29ubmVjdGVkKDApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0gLy9zYXZlcyB3b3JrXHJcblxyXG4gICAgICAgICAgICB2YXIgdGV4ID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMucHJlY2lzaW9uID09PSBMR3JhcGhUZXh0dXJlLlBBU1NfVEhST1VHSCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRleCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghdGV4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3RleCA9IExHcmFwaFRleHR1cmUuZ2V0VGFyZ2V0VGV4dHVyZShcclxuICAgICAgICAgICAgICAgIHRleCxcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RleCxcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5wcmVjaXNpb25cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vaXRlcmF0aW9uc1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUxID0gdGhpcy5wcm9wZXJ0aWVzLnZhbHVlMTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnB1dENvbm5lY3RlZCgxKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUxID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUxID0gdmFsdWUxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdmFsdWUyID0gdGhpcy5wcm9wZXJ0aWVzLnZhbHVlMjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnB1dENvbm5lY3RlZCgyKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUyID0gdGhpcy5nZXRJbnB1dERhdGEoMik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUyID0gdmFsdWUyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZnggPSB0aGlzLnByb3BlcnRpZXMuZng7XHJcbiAgICAgICAgICAgIHZhciBzaGFkZXIgPSBMR3JhcGhGWEdlbmVyaWMuc2hhZGVyc1tmeF07XHJcbiAgICAgICAgICAgIGlmICghc2hhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGl4ZWxfc2hhZGVyX2NvZGUgPSBMR3JhcGhGWEdlbmVyaWNbXCJwaXhlbF9zaGFkZXJfXCIgKyBmeF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBpeGVsX3NoYWRlcl9jb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNoYWRlciA9IExHcmFwaEZYR2VuZXJpYy5zaGFkZXJzW2Z4XSA9IG5ldyBHTC5TaGFkZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgU2hhZGVyLlNDUkVFTl9WRVJURVhfU0hBREVSLFxyXG4gICAgICAgICAgICAgICAgICAgIHBpeGVsX3NoYWRlcl9jb2RlXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcclxuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgICAgICAgICAgdmFyIG1lc2ggPSBNZXNoLmdldFNjcmVlblF1YWQoKTtcclxuICAgICAgICAgICAgdmFyIGNhbWVyYSA9IGdsb2JhbC5MUyA/IExTLlJlbmRlcmVyLl9jdXJyZW50X2NhbWVyYSA6IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBjYW1lcmFfcGxhbmVzO1xyXG4gICAgICAgICAgICBpZiAoY2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICBjYW1lcmFfcGxhbmVzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIExTLlJlbmRlcmVyLl9jdXJyZW50X2NhbWVyYS5uZWFyLFxyXG4gICAgICAgICAgICAgICAgICAgIExTLlJlbmRlcmVyLl9jdXJyZW50X2NhbWVyYS5mYXJcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjYW1lcmFfcGxhbmVzID0gWzEsIDEwMF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBub2lzZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChmeCA9PSBcIm5vaXNlXCIpIHtcclxuICAgICAgICAgICAgICAgIG5vaXNlID0gTEdyYXBoVGV4dHVyZS5nZXROb2lzZVRleHR1cmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fdGV4LmRyYXdUbyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRleC5iaW5kKDApO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZ4ID09IFwibm9pc2VcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vaXNlLmJpbmQoMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc2hhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLnVuaWZvcm1zKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV90ZXh0dXJlOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X25vaXNlOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X3NpemU6IFt0ZXgud2lkdGgsIHRleC5oZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X3JhbmQ6IFtNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV92YWx1ZTE6IHZhbHVlMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV92YWx1ZTI6IHZhbHVlMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdV9jYW1lcmFfcGxhbmVzOiBjYW1lcmFfcGxhbmVzXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuZHJhdyhtZXNoKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fdGV4KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBMR3JhcGhGWEdlbmVyaWMucGl4ZWxfc2hhZGVyX2hhbGZ0b25lID1cclxuICAgICAgICAgICAgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcclxuXHRcdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gdmVjMiB1X2NhbWVyYV9wbGFuZXM7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSB2ZWMyIHVfc2l6ZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfdmFsdWUxO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV92YWx1ZTI7XFxuXFxcclxuXHRcdFx0XFxuXFxcclxuXHRcdFx0ZmxvYXQgcGF0dGVybigpIHtcXG5cXFxyXG5cdFx0XHRcdGZsb2F0IHMgPSBzaW4odV92YWx1ZTEgKiAzLjE0MTUpLCBjID0gY29zKHVfdmFsdWUxICogMy4xNDE1KTtcXG5cXFxyXG5cdFx0XHRcdHZlYzIgdGV4ID0gdl9jb29yZCAqIHVfc2l6ZS54eTtcXG5cXFxyXG5cdFx0XHRcdHZlYzIgcG9pbnQgPSB2ZWMyKFxcblxcXHJcblx0XHRcdFx0ICAgYyAqIHRleC54IC0gcyAqIHRleC55ICxcXG5cXFxyXG5cdFx0XHRcdCAgIHMgKiB0ZXgueCArIGMgKiB0ZXgueSBcXG5cXFxyXG5cdFx0XHRcdCkgKiB1X3ZhbHVlMjtcXG5cXFxyXG5cdFx0XHRcdHJldHVybiAoc2luKHBvaW50LngpICogc2luKHBvaW50LnkpKSAqIDQuMDtcXG5cXFxyXG5cdFx0XHR9XFxuXFxcclxuXHRcdFx0dm9pZCBtYWluKCkge1xcblxcXHJcblx0XHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQpO1xcblxcXHJcblx0XHRcdFx0ZmxvYXQgYXZlcmFnZSA9IChjb2xvci5yICsgY29sb3IuZyArIGNvbG9yLmIpIC8gMy4wO1xcblxcXHJcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKGF2ZXJhZ2UgKiAxMC4wIC0gNS4wICsgcGF0dGVybigpKSwgY29sb3IuYSk7XFxuXFxcclxuXHRcdFx0fVxcblwiO1xyXG5cclxuICAgICAgICBMR3JhcGhGWEdlbmVyaWMucGl4ZWxfc2hhZGVyX3BpeGVsYXRlID1cclxuICAgICAgICAgICAgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcclxuXHRcdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gdmVjMiB1X2NhbWVyYV9wbGFuZXM7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSB2ZWMyIHVfc2l6ZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfdmFsdWUxO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV92YWx1ZTI7XFxuXFxcclxuXHRcdFx0XFxuXFxcclxuXHRcdFx0dm9pZCBtYWluKCkge1xcblxcXHJcblx0XHRcdFx0dmVjMiBjb29yZCA9IHZlYzIoIGZsb29yKHZfY29vcmQueCAqIHVfdmFsdWUxKSAvIHVfdmFsdWUxLCBmbG9vcih2X2Nvb3JkLnkgKiB1X3ZhbHVlMikgLyB1X3ZhbHVlMiApO1xcblxcXHJcblx0XHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIGNvb3JkKTtcXG5cXFxyXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblxcXHJcblx0XHRcdH1cXG5cIjtcclxuXHJcbiAgICAgICAgTEdyYXBoRlhHZW5lcmljLnBpeGVsX3NoYWRlcl9sb3dwYWxldHRlID1cclxuICAgICAgICAgICAgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcclxuXHRcdFx0dmFyeWluZyB2ZWMyIHZfY29vcmQ7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gdmVjMiB1X2NhbWVyYV9wbGFuZXM7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSB2ZWMyIHVfc2l6ZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfdmFsdWUxO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV92YWx1ZTI7XFxuXFxcclxuXHRcdFx0XFxuXFxcclxuXHRcdFx0dm9pZCBtYWluKCkge1xcblxcXHJcblx0XHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfY29vcmQpO1xcblxcXHJcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gZmxvb3IoY29sb3IgKiB1X3ZhbHVlMSkgLyB1X3ZhbHVlMTtcXG5cXFxyXG5cdFx0XHR9XFxuXCI7XHJcblxyXG4gICAgICAgIExHcmFwaEZYR2VuZXJpYy5waXhlbF9zaGFkZXJfbm9pc2UgPVxyXG4gICAgICAgICAgICBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxyXG5cdFx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdV9ub2lzZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHZlYzIgdV9zaXplO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgdV92YWx1ZTE7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCB1X3ZhbHVlMjtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHZlYzIgdV9yYW5kO1xcblxcXHJcblx0XHRcdFxcblxcXHJcblx0XHRcdHZvaWQgbWFpbigpIHtcXG5cXFxyXG5cdFx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X2Nvb3JkKTtcXG5cXFxyXG5cdFx0XHRcdHZlYzMgbm9pc2UgPSB0ZXh0dXJlMkQodV9ub2lzZSwgdl9jb29yZCAqIHZlYzIodV9zaXplLnggLyA1MTIuMCwgdV9zaXplLnkgLyA1MTIuMCkgKyB1X3JhbmQpLnh5eiAtIHZlYzMoMC41KTtcXG5cXFxyXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yLnh5eiArIG5vaXNlICogdV92YWx1ZTEsIGNvbG9yLmEgKTtcXG5cXFxyXG5cdFx0XHR9XFxuXCI7XHJcblxyXG4gICAgICAgIExHcmFwaEZYR2VuZXJpYy5waXhlbF9zaGFkZXJfZ2FtbWEgPVxyXG4gICAgICAgICAgICBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxyXG5cdFx0XHR2YXJ5aW5nIHZlYzIgdl9jb29yZDtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXFxcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCB1X3ZhbHVlMTtcXG5cXFxyXG5cdFx0XHRcXG5cXFxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XFxuXFxcclxuXHRcdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCk7XFxuXFxcclxuXHRcdFx0XHRmbG9hdCBnYW1tYSA9IDEuMCAvIHVfdmFsdWUxO1xcblxcXHJcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggcG93KCBjb2xvci54eXosIHZlYzMoZ2FtbWEpICksIGNvbG9yLmEgKTtcXG5cXFxyXG5cdFx0XHR9XFxuXCI7XHJcblxyXG4gICAgICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiZngvZ2VuZXJpY1wiLCBMR3JhcGhGWEdlbmVyaWMpO1xyXG4gICAgICAgIGdsb2JhbC5MR3JhcGhGWEdlbmVyaWMgPSBMR3JhcGhGWEdlbmVyaWM7XHJcblxyXG4gICAgICAgIC8vIFZpZ25ldGluZyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gTEdyYXBoRlhWaWduZXRpbmcoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW5wdXQoXCJUZXguXCIsIFwiVGV4dHVyZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnB1dChcImludGVuc2l0eVwiLCBcIm51bWJlclwiKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0cHV0KFwiVGV4dHVyZVwiLCBcIlRleHR1cmVcIik7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgICAgIGludGVuc2l0eTogMSxcclxuICAgICAgICAgICAgICAgIGludmVydDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IExHcmFwaFRleHR1cmUuREVGQVVMVFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKCFMR3JhcGhGWFZpZ25ldGluZy5fc2hhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBMR3JhcGhGWFZpZ25ldGluZy5fc2hhZGVyID0gbmV3IEdMLlNoYWRlcihcclxuICAgICAgICAgICAgICAgICAgICBTaGFkZXIuU0NSRUVOX1ZFUlRFWF9TSEFERVIsXHJcbiAgICAgICAgICAgICAgICAgICAgTEdyYXBoRlhWaWduZXRpbmcucGl4ZWxfc2hhZGVyXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBMR3JhcGhGWFZpZ25ldGluZy50aXRsZSA9IFwiVmlnbmV0aW5nXCI7XHJcbiAgICAgICAgTEdyYXBoRlhWaWduZXRpbmcuZGVzYyA9IFwiVmlnbmV0aW5nXCI7XHJcblxyXG4gICAgICAgIExHcmFwaEZYVmlnbmV0aW5nLndpZGdldHNfaW5mbyA9IHtcclxuICAgICAgICAgICAgcHJlY2lzaW9uOiB7IHdpZGdldDogXCJjb21ib1wiLCB2YWx1ZXM6IExHcmFwaFRleHR1cmUuTU9ERV9WQUxVRVMgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIExHcmFwaEZYVmlnbmV0aW5nLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHRleCA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5wcmVjaXNpb24gPT09IExHcmFwaFRleHR1cmUuUEFTU19USFJPVUdIKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGV4KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCF0ZXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fdGV4ID0gTEdyYXBoVGV4dHVyZS5nZXRUYXJnZXRUZXh0dXJlKFxyXG4gICAgICAgICAgICAgICAgdGV4LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnByZWNpc2lvblxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGludGVuc2l0eSA9IHRoaXMucHJvcGVydGllcy5pbnRlbnNpdHk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5wdXRDb25uZWN0ZWQoMSkpIHtcclxuICAgICAgICAgICAgICAgIGludGVuc2l0eSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmludGVuc2l0eSA9IGludGVuc2l0eTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbWVzaCA9IE1lc2guZ2V0U2NyZWVuUXVhZCgpO1xyXG4gICAgICAgICAgICB2YXIgc2hhZGVyID0gTEdyYXBoRlhWaWduZXRpbmcuX3NoYWRlcjtcclxuICAgICAgICAgICAgdmFyIGludmVydCA9IHRoaXMucHJvcGVydGllcy5pbnZlcnQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl90ZXguZHJhd1RvKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGV4LmJpbmQoMCk7XHJcbiAgICAgICAgICAgICAgICBzaGFkZXJcclxuICAgICAgICAgICAgICAgICAgICAudW5pZm9ybXMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1X3RleHR1cmU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfaW50ZW5zaXR5OiBpbnRlbnNpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfaXNpemU6IFsxIC8gdGV4LndpZHRoLCAxIC8gdGV4LmhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVfaW52ZXJ0OiBpbnZlcnQgPyAxIDogMFxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmRyYXcobWVzaCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMuX3RleCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgTEdyYXBoRlhWaWduZXRpbmcucGl4ZWxfc2hhZGVyID1cclxuICAgICAgICAgICAgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcclxuXHRcdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcXHJcblx0XHRcdHZhcnlpbmcgdmVjMiB2X2Nvb3JkO1xcblxcXHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHVfaW50ZW5zaXR5O1xcblxcXHJcblx0XHRcdHVuaWZvcm0gaW50IHVfaW52ZXJ0O1xcblxcXHJcblx0XHRcdFxcblxcXHJcblx0XHRcdHZvaWQgbWFpbigpIHtcXG5cXFxyXG5cdFx0XHRcdGZsb2F0IGx1bWluYW5jZSA9IDEuMCAtIGxlbmd0aCggdl9jb29yZCAtIHZlYzIoMC41KSApICogMS40MTQ7XFxuXFxcclxuXHRcdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl9jb29yZCk7XFxuXFxcclxuXHRcdFx0XHRpZih1X2ludmVydCA9PSAxKVxcblxcXHJcblx0XHRcdFx0XHRsdW1pbmFuY2UgPSAxLjAgLSBsdW1pbmFuY2U7XFxuXFxcclxuXHRcdFx0XHRsdW1pbmFuY2UgPSBtaXgoMS4wLCBsdW1pbmFuY2UsIHVfaW50ZW5zaXR5KTtcXG5cXFxyXG5cdFx0XHQgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBsdW1pbmFuY2UgKiBjb2xvci54eXosIGNvbG9yLmEpO1xcblxcXHJcblx0XHRcdH1cXG5cXFxyXG5cdFx0XHRcIjtcclxuXHJcbiAgICAgICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJmeC92aWduZXRpbmdcIiwgTEdyYXBoRlhWaWduZXRpbmcpO1xyXG4gICAgICAgIGdsb2JhbC5MR3JhcGhGWFZpZ25ldGluZyA9IExHcmFwaEZYVmlnbmV0aW5nO1xyXG4gICAgfVxyXG59KSh0aGlzKTtcclxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgICB2YXIgTGl0ZUdyYXBoID0gZ2xvYmFsLkxpdGVHcmFwaDtcclxuICAgIHZhciBNSURJX0NPTE9SID0gXCIjMjQzXCI7XHJcblxyXG4gICAgZnVuY3Rpb24gTUlESUV2ZW50KGRhdGEpIHtcclxuICAgICAgICB0aGlzLmNoYW5uZWwgPSAwO1xyXG4gICAgICAgIHRoaXMuY21kID0gMDtcclxuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgVWludDMyQXJyYXkoMyk7XHJcblxyXG4gICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0dXAoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIExpdGVHcmFwaC5NSURJRXZlbnQgPSBNSURJRXZlbnQ7XHJcblxyXG4gICAgTUlESUV2ZW50LnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uKG8pIHtcclxuICAgICAgICB0aGlzLnNldHVwKG8uZGF0YSk7XHJcbiAgICB9O1xyXG5cclxuICAgIE1JRElFdmVudC5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgdmFyIHJhd19kYXRhID0gZGF0YTtcclxuICAgICAgICBpZiAoZGF0YS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIHJhd19kYXRhID0gZGF0YS5kYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5kYXRhLnNldChyYXdfZGF0YSk7XHJcblxyXG4gICAgICAgIHZhciBtaWRpU3RhdHVzID0gcmF3X2RhdGFbMF07XHJcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBtaWRpU3RhdHVzO1xyXG5cclxuICAgICAgICB2YXIgbWlkaUNvbW1hbmQgPSBtaWRpU3RhdHVzICYgMHhmMDtcclxuXHJcbiAgICAgICAgaWYgKG1pZGlTdGF0dXMgPj0gMHhmMCkge1xyXG4gICAgICAgICAgICB0aGlzLmNtZCA9IG1pZGlTdGF0dXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jbWQgPSBtaWRpQ29tbWFuZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmNtZCA9PSBNSURJRXZlbnQuTk9URU9OICYmIHRoaXMudmVsb2NpdHkgPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmNtZCA9IE1JRElFdmVudC5OT1RFT0ZGO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jbWRfc3RyID0gTUlESUV2ZW50LmNvbW1hbmRzW3RoaXMuY21kXSB8fCBcIlwiO1xyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIG1pZGlDb21tYW5kID49IE1JRElFdmVudC5OT1RFT04gfHxcclxuICAgICAgICAgICAgbWlkaUNvbW1hbmQgPD0gTUlESUV2ZW50Lk5PVEVPRkZcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFubmVsID0gbWlkaVN0YXR1cyAmIDB4MGY7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTUlESUV2ZW50LnByb3RvdHlwZSwgXCJ2ZWxvY2l0eVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY21kID09IE1JRElFdmVudC5OT1RFT04pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbMl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVsyXSA9IHY7IC8vICB2IC8gMTI3O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcblxyXG4gICAgTUlESUV2ZW50Lm5vdGVzID0gW1xyXG4gICAgICAgIFwiQVwiLFxyXG4gICAgICAgIFwiQSNcIixcclxuICAgICAgICBcIkJcIixcclxuICAgICAgICBcIkNcIixcclxuICAgICAgICBcIkMjXCIsXHJcbiAgICAgICAgXCJEXCIsXHJcbiAgICAgICAgXCJEI1wiLFxyXG4gICAgICAgIFwiRVwiLFxyXG4gICAgICAgIFwiRlwiLFxyXG4gICAgICAgIFwiRiNcIixcclxuICAgICAgICBcIkdcIixcclxuICAgICAgICBcIkcjXCJcclxuICAgIF07XHJcbiAgICBNSURJRXZlbnQubm90ZV90b19pbmRleCA9IHtcclxuICAgICAgICBBOiAwLFxyXG4gICAgICAgIFwiQSNcIjogMSxcclxuICAgICAgICBCOiAyLFxyXG4gICAgICAgIEM6IDMsXHJcbiAgICAgICAgXCJDI1wiOiA0LFxyXG4gICAgICAgIEQ6IDUsXHJcbiAgICAgICAgXCJEI1wiOiA2LFxyXG4gICAgICAgIEU6IDcsXHJcbiAgICAgICAgRjogOCxcclxuICAgICAgICBcIkYjXCI6IDksXHJcbiAgICAgICAgRzogMTAsXHJcbiAgICAgICAgXCJHI1wiOiAxMVxyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTUlESUV2ZW50LnByb3RvdHlwZSwgXCJub3RlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jbWQgIT0gTUlESUV2ZW50Lk5PVEVPTikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBNSURJRXZlbnQudG9Ob3RlU3RyaW5nKHRoaXMuZGF0YVsxXSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgICAgdGhyb3cgXCJub3RlcyBjYW5ub3QgYmUgYXNzaWduZWQgdGhpcyB3YXksIG11c3QgbW9kaWZ5IHRoZSBkYXRhWzFdXCI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTUlESUV2ZW50LnByb3RvdHlwZSwgXCJvY3RhdmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNtZCAhPSBNSURJRXZlbnQuTk9URU9OKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG9jdGF2ZSA9IHRoaXMuZGF0YVsxXSAtIDI0O1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihvY3RhdmUgLyAxMiArIDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICAgIHRocm93IFwib2N0YXZlIGNhbm5vdCBiZSBhc3NpZ25lZCB0aGlzIHdheSwgbXVzdCBtb2RpZnkgdGhlIGRhdGFbMV1cIjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcclxuICAgIH0pO1xyXG5cclxuICAgIC8vcmV0dXJucyBIWnNcclxuICAgIE1JRElFdmVudC5wcm90b3R5cGUuZ2V0UGl0Y2ggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgKHRoaXMuZGF0YVsxXSAtIDY5KSAvIDEyKSAqIDQ0MDtcclxuICAgIH07XHJcblxyXG4gICAgTUlESUV2ZW50LmNvbXB1dGVQaXRjaCA9IGZ1bmN0aW9uKG5vdGUpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgKG5vdGUgLSA2OSkgLyAxMikgKiA0NDA7XHJcbiAgICB9O1xyXG5cclxuICAgIE1JRElFdmVudC5wcm90b3R5cGUuZ2V0Q0MgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhWzFdO1xyXG4gICAgfTtcclxuXHJcbiAgICBNSURJRXZlbnQucHJvdG90eXBlLmdldENDVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhWzJdO1xyXG4gICAgfTtcclxuXHJcbiAgICAvL25vdCB0ZXN0ZWQsIHRoZXJlIGlzIGEgZm9ybXVsYSBtaXNzaW5nIGhlcmVcclxuICAgIE1JRElFdmVudC5wcm90b3R5cGUuZ2V0UGl0Y2hCZW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVsxXSArICh0aGlzLmRhdGFbMl0gPDwgNykgLSA4MTkyO1xyXG4gICAgfTtcclxuXHJcbiAgICBNSURJRXZlbnQuY29tcHV0ZVBpdGNoQmVuZCA9IGZ1bmN0aW9uKHYxLCB2Mikge1xyXG4gICAgICAgIHJldHVybiB2MSArICh2MiA8PCA3KSAtIDgxOTI7XHJcbiAgICB9O1xyXG5cclxuICAgIE1JRElFdmVudC5wcm90b3R5cGUuc2V0Q29tbWFuZEZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICB0aGlzLmNtZCA9IE1JRElFdmVudC5jb21wdXRlQ29tbWFuZEZyb21TdHJpbmcoc3RyKTtcclxuICAgIH07XHJcblxyXG4gICAgTUlESUV2ZW50LmNvbXB1dGVDb21tYW5kRnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgIGlmICghc3RyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN0ciAmJiBzdHIuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gc3RyLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgc3dpdGNoIChzdHIpIHtcclxuICAgICAgICAgICAgY2FzZSBcIk5PVEUgT05cIjpcclxuICAgICAgICAgICAgY2FzZSBcIk5PVEVPTlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JRElFdmVudC5OT1RFT047XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIk5PVEUgT0ZGXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJOT1RFT0ZGXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUlESUV2ZW50Lk5PVEVPTjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiS0VZIFBSRVNTVVJFXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJLRVlQUkVTU1VSRVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JRElFdmVudC5LRVlQUkVTU1VSRTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiQ09OVFJPTExFUiBDSEFOR0VcIjpcclxuICAgICAgICAgICAgY2FzZSBcIkNPTlRST0xMRVJDSEFOR0VcIjpcclxuICAgICAgICAgICAgY2FzZSBcIkNDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUlESUV2ZW50LkNPTlRST0xMRVJDSEFOR0U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIlBST0dSQU0gQ0hBTkdFXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJQUk9HUkFNQ0hBTkdFXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJQQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JRElFdmVudC5QUk9HUkFNQ0hBTkdFO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJDSEFOTkVMIFBSRVNTVVJFXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJDSEFOTkVMUFJFU1NVUkVcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBNSURJRXZlbnQuQ0hBTk5FTFBSRVNTVVJFO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJQSVRDSCBCRU5EXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJQSVRDSEJFTkRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBNSURJRXZlbnQuUElUQ0hCRU5EO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJUSU1FIFRJQ0tcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlRJTUVUSUNLXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUlESUV2ZW50LlRJTUVUSUNLO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHN0cik7IC8vYXNzdW1lIGl0cyBhIGhleCBjb2RlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvL3RyYW5zZm9ybSBmcm9tIGEgcGl0Y2ggbnVtYmVyIHRvIHN0cmluZyBsaWtlIFwiQzRcIlxyXG4gICAgTUlESUV2ZW50LnRvTm90ZVN0cmluZyA9IGZ1bmN0aW9uKGQsIHNraXBfb2N0YXZlKSB7XHJcbiAgICAgICAgZCA9IE1hdGgucm91bmQoZCk7IC8vaW4gY2FzZSBpdCBoYXMgZGVjaW1hbHNcclxuICAgICAgICB2YXIgbm90ZSA9IGQgLSAyMTtcclxuICAgICAgICB2YXIgb2N0YXZlID0gTWF0aC5mbG9vcigoZCAtIDI0KSAvIDEyICsgMSk7XHJcbiAgICAgICAgbm90ZSA9IG5vdGUgJSAxMjtcclxuICAgICAgICBpZiAobm90ZSA8IDApIHtcclxuICAgICAgICAgICAgbm90ZSA9IDEyICsgbm90ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE1JRElFdmVudC5ub3Rlc1tub3RlXSArIChza2lwX29jdGF2ZSA/IFwiXCIgOiBvY3RhdmUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBNSURJRXZlbnQuTm90ZVN0cmluZ1RvUGl0Y2ggPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICBzdHIgPSBzdHIudG9VcHBlckNhc2UoKTtcclxuICAgICAgICB2YXIgbm90ZSA9IHN0clswXTtcclxuICAgICAgICB2YXIgb2N0YXZlID0gNDtcclxuXHJcbiAgICAgICAgaWYgKHN0clsxXSA9PSBcIiNcIikge1xyXG4gICAgICAgICAgICBub3RlICs9IFwiI1wiO1xyXG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgICAgIG9jdGF2ZSA9IE51bWJlcihzdHJbMl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBvY3RhdmUgPSBOdW1iZXIoc3RyWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGl0Y2ggPSBNSURJRXZlbnQubm90ZV90b19pbmRleFtub3RlXTtcclxuICAgICAgICBpZiAocGl0Y2ggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChvY3RhdmUgLSAxKSAqIDEyICsgcGl0Y2ggKyAyMTtcclxuICAgIH07XHJcblxyXG4gICAgTUlESUV2ZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBzdHIgPSBcIlwiICsgdGhpcy5jaGFubmVsICsgXCIuIFwiO1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5jbWQpIHtcclxuICAgICAgICAgICAgY2FzZSBNSURJRXZlbnQuTk9URU9OOlxyXG4gICAgICAgICAgICAgICAgc3RyICs9IFwiTk9URU9OIFwiICsgTUlESUV2ZW50LnRvTm90ZVN0cmluZyh0aGlzLmRhdGFbMV0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTUlESUV2ZW50Lk5PVEVPRkY6XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCJOT1RFT0ZGIFwiICsgTUlESUV2ZW50LnRvTm90ZVN0cmluZyh0aGlzLmRhdGFbMV0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTUlESUV2ZW50LkNPTlRST0xMRVJDSEFOR0U6XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCJDQyBcIiArIHRoaXMuZGF0YVsxXSArIFwiIFwiICsgdGhpcy5kYXRhWzJdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTUlESUV2ZW50LlBST0dSQU1DSEFOR0U6XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCJQQyBcIiArIHRoaXMuZGF0YVsxXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE1JRElFdmVudC5QSVRDSEJFTkQ6XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCJQSVRDSEJFTkQgXCIgKyB0aGlzLmdldFBpdGNoQmVuZCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTUlESUV2ZW50LktFWVBSRVNTVVJFOlxyXG4gICAgICAgICAgICAgICAgc3RyICs9IFwiS0VZUFJFU1MgXCIgKyB0aGlzLmRhdGFbMV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9O1xyXG5cclxuICAgIE1JRElFdmVudC5wcm90b3R5cGUudG9IZXhTdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc3RyID0gXCJcIjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzdHIgKz0gdGhpcy5kYXRhW2ldLnRvU3RyaW5nKDE2KSArIFwiIFwiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTUlESUV2ZW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiBbdGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbMV0sIHRoaXMuZGF0YVsyXV0sXHJcbiAgICAgICAgICAgIG9iamVjdF9jbGFzczogXCJNSURJRXZlbnRcIlxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIE1JRElFdmVudC5OT1RFT0ZGID0gMHg4MDtcclxuICAgIE1JRElFdmVudC5OT1RFT04gPSAweDkwO1xyXG4gICAgTUlESUV2ZW50LktFWVBSRVNTVVJFID0gMHhhMDtcclxuICAgIE1JRElFdmVudC5DT05UUk9MTEVSQ0hBTkdFID0gMHhiMDtcclxuICAgIE1JRElFdmVudC5QUk9HUkFNQ0hBTkdFID0gMHhjMDtcclxuICAgIE1JRElFdmVudC5DSEFOTkVMUFJFU1NVUkUgPSAweGQwO1xyXG4gICAgTUlESUV2ZW50LlBJVENIQkVORCA9IDB4ZTA7XHJcbiAgICBNSURJRXZlbnQuVElNRVRJQ0sgPSAweGY4O1xyXG5cclxuICAgIE1JRElFdmVudC5jb21tYW5kcyA9IHtcclxuICAgICAgICAweDgwOiBcIm5vdGUgb2ZmXCIsXHJcbiAgICAgICAgMHg5MDogXCJub3RlIG9uXCIsXHJcbiAgICAgICAgMHhhMDogXCJrZXkgcHJlc3N1cmVcIixcclxuICAgICAgICAweGIwOiBcImNvbnRyb2xsZXIgY2hhbmdlXCIsXHJcbiAgICAgICAgMHhjMDogXCJwcm9ncmFtIGNoYW5nZVwiLFxyXG4gICAgICAgIDB4ZDA6IFwiY2hhbm5lbCBwcmVzc3VyZVwiLFxyXG4gICAgICAgIDB4ZTA6IFwicGl0Y2ggYmVuZFwiLFxyXG4gICAgICAgIDB4ZjA6IFwic3lzdGVtXCIsXHJcbiAgICAgICAgMHhmMjogXCJTb25nIHBvc1wiLFxyXG4gICAgICAgIDB4ZjM6IFwiU29uZyBzZWxlY3RcIixcclxuICAgICAgICAweGY2OiBcIlR1bmUgcmVxdWVzdFwiLFxyXG4gICAgICAgIDB4Zjg6IFwidGltZSB0aWNrXCIsXHJcbiAgICAgICAgMHhmYTogXCJTdGFydCBTb25nXCIsXHJcbiAgICAgICAgMHhmYjogXCJDb250aW51ZSBTb25nXCIsXHJcbiAgICAgICAgMHhmYzogXCJTdG9wIFNvbmdcIixcclxuICAgICAgICAweGZlOiBcIlNlbnNpbmdcIixcclxuICAgICAgICAweGZmOiBcIlJlc2V0XCJcclxuICAgIH07XHJcblxyXG4gICAgTUlESUV2ZW50LmNvbW1hbmRzX3Nob3J0ID0ge1xyXG4gICAgICAgIDB4ODA6IFwiTk9URU9GRlwiLFxyXG4gICAgICAgIDB4OTA6IFwiTk9URU9GRlwiLFxyXG4gICAgICAgIDB4YTA6IFwiS0VZUFwiLFxyXG4gICAgICAgIDB4YjA6IFwiQ0NcIixcclxuICAgICAgICAweGMwOiBcIlBDXCIsXHJcbiAgICAgICAgMHhkMDogXCJDUFwiLFxyXG4gICAgICAgIDB4ZTA6IFwiUEJcIixcclxuICAgICAgICAweGYwOiBcIlNZU1wiLFxyXG4gICAgICAgIDB4ZjI6IFwiUE9TXCIsXHJcbiAgICAgICAgMHhmMzogXCJTRUxFQ1RcIixcclxuICAgICAgICAweGY2OiBcIlRVTkVSRVFcIixcclxuICAgICAgICAweGY4OiBcIlRUXCIsXHJcbiAgICAgICAgMHhmYTogXCJTVEFSVFwiLFxyXG4gICAgICAgIDB4ZmI6IFwiQ09OVElOVUVcIixcclxuICAgICAgICAweGZjOiBcIlNUT1BcIixcclxuICAgICAgICAweGZlOiBcIlNFTlNcIixcclxuICAgICAgICAweGZmOiBcIlJFU0VUXCJcclxuICAgIH07XHJcblxyXG4gICAgTUlESUV2ZW50LmNvbW1hbmRzX3JldmVyc2VkID0ge307XHJcbiAgICBmb3IgKHZhciBpIGluIE1JRElFdmVudC5jb21tYW5kcykge1xyXG4gICAgICAgIE1JRElFdmVudC5jb21tYW5kc19yZXZlcnNlZFtNSURJRXZlbnQuY29tbWFuZHNbaV1dID0gaTtcclxuICAgIH1cclxuXHJcbiAgICAvL01JREkgd3JhcHBlciwgaW5zdGFudGlhdGUgYnkgTUlESUluIGFuZCBNSURJT3V0XHJcbiAgICBmdW5jdGlvbiBNSURJSW50ZXJmYWNlKG9uX3JlYWR5LCBvbl9lcnJvcikge1xyXG4gICAgICAgIGlmICghbmF2aWdhdG9yLnJlcXVlc3RNSURJQWNjZXNzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIm5vdCBzdXBwb29ydGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChvbl9lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgb25fZXJyb3IoXCJOb3Qgc3VwcG9ydGVkXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk1JREkgTk9UIFNVUFBPUlRFRCwgZW5hYmxlIGJ5IGNocm9tZTovL2ZsYWdzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMub25fcmVhZHkgPSBvbl9yZWFkeTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgbm90ZTogW10sXHJcbiAgICAgICAgICAgIGNjOiBbXVxyXG4gICAgICAgIH07XHJcblxyXG5cdFx0dGhpcy5pbnB1dF9wb3J0cyA9IG51bGw7XHJcblx0XHR0aGlzLmlucHV0X3BvcnRzX2luZm8gPSBbXTtcclxuXHRcdHRoaXMub3V0cHV0X3BvcnRzID0gbnVsbDtcclxuXHRcdHRoaXMub3V0cHV0X3BvcnRzX2luZm8gPSBbXTtcclxuXHJcbiAgICAgICAgbmF2aWdhdG9yLnJlcXVlc3RNSURJQWNjZXNzKCkudGhlbih0aGlzLm9uTUlESVN1Y2Nlc3MuYmluZCh0aGlzKSwgdGhpcy5vbk1JRElGYWlsdXJlLmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG5cclxuICAgIE1JRElJbnRlcmZhY2UuaW5wdXQgPSBudWxsO1xyXG5cclxuICAgIE1JRElJbnRlcmZhY2UuTUlESUV2ZW50ID0gTUlESUV2ZW50O1xyXG5cclxuICAgIE1JRElJbnRlcmZhY2UucHJvdG90eXBlLm9uTUlESVN1Y2Nlc3MgPSBmdW5jdGlvbihtaWRpQWNjZXNzKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJNSURJIHJlYWR5IVwiKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhtaWRpQWNjZXNzKTtcclxuICAgICAgICB0aGlzLm1pZGkgPSBtaWRpQWNjZXNzOyAvLyBzdG9yZSBpbiB0aGUgZ2xvYmFsIChpbiByZWFsIHVzYWdlLCB3b3VsZCBwcm9iYWJseSBrZWVwIGluIGFuIG9iamVjdCBpbnN0YW5jZSlcclxuICAgICAgICB0aGlzLnVwZGF0ZVBvcnRzKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm9uX3JlYWR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMub25fcmVhZHkodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBNSURJSW50ZXJmYWNlLnByb3RvdHlwZS51cGRhdGVQb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBtaWRpID0gdGhpcy5taWRpO1xyXG4gICAgICAgIHRoaXMuaW5wdXRfcG9ydHMgPSBtaWRpLmlucHV0cztcclxuXHRcdHRoaXMuaW5wdXRfcG9ydHNfaW5mbyA9IFtdO1xyXG4gICAgICAgIHRoaXMub3V0cHV0X3BvcnRzID0gbWlkaS5vdXRwdXRzO1xyXG5cdFx0dGhpcy5vdXRwdXRfcG9ydHNfaW5mbyA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgbnVtID0gMDtcclxuXHJcbiAgICAgICAgdmFyIGl0ID0gdGhpcy5pbnB1dF9wb3J0cy52YWx1ZXMoKTtcclxuICAgICAgICB2YXIgaXRfdmFsdWUgPSBpdC5uZXh0KCk7XHJcbiAgICAgICAgd2hpbGUgKGl0X3ZhbHVlICYmIGl0X3ZhbHVlLmRvbmUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3J0X2luZm8gPSBpdF92YWx1ZS52YWx1ZTtcclxuXHRcdFx0dGhpcy5pbnB1dF9wb3J0c19pbmZvLnB1c2gocG9ydF9pbmZvKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coIFwiSW5wdXQgcG9ydCBbdHlwZTonXCIgKyBwb3J0X2luZm8udHlwZSArIFwiJ10gaWQ6J1wiICsgcG9ydF9pbmZvLmlkICsgXCInIG1hbnVmYWN0dXJlcjonXCIgKyBwb3J0X2luZm8ubWFudWZhY3R1cmVyICsgXCInIG5hbWU6J1wiICsgcG9ydF9pbmZvLm5hbWUgKyBcIicgdmVyc2lvbjonXCIgKyBwb3J0X2luZm8udmVyc2lvbiArIFwiJ1wiICk7XHJcbiAgICAgICAgICAgIG51bSsrO1xyXG4gICAgICAgICAgICBpdF92YWx1ZSA9IGl0Lm5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5udW1faW5wdXRfcG9ydHMgPSBudW07XHJcblxyXG4gICAgICAgIG51bSA9IDA7XHJcbiAgICAgICAgdmFyIGl0ID0gdGhpcy5vdXRwdXRfcG9ydHMudmFsdWVzKCk7XHJcbiAgICAgICAgdmFyIGl0X3ZhbHVlID0gaXQubmV4dCgpO1xyXG4gICAgICAgIHdoaWxlIChpdF92YWx1ZSAmJiBpdF92YWx1ZS5kb25lID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB2YXIgcG9ydF9pbmZvID0gaXRfdmFsdWUudmFsdWU7XHJcblx0XHRcdHRoaXMub3V0cHV0X3BvcnRzX2luZm8ucHVzaChwb3J0X2luZm8pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyggXCJPdXRwdXQgcG9ydCBbdHlwZTonXCIgKyBwb3J0X2luZm8udHlwZSArIFwiJ10gaWQ6J1wiICsgcG9ydF9pbmZvLmlkICsgXCInIG1hbnVmYWN0dXJlcjonXCIgKyBwb3J0X2luZm8ubWFudWZhY3R1cmVyICsgXCInIG5hbWU6J1wiICsgcG9ydF9pbmZvLm5hbWUgKyBcIicgdmVyc2lvbjonXCIgKyBwb3J0X2luZm8udmVyc2lvbiArIFwiJ1wiICk7XHJcbiAgICAgICAgICAgIG51bSsrO1xyXG4gICAgICAgICAgICBpdF92YWx1ZSA9IGl0Lm5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5udW1fb3V0cHV0X3BvcnRzID0gbnVtO1xyXG4gICAgfTtcclxuXHJcbiAgICBNSURJSW50ZXJmYWNlLnByb3RvdHlwZS5vbk1JRElGYWlsdXJlID0gZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBnZXQgTUlESSBhY2Nlc3MgLSBcIiArIG1zZyk7XHJcbiAgICB9O1xyXG5cclxuICAgIE1JRElJbnRlcmZhY2UucHJvdG90eXBlLm9wZW5JbnB1dFBvcnQgPSBmdW5jdGlvbihwb3J0LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBpbnB1dF9wb3J0ID0gdGhpcy5pbnB1dF9wb3J0cy5nZXQoXCJpbnB1dC1cIiArIHBvcnQpO1xyXG4gICAgICAgIGlmICghaW5wdXRfcG9ydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE1JRElJbnRlcmZhY2UuaW5wdXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICAgICAgaW5wdXRfcG9ydC5vbm1pZGltZXNzYWdlID0gZnVuY3Rpb24oYSkge1xyXG4gICAgICAgICAgICB2YXIgbWlkaV9ldmVudCA9IG5ldyBNSURJRXZlbnQoYS5kYXRhKTtcclxuICAgICAgICAgICAgdGhhdC51cGRhdGVTdGF0ZShtaWRpX2V2ZW50KTtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhhLmRhdGEsIG1pZGlfZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChNSURJSW50ZXJmYWNlLm9uX21lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIE1JRElJbnRlcmZhY2Uub25fbWVzc2FnZShhLmRhdGEsIG1pZGlfZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInBvcnQgb3BlbjogXCIsIGlucHV0X3BvcnQpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBNSURJSW50ZXJmYWNlLnBhcnNlTXNnID0gZnVuY3Rpb24oZGF0YSkge307XHJcblxyXG4gICAgTUlESUludGVyZmFjZS5wcm90b3R5cGUudXBkYXRlU3RhdGUgPSBmdW5jdGlvbihtaWRpX2V2ZW50KSB7XHJcbiAgICAgICAgc3dpdGNoIChtaWRpX2V2ZW50LmNtZCkge1xyXG4gICAgICAgICAgICBjYXNlIE1JRElFdmVudC5OT1RFT046XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLm5vdGVbbWlkaV9ldmVudC52YWx1ZTEgfCAwXSA9IG1pZGlfZXZlbnQudmFsdWUyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTUlESUV2ZW50Lk5PVEVPRkY6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLm5vdGVbbWlkaV9ldmVudC52YWx1ZTEgfCAwXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBNSURJRXZlbnQuQ09OVFJPTExFUkNIQU5HRTpcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY2NbbWlkaV9ldmVudC5nZXRDQygpXSA9IG1pZGlfZXZlbnQuZ2V0Q0NWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBNSURJSW50ZXJmYWNlLnByb3RvdHlwZS5zZW5kTUlESSA9IGZ1bmN0aW9uKHBvcnQsIG1pZGlfZGF0YSkge1xyXG4gICAgICAgIGlmICghbWlkaV9kYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBvdXRwdXRfcG9ydCA9IHRoaXMub3V0cHV0X3BvcnRzX2luZm9bcG9ydF07Ly90aGlzLm91dHB1dF9wb3J0cy5nZXQoXCJvdXRwdXQtXCIgKyBwb3J0KTtcclxuICAgICAgICBpZiAoIW91dHB1dF9wb3J0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIE1JRElJbnRlcmZhY2Uub3V0cHV0ID0gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKG1pZGlfZGF0YS5jb25zdHJ1Y3RvciA9PT0gTUlESUV2ZW50KSB7XHJcbiAgICAgICAgICAgIG91dHB1dF9wb3J0LnNlbmQobWlkaV9kYXRhLmRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG91dHB1dF9wb3J0LnNlbmQobWlkaV9kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIExHTUlESUluKCkge1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib25fbWlkaVwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwibWlkaVwiKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHBvcnQ6IDAgfTtcclxuICAgICAgICB0aGlzLl9sYXN0X21pZGlfZXZlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRfbWlkaV9ldmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiI0FBQVwiO1xyXG4gICAgICAgIHRoaXMuX2xhc3RfdGltZSA9IDA7XHJcblxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBuZXcgTUlESUludGVyZmFjZShmdW5jdGlvbihtaWRpKSB7XHJcbiAgICAgICAgICAgIC8vb3BlblxyXG4gICAgICAgICAgICB0aGF0Ll9taWRpID0gbWlkaTtcclxuICAgICAgICAgICAgaWYgKHRoYXQuX3dhaXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQub25TdGFydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoYXQuX3dhaXRpbmcgPSBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBMR01JRElJbi5NSURJSW50ZXJmYWNlID0gTUlESUludGVyZmFjZTtcclxuXHJcbiAgICBMR01JRElJbi50aXRsZSA9IFwiTUlESSBJbnB1dFwiO1xyXG4gICAgTEdNSURJSW4uZGVzYyA9IFwiUmVhZHMgTUlESSBmcm9tIGEgaW5wdXQgcG9ydFwiO1xyXG4gICAgTEdNSURJSW4uY29sb3IgPSBNSURJX0NPTE9SO1xyXG5cclxuICAgIExHTUlESUluLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUluZm8gPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9taWRpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuYW1lID09IFwicG9ydFwiKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9taWRpLmlucHV0X3BvcnRzX2luZm8ubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuX21pZGkuaW5wdXRfcG9ydHNfaW5mb1tpXTtcclxuICAgICAgICAgICAgICAgIHZhbHVlc1tpXSA9IGkgKyBcIi4tIFwiICsgaW5wdXQubmFtZSArIFwiIHZlcnNpb246XCIgKyBpbnB1dC52ZXJzaW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZW51bVwiLCB2YWx1ZXM6IHZhbHVlcyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJSW4ucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5fbWlkaSkge1xyXG4gICAgICAgICAgICB0aGlzLl9taWRpLm9wZW5JbnB1dFBvcnQoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMucG9ydCxcclxuICAgICAgICAgICAgICAgIHRoaXMub25NSURJRXZlbnQuYmluZCh0aGlzKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dhaXRpbmcgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJSW4ucHJvdG90eXBlLm9uTUlESUV2ZW50ID0gZnVuY3Rpb24oZGF0YSwgbWlkaV9ldmVudCkge1xyXG4gICAgICAgIHRoaXMuX2xhc3RfbWlkaV9ldmVudCA9IG1pZGlfZXZlbnQ7XHJcbiAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiI0FGQVwiO1xyXG4gICAgICAgIHRoaXMuX2xhc3RfdGltZSA9IExpdGVHcmFwaC5nZXRUaW1lKCk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwib25fbWlkaVwiLCBtaWRpX2V2ZW50KTtcclxuICAgICAgICBpZiAobWlkaV9ldmVudC5jbWQgPT0gTUlESUV2ZW50Lk5PVEVPTikge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJvbl9ub3Rlb25cIiwgbWlkaV9ldmVudCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtaWRpX2V2ZW50LmNtZCA9PSBNSURJRXZlbnQuTk9URU9GRikge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJvbl9ub3Rlb2ZmXCIsIG1pZGlfZXZlbnQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWlkaV9ldmVudC5jbWQgPT0gTUlESUV2ZW50LkNPTlRST0xMRVJDSEFOR0UpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwib25fY2NcIiwgbWlkaV9ldmVudCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtaWRpX2V2ZW50LmNtZCA9PSBNSURJRXZlbnQuUFJPR1JBTUNIQU5HRSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJvbl9wY1wiLCBtaWRpX2V2ZW50KTtcclxuICAgICAgICB9IGVsc2UgaWYgKG1pZGlfZXZlbnQuY21kID09IE1JRElFdmVudC5QSVRDSEJFTkQpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwib25fcGl0Y2hiZW5kXCIsIG1pZGlfZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJSW4ucHJvdG90eXBlLm9uRHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbihjdHgpIHtcclxuICAgICAgICB0aGlzLmJveGNvbG9yID0gXCIjQUFBXCI7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZsYWdzLmNvbGxhcHNlZCAmJiB0aGlzLl9sYXN0X21pZGlfZXZlbnQpIHtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcclxuICAgICAgICAgICAgdmFyIG5vdyA9IExpdGVHcmFwaC5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIHZhciBmID0gMS4wIC0gTWF0aC5tYXgoMCwgKG5vdyAtIHRoaXMuX2xhc3RfdGltZSkgKiAwLjAwMSk7XHJcbiAgICAgICAgICAgIGlmIChmID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBjdHguZ2xvYmFsQWxwaGE7XHJcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gZjtcclxuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gXCIxMnB4IFRhaG9tYVwiO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RfbWlkaV9ldmVudC50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgICAgIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplWzFdICogMC41ICsgM1xyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIC8vY3R4LmZpbGxSZWN0KDAsMCx0aGlzLnNpemVbMF0sdGhpcy5zaXplWzFdKTtcclxuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUluLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5vdXRwdXRzKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXN0ID0gdGhpcy5fbGFzdF9taWRpX2V2ZW50O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciB2ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3V0cHV0Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWlkaVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5fbWlkaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxhc3RfbWlkaVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gbGFzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoaSwgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUluLnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbXCJsYXN0X21pZGlcIiwgXCJtaWRpXCJdLFxyXG4gICAgICAgICAgICBbXCJvbl9taWRpXCIsIExpdGVHcmFwaC5FVkVOVF0sXHJcbiAgICAgICAgICAgIFtcIm9uX25vdGVvblwiLCBMaXRlR3JhcGguRVZFTlRdLFxyXG4gICAgICAgICAgICBbXCJvbl9ub3Rlb2ZmXCIsIExpdGVHcmFwaC5FVkVOVF0sXHJcbiAgICAgICAgICAgIFtcIm9uX2NjXCIsIExpdGVHcmFwaC5FVkVOVF0sXHJcbiAgICAgICAgICAgIFtcIm9uX3BjXCIsIExpdGVHcmFwaC5FVkVOVF0sXHJcbiAgICAgICAgICAgIFtcIm9uX3BpdGNoYmVuZFwiLCBMaXRlR3JhcGguRVZFTlRdXHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtaWRpL2lucHV0XCIsIExHTUlESUluKTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR01JRElPdXQoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInNlbmRcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IHBvcnQ6IDAgfTtcclxuXHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIG5ldyBNSURJSW50ZXJmYWNlKGZ1bmN0aW9uKG1pZGkpIHtcclxuICAgICAgICAgICAgdGhhdC5fbWlkaSA9IG1pZGk7XHJcblx0XHRcdHRoYXQud2lkZ2V0Lm9wdGlvbnMudmFsdWVzID0gdGhhdC5nZXRNSURJT3V0cHV0cygpO1xyXG4gICAgICAgIH0pO1xyXG5cdFx0dGhpcy53aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcImNvbWJvXCIsXCJEZXZpY2VcIix0aGlzLnByb3BlcnRpZXMucG9ydCx7IHByb3BlcnR5OiBcInBvcnRcIiwgdmFsdWVzOiB0aGlzLmdldE1JRElPdXRwdXRzLmJpbmQodGhpcykgfSk7XHJcblx0XHR0aGlzLnNpemUgPSBbMzQwLDYwXTtcclxuICAgIH1cclxuXHJcbiAgICBMR01JRElPdXQuTUlESUludGVyZmFjZSA9IE1JRElJbnRlcmZhY2U7XHJcblxyXG4gICAgTEdNSURJT3V0LnRpdGxlID0gXCJNSURJIE91dHB1dFwiO1xyXG4gICAgTEdNSURJT3V0LmRlc2MgPSBcIlNlbmRzIE1JREkgdG8gb3V0cHV0IGNoYW5uZWxcIjtcclxuICAgIExHTUlESU91dC5jb2xvciA9IE1JRElfQ09MT1I7XHJcblxyXG4gICAgTEdNSURJT3V0LnByb3RvdHlwZS5vbkdldFByb3BlcnR5SW5mbyA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX21pZGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJwb3J0XCIpIHtcclxuXHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMuZ2V0TUlESU91dHB1dHMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlbnVtXCIsIHZhbHVlczogdmFsdWVzIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHRMR01JRElPdXQuZGVmYXVsdF9wb3J0cyA9IHswOlwidW5rbm93blwifTtcclxuXHJcblx0TEdNSURJT3V0LnByb3RvdHlwZS5nZXRNSURJT3V0cHV0cyA9IGZ1bmN0aW9uKClcclxuXHR7XHJcblx0XHR2YXIgdmFsdWVzID0ge307XHJcblx0XHRpZighdGhpcy5fbWlkaSlcclxuXHRcdFx0cmV0dXJuIExHTUlESU91dC5kZWZhdWx0X3BvcnRzO1xyXG5cdFx0aWYodGhpcy5fbWlkaS5vdXRwdXRfcG9ydHNfaW5mbylcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbWlkaS5vdXRwdXRfcG9ydHNfaW5mby5sZW5ndGg7ICsraSkge1xyXG5cdFx0XHR2YXIgb3V0cHV0ID0gdGhpcy5fbWlkaS5vdXRwdXRfcG9ydHNfaW5mb1tpXTtcclxuXHRcdFx0aWYoIW91dHB1dClcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0dmFyIG5hbWUgPSBpICsgXCIuLSBcIiArIG91dHB1dC5uYW1lICsgXCIgdmVyc2lvbjpcIiArIG91dHB1dC52ZXJzaW9uO1xyXG5cdFx0XHR2YWx1ZXNbaV0gPSBuYW1lO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlcztcclxuXHR9XHJcblxyXG4gICAgTEdNSURJT3V0LnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGV2ZW50LCBtaWRpX2V2ZW50KSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhtaWRpX2V2ZW50KTtcclxuICAgICAgICBpZiAoIXRoaXMuX21pZGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnQgPT0gXCJzZW5kXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWlkaS5zZW5kTUlESSh0aGlzLnByb3BlcnRpZXMucG9ydCwgbWlkaV9ldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJpZ2dlcihcIm1pZGlcIiwgbWlkaV9ldmVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESU91dC5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcInNlbmRcIiwgTGl0ZUdyYXBoLkFDVElPTl1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElPdXQucHJvdG90eXBlLm9uR2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wib25fbWlkaVwiLCBMaXRlR3JhcGguRVZFTlRdXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtaWRpL291dHB1dFwiLCBMR01JRElPdXQpO1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBMR01JRElTaG93KCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJvbl9taWRpXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5fc3RyID0gXCJcIjtcclxuICAgICAgICB0aGlzLnNpemUgPSBbMjAwLCA0MF07XHJcbiAgICB9XHJcblxyXG4gICAgTEdNSURJU2hvdy50aXRsZSA9IFwiTUlESSBTaG93XCI7XHJcbiAgICBMR01JRElTaG93LmRlc2MgPSBcIlNob3dzIE1JREkgaW4gdGhlIGdyYXBoXCI7XHJcbiAgICBMR01JRElTaG93LmNvbG9yID0gTUlESV9DT0xPUjtcclxuXHJcbiAgICBMR01JRElTaG93LnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmNvbGxhcHNlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50aXRsZTtcclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJU2hvdy5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihldmVudCwgbWlkaV9ldmVudCkge1xyXG4gICAgICAgIGlmICghbWlkaV9ldmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtaWRpX2V2ZW50LmNvbnN0cnVjdG9yID09PSBNSURJRXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RyID0gbWlkaV9ldmVudC50b1N0cmluZygpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0ciA9IFwiPz8/XCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElTaG93LnByb3RvdHlwZS5vbkRyYXdGb3JlZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdHIgfHwgdGhpcy5mbGFncy5jb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3R4LmZvbnQgPSBcIjMwcHggQXJpYWxcIjtcclxuICAgICAgICBjdHguZmlsbFRleHQodGhpcy5fc3RyLCAxMCwgdGhpcy5zaXplWzFdICogMC44KTtcclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJU2hvdy5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcImluXCIsIExpdGVHcmFwaC5BQ1RJT05dXTtcclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJU2hvdy5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtbXCJvbl9taWRpXCIsIExpdGVHcmFwaC5FVkVOVF1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1pZGkvc2hvd1wiLCBMR01JRElTaG93KTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR01JRElGaWx0ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBjaGFubmVsOiAtMSxcclxuICAgICAgICAgICAgY21kOiAtMSxcclxuICAgICAgICAgICAgbWluX3ZhbHVlOiAtMSxcclxuICAgICAgICAgICAgbWF4X3ZhbHVlOiAtMVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGlzLl9sZWFybmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYWRkV2lkZ2V0KFwiYnV0dG9uXCIsIFwiTGVhcm5cIiwgXCJcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoYXQuX2xlYXJuaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IFwiI0ZBM1wiO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm9uX21pZGlcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmJveGNvbG9yID0gXCIjQUFBXCI7XHJcbiAgICB9XHJcblxyXG4gICAgTEdNSURJRmlsdGVyLnRpdGxlID0gXCJNSURJIEZpbHRlclwiO1xyXG4gICAgTEdNSURJRmlsdGVyLmRlc2MgPSBcIkZpbHRlcnMgTUlESSBtZXNzYWdlc1wiO1xyXG4gICAgTEdNSURJRmlsdGVyLmNvbG9yID0gTUlESV9DT0xPUjtcclxuXHJcbiAgICBMR01JRElGaWx0ZXJbXCJAY21kXCJdID0ge1xyXG4gICAgICAgIHR5cGU6IFwiZW51bVwiLFxyXG4gICAgICAgIHRpdGxlOiBcIkNvbW1hbmRcIixcclxuICAgICAgICB2YWx1ZXM6IE1JRElFdmVudC5jb21tYW5kc19yZXZlcnNlZFxyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElGaWx0ZXIucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHN0ciA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5jbWQgPT0gLTEpIHtcclxuICAgICAgICAgICAgc3RyID0gXCJOb3RoaW5nXCI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RyID0gTUlESUV2ZW50LmNvbW1hbmRzX3Nob3J0W3RoaXMucHJvcGVydGllcy5jbWRdIHx8IFwiVW5rbm93blwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWluX3ZhbHVlICE9IC0xICYmXHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5tYXhfdmFsdWUgIT0gLTFcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgc3RyICs9XHJcbiAgICAgICAgICAgICAgICBcIiBcIiArXHJcbiAgICAgICAgICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLm1pbl92YWx1ZSA9PSB0aGlzLnByb3BlcnRpZXMubWF4X3ZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnByb3BlcnRpZXMubWF4X3ZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnByb3BlcnRpZXMubWluX3ZhbHVlICtcclxuICAgICAgICAgICAgICAgICAgICAgIFwiLi5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWF4X3ZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBcIkZpbHRlcjogXCIgKyBzdHI7XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUZpbHRlci5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09IFwiY21kXCIpIHtcclxuICAgICAgICAgICAgdmFyIG51bSA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihudW0pKSB7XHJcbiAgICAgICAgICAgICAgICBudW0gPSBNSURJRXZlbnQuY29tbWFuZHNbdmFsdWVdIHx8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmNtZCA9IG51bTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUZpbHRlci5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihldmVudCwgbWlkaV9ldmVudCkge1xyXG4gICAgICAgIGlmICghbWlkaV9ldmVudCB8fCBtaWRpX2V2ZW50LmNvbnN0cnVjdG9yICE9PSBNSURJRXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2xlYXJuaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlYXJuaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYm94Y29sb3IgPSBcIiNBQUFcIjtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWwgPSBtaWRpX2V2ZW50LmNoYW5uZWw7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5jbWQgPSBtaWRpX2V2ZW50LmNtZDtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm1pbl92YWx1ZSA9IHRoaXMucHJvcGVydGllcy5tYXhfdmFsdWUgPVxyXG4gICAgICAgICAgICAgICAgbWlkaV9ldmVudC5kYXRhWzFdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5jaGFubmVsICE9IC0xICYmXHJcbiAgICAgICAgICAgICAgICBtaWRpX2V2ZW50LmNoYW5uZWwgIT0gdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmNtZCAhPSAtMSAmJlxyXG4gICAgICAgICAgICAgICAgbWlkaV9ldmVudC5jbWQgIT0gdGhpcy5wcm9wZXJ0aWVzLmNtZFxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWluX3ZhbHVlICE9IC0xICYmXHJcbiAgICAgICAgICAgICAgICBtaWRpX2V2ZW50LmRhdGFbMV0gPCB0aGlzLnByb3BlcnRpZXMubWluX3ZhbHVlXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5tYXhfdmFsdWUgIT0gLTEgJiZcclxuICAgICAgICAgICAgICAgIG1pZGlfZXZlbnQuZGF0YVsxXSA+IHRoaXMucHJvcGVydGllcy5tYXhfdmFsdWVcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudHJpZ2dlcihcIm9uX21pZGlcIiwgbWlkaV9ldmVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWlkaS9maWx0ZXJcIiwgTEdNSURJRmlsdGVyKTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR01JRElFdmVudCgpIHtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIGNoYW5uZWw6IDAsXHJcbiAgICAgICAgICAgIGNtZDogMTQ0LCAvLzB4OTBcclxuICAgICAgICAgICAgdmFsdWUxOiAxLFxyXG4gICAgICAgICAgICB2YWx1ZTI6IDFcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmFkZElucHV0KFwic2VuZFwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJhc3NpZ25cIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm9uX21pZGlcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuXHJcbiAgICAgICAgdGhpcy5taWRpX2V2ZW50ID0gbmV3IE1JRElFdmVudCgpO1xyXG4gICAgICAgIHRoaXMuZ2F0ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIExHTUlESUV2ZW50LnRpdGxlID0gXCJNSURJRXZlbnRcIjtcclxuICAgIExHTUlESUV2ZW50LmRlc2MgPSBcIkNyZWF0ZSBhIE1JREkgRXZlbnRcIjtcclxuICAgIExHTUlESUV2ZW50LmNvbG9yID0gTUlESV9DT0xPUjtcclxuXHJcbiAgICBMR01JRElFdmVudC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihldmVudCwgbWlkaV9ldmVudCkge1xyXG4gICAgICAgIGlmIChldmVudCA9PSBcImFzc2lnblwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5jaGFubmVsID0gbWlkaV9ldmVudC5jaGFubmVsO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuY21kID0gbWlkaV9ldmVudC5jbWQ7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZTEgPSBtaWRpX2V2ZW50LmRhdGFbMV07XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZTIgPSBtaWRpX2V2ZW50LmRhdGFbMl07XHJcbiAgICAgICAgICAgIGlmIChtaWRpX2V2ZW50LmNtZCA9PSBNSURJRXZlbnQuTk9URU9OKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1pZGlfZXZlbnQuY21kID09IE1JRElFdmVudC5OT1RFT0ZGKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3NlbmRcclxuICAgICAgICB2YXIgbWlkaV9ldmVudCA9IHRoaXMubWlkaV9ldmVudDtcclxuICAgICAgICBtaWRpX2V2ZW50LmNoYW5uZWwgPSB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbDtcclxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmNtZCAmJiB0aGlzLnByb3BlcnRpZXMuY21kLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcclxuICAgICAgICAgICAgbWlkaV9ldmVudC5zZXRDb21tYW5kRnJvbVN0cmluZyh0aGlzLnByb3BlcnRpZXMuY21kKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtaWRpX2V2ZW50LmNtZCA9IHRoaXMucHJvcGVydGllcy5jbWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1pZGlfZXZlbnQuZGF0YVswXSA9IG1pZGlfZXZlbnQuY21kIHwgbWlkaV9ldmVudC5jaGFubmVsO1xyXG4gICAgICAgIG1pZGlfZXZlbnQuZGF0YVsxXSA9IE51bWJlcih0aGlzLnByb3BlcnRpZXMudmFsdWUxKTtcclxuICAgICAgICBtaWRpX2V2ZW50LmRhdGFbMl0gPSBOdW1iZXIodGhpcy5wcm9wZXJ0aWVzLnZhbHVlMik7XHJcblxyXG4gICAgICAgIHRoaXMudHJpZ2dlcihcIm9uX21pZGlcIiwgbWlkaV9ldmVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUV2ZW50LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BlcnRpZXM7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlucHV0cykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5saW5rID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGlucHV0Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm90ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodi5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IE1JRElFdmVudC5Ob3RlU3RyaW5nVG9QaXRjaCh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZTEgPSAodiB8IDApICUgMjU1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjbWRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmNtZCA9IHY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInZhbHVlMVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMudmFsdWUxID0gY2xhbXAodnwwLDAsMTI3KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWUyXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52YWx1ZTIgPSBjbGFtcCh2fDAsMCwxMjcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5vdXRwdXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvdXRwdXQubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtaWRpXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBuZXcgTUlESUV2ZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYuc2V0dXAoW3Byb3BzLmNtZCwgcHJvcHMudmFsdWUxLCBwcm9wcy52YWx1ZTJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdi5jaGFubmVsID0gcHJvcHMuY2hhbm5lbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbW1hbmRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHByb3BzLmNtZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNjXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBwcm9wcy52YWx1ZTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjY192YWx1ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gcHJvcHMudmFsdWUyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm90ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmNtZCA9PSBNSURJRXZlbnQuTk9URU9OIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5jbWQgPT0gTUlESUV2ZW50Lk5PVEVPRkZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHByb3BzLnZhbHVlMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInZlbG9jaXR5XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBwcm9wcy5jbWQgPT0gTUlESUV2ZW50Lk5PVEVPTiA/IHByb3BzLnZhbHVlMiA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwaXRjaFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmNtZCA9PSBNSURJRXZlbnQuTk9URU9OXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBNSURJRXZlbnQuY29tcHV0ZVBpdGNoKHByb3BzLnZhbHVlMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwaXRjaGJlbmRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5jbWQgPT0gTUlESUV2ZW50LlBJVENIQkVORFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gTUlESUV2ZW50LmNvbXB1dGVQaXRjaEJlbmQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMudmFsdWUxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLnZhbHVlMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdhdGVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuZ2F0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YShpLCB2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJRXZlbnQucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcImNtZFwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5jbWQgPSBNSURJRXZlbnQuY29tcHV0ZUNvbW1hbmRGcm9tU3RyaW5nKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUV2ZW50LnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wiY21kXCIsIFwibnVtYmVyXCJdLFtcIm5vdGVcIiwgXCJudW1iZXJcIl0sW1widmFsdWUxXCIsIFwibnVtYmVyXCJdLFtcInZhbHVlMlwiLCBcIm51bWJlclwiXV07XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUV2ZW50LnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbXCJtaWRpXCIsIFwibWlkaVwiXSxcclxuICAgICAgICAgICAgW1wib25fbWlkaVwiLCBMaXRlR3JhcGguRVZFTlRdLFxyXG4gICAgICAgICAgICBbXCJjb21tYW5kXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJub3RlXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJ2ZWxvY2l0eVwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiY2NcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImNjX3ZhbHVlXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJwaXRjaFwiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wiZ2F0ZVwiLCBcImJvb2xcIl0sXHJcbiAgICAgICAgICAgIFtcInBpdGNoYmVuZFwiLCBcIm51bWJlclwiXVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWlkaS9ldmVudFwiLCBMR01JRElFdmVudCk7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdNSURJQ0MoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICAvL1x0XHRjaGFubmVsOiAwLFxyXG4gICAgICAgICAgICBjYzogMSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcInZhbHVlXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIExHTUlESUNDLnRpdGxlID0gXCJNSURJQ0NcIjtcclxuICAgIExHTUlESUNDLmRlc2MgPSBcImdldHMgYSBDb250cm9sbGVyIENoYW5nZVwiO1xyXG4gICAgTEdNSURJQ0MuY29sb3IgPSBNSURJX0NPTE9SO1xyXG5cclxuICAgIExHTUlESUNDLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BlcnRpZXM7XHJcbiAgICAgICAgaWYgKE1JRElJbnRlcmZhY2UuaW5wdXQpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZhbHVlID1cclxuICAgICAgICAgICAgICAgIE1JRElJbnRlcmZhY2UuaW5wdXQuc3RhdGUuY2NbdGhpcy5wcm9wZXJ0aWVzLmNjXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsIHRoaXMucHJvcGVydGllcy52YWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWlkaS9jY1wiLCBMR01JRElDQyk7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdNSURJR2VuZXJhdG9yKCkge1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJnZW5lcmF0ZVwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwic2NhbGVcIiwgXCJzdHJpbmdcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIm9jdGF2ZVwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm5vdGVcIiwgTGl0ZUdyYXBoLkVWRU5UKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIG5vdGVzOiBcIkEsQSMsQixDLEMjLEQsRCMsRSxGLEYjLEcsRyNcIixcclxuICAgICAgICAgICAgb2N0YXZlOiAyLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogMC41LFxyXG4gICAgICAgICAgICBtb2RlOiBcInNlcXVlbmNlXCJcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLm5vdGVzX3BpdGNoZXMgPSBMR01JRElHZW5lcmF0b3IucHJvY2Vzc1NjYWxlKFxyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubm90ZXNcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuc2VxdWVuY2VfaW5kZXggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIExHTUlESUdlbmVyYXRvci50aXRsZSA9IFwiTUlESSBHZW5lcmF0b3JcIjtcclxuICAgIExHTUlESUdlbmVyYXRvci5kZXNjID0gXCJHZW5lcmF0ZXMgYSByYW5kb20gTUlESSBub3RlXCI7XHJcbiAgICBMR01JRElHZW5lcmF0b3IuY29sb3IgPSBNSURJX0NPTE9SO1xyXG5cclxuICAgIExHTUlESUdlbmVyYXRvci5wcm9jZXNzU2NhbGUgPSBmdW5jdGlvbihzY2FsZSkge1xyXG4gICAgICAgIHZhciBub3RlcyA9IHNjYWxlLnNwbGl0KFwiLFwiKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdGVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gbm90ZXNbaV07XHJcbiAgICAgICAgICAgIGlmICgobi5sZW5ndGggPT0gMiAmJiBuWzFdICE9IFwiI1wiKSB8fCBuLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgICAgIG5vdGVzW2ldID0gLUxpdGVHcmFwaC5NSURJRXZlbnQuTm90ZVN0cmluZ1RvUGl0Y2gobik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBub3Rlc1tpXSA9IE1JRElFdmVudC5ub3RlX3RvX2luZGV4W25dIHx8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vdGVzO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElHZW5lcmF0b3IucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcIm5vdGVzXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5ub3Rlc19waXRjaGVzID0gTEdNSURJR2VuZXJhdG9yLnByb2Nlc3NTY2FsZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElHZW5lcmF0b3IucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBvY3RhdmUgPSB0aGlzLmdldElucHV0RGF0YSgyKTtcclxuICAgICAgICBpZiAob2N0YXZlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLm9jdGF2ZSA9IG9jdGF2ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgIGlmIChzY2FsZSkge1xyXG4gICAgICAgICAgICB0aGlzLm5vdGVzX3BpdGNoZXMgPSBMR01JRElHZW5lcmF0b3IucHJvY2Vzc1NjYWxlKHNjYWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUdlbmVyYXRvci5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihldmVudCwgbWlkaV9ldmVudCkge1xyXG4gICAgICAgIC8vdmFyIHJhbmdlID0gdGhpcy5wcm9wZXJ0aWVzLm1heCAtIHRoaXMucHJvcGVydGllcy5taW47XHJcbiAgICAgICAgLy92YXIgcGl0Y2ggPSB0aGlzLnByb3BlcnRpZXMubWluICsgKChNYXRoLnJhbmRvbSgpICogcmFuZ2UpfDApO1xyXG4gICAgICAgIHZhciBwaXRjaCA9IDA7XHJcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5ub3Rlc19waXRjaGVzLmxlbmd0aDtcclxuICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLm1vZGUgPT0gXCJzZXF1ZW5jZVwiKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zZXF1ZW5jZV9pbmRleCA9ICh0aGlzLnNlcXVlbmNlX2luZGV4ICsgMSkgJSByYW5nZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJvcGVydGllcy5tb2RlID09IFwicmFuZG9tXCIpIHtcclxuICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByYW5nZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbm90ZSA9IHRoaXMubm90ZXNfcGl0Y2hlc1tpbmRleF07XHJcbiAgICAgICAgaWYgKG5vdGUgPj0gMCkge1xyXG4gICAgICAgICAgICBwaXRjaCA9IG5vdGUgKyAodGhpcy5wcm9wZXJ0aWVzLm9jdGF2ZSAtIDEpICogMTIgKyAzMztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwaXRjaCA9IC1ub3RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG1pZGlfZXZlbnQgPSBuZXcgTUlESUV2ZW50KCk7XHJcbiAgICAgICAgbWlkaV9ldmVudC5zZXR1cChbTUlESUV2ZW50Lk5PVEVPTiwgcGl0Y2gsIDEwXSk7XHJcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5wcm9wZXJ0aWVzLmR1cmF0aW9uIHx8IDE7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwibm90ZVwiLCBtaWRpX2V2ZW50KTtcclxuXHJcbiAgICAgICAgLy9ub3Rlb2ZmXHJcbiAgICAgICAgc2V0VGltZW91dChcclxuICAgICAgICAgICAgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWlkaV9ldmVudCA9IG5ldyBNSURJRXZlbnQoKTtcclxuICAgICAgICAgICAgICAgIG1pZGlfZXZlbnQuc2V0dXAoW01JRElFdmVudC5OT1RFT0ZGLCBwaXRjaCwgMF0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwibm90ZVwiLCBtaWRpX2V2ZW50KTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICBkdXJhdGlvbiAqIDEwMDBcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1pZGkvZ2VuZXJhdG9yXCIsIExHTUlESUdlbmVyYXRvcik7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdNSURJVHJhbnNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgYW1vdW50OiAwXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImFtb3VudFwiLCBcIm51bWJlclwiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG5cclxuICAgICAgICB0aGlzLm1pZGlfZXZlbnQgPSBuZXcgTUlESUV2ZW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgTEdNSURJVHJhbnNwb3NlLnRpdGxlID0gXCJNSURJIFRyYW5zcG9zZVwiO1xyXG4gICAgTEdNSURJVHJhbnNwb3NlLmRlc2MgPSBcIlRyYW5zcG9zZSBhIE1JREkgbm90ZVwiO1xyXG4gICAgTEdNSURJVHJhbnNwb3NlLmNvbG9yID0gTUlESV9DT0xPUjtcclxuXHJcbiAgICBMR01JRElUcmFuc3Bvc2UucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oZXZlbnQsIG1pZGlfZXZlbnQpIHtcclxuICAgICAgICBpZiAoIW1pZGlfZXZlbnQgfHwgbWlkaV9ldmVudC5jb25zdHJ1Y3RvciAhPT0gTUlESUV2ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgbWlkaV9ldmVudC5kYXRhWzBdID09IE1JRElFdmVudC5OT1RFT04gfHxcclxuICAgICAgICAgICAgbWlkaV9ldmVudC5kYXRhWzBdID09IE1JRElFdmVudC5OT1RFT0ZGXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWlkaV9ldmVudCA9IG5ldyBNSURJRXZlbnQoKTtcclxuICAgICAgICAgICAgdGhpcy5taWRpX2V2ZW50LnNldHVwKG1pZGlfZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMubWlkaV9ldmVudC5kYXRhWzFdID0gTWF0aC5yb3VuZChcclxuICAgICAgICAgICAgICAgIHRoaXMubWlkaV9ldmVudC5kYXRhWzFdICsgdGhpcy5wcm9wZXJ0aWVzLmFtb3VudFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJvdXRcIiwgdGhpcy5taWRpX2V2ZW50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJvdXRcIiwgbWlkaV9ldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElUcmFuc3Bvc2UucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBhbW91bnQgPSB0aGlzLmdldElucHV0RGF0YSgxKTtcclxuICAgICAgICBpZiAoYW1vdW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmFtb3VudCA9IGFtb3VudDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWlkaS90cmFuc3Bvc2VcIiwgTEdNSURJVHJhbnNwb3NlKTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR01JRElRdWFudGl6ZSgpIHtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIHNjYWxlOiBcIkEsQSMsQixDLEMjLEQsRCMsRSxGLEYjLEcsRyNcIlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcIm5vdGVcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInNjYWxlXCIsIFwic3RyaW5nXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcblxyXG4gICAgICAgIHRoaXMudmFsaWRfbm90ZXMgPSBuZXcgQXJyYXkoMTIpO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0X25vdGVzID0gbmV3IEFycmF5KDEyKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NTY2FsZSh0aGlzLnByb3BlcnRpZXMuc2NhbGUpO1xyXG4gICAgfVxyXG5cclxuICAgIExHTUlESVF1YW50aXplLnRpdGxlID0gXCJNSURJIFF1YW50aXplIFBpdGNoXCI7XHJcbiAgICBMR01JRElRdWFudGl6ZS5kZXNjID0gXCJUcmFuc3Bvc2UgYSBNSURJIG5vdGUgdHAgZml0IGFuIHNjYWxlXCI7XHJcbiAgICBMR01JRElRdWFudGl6ZS5jb2xvciA9IE1JRElfQ09MT1I7XHJcblxyXG4gICAgTEdNSURJUXVhbnRpemUucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcInNjYWxlXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzU2NhbGUodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJUXVhbnRpemUucHJvdG90eXBlLnByb2Nlc3NTY2FsZSA9IGZ1bmN0aW9uKHNjYWxlKSB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudF9zY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgIHRoaXMubm90ZXNfcGl0Y2hlcyA9IExHTUlESUdlbmVyYXRvci5wcm9jZXNzU2NhbGUoc2NhbGUpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTI7ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbGlkX25vdGVzW2ldID0gdGhpcy5ub3Rlc19waXRjaGVzLmluZGV4T2YoaSkgIT0gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTI7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy52YWxpZF9ub3Rlc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRfbm90ZXNbaV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCAxMjsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWxpZF9ub3Rlc1soaSAtIGopICUgMTJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRfbm90ZXNbaV0gPSAtajtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkX25vdGVzWyhpICsgaikgJSAxMl0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldF9ub3Rlc1tpXSA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESVF1YW50aXplLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGV2ZW50LCBtaWRpX2V2ZW50KSB7XHJcbiAgICAgICAgaWYgKCFtaWRpX2V2ZW50IHx8IG1pZGlfZXZlbnQuY29uc3RydWN0b3IgIT09IE1JRElFdmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIG1pZGlfZXZlbnQuZGF0YVswXSA9PSBNSURJRXZlbnQuTk9URU9OIHx8XHJcbiAgICAgICAgICAgIG1pZGlfZXZlbnQuZGF0YVswXSA9PSBNSURJRXZlbnQuTk9URU9GRlxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICB0aGlzLm1pZGlfZXZlbnQgPSBuZXcgTUlESUV2ZW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMubWlkaV9ldmVudC5zZXR1cChtaWRpX2V2ZW50LmRhdGEpO1xyXG4gICAgICAgICAgICB2YXIgbm90ZSA9IG1pZGlfZXZlbnQubm90ZTtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gTUlESUV2ZW50Lm5vdGVfdG9faW5kZXhbbm90ZV07XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldF9ub3Rlc1tpbmRleF07XHJcbiAgICAgICAgICAgIHRoaXMubWlkaV9ldmVudC5kYXRhWzFdICs9IG9mZnNldDtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwib3V0XCIsIHRoaXMubWlkaV9ldmVudCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwib3V0XCIsIG1pZGlfZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJUXVhbnRpemUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0SW5wdXREYXRhKDEpO1xyXG4gICAgICAgIGlmIChzY2FsZSAhPSBudWxsICYmIHNjYWxlICE9IHRoaXMuX2N1cnJlbnRfc2NhbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzU2NhbGUoc2NhbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJtaWRpL3F1YW50aXplXCIsIExHTUlESVF1YW50aXplKTtcclxuXHJcblx0ZnVuY3Rpb24gTEdNSURJRnJvbUZpbGUoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICB1cmw6IFwiXCIsXHJcblx0XHRcdGF1dG9wbGF5OiB0cnVlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInBsYXlcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInBhdXNlXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwibm90ZVwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG5cdFx0dGhpcy5fbWlkaSA9IG51bGw7XHJcblx0XHR0aGlzLl9jdXJyZW50X3RpbWUgPSAwO1xyXG5cdFx0dGhpcy5fcGxheWluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIE1pZGlQYXJzZXIgPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJtaWRpLXBhcnNlci5qcyBub3QgaW5jbHVkZWQsIExHTWlkaVBsYXkgcmVxdWlyZXMgdGhhdCBsaWJyYXJ5OiBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vY29seGkvbWlkaS1wYXJzZXItanMvbWFzdGVyL3NyYy9tYWluLmpzXCJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwicmVkXCI7XHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbiAgICBMR01JRElGcm9tRmlsZS50aXRsZSA9IFwiTUlESSBmcm9tRmlsZVwiO1xyXG4gICAgTEdNSURJRnJvbUZpbGUuZGVzYyA9IFwiUGxheXMgYSBNSURJIGZpbGVcIjtcclxuICAgIExHTUlESUZyb21GaWxlLmNvbG9yID0gTUlESV9DT0xPUjtcclxuXHJcblx0TEdNSURJRnJvbUZpbGUucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oIG5hbWUgKVxyXG5cdHtcclxuXHRcdGlmKG5hbWUgPT0gXCJwbGF5XCIpXHJcblx0XHRcdHRoaXMucGxheSgpO1xyXG5cdFx0ZWxzZSBpZihuYW1lID09IFwicGF1c2VcIilcclxuXHRcdFx0dGhpcy5fcGxheWluZyA9ICF0aGlzLl9wbGF5aW5nO1xyXG5cdH1cclxuXHJcblx0TEdNSURJRnJvbUZpbGUucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSx2YWx1ZSlcclxuXHR7XHJcblx0XHRpZihuYW1lID09IFwidXJsXCIpXHJcblx0XHRcdHRoaXMubG9hZE1JRElGaWxlKHZhbHVlKTtcclxuXHR9XHJcblxyXG4gICAgTEdNSURJRnJvbUZpbGUucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYoIXRoaXMuX21pZGkpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHRpZighdGhpcy5fcGxheWluZylcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHRoaXMuX2N1cnJlbnRfdGltZSArPSB0aGlzLmdyYXBoLmVsYXBzZWRfdGltZTtcclxuXHRcdHZhciBjdXJyZW50X3RpbWUgPSB0aGlzLl9jdXJyZW50X3RpbWUgKiAxMDA7XHJcblxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX21pZGkudHJhY2tzOyArK2kpXHJcblx0XHR7XHJcblx0XHRcdHZhciB0cmFjayA9IHRoaXMuX21pZGkudHJhY2tbaV07XHJcblx0XHRcdGlmKCF0cmFjay5fbGFzdF9wb3MpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0cmFjay5fbGFzdF9wb3MgPSAwO1xyXG5cdFx0XHRcdHRyYWNrLl90aW1lID0gMDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGVsZW0gPSB0cmFjay5ldmVudFsgdHJhY2suX2xhc3RfcG9zIF07XHJcblx0XHRcdGlmKGVsZW0gJiYgKHRyYWNrLl90aW1lICsgZWxlbS5kZWx0YVRpbWUpIDw9IGN1cnJlbnRfdGltZSApXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0cmFjay5fbGFzdF9wb3MrKztcclxuXHRcdFx0XHR0cmFjay5fdGltZSArPSBlbGVtLmRlbHRhVGltZTtcclxuXHJcblx0XHRcdFx0aWYoZWxlbS5kYXRhKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHZhciBtaWRpX2NtZCA9IGVsZW0udHlwZSA8PCA0ICsgZWxlbS5jaGFubmVsO1xyXG5cdFx0XHRcdFx0dmFyIG1pZGlfZXZlbnQgPSBuZXcgTUlESUV2ZW50KCk7XHJcblx0XHRcdFx0XHRtaWRpX2V2ZW50LnNldHVwKFttaWRpX2NtZCwgZWxlbS5kYXRhWzBdLCBlbGVtLmRhdGFbMV1dKTtcclxuXHRcdFx0XHRcdHRoaXMudHJpZ2dlcihcIm5vdGVcIiwgbWlkaV9ldmVudCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0fVxyXG4gICAgfTtcclxuXHJcblx0TEdNSURJRnJvbUZpbGUucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbigpXHJcblx0e1xyXG5cdFx0dGhpcy5fcGxheWluZyA9IHRydWU7XHJcblx0XHR0aGlzLl9jdXJyZW50X3RpbWUgPSAwO1xyXG5cdFx0aWYoIXRoaXMuX21pZGkpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fbWlkaS50cmFja3M7ICsraSlcclxuXHRcdHtcclxuXHRcdFx0dmFyIHRyYWNrID0gdGhpcy5fbWlkaS50cmFja1tpXTtcclxuXHRcdFx0dHJhY2suX2xhc3RfcG9zID0gMDtcclxuXHRcdFx0dHJhY2suX3RpbWUgPSAwO1xyXG5cdFx0fVx0XHRcclxuXHR9XHJcblxyXG5cdExHTUlESUZyb21GaWxlLnByb3RvdHlwZS5sb2FkTUlESUZpbGUgPSBmdW5jdGlvbih1cmwpXHJcblx0e1xyXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cdFx0TGl0ZUdyYXBoLmZldGNoRmlsZSggdXJsLCBcImFycmF5YnVmZmVyXCIsIGZ1bmN0aW9uKGRhdGEpXHJcblx0XHR7XHJcblx0XHRcdHRoYXQuYm94Y29sb3IgPSBcIiNBRkFcIjtcclxuXHRcdFx0dGhhdC5fbWlkaSA9IE1pZGlQYXJzZXIucGFyc2UoIG5ldyBVaW50OEFycmF5KGRhdGEpICk7XHJcblx0XHRcdGlmKHRoYXQucHJvcGVydGllcy5hdXRvcGxheSlcclxuXHRcdFx0XHR0aGF0LnBsYXkoKTtcclxuXHRcdH0sIGZ1bmN0aW9uKGVycil7XHJcblx0XHRcdHRoYXQuYm94Y29sb3IgPSBcIiNGQUFcIjtcclxuXHRcdFx0dGhhdC5fbWlkaSA9IG51bGw7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdExHTUlESUZyb21GaWxlLnByb3RvdHlwZS5vbkRyb3BGaWxlID0gZnVuY3Rpb24oZmlsZSlcclxuXHR7XHJcblx0XHR0aGlzLnByb3BlcnRpZXMudXJsID0gXCJcIjtcclxuXHRcdHRoaXMubG9hZE1JRElGaWxlKCBmaWxlICk7XHJcblx0fVxyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWlkaS9mcm9tRmlsZVwiLCBMR01JRElGcm9tRmlsZSk7XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIExHTUlESVBsYXkoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICB2b2x1bWU6IDAuNSxcclxuICAgICAgICAgICAgZHVyYXRpb246IDFcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJub3RlXCIsIExpdGVHcmFwaC5BQ1RJT04pO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJ2b2x1bWVcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImR1cmF0aW9uXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwibm90ZVwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIEF1ZGlvU3ludGggPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJBdWRpb3N5bnRoLmpzIG5vdCBpbmNsdWRlZCwgTEdNaWRpUGxheSByZXF1aXJlcyB0aGF0IGxpYnJhcnlcIlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB0aGlzLmJveGNvbG9yID0gXCJyZWRcIjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgU3ludGggPSAodGhpcy5zeW50aCA9IG5ldyBBdWRpb1N5bnRoKCkpO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RydW1lbnQgPSBTeW50aC5jcmVhdGVJbnN0cnVtZW50KFwicGlhbm9cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIExHTUlESVBsYXkudGl0bGUgPSBcIk1JREkgUGxheVwiO1xyXG4gICAgTEdNSURJUGxheS5kZXNjID0gXCJQbGF5cyBhIE1JREkgbm90ZVwiO1xyXG4gICAgTEdNSURJUGxheS5jb2xvciA9IE1JRElfQ09MT1I7XHJcblxyXG4gICAgTEdNSURJUGxheS5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihldmVudCwgbWlkaV9ldmVudCkge1xyXG4gICAgICAgIGlmICghbWlkaV9ldmVudCB8fCBtaWRpX2V2ZW50LmNvbnN0cnVjdG9yICE9PSBNSURJRXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaW5zdHJ1bWVudCAmJiBtaWRpX2V2ZW50LmRhdGFbMF0gPT0gTUlESUV2ZW50Lk5PVEVPTikge1xyXG4gICAgICAgICAgICB2YXIgbm90ZSA9IG1pZGlfZXZlbnQubm90ZTsgLy9DI1xyXG4gICAgICAgICAgICBpZiAoIW5vdGUgfHwgbm90ZSA9PSBcInVuZGVmaW5lZFwiIHx8IG5vdGUuY29uc3RydWN0b3IgIT09IFN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdHJ1bWVudC5wbGF5KFxyXG4gICAgICAgICAgICAgICAgbm90ZSxcclxuICAgICAgICAgICAgICAgIG1pZGlfZXZlbnQub2N0YXZlLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnZvbHVtZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyaWdnZXIoXCJub3RlXCIsIG1pZGlfZXZlbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElQbGF5LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdm9sdW1lID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgaWYgKHZvbHVtZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy52b2x1bWUgPSB2b2x1bWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmdldElucHV0RGF0YSgyKTtcclxuICAgICAgICBpZiAoZHVyYXRpb24gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwibWlkaS9wbGF5XCIsIExHTUlESVBsYXkpO1xyXG5cclxuICAgIGZ1bmN0aW9uIExHTUlESUtleXMoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBudW1fb2N0YXZlczogMixcclxuICAgICAgICAgICAgc3RhcnRfb2N0YXZlOiAyXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwibm90ZVwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwicmVzZXRcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJub3RlXCIsIExpdGVHcmFwaC5FVkVOVCk7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzQwMCwgMTAwXTtcclxuICAgICAgICB0aGlzLmtleXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9sYXN0X2tleSA9IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIExHTUlESUtleXMudGl0bGUgPSBcIk1JREkgS2V5c1wiO1xyXG4gICAgTEdNSURJS2V5cy5kZXNjID0gXCJLZXlib2FyZCB0byBwbGF5IG5vdGVzXCI7XHJcbiAgICBMR01JRElLZXlzLmNvbG9yID0gTUlESV9DT0xPUjtcclxuXHJcbiAgICBMR01JRElLZXlzLmtleXMgPSBbXHJcbiAgICAgICAgeyB4OiAwLCB3OiAxLCBoOiAxLCB0OiAwIH0sXHJcbiAgICAgICAgeyB4OiAwLjc1LCB3OiAwLjUsIGg6IDAuNiwgdDogMSB9LFxyXG4gICAgICAgIHsgeDogMSwgdzogMSwgaDogMSwgdDogMCB9LFxyXG4gICAgICAgIHsgeDogMS43NSwgdzogMC41LCBoOiAwLjYsIHQ6IDEgfSxcclxuICAgICAgICB7IHg6IDIsIHc6IDEsIGg6IDEsIHQ6IDAgfSxcclxuICAgICAgICB7IHg6IDIuNzUsIHc6IDAuNSwgaDogMC42LCB0OiAxIH0sXHJcbiAgICAgICAgeyB4OiAzLCB3OiAxLCBoOiAxLCB0OiAwIH0sXHJcbiAgICAgICAgeyB4OiA0LCB3OiAxLCBoOiAxLCB0OiAwIH0sXHJcbiAgICAgICAgeyB4OiA0Ljc1LCB3OiAwLjUsIGg6IDAuNiwgdDogMSB9LFxyXG4gICAgICAgIHsgeDogNSwgdzogMSwgaDogMSwgdDogMCB9LFxyXG4gICAgICAgIHsgeDogNS43NSwgdzogMC41LCBoOiAwLjYsIHQ6IDEgfSxcclxuICAgICAgICB7IHg6IDYsIHc6IDEsIGg6IDEsIHQ6IDAgfVxyXG4gICAgXTtcclxuXHJcbiAgICBMR01JRElLZXlzLnByb3RvdHlwZS5vbkRyYXdGb3JlZ3JvdW5kID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MuY29sbGFwc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBudW1fa2V5cyA9IHRoaXMucHJvcGVydGllcy5udW1fb2N0YXZlcyAqIDEyO1xyXG4gICAgICAgIHRoaXMua2V5cy5sZW5ndGggPSBudW1fa2V5cztcclxuICAgICAgICB2YXIga2V5X3dpZHRoID0gdGhpcy5zaXplWzBdIC8gKHRoaXMucHJvcGVydGllcy5udW1fb2N0YXZlcyAqIDcpO1xyXG4gICAgICAgIHZhciBrZXlfaGVpZ2h0ID0gdGhpcy5zaXplWzFdO1xyXG5cclxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xyXG5cclxuICAgICAgICBmb3IgKFxyXG4gICAgICAgICAgICB2YXIgayA9IDA7XHJcbiAgICAgICAgICAgIGsgPCAyO1xyXG4gICAgICAgICAgICBrKysgLy9kcmF3IGZpcnN0IHdoaXRlcyAoMCkgdGhlbiBibGFja3MgKDEpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2tleXM7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleV9pbmZvID0gTEdNSURJS2V5cy5rZXlzW2kgJSAxMl07XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5X2luZm8udCAhPSBrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgb2N0YXZlID0gTWF0aC5mbG9vcihpIC8gMTIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBvY3RhdmUgKiA3ICoga2V5X3dpZHRoICsga2V5X2luZm8ueCAqIGtleV93aWR0aDtcclxuICAgICAgICAgICAgICAgIGlmIChrID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5rZXlzW2ldID8gXCIjQ0NDXCIgOiBcIndoaXRlXCI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmtleXNbaV0gPyBcIiMzMzNcIiA6IFwiYmxhY2tcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChcclxuICAgICAgICAgICAgICAgICAgICB4ICsgMSxcclxuICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGtleV93aWR0aCAqIGtleV9pbmZvLncgLSAyLFxyXG4gICAgICAgICAgICAgICAgICAgIGtleV9oZWlnaHQgKiBrZXlfaW5mby5oXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElLZXlzLnByb3RvdHlwZS5nZXRLZXlJbmRleCA9IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgICAgIHZhciBudW1fa2V5cyA9IHRoaXMucHJvcGVydGllcy5udW1fb2N0YXZlcyAqIDEyO1xyXG4gICAgICAgIHZhciBrZXlfd2lkdGggPSB0aGlzLnNpemVbMF0gLyAodGhpcy5wcm9wZXJ0aWVzLm51bV9vY3RhdmVzICogNyk7XHJcbiAgICAgICAgdmFyIGtleV9oZWlnaHQgPSB0aGlzLnNpemVbMV07XHJcblxyXG4gICAgICAgIGZvciAoXHJcbiAgICAgICAgICAgIHZhciBrID0gMTtcclxuICAgICAgICAgICAgayA+PSAwO1xyXG4gICAgICAgICAgICBrLS0gLy90ZXN0IGJsYWNrcyBmaXJzdCAoMSkgdGhlbiB3aGl0ZXMgKDApXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5X2luZm8gPSBMR01JRElLZXlzLmtleXNbaSAlIDEyXTtcclxuICAgICAgICAgICAgICAgIGlmIChrZXlfaW5mby50ICE9IGspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBvY3RhdmUgPSBNYXRoLmZsb29yKGkgLyAxMik7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IG9jdGF2ZSAqIDcgKiBrZXlfd2lkdGggKyBrZXlfaW5mby54ICoga2V5X3dpZHRoO1xyXG4gICAgICAgICAgICAgICAgdmFyIHcgPSBrZXlfd2lkdGggKiBrZXlfaW5mby53O1xyXG4gICAgICAgICAgICAgICAgdmFyIGggPSBrZXlfaGVpZ2h0ICoga2V5X2luZm8uaDtcclxuICAgICAgICAgICAgICAgIGlmIChwb3NbMF0gPCB4IHx8IHBvc1swXSA+IHggKyB3IHx8IHBvc1sxXSA+IGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH07XHJcblxyXG4gICAgTEdNSURJS2V5cy5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihldmVudCwgcGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKGV2ZW50ID09IFwicmVzZXRcIikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5rZXlzW2ldID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFwYXJhbXMgfHwgcGFyYW1zLmNvbnN0cnVjdG9yICE9PSBNSURJRXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWlkaV9ldmVudCA9IHBhcmFtcztcclxuICAgICAgICB2YXIgc3RhcnRfbm90ZSA9ICh0aGlzLnByb3BlcnRpZXMuc3RhcnRfb2N0YXZlIC0gMSkgKiAxMiArIDI5O1xyXG4gICAgICAgIHZhciBpbmRleCA9IG1pZGlfZXZlbnQuZGF0YVsxXSAtIHN0YXJ0X25vdGU7XHJcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLmtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmIChtaWRpX2V2ZW50LmRhdGFbMF0gPT0gTUlESUV2ZW50Lk5PVEVPTikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5rZXlzW2luZGV4XSA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWlkaV9ldmVudC5kYXRhWzBdID09IE1JRElFdmVudC5OT1RFT0ZGKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmtleXNbaW5kZXhdID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudHJpZ2dlcihcIm5vdGVcIiwgbWlkaV9ldmVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUtleXMucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24oZSwgcG9zKSB7XHJcbiAgICAgICAgaWYgKHBvc1sxXSA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEtleUluZGV4KHBvcyk7XHJcbiAgICAgICAgdGhpcy5rZXlzW2luZGV4XSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fbGFzdF9rZXkgPSBpbmRleDtcclxuICAgICAgICB2YXIgcGl0Y2ggPSAodGhpcy5wcm9wZXJ0aWVzLnN0YXJ0X29jdGF2ZSAtIDEpICogMTIgKyAyOSArIGluZGV4O1xyXG4gICAgICAgIHZhciBtaWRpX2V2ZW50ID0gbmV3IE1JRElFdmVudCgpO1xyXG4gICAgICAgIG1pZGlfZXZlbnQuc2V0dXAoW01JRElFdmVudC5OT1RFT04sIHBpdGNoLCAxMDBdKTtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoXCJub3RlXCIsIG1pZGlfZXZlbnQpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR01JRElLZXlzLnByb3RvdHlwZS5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uKGUsIHBvcykge1xyXG4gICAgICAgIGlmIChwb3NbMV0gPCAwIHx8IHRoaXMuX2xhc3Rfa2V5ID09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXREaXJ0eUNhbnZhcyh0cnVlKTtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEtleUluZGV4KHBvcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xhc3Rfa2V5ID09IGluZGV4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmtleXNbdGhpcy5fbGFzdF9rZXldID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHBpdGNoID1cclxuICAgICAgICAgICAgKHRoaXMucHJvcGVydGllcy5zdGFydF9vY3RhdmUgLSAxKSAqIDEyICsgMjkgKyB0aGlzLl9sYXN0X2tleTtcclxuICAgICAgICB2YXIgbWlkaV9ldmVudCA9IG5ldyBNSURJRXZlbnQoKTtcclxuICAgICAgICBtaWRpX2V2ZW50LnNldHVwKFtNSURJRXZlbnQuTk9URU9GRiwgcGl0Y2gsIDEwMF0pO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcihcIm5vdGVcIiwgbWlkaV9ldmVudCk7XHJcblxyXG4gICAgICAgIHRoaXMua2V5c1tpbmRleF0gPSB0cnVlO1xyXG4gICAgICAgIHZhciBwaXRjaCA9ICh0aGlzLnByb3BlcnRpZXMuc3RhcnRfb2N0YXZlIC0gMSkgKiAxMiArIDI5ICsgaW5kZXg7XHJcbiAgICAgICAgdmFyIG1pZGlfZXZlbnQgPSBuZXcgTUlESUV2ZW50KCk7XHJcbiAgICAgICAgbWlkaV9ldmVudC5zZXR1cChbTUlESUV2ZW50Lk5PVEVPTiwgcGl0Y2gsIDEwMF0pO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcihcIm5vdGVcIiwgbWlkaV9ldmVudCk7XHJcblxyXG4gICAgICAgIHRoaXMuX2xhc3Rfa2V5ID0gaW5kZXg7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIExHTUlESUtleXMucHJvdG90eXBlLm9uTW91c2VVcCA9IGZ1bmN0aW9uKGUsIHBvcykge1xyXG4gICAgICAgIGlmIChwb3NbMV0gPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRLZXlJbmRleChwb3MpO1xyXG4gICAgICAgIHRoaXMua2V5c1tpbmRleF0gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9sYXN0X2tleSA9IC0xO1xyXG4gICAgICAgIHZhciBwaXRjaCA9ICh0aGlzLnByb3BlcnRpZXMuc3RhcnRfb2N0YXZlIC0gMSkgKiAxMiArIDI5ICsgaW5kZXg7XHJcbiAgICAgICAgdmFyIG1pZGlfZXZlbnQgPSBuZXcgTUlESUV2ZW50KCk7XHJcbiAgICAgICAgbWlkaV9ldmVudC5zZXR1cChbTUlESUV2ZW50Lk5PVEVPRkYsIHBpdGNoLCAxMDBdKTtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoXCJub3RlXCIsIG1pZGlfZXZlbnQpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm1pZGkva2V5c1wiLCBMR01JRElLZXlzKTtcclxuXHJcbiAgICBmdW5jdGlvbiBub3coKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIH1cclxufSkodGhpcyk7XHJcblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xyXG4gICAgdmFyIExpdGVHcmFwaCA9IGdsb2JhbC5MaXRlR3JhcGg7XHJcblxyXG4gICAgdmFyIExHQXVkaW8gPSB7fTtcclxuICAgIGdsb2JhbC5MR0F1ZGlvID0gTEdBdWRpbztcclxuXHJcbiAgICBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fYXVkaW9fY29udGV4dCkge1xyXG4gICAgICAgICAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID1cclxuICAgICAgICAgICAgICAgIHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtcclxuICAgICAgICAgICAgaWYgKCF3aW5kb3cuQXVkaW9Db250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQXVkaW9Db250ZXh0IG5vdCBzdXBwb3J0ZWQgYnkgYnJvd3NlclwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvX2NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvX2NvbnRleHQub25tZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm1zZ1wiLCBtc2cpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb19jb250ZXh0Lm9uZW5kZWQgPSBmdW5jdGlvbihtc2cpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZW5kZWRcIiwgbXNnKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9fY29udGV4dC5vbmNvbXBsZXRlID0gZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbXBsZXRlXCIsIG1zZyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2luIGNhc2UgaXQgY3Jhc2hlc1xyXG4gICAgICAgIC8vaWYodGhpcy5fYXVkaW9fY29udGV4dC5zdGF0ZSA9PSBcInN1c3BlbmRlZFwiKVxyXG4gICAgICAgIC8vXHR0aGlzLl9hdWRpb19jb250ZXh0LnJlc3VtZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hdWRpb19jb250ZXh0O1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvLmNvbm5lY3QgPSBmdW5jdGlvbihhdWRpb25vZGVBLCBhdWRpb25vZGVCKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXVkaW9ub2RlQS5jb25uZWN0KGF1ZGlvbm9kZUIpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJMR3JhcGhBdWRpbzpcIiwgZXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW8uZGlzY29ubmVjdCA9IGZ1bmN0aW9uKGF1ZGlvbm9kZUEsIGF1ZGlvbm9kZUIpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhdWRpb25vZGVBLmRpc2Nvbm5lY3QoYXVkaW9ub2RlQik7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkxHcmFwaEF1ZGlvOlwiLCBlcnIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpby5jaGFuZ2VBbGxBdWRpb3NDb25uZWN0aW9ucyA9IGZ1bmN0aW9uKG5vZGUsIGNvbm5lY3QpIHtcclxuICAgICAgICBpZiAobm9kZS5pbnB1dHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmlucHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gbm9kZS5pbnB1dHNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlua19pbmZvID0gbm9kZS5ncmFwaC5saW5rc1tpbnB1dC5saW5rXTtcclxuICAgICAgICAgICAgICAgIGlmICghbGlua19pbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbl9ub2RlID0gbm9kZS5ncmFwaC5nZXROb2RlQnlJZChsaW5rX2luZm8ub3JpZ2luX2lkKTtcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5fYXVkaW9ub2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5fbm9kZS5nZXRBdWRpb05vZGVJbk91dHB1dFNsb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5fYXVkaW9ub2RlID0gb3JpZ2luX25vZGUuZ2V0QXVkaW9Ob2RlSW5PdXRwdXRTbG90KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8ub3JpZ2luX3Nsb3RcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5fYXVkaW9ub2RlID0gb3JpZ2luX25vZGUuYXVkaW9ub2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRfYXVkaW9ub2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmdldEF1ZGlvTm9kZUluSW5wdXRTbG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X2F1ZGlvbm9kZSA9IG5vZGUuZ2V0QXVkaW9Ob2RlSW5JbnB1dFNsb3QoaSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldF9hdWRpb25vZGUgPSBub2RlLmF1ZGlvbm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIExHQXVkaW8uY29ubmVjdChvcmlnaW5fYXVkaW9ub2RlLCB0YXJnZXRfYXVkaW9ub2RlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTEdBdWRpby5kaXNjb25uZWN0KG9yaWdpbl9hdWRpb25vZGUsIHRhcmdldF9hdWRpb25vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobm9kZS5vdXRwdXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gbm9kZS5vdXRwdXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdXRwdXQubGlua3MubGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGlua19pbmZvID0gbm9kZS5ncmFwaC5saW5rc1tvdXRwdXQubGlua3Nbal1dO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbGlua19pbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbl9hdWRpb25vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmdldEF1ZGlvTm9kZUluT3V0cHV0U2xvdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5fYXVkaW9ub2RlID0gbm9kZS5nZXRBdWRpb05vZGVJbk91dHB1dFNsb3QoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luX2F1ZGlvbm9kZSA9IG5vZGUuYXVkaW9ub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldF9ub2RlID0gbm9kZS5ncmFwaC5nZXROb2RlQnlJZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua19pbmZvLnRhcmdldF9pZFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldF9hdWRpb25vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRfbm9kZS5nZXRBdWRpb05vZGVJbklucHV0U2xvdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRfYXVkaW9ub2RlID0gdGFyZ2V0X25vZGUuZ2V0QXVkaW9Ob2RlSW5JbnB1dFNsb3QoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2luZm8udGFyZ2V0X3Nsb3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRfYXVkaW9ub2RlID0gdGFyZ2V0X25vZGUuYXVkaW9ub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTEdBdWRpby5jb25uZWN0KG9yaWdpbl9hdWRpb25vZGUsIHRhcmdldF9hdWRpb25vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExHQXVkaW8uZGlzY29ubmVjdChvcmlnaW5fYXVkaW9ub2RlLCB0YXJnZXRfYXVkaW9ub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vdXNlZCBieSBtYW55IG5vZGVzXHJcbiAgICBMR0F1ZGlvLm9uQ29ubmVjdGlvbnNDaGFuZ2UgPSBmdW5jdGlvbihcclxuICAgICAgICBjb25uZWN0aW9uLFxyXG4gICAgICAgIHNsb3QsXHJcbiAgICAgICAgY29ubmVjdGVkLFxyXG4gICAgICAgIGxpbmtfaW5mb1xyXG4gICAgKSB7XHJcbiAgICAgICAgLy9vbmx5IHByb2Nlc3MgdGhlIG91dHB1dHMgZXZlbnRzXHJcbiAgICAgICAgaWYgKGNvbm5lY3Rpb24gIT0gTGl0ZUdyYXBoLk9VVFBVVCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdGFyZ2V0X25vZGUgPSBudWxsO1xyXG4gICAgICAgIGlmIChsaW5rX2luZm8pIHtcclxuICAgICAgICAgICAgdGFyZ2V0X25vZGUgPSB0aGlzLmdyYXBoLmdldE5vZGVCeUlkKGxpbmtfaW5mby50YXJnZXRfaWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0YXJnZXRfbm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2dldCBvcmlnaW4gYXVkaW9ub2RlXHJcbiAgICAgICAgdmFyIGxvY2FsX2F1ZGlvbm9kZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0QXVkaW9Ob2RlSW5PdXRwdXRTbG90KSB7XHJcbiAgICAgICAgICAgIGxvY2FsX2F1ZGlvbm9kZSA9IHRoaXMuZ2V0QXVkaW9Ob2RlSW5PdXRwdXRTbG90KHNsb3QpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxvY2FsX2F1ZGlvbm9kZSA9IHRoaXMuYXVkaW9ub2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9nZXQgdGFyZ2V0IGF1ZGlvbm9kZVxyXG4gICAgICAgIHZhciB0YXJnZXRfYXVkaW9ub2RlID0gbnVsbDtcclxuICAgICAgICBpZiAodGFyZ2V0X25vZGUuZ2V0QXVkaW9Ob2RlSW5JbnB1dFNsb3QpIHtcclxuICAgICAgICAgICAgdGFyZ2V0X2F1ZGlvbm9kZSA9IHRhcmdldF9ub2RlLmdldEF1ZGlvTm9kZUluSW5wdXRTbG90KFxyXG4gICAgICAgICAgICAgICAgbGlua19pbmZvLnRhcmdldF9zbG90XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGFyZ2V0X2F1ZGlvbm9kZSA9IHRhcmdldF9ub2RlLmF1ZGlvbm9kZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZG8gdGhlIGNvbm5lY3Rpb24vZGlzY29ubmVjdGlvblxyXG4gICAgICAgIGlmIChjb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgTEdBdWRpby5jb25uZWN0KGxvY2FsX2F1ZGlvbm9kZSwgdGFyZ2V0X2F1ZGlvbm9kZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgTEdBdWRpby5kaXNjb25uZWN0KGxvY2FsX2F1ZGlvbm9kZSwgdGFyZ2V0X2F1ZGlvbm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvL3RoaXMgZnVuY3Rpb24gaGVscHMgY3JlYXRpbmcgd3JhcHBlcnMgdG8gZXhpc3RpbmcgY2xhc3Nlc1xyXG4gICAgTEdBdWRpby5jcmVhdGVBdWRpb05vZGVXcmFwcGVyID0gZnVuY3Rpb24oY2xhc3Nfb2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIG9sZF9mdW5jID0gY2xhc3Nfb2JqZWN0LnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZDtcclxuXHJcbiAgICAgICAgY2xhc3Nfb2JqZWN0LnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmIChvbGRfZnVuYykge1xyXG4gICAgICAgICAgICAgICAgb2xkX2Z1bmMuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5hdWRpb25vZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXVkaW9ub2RlW25hbWVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXVkaW9ub2RlW25hbWVdLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlW25hbWVdLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZVtuYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY2xhc3Nfb2JqZWN0LnByb3RvdHlwZS5vbkNvbm5lY3Rpb25zQ2hhbmdlID1cclxuICAgICAgICAgICAgTEdBdWRpby5vbkNvbm5lY3Rpb25zQ2hhbmdlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvL2NvbnRhaW5zIHRoZSBzYW1wbGVzIGRlY29kZWQgb2YgdGhlIGxvYWRlZCBhdWRpb3MgaW4gQXVkaW9CdWZmZXIgZm9ybWF0XHJcbiAgICBMR0F1ZGlvLmNhY2hlZF9hdWRpb3MgPSB7fTtcclxuXHJcbiAgICBMR0F1ZGlvLmxvYWRTb3VuZCA9IGZ1bmN0aW9uKHVybCwgb25fY29tcGxldGUsIG9uX2Vycm9yKSB7XHJcbiAgICAgICAgaWYgKExHQXVkaW8uY2FjaGVkX2F1ZGlvc1t1cmxdICYmIHVybC5pbmRleE9mKFwiYmxvYjpcIikgPT0gLTEpIHtcclxuICAgICAgICAgICAgaWYgKG9uX2NvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICBvbl9jb21wbGV0ZShMR0F1ZGlvLmNhY2hlZF9hdWRpb3NbdXJsXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKExHQXVkaW8ub25Qcm9jZXNzQXVkaW9VUkwpIHtcclxuICAgICAgICAgICAgdXJsID0gTEdBdWRpby5vblByb2Nlc3NBdWRpb1VSTCh1cmwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9sb2FkIG5ldyBzYW1wbGVcclxuICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xyXG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG5cclxuICAgICAgICB2YXIgY29udGV4dCA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCk7XHJcblxyXG4gICAgICAgIC8vIERlY29kZSBhc3luY2hyb25vdXNseVxyXG4gICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQXVkaW9Tb3VyY2UgbG9hZGVkXCIpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmRlY29kZUF1ZGlvRGF0YShcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2UsXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkF1ZGlvU291cmNlIGRlY29kZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgTEdBdWRpby5jYWNoZWRfYXVkaW9zW3VybF0gPSBidWZmZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uX2NvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uX2NvbXBsZXRlKGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uRXJyb3JcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlcXVlc3Quc2VuZCgpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBvbkVycm9yKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkF1ZGlvIGxvYWRpbmcgc2FtcGxlIGVycm9yOlwiLCBlcnIpO1xyXG4gICAgICAgICAgICBpZiAob25fZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIG9uX2Vycm9yKGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbiAgICBmdW5jdGlvbiBMR0F1ZGlvU291cmNlKCkge1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgc3JjOiBcIlwiLFxyXG4gICAgICAgICAgICBnYWluOiAwLjUsXHJcbiAgICAgICAgICAgIGxvb3A6IHRydWUsXHJcbiAgICAgICAgICAgIGF1dG9wbGF5OiB0cnVlLFxyXG4gICAgICAgICAgICBwbGF5YmFja1JhdGU6IDFcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLl9sb2FkaW5nX2F1ZGlvID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fYXVkaW9idWZmZXIgPSBudWxsOyAvL3BvaW50cyB0byBBdWRpb0J1ZmZlciB3aXRoIHRoZSBhdWRpbyBzYW1wbGVzIGRlY29kZWRcclxuICAgICAgICB0aGlzLl9hdWRpb25vZGVzID0gW107XHJcbiAgICAgICAgdGhpcy5fbGFzdF9zb3VyY2Vub2RlID0gbnVsbDsgLy90aGUgbGFzdCBBdWRpb0J1ZmZlclNvdXJjZU5vZGUgKHRoZXJlIGNvdWxkIGJlIG1vcmUgaWYgdGhlcmUgYXJlIHNldmVyYWwgc291bmRzIHBsYXlpbmcpXHJcblxyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiYXVkaW9cIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImdhaW5cIiwgXCJudW1iZXJcIik7XHJcblxyXG4gICAgICAgIC8vaW5pdCBjb250ZXh0XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpO1xyXG5cclxuICAgICAgICAvL2NyZWF0ZSBnYWluIG5vZGUgdG8gY29udHJvbCB2b2x1bWVcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZSA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLmdyYXBobm9kZSA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUuZ2Fpbi52YWx1ZSA9IHRoaXMucHJvcGVydGllcy5nYWluO1xyXG5cclxuICAgICAgICAvL2RlYnVnXHJcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5zcmMpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkU291bmQodGhpcy5wcm9wZXJ0aWVzLnNyYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHRMR0F1ZGlvU291cmNlLmRlc2MgPSBcIlBsYXlzIGFuIGF1ZGlvIGZpbGVcIjtcclxuICAgIExHQXVkaW9Tb3VyY2VbXCJAc3JjXCJdID0geyB3aWRnZXQ6IFwicmVzb3VyY2VcIiB9O1xyXG4gICAgTEdBdWRpb1NvdXJjZS5zdXBwb3J0ZWRfZXh0ZW5zaW9ucyA9IFtcIndhdlwiLCBcIm9nZ1wiLCBcIm1wM1wiXTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS5vbkFkZGVkID0gZnVuY3Rpb24oZ3JhcGgpIHtcclxuICAgICAgICBpZiAoZ3JhcGguc3RhdHVzID09PSBMR3JhcGguU1RBVFVTX1JVTk5JTkcpIHtcclxuICAgICAgICAgICAgdGhpcy5vblN0YXJ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9hdWRpb2J1ZmZlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmF1dG9wbGF5KSB7XHJcblx0XHRcdHRoaXMucGxheUJ1ZmZlcih0aGlzLl9hdWRpb2J1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS5vblN0b3AgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnN0b3BBbGxTb3VuZHMoKTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUub25QYXVzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMucGF1c2VBbGxTb3VuZHMoKTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUub25VbnBhdXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy51bnBhdXNlQWxsU291bmRzKCk7XHJcbiAgICAgICAgLy90aGlzLm9uU3RhcnQoKTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUub25SZW1vdmVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wQWxsU291bmRzKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BwZWRfdXJsKSB7XHJcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5fdXJsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLnN0b3BBbGxTb3VuZHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvL2l0ZXJhdGUgYW5kIHN0b3BcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2F1ZGlvbm9kZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2F1ZGlvbm9kZXNbaV0uc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXVkaW9ub2Rlc1tpXS5zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb25vZGVzW2ldLnN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3RoaXMuX2F1ZGlvbm9kZXNbaV0uZGlzY29ubmVjdCggdGhpcy5hdWRpb25vZGUgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYXVkaW9ub2Rlcy5sZW5ndGggPSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS5wYXVzZUFsbFNvdW5kcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCkuc3VzcGVuZCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS51bnBhdXNlQWxsU291bmRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKS5yZXN1bWUoKTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmxpbmsgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuICAgICAgICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5uYW1lID09IFwiZ2FpblwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlLmdhaW4udmFsdWUgPSB2O1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXQubmFtZSA9PSBcInNyY1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eShcInNyY1wiLHYpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5uYW1lID09IFwicGxheWJhY2tSYXRlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMucGxheWJhY2tSYXRlID0gdjtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX2F1ZGlvbm9kZXMubGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXVkaW9ub2Rlc1tqXS5wbGF5YmFja1JhdGUudmFsdWUgPSB2O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0cykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubmFtZSA9PSBcImJ1ZmZlclwiICYmIHRoaXMuX2F1ZGlvYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKGksIHRoaXMuX2F1ZGlvYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9hdWRpb2J1ZmZlcikge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQgPT0gXCJQbGF5XCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheUJ1ZmZlcih0aGlzLl9hdWRpb2J1ZmZlcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQgPT0gXCJTdG9wXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEFsbFNvdW5kcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJzcmNcIikge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRTb3VuZCh2YWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwiZ2FpblwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlLmdhaW4udmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJwbGF5YmFja1JhdGVcIikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX2F1ZGlvbm9kZXMubGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvbm9kZXNbal0ucGxheWJhY2tSYXRlLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Tb3VyY2UucHJvdG90eXBlLnBsYXlCdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpO1xyXG5cclxuICAgICAgICAvL2NyZWF0ZSBhIG5ldyBhdWRpb25vZGUgKHRoaXMgaXMgbWFuZGF0b3J5LCBBdWRpb0FQSSBkb2VzbnQgbGlrZSB0byByZXVzZSBvbGQgb25lcylcclxuICAgICAgICB2YXIgYXVkaW9ub2RlID0gY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTsgLy9jcmVhdGUgYSBBdWRpb0J1ZmZlclNvdXJjZU5vZGVcclxuICAgICAgICB0aGlzLl9sYXN0X3NvdXJjZW5vZGUgPSBhdWRpb25vZGU7XHJcbiAgICAgICAgYXVkaW9ub2RlLmdyYXBobm9kZSA9IHRoaXM7XHJcbiAgICAgICAgYXVkaW9ub2RlLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICBhdWRpb25vZGUubG9vcCA9IHRoaXMucHJvcGVydGllcy5sb29wO1xyXG4gICAgICAgIGF1ZGlvbm9kZS5wbGF5YmFja1JhdGUudmFsdWUgPSB0aGlzLnByb3BlcnRpZXMucGxheWJhY2tSYXRlO1xyXG4gICAgICAgIHRoaXMuX2F1ZGlvbm9kZXMucHVzaChhdWRpb25vZGUpO1xyXG4gICAgICAgIGF1ZGlvbm9kZS5jb25uZWN0KHRoaXMuYXVkaW9ub2RlKTsgLy9jb25uZWN0IHRvIGdhaW5cclxuXHJcblx0XHR0aGlzLl9hdWRpb25vZGVzLnB1c2goYXVkaW9ub2RlKTtcclxuXHJcblx0XHR0aGlzLnRyaWdnZXIoXCJzdGFydFwiKTtcclxuXHJcbiAgICAgICAgYXVkaW9ub2RlLm9uZW5kZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImVuZGVkIVwiKTtcclxuICAgICAgICAgICAgdGhhdC50cmlnZ2VyKFwiZW5kZWRcIik7XHJcbiAgICAgICAgICAgIC8vcmVtb3ZlXHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoYXQuX2F1ZGlvbm9kZXMuaW5kZXhPZihhdWRpb25vZGUpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuX2F1ZGlvbm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICghYXVkaW9ub2RlLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgYXVkaW9ub2RlLnN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBhdWRpb25vZGUuc3RhcnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF1ZGlvbm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUubG9hZFNvdW5kID0gZnVuY3Rpb24odXJsKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICAvL2tpbGwgcHJldmlvdXMgbG9hZFxyXG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QuYWJvcnQoKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9hdWRpb2J1ZmZlciA9IG51bGw7IC8vcG9pbnRzIHRvIHRoZSBhdWRpb2J1ZmZlciBvbmNlIHRoZSBhdWRpbyBpcyBsb2FkZWRcclxuICAgICAgICB0aGlzLl9sb2FkaW5nX2F1ZGlvID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICghdXJsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3JlcXVlc3QgPSBMR0F1ZGlvLmxvYWRTb3VuZCh1cmwsIGlubmVyKTtcclxuXHJcbiAgICAgICAgdGhpcy5fbG9hZGluZ19hdWRpbyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiI0FBNFwiO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbm5lcihidWZmZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5ib3hjb2xvciA9IExpdGVHcmFwaC5OT0RFX0RFRkFVTFRfQk9YQ09MT1I7XHJcbiAgICAgICAgICAgIHRoYXQuX2F1ZGlvYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICAgICAgICB0aGF0Ll9sb2FkaW5nX2F1ZGlvID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vaWYgaXMgcGxheWluZywgdGhlbiBwbGF5IGl0XHJcbiAgICAgICAgICAgIGlmICh0aGF0LmdyYXBoICYmIHRoYXQuZ3JhcGguc3RhdHVzID09PSBMR3JhcGguU1RBVFVTX1JVTk5JTkcpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQub25TdGFydCgpO1xyXG4gICAgICAgICAgICB9IC8vdGhpcyBjb250cm9scyB0aGUgYXV0b3BsYXkgYWxyZWFkeVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy9IZWxwcyBjb25uZWN0L2Rpc2Nvbm5lY3QgQXVkaW9Ob2RlcyB3aGVuIG5ldyBjb25uZWN0aW9ucyBhcmUgbWFkZSBpbiB0aGUgbm9kZVxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUub25Db25uZWN0aW9uc0NoYW5nZSA9IExHQXVkaW8ub25Db25uZWN0aW9uc0NoYW5nZTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFtcInBsYXliYWNrUmF0ZVwiLCBcIm51bWJlclwiXSxcclxuXHRcdFx0W1wic3JjXCIsXCJzdHJpbmdcIl0sXHJcbiAgICAgICAgICAgIFtcIlBsYXlcIiwgTGl0ZUdyYXBoLkFDVElPTl0sXHJcbiAgICAgICAgICAgIFtcIlN0b3BcIiwgTGl0ZUdyYXBoLkFDVElPTl1cclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU291cmNlLnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcImJ1ZmZlclwiLCBcImF1ZGlvYnVmZmVyXCJdLCBbXCJzdGFydFwiLCBMaXRlR3JhcGguRVZFTlRdLCBbXCJlbmRlZFwiLCBMaXRlR3JhcGguRVZFTlRdXTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS5wcm90b3R5cGUub25Ecm9wRmlsZSA9IGZ1bmN0aW9uKGZpbGUpIHtcclxuICAgICAgICBpZiAodGhpcy5fZHJvcHBlZF91cmwpIHtcclxuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLl9kcm9wcGVkX3VybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcy5zcmMgPSB1cmw7XHJcbiAgICAgICAgdGhpcy5sb2FkU291bmQodXJsKTtcclxuICAgICAgICB0aGlzLl9kcm9wcGVkX3VybCA9IHVybDtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NvdXJjZS50aXRsZSA9IFwiU291cmNlXCI7XHJcbiAgICBMR0F1ZGlvU291cmNlLmRlc2MgPSBcIlBsYXlzIGF1ZGlvXCI7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImF1ZGlvL3NvdXJjZVwiLCBMR0F1ZGlvU291cmNlKTtcclxuXHJcbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbiAgICBmdW5jdGlvbiBMR0F1ZGlvTWVkaWFTb3VyY2UoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBnYWluOiAwLjVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLl9hdWRpb25vZGVzID0gW107XHJcbiAgICAgICAgdGhpcy5fbWVkaWFfc3RyZWFtID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJhdWRpb1wiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiZ2FpblwiLCBcIm51bWJlclwiKTtcclxuXHJcbiAgICAgICAgLy9jcmVhdGUgZ2FpbiBub2RlIHRvIGNvbnRyb2wgdm9sdW1lXHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpO1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlID0gY29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUuZ3JhcGhub2RlID0gdGhpcztcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5nYWluLnZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzLmdhaW47XHJcbiAgICB9XHJcblxyXG4gICAgTEdBdWRpb01lZGlhU291cmNlLnByb3RvdHlwZS5vbkFkZGVkID0gZnVuY3Rpb24oZ3JhcGgpIHtcclxuICAgICAgICBpZiAoZ3JhcGguc3RhdHVzID09PSBMR3JhcGguU1RBVFVTX1JVTk5JTkcpIHtcclxuICAgICAgICAgICAgdGhpcy5vblN0YXJ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvTWVkaWFTb3VyY2UucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5fbWVkaWFfc3RyZWFtID09IG51bGwgJiYgIXRoaXMuX3dhaXRpbmdfY29uZmlybWF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlblN0cmVhbSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb01lZGlhU291cmNlLnByb3RvdHlwZS5vblN0b3AgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5nYWluLnZhbHVlID0gMDtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb01lZGlhU291cmNlLnByb3RvdHlwZS5vblBhdXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUuZ2Fpbi52YWx1ZSA9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9NZWRpYVNvdXJjZS5wcm90b3R5cGUub25VbnBhdXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUuZ2Fpbi52YWx1ZSA9IHRoaXMucHJvcGVydGllcy5nYWluO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvTWVkaWFTb3VyY2UucHJvdG90eXBlLm9uUmVtb3ZlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLmdhaW4udmFsdWUgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLmF1ZGlvc291cmNlX25vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb3NvdXJjZV9ub2RlLmRpc2Nvbm5lY3QodGhpcy5hdWRpb25vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvc291cmNlX25vZGUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fbWVkaWFfc3RyZWFtKSB7XHJcbiAgICAgICAgICAgIHZhciB0cmFja3MgPSB0aGlzLl9tZWRpYV9zdHJlYW0uZ2V0VHJhY2tzKCk7XHJcbiAgICAgICAgICAgIGlmICh0cmFja3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFja3NbMF0uc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvTWVkaWFTb3VyY2UucHJvdG90eXBlLm9wZW5TdHJlYW0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIW5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgICBcImdldFVzZXJNZWRpYSgpIGlzIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBicm93c2VyLCB1c2UgY2hyb21lIGFuZCBlbmFibGUgV2ViUlRDIGZyb20gYWJvdXQ6Ly9mbGFnc1wiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3dhaXRpbmdfY29uZmlybWF0aW9uID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gTm90IHNob3dpbmcgdmVuZG9yIHByZWZpeGVzLlxyXG4gICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXNcclxuICAgICAgICAgICAgLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlLCB2aWRlbzogZmFsc2UgfSlcclxuICAgICAgICAgICAgLnRoZW4odGhpcy5zdHJlYW1SZWFkeS5iaW5kKHRoaXMpKVxyXG4gICAgICAgICAgICAuY2F0Y2gob25GYWlsU29IYXJkKTtcclxuXHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIGZ1bmN0aW9uIG9uRmFpbFNvSGFyZChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJNZWRpYSByZWplY3RlZFwiLCBlcnIpO1xyXG4gICAgICAgICAgICB0aGF0Ll9tZWRpYV9zdHJlYW0gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IFwicmVkXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvTWVkaWFTb3VyY2UucHJvdG90eXBlLnN0cmVhbVJlYWR5ID0gZnVuY3Rpb24obG9jYWxNZWRpYVN0cmVhbSkge1xyXG4gICAgICAgIHRoaXMuX21lZGlhX3N0cmVhbSA9IGxvY2FsTWVkaWFTdHJlYW07XHJcbiAgICAgICAgLy90aGlzLl93YWl0aW5nX2NvbmZpcm1hdGlvbiA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvL2luaXQgY29udGV4dFxyXG4gICAgICAgIGlmICh0aGlzLmF1ZGlvc291cmNlX25vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb3NvdXJjZV9ub2RlLmRpc2Nvbm5lY3QodGhpcy5hdWRpb25vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29udGV4dCA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCk7XHJcbiAgICAgICAgdGhpcy5hdWRpb3NvdXJjZV9ub2RlID0gY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShcclxuICAgICAgICAgICAgbG9jYWxNZWRpYVN0cmVhbVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5hdWRpb3NvdXJjZV9ub2RlLmdyYXBobm9kZSA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5hdWRpb3NvdXJjZV9ub2RlLmNvbm5lY3QodGhpcy5hdWRpb25vZGUpO1xyXG4gICAgICAgIHRoaXMuYm94Y29sb3IgPSBcIndoaXRlXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9NZWRpYVNvdXJjZS5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21lZGlhX3N0cmVhbSA9PSBudWxsICYmICF0aGlzLl93YWl0aW5nX2NvbmZpcm1hdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLm9wZW5TdHJlYW0oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlucHV0cykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5saW5rID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQubmFtZSA9PSBcImdhaW5cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlLmdhaW4udmFsdWUgPSB0aGlzLnByb3BlcnRpZXMuZ2FpbiA9IHY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9NZWRpYVNvdXJjZS5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgIGlmIChldmVudCA9PSBcIlBsYXlcIikge1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZS5nYWluLnZhbHVlID0gdGhpcy5wcm9wZXJ0aWVzLmdhaW47XHJcbiAgICAgICAgfSBlbHNlIGlmIChldmVudCA9PSBcIlN0b3BcIikge1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZS5nYWluLnZhbHVlID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9NZWRpYVNvdXJjZS5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09IFwiZ2FpblwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlLmdhaW4udmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vSGVscHMgY29ubmVjdC9kaXNjb25uZWN0IEF1ZGlvTm9kZXMgd2hlbiBuZXcgY29ubmVjdGlvbnMgYXJlIG1hZGUgaW4gdGhlIG5vZGVcclxuICAgIExHQXVkaW9NZWRpYVNvdXJjZS5wcm90b3R5cGUub25Db25uZWN0aW9uc0NoYW5nZSA9XHJcbiAgICAgICAgTEdBdWRpby5vbkNvbm5lY3Rpb25zQ2hhbmdlO1xyXG5cclxuICAgIExHQXVkaW9NZWRpYVNvdXJjZS5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbXCJwbGF5YmFja1JhdGVcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcIlBsYXlcIiwgTGl0ZUdyYXBoLkFDVElPTl0sXHJcbiAgICAgICAgICAgIFtcIlN0b3BcIiwgTGl0ZUdyYXBoLkFDVElPTl1cclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvTWVkaWFTb3VyY2UudGl0bGUgPSBcIk1lZGlhU291cmNlXCI7XHJcbiAgICBMR0F1ZGlvTWVkaWFTb3VyY2UuZGVzYyA9IFwiUGxheXMgbWljcm9waG9uZVwiO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJhdWRpby9tZWRpYV9zb3VyY2VcIiwgTEdBdWRpb01lZGlhU291cmNlKTtcclxuXHJcbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG4gICAgZnVuY3Rpb24gTEdBdWRpb0FuYWx5c2VyKCkge1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgZmZ0U2l6ZTogMjA0OCxcclxuICAgICAgICAgICAgbWluRGVjaWJlbHM6IC0xMDAsXHJcbiAgICAgICAgICAgIG1heERlY2liZWxzOiAtMTAsXHJcbiAgICAgICAgICAgIHNtb290aGluZ1RpbWVDb25zdGFudDogMC41XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpO1xyXG5cclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZSA9IGNvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5ncmFwaG5vZGUgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLmZmdFNpemUgPSB0aGlzLnByb3BlcnRpZXMuZmZ0U2l6ZTtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5taW5EZWNpYmVscyA9IHRoaXMucHJvcGVydGllcy5taW5EZWNpYmVscztcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5tYXhEZWNpYmVscyA9IHRoaXMucHJvcGVydGllcy5tYXhEZWNpYmVscztcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5zbW9vdGhpbmdUaW1lQ29uc3RhbnQgPSB0aGlzLnByb3BlcnRpZXMuc21vb3RoaW5nVGltZUNvbnN0YW50O1xyXG5cclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW5cIiwgXCJhdWRpb1wiKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcImZyZXFzXCIsIFwiYXJyYXlcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJzYW1wbGVzXCIsIFwiYXJyYXlcIik7XHJcblxyXG4gICAgICAgIHRoaXMuX2ZyZXFfYmluID0gbnVsbDtcclxuICAgICAgICB0aGlzLl90aW1lX2JpbiA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgTEdBdWRpb0FuYWx5c2VyLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGVbbmFtZV0gPSB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb0FuYWx5c2VyLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5pc091dHB1dENvbm5lY3RlZCgwKSkge1xyXG4gICAgICAgICAgICAvL3NlbmQgRkZUXHJcbiAgICAgICAgICAgIHZhciBidWZmZXJMZW5ndGggPSB0aGlzLmF1ZGlvbm9kZS5mcmVxdWVuY3lCaW5Db3VudDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9mcmVxX2JpbiB8fCB0aGlzLl9mcmVxX2Jpbi5sZW5ndGggIT0gYnVmZmVyTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcmVxX2JpbiA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlckxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEodGhpcy5fZnJlcV9iaW4pO1xyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMCwgdGhpcy5fZnJlcV9iaW4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zZW5kIGFuYWx5emVyXHJcbiAgICAgICAgaWYgKHRoaXMuaXNPdXRwdXRDb25uZWN0ZWQoMSkpIHtcclxuICAgICAgICAgICAgLy9zZW5kIFNhbXBsZXNcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlckxlbmd0aCA9IHRoaXMuYXVkaW9ub2RlLmZyZXF1ZW5jeUJpbkNvdW50O1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RpbWVfYmluIHx8IHRoaXMuX3RpbWVfYmluLmxlbmd0aCAhPSBidWZmZXJMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVfYmluID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyTGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZS5nZXRCeXRlVGltZURvbWFpbkRhdGEodGhpcy5fdGltZV9iaW4pO1xyXG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dERhdGEoMSwgdGhpcy5fdGltZV9iaW4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9wcm9wZXJ0aWVzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcclxuICAgICAgICAgICAgaWYgKGlucHV0LmxpbmsgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb25vZGVbaW5wdXQubmFtZV0udmFsdWUgPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3RpbWUgZG9tYWluXHJcbiAgICAgICAgLy90aGlzLmF1ZGlvbm9kZS5nZXRGbG9hdFRpbWVEb21haW5EYXRhKCBkYXRhQXJyYXkgKTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb0FuYWx5c2VyLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFtcIm1pbkRlY2liZWxzXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJtYXhEZWNpYmVsc1wiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wic21vb3RoaW5nVGltZUNvbnN0YW50XCIsIFwibnVtYmVyXCJdXHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb0FuYWx5c2VyLnByb3RvdHlwZS5vbkdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcImZyZXFzXCIsIFwiYXJyYXlcIl0sIFtcInNhbXBsZXNcIiwgXCJhcnJheVwiXV07XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9BbmFseXNlci50aXRsZSA9IFwiQW5hbHlzZXJcIjtcclxuICAgIExHQXVkaW9BbmFseXNlci5kZXNjID0gXCJBdWRpbyBBbmFseXNlclwiO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJhdWRpby9hbmFseXNlclwiLCBMR0F1ZGlvQW5hbHlzZXIpO1xyXG5cclxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbiAgICBmdW5jdGlvbiBMR0F1ZGlvR2FpbigpIHtcclxuICAgICAgICAvL2RlZmF1bHRcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIGdhaW46IDFcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZSA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcImF1ZGlvXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJnYWluXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiYXVkaW9cIik7XHJcbiAgICB9XHJcblxyXG4gICAgTEdBdWRpb0dhaW4ucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMgfHwgIXRoaXMuaW5wdXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xyXG4gICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZVtpbnB1dC5uYW1lXS52YWx1ZSA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW8uY3JlYXRlQXVkaW9Ob2RlV3JhcHBlcihMR0F1ZGlvR2Fpbik7XHJcblxyXG4gICAgTEdBdWRpb0dhaW4udGl0bGUgPSBcIkdhaW5cIjtcclxuICAgIExHQXVkaW9HYWluLmRlc2MgPSBcIkF1ZGlvIGdhaW5cIjtcclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYXVkaW8vZ2FpblwiLCBMR0F1ZGlvR2Fpbik7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdBdWRpb0NvbnZvbHZlcigpIHtcclxuICAgICAgICAvL2RlZmF1bHRcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIGltcHVsc2Vfc3JjOiBcIlwiLFxyXG4gICAgICAgICAgICBub3JtYWxpemU6IHRydWVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZSA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlQ29udm9sdmVyKCk7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwiYXVkaW9cIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJhdWRpb1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBMR0F1ZGlvLmNyZWF0ZUF1ZGlvTm9kZVdyYXBwZXIoTEdBdWRpb0NvbnZvbHZlcik7XHJcblxyXG4gICAgTEdBdWRpb0NvbnZvbHZlci5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5fZHJvcHBlZF91cmwpIHtcclxuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLl9kcm9wcGVkX3VybCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvQ29udm9sdmVyLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJpbXB1bHNlX3NyY1wiKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZEltcHVsc2UodmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcIm5vcm1hbGl6ZVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlLm5vcm1hbGl6ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb0NvbnZvbHZlci5wcm90b3R5cGUub25Ecm9wRmlsZSA9IGZ1bmN0aW9uKGZpbGUpIHtcclxuICAgICAgICBpZiAodGhpcy5fZHJvcHBlZF91cmwpIHtcclxuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLl9kcm9wcGVkX3VybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2Ryb3BwZWRfdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMuaW1wdWxzZV9zcmMgPSB0aGlzLl9kcm9wcGVkX3VybDtcclxuICAgICAgICB0aGlzLmxvYWRJbXB1bHNlKHRoaXMuX2Ryb3BwZWRfdXJsKTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb0NvbnZvbHZlci5wcm90b3R5cGUubG9hZEltcHVsc2UgPSBmdW5jdGlvbih1cmwpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIC8va2lsbCBwcmV2aW91cyBsb2FkXHJcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdC5hYm9ydCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2ltcHVsc2VfYnVmZmVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9sb2FkaW5nX2ltcHVsc2UgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKCF1cmwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9sb2FkIG5ldyBzYW1wbGVcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gTEdBdWRpby5sb2FkU291bmQodXJsLCBpbm5lcik7XHJcbiAgICAgICAgdGhpcy5fbG9hZGluZ19pbXB1bHNlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gRGVjb2RlIGFzeW5jaHJvbm91c2x5XHJcbiAgICAgICAgZnVuY3Rpb24gaW5uZXIoYnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHRoYXQuX2ltcHVsc2VfYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICAgICAgICB0aGF0LmF1ZGlvbm9kZS5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW1wdWxzZSBzaWduYWwgc2V0XCIpO1xyXG4gICAgICAgICAgICB0aGF0Ll9sb2FkaW5nX2ltcHVsc2UgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9Db252b2x2ZXIudGl0bGUgPSBcIkNvbnZvbHZlclwiO1xyXG4gICAgTEdBdWRpb0NvbnZvbHZlci5kZXNjID0gXCJDb252b2x2ZXMgdGhlIHNpZ25hbCAodXNlZCBmb3IgcmV2ZXJiKVwiO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJhdWRpby9jb252b2x2ZXJcIiwgTEdBdWRpb0NvbnZvbHZlcik7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdBdWRpb0R5bmFtaWNzQ29tcHJlc3NvcigpIHtcclxuICAgICAgICAvL2RlZmF1bHRcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIHRocmVzaG9sZDogLTUwLFxyXG4gICAgICAgICAgICBrbmVlOiA0MCxcclxuICAgICAgICAgICAgcmF0aW86IDEyLFxyXG4gICAgICAgICAgICByZWR1Y3Rpb246IC0yMCxcclxuICAgICAgICAgICAgYXR0YWNrOiAwLFxyXG4gICAgICAgICAgICByZWxlYXNlOiAwLjI1XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZUR5bmFtaWNzQ29tcHJlc3NvcigpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCBcImF1ZGlvXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiYXVkaW9cIik7XHJcbiAgICB9XHJcblxyXG4gICAgTEdBdWRpby5jcmVhdGVBdWRpb05vZGVXcmFwcGVyKExHQXVkaW9EeW5hbWljc0NvbXByZXNzb3IpO1xyXG5cclxuICAgIExHQXVkaW9EeW5hbWljc0NvbXByZXNzb3IucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMgfHwgIXRoaXMuaW5wdXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dHNbaV07XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5saW5rID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoaSk7XHJcbiAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlW2lucHV0Lm5hbWVdLnZhbHVlID0gdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb0R5bmFtaWNzQ29tcHJlc3Nvci5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbXCJ0aHJlc2hvbGRcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImtuZWVcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInJhdGlvXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJyZWR1Y3Rpb25cIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcImF0dGFja1wiLCBcIm51bWJlclwiXSxcclxuICAgICAgICAgICAgW1wicmVsZWFzZVwiLCBcIm51bWJlclwiXVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9EeW5hbWljc0NvbXByZXNzb3IudGl0bGUgPSBcIkR5bmFtaWNzQ29tcHJlc3NvclwiO1xyXG4gICAgTEdBdWRpb0R5bmFtaWNzQ29tcHJlc3Nvci5kZXNjID0gXCJEeW5hbWljcyBDb21wcmVzc29yXCI7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcclxuICAgICAgICBcImF1ZGlvL2R5bmFtaWNzQ29tcHJlc3NvclwiLFxyXG4gICAgICAgIExHQXVkaW9EeW5hbWljc0NvbXByZXNzb3JcclxuICAgICk7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdBdWRpb1dhdmVTaGFwZXIoKSB7XHJcbiAgICAgICAgLy9kZWZhdWx0XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge307XHJcblxyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVXYXZlU2hhcGVyKCk7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwiYXVkaW9cIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInNoYXBlXCIsIFwid2F2ZXNoYXBlXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiYXVkaW9cIik7XHJcbiAgICB9XHJcblxyXG4gICAgTEdBdWRpb1dhdmVTaGFwZXIucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbnB1dHMgfHwgIXRoaXMuaW5wdXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLmN1cnZlID0gdjtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1dhdmVTaGFwZXIucHJvdG90eXBlLnNldFdhdmVTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUuY3VydmUgPSBzaGFwZTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpby5jcmVhdGVBdWRpb05vZGVXcmFwcGVyKExHQXVkaW9XYXZlU2hhcGVyKTtcclxuXHJcbiAgICAvKiBkaXNhYmxlZCB0aWxsIEkgZG9udCBmaW5kIGEgd2F5IHRvIGRvIGEgd2F2ZSBzaGFwZVxyXG5MR0F1ZGlvV2F2ZVNoYXBlci50aXRsZSA9IFwiV2F2ZVNoYXBlclwiO1xyXG5MR0F1ZGlvV2F2ZVNoYXBlci5kZXNjID0gXCJEaXN0b3J0aW9uIHVzaW5nIHdhdmUgc2hhcGVcIjtcclxuTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJhdWRpby93YXZlU2hhcGVyXCIsIExHQXVkaW9XYXZlU2hhcGVyKTtcclxuKi9cclxuXHJcbiAgICBmdW5jdGlvbiBMR0F1ZGlvTWl4ZXIoKSB7XHJcbiAgICAgICAgLy9kZWZhdWx0XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBnYWluMTogMC41LFxyXG4gICAgICAgICAgICBnYWluMjogMC41XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZUdhaW4oKTtcclxuXHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUxID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUxLmdhaW4udmFsdWUgPSB0aGlzLnByb3BlcnRpZXMuZ2FpbjE7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUyID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUyLmdhaW4udmFsdWUgPSB0aGlzLnByb3BlcnRpZXMuZ2FpbjI7XHJcblxyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlMS5jb25uZWN0KHRoaXMuYXVkaW9ub2RlKTtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZTIuY29ubmVjdCh0aGlzLmF1ZGlvbm9kZSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpbjFcIiwgXCJhdWRpb1wiKTtcclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiaW4xIGdhaW5cIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluMlwiLCBcImF1ZGlvXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpbjIgZ2FpblwiLCBcIm51bWJlclwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJhdWRpb1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBMR0F1ZGlvTWl4ZXIucHJvdG90eXBlLmdldEF1ZGlvTm9kZUluSW5wdXRTbG90ID0gZnVuY3Rpb24oc2xvdCkge1xyXG4gICAgICAgIGlmIChzbG90ID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXVkaW9ub2RlMTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNsb3QgPT0gMikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdWRpb25vZGUyO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb01peGVyLnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJnYWluMVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlMS5nYWluLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwiZ2FpbjJcIikge1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZTIuZ2Fpbi52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb01peGVyLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzIHx8ICF0aGlzLmlucHV0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5saW5rID09IG51bGwgfHwgaW5wdXQudHlwZSA9PSBcImF1ZGlvXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUxLmdhaW4udmFsdWUgPSB2O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT0gMykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUyLmdhaW4udmFsdWUgPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvLmNyZWF0ZUF1ZGlvTm9kZVdyYXBwZXIoTEdBdWRpb01peGVyKTtcclxuXHJcbiAgICBMR0F1ZGlvTWl4ZXIudGl0bGUgPSBcIk1peGVyXCI7XHJcbiAgICBMR0F1ZGlvTWl4ZXIuZGVzYyA9IFwiQXVkaW8gbWl4ZXJcIjtcclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYXVkaW8vbWl4ZXJcIiwgTEdBdWRpb01peGVyKTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR0F1ZGlvQURTUigpIHtcclxuICAgICAgICAvL2RlZmF1bHRcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIEE6IDAuMSxcclxuICAgICAgICAgICAgRDogMC4xLFxyXG4gICAgICAgICAgICBTOiAwLjEsXHJcbiAgICAgICAgICAgIFI6IDAuMVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUuZ2Fpbi52YWx1ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwiYXVkaW9cIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImdhdGVcIiwgXCJib29sZWFuXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkT3V0cHV0KFwib3V0XCIsIFwiYXVkaW9cIik7XHJcbiAgICAgICAgdGhpcy5nYXRlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgTEdBdWRpb0FEU1IucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBhdWRpb0NvbnRleHQgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpO1xyXG4gICAgICAgIHZhciBub3cgPSBhdWRpb0NvbnRleHQuY3VycmVudFRpbWU7XHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmF1ZGlvbm9kZTtcclxuICAgICAgICB2YXIgZ2FpbiA9IG5vZGUuZ2FpbjtcclxuICAgICAgICB2YXIgY3VycmVudF9nYXRlID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcblxyXG4gICAgICAgIHZhciBBID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJBXCIpO1xyXG4gICAgICAgIHZhciBEID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJEXCIpO1xyXG4gICAgICAgIHZhciBTID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJTXCIpO1xyXG4gICAgICAgIHZhciBSID0gdGhpcy5nZXRJbnB1dE9yUHJvcGVydHkoXCJSXCIpO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuZ2F0ZSAmJiBjdXJyZW50X2dhdGUpIHtcclxuICAgICAgICAgICAgZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoMCk7XHJcbiAgICAgICAgICAgIGdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgbm93KTtcclxuICAgICAgICAgICAgZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgxLCBub3cgKyBBKTtcclxuICAgICAgICAgICAgZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShTLCBub3cgKyBBICsgRCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmdhdGUgJiYgIWN1cnJlbnRfZ2F0ZSkge1xyXG4gICAgICAgICAgICBnYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcygwKTtcclxuICAgICAgICAgICAgZ2Fpbi5zZXRWYWx1ZUF0VGltZShnYWluLnZhbHVlLCBub3cpO1xyXG4gICAgICAgICAgICBnYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIG5vdyArIFIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5nYXRlID0gY3VycmVudF9nYXRlO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvQURTUi5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbXCJBXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJEXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJTXCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJSXCIsIFwibnVtYmVyXCJdXHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpby5jcmVhdGVBdWRpb05vZGVXcmFwcGVyKExHQXVkaW9BRFNSKTtcclxuXHJcbiAgICBMR0F1ZGlvQURTUi50aXRsZSA9IFwiQURTUlwiO1xyXG4gICAgTEdBdWRpb0FEU1IuZGVzYyA9IFwiQXVkaW8gZW52ZWxvcGVcIjtcclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYXVkaW8vYWRzclwiLCBMR0F1ZGlvQURTUik7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdBdWRpb0RlbGF5KCkge1xyXG4gICAgICAgIC8vZGVmYXVsdFxyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgZGVsYXlUaW1lOiAwLjVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZSA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlRGVsYXkoMTApO1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLmRlbGF5VGltZS52YWx1ZSA9IHRoaXMucHJvcGVydGllcy5kZWxheVRpbWU7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwiYXVkaW9cIik7XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInRpbWVcIiwgXCJudW1iZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJhdWRpb1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBMR0F1ZGlvLmNyZWF0ZUF1ZGlvTm9kZVdyYXBwZXIoTEdBdWRpb0RlbGF5KTtcclxuXHJcbiAgICBMR0F1ZGlvRGVsYXkucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZS5kZWxheVRpbWUudmFsdWUgPSB2O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb0RlbGF5LnRpdGxlID0gXCJEZWxheVwiO1xyXG4gICAgTEdBdWRpb0RlbGF5LmRlc2MgPSBcIkF1ZGlvIGRlbGF5XCI7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImF1ZGlvL2RlbGF5XCIsIExHQXVkaW9EZWxheSk7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdBdWRpb0JpcXVhZEZpbHRlcigpIHtcclxuICAgICAgICAvL2RlZmF1bHRcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIGZyZXF1ZW5jeTogMzUwLFxyXG4gICAgICAgICAgICBkZXR1bmU6IDAsXHJcbiAgICAgICAgICAgIFE6IDFcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJ0eXBlXCIsIFwibG93cGFzc1wiLCBcImVudW1cIiwge1xyXG4gICAgICAgICAgICB2YWx1ZXM6IFtcclxuICAgICAgICAgICAgICAgIFwibG93cGFzc1wiLFxyXG4gICAgICAgICAgICAgICAgXCJoaWdocGFzc1wiLFxyXG4gICAgICAgICAgICAgICAgXCJiYW5kcGFzc1wiLFxyXG4gICAgICAgICAgICAgICAgXCJsb3dzaGVsZlwiLFxyXG4gICAgICAgICAgICAgICAgXCJoaWdoc2hlbGZcIixcclxuICAgICAgICAgICAgICAgIFwicGVha2luZ1wiLFxyXG4gICAgICAgICAgICAgICAgXCJub3RjaFwiLFxyXG4gICAgICAgICAgICAgICAgXCJhbGxwYXNzXCJcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvL2NyZWF0ZSBub2RlXHJcbiAgICAgICAgdGhpcy5hdWRpb25vZGUgPSBMR0F1ZGlvLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xyXG5cclxuICAgICAgICAvL3Nsb3RzXHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwiYXVkaW9cIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJhdWRpb1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBMR0F1ZGlvQmlxdWFkRmlsdGVyLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzIHx8ICF0aGlzLmlucHV0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcclxuICAgICAgICAgICAgaWYgKGlucHV0LmxpbmsgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb25vZGVbaW5wdXQubmFtZV0udmFsdWUgPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvQmlxdWFkRmlsdGVyLnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wiZnJlcXVlbmN5XCIsIFwibnVtYmVyXCJdLCBbXCJkZXR1bmVcIiwgXCJudW1iZXJcIl0sIFtcIlFcIiwgXCJudW1iZXJcIl1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvLmNyZWF0ZUF1ZGlvTm9kZVdyYXBwZXIoTEdBdWRpb0JpcXVhZEZpbHRlcik7XHJcblxyXG4gICAgTEdBdWRpb0JpcXVhZEZpbHRlci50aXRsZSA9IFwiQmlxdWFkRmlsdGVyXCI7XHJcbiAgICBMR0F1ZGlvQmlxdWFkRmlsdGVyLmRlc2MgPSBcIkF1ZGlvIGZpbHRlclwiO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJhdWRpby9iaXF1YWRmaWx0ZXJcIiwgTEdBdWRpb0JpcXVhZEZpbHRlcik7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdBdWRpb09zY2lsbGF0b3JOb2RlKCkge1xyXG4gICAgICAgIC8vZGVmYXVsdFxyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgZnJlcXVlbmN5OiA0NDAsXHJcbiAgICAgICAgICAgIGRldHVuZTogMCxcclxuICAgICAgICAgICAgdHlwZTogXCJzaW5lXCJcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYWRkUHJvcGVydHkoXCJ0eXBlXCIsIFwic2luZVwiLCBcImVudW1cIiwge1xyXG4gICAgICAgICAgICB2YWx1ZXM6IFtcInNpbmVcIiwgXCJzcXVhcmVcIiwgXCJzYXd0b290aFwiLCBcInRyaWFuZ2xlXCIsIFwiY3VzdG9tXCJdXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vY3JlYXRlIG5vZGVcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZSA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlT3NjaWxsYXRvcigpO1xyXG5cclxuICAgICAgICAvL3Nsb3RzXHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJhdWRpb1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBMR0F1ZGlvT3NjaWxsYXRvck5vZGUucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYXVkaW9ub2RlLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUuc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZS5zdGFydCgpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvT3NjaWxsYXRvck5vZGUucHJvdG90eXBlLm9uU3RvcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmF1ZGlvbm9kZS5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9ub2RlLnN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUuc3RvcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb09zY2lsbGF0b3JOb2RlLnByb3RvdHlwZS5vblBhdXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5vblN0b3AoKTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb09zY2lsbGF0b3JOb2RlLnByb3RvdHlwZS5vblVucGF1c2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLm9uU3RhcnQoKTtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb09zY2lsbGF0b3JOb2RlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzIHx8ICF0aGlzLmlucHV0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1tpXTtcclxuICAgICAgICAgICAgaWYgKGlucHV0LmxpbmsgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb25vZGVbaW5wdXQubmFtZV0udmFsdWUgPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvT3NjaWxsYXRvck5vZGUucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgW1wiZnJlcXVlbmN5XCIsIFwibnVtYmVyXCJdLFxyXG4gICAgICAgICAgICBbXCJkZXR1bmVcIiwgXCJudW1iZXJcIl0sXHJcbiAgICAgICAgICAgIFtcInR5cGVcIiwgXCJzdHJpbmdcIl1cclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvLmNyZWF0ZUF1ZGlvTm9kZVdyYXBwZXIoTEdBdWRpb09zY2lsbGF0b3JOb2RlKTtcclxuXHJcbiAgICBMR0F1ZGlvT3NjaWxsYXRvck5vZGUudGl0bGUgPSBcIk9zY2lsbGF0b3JcIjtcclxuICAgIExHQXVkaW9Pc2NpbGxhdG9yTm9kZS5kZXNjID0gXCJPc2NpbGxhdG9yXCI7XHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcImF1ZGlvL29zY2lsbGF0b3JcIiwgTEdBdWRpb09zY2lsbGF0b3JOb2RlKTtcclxuXHJcbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG4gICAgLy9FWFRSQVxyXG5cclxuICAgIGZ1bmN0aW9uIExHQXVkaW9WaXN1YWxpemF0aW9uKCkge1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgY29udGludW91czogdHJ1ZSxcclxuICAgICAgICAgICAgbWFyazogLTFcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmFkZElucHV0KFwiZGF0YVwiLCBcImFycmF5XCIpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJtYXJrXCIsIFwibnVtYmVyXCIpO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IFszMDAsIDIwMF07XHJcbiAgICAgICAgdGhpcy5fbGFzdF9idWZmZXIgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIExHQXVkaW9WaXN1YWxpemF0aW9uLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl9sYXN0X2J1ZmZlciA9IHRoaXMuZ2V0SW5wdXREYXRhKDApO1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubWFyayA9IHY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0RGlydHlDYW52YXModHJ1ZSwgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvVmlzdWFsaXphdGlvbi5wcm90b3R5cGUub25EcmF3Rm9yZWdyb3VuZCA9IGZ1bmN0aW9uKGN0eCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fbGFzdF9idWZmZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuX2xhc3RfYnVmZmVyO1xyXG5cclxuICAgICAgICAvL2RlbHRhIHJlcHJlc2VudHMgaG93IG1hbnkgc2FtcGxlcyB3ZSBhZHZhbmNlIHBlciBwaXhlbFxyXG4gICAgICAgIHZhciBkZWx0YSA9IGJ1ZmZlci5sZW5ndGggLyB0aGlzLnNpemVbMF07XHJcbiAgICAgICAgdmFyIGggPSB0aGlzLnNpemVbMV07XHJcblxyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XHJcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuc2l6ZVswXSwgdGhpcy5zaXplWzFdKTtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIndoaXRlXCI7XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHZhciB4ID0gMDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5jb250aW51b3VzKSB7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgaCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSArPSBkZWx0YSkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCBoIC0gKGJ1ZmZlcltpIHwgMF0gLyAyNTUpICogaCk7XHJcbiAgICAgICAgICAgICAgICB4Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gZGVsdGEpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIDAuNSwgaCk7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyAwLjUsIGggLSAoYnVmZmVyW2kgfCAwXSAvIDI1NSkgKiBoKTtcclxuICAgICAgICAgICAgICAgIHgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMubWFyayA+PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciBzYW1wbGVyYXRlID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKS5zYW1wbGVSYXRlO1xyXG4gICAgICAgICAgICB2YXIgYmluZnJlcSA9IHNhbXBsZXJhdGUgLyBidWZmZXIubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgeCA9ICgyICogKHRoaXMucHJvcGVydGllcy5tYXJrIC8gYmluZnJlcSkpIC8gZGVsdGE7XHJcbiAgICAgICAgICAgIGlmICh4ID49IHRoaXMuc2l6ZVswXSkge1xyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuc2l6ZVswXSAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZWRcIjtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIGgpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIDApO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvVmlzdWFsaXphdGlvbi50aXRsZSA9IFwiVmlzdWFsaXphdGlvblwiO1xyXG4gICAgTEdBdWRpb1Zpc3VhbGl6YXRpb24uZGVzYyA9IFwiQXVkaW8gVmlzdWFsaXphdGlvblwiO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJhdWRpby92aXN1YWxpemF0aW9uXCIsIExHQXVkaW9WaXN1YWxpemF0aW9uKTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR0F1ZGlvQmFuZFNpZ25hbCgpIHtcclxuICAgICAgICAvL2RlZmF1bHRcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIGJhbmQ6IDQ0MCxcclxuICAgICAgICAgICAgYW1wbGl0dWRlOiAxXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImZyZXFzXCIsIFwiYXJyYXlcIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJzaWduYWxcIiwgXCJudW1iZXJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgTEdBdWRpb0JhbmRTaWduYWwucHJvdG90eXBlLm9uRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX2ZyZXFzID0gdGhpcy5nZXRJbnB1dERhdGEoMCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9mcmVxcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYmFuZCA9IHRoaXMucHJvcGVydGllcy5iYW5kO1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXRJbnB1dERhdGEoMSk7XHJcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBiYW5kID0gdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzYW1wbGVyYXRlID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKS5zYW1wbGVSYXRlO1xyXG4gICAgICAgIHZhciBiaW5mcmVxID0gc2FtcGxlcmF0ZSAvIHRoaXMuX2ZyZXFzLmxlbmd0aDtcclxuICAgICAgICB2YXIgaW5kZXggPSAyICogKGJhbmQgLyBiaW5mcmVxKTtcclxuICAgICAgICB2YXIgdiA9IDA7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICB2ID0gdGhpcy5fZnJlcXNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLl9mcmVxcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdiA9IHRoaXMuX2ZyZXFzW3RoaXMuX2ZyZXFzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSBpbmRleCB8IDA7XHJcbiAgICAgICAgICAgIHZhciB2MCA9IHRoaXMuX2ZyZXFzW3Bvc107XHJcbiAgICAgICAgICAgIHZhciB2MSA9IHRoaXMuX2ZyZXFzW3BvcyArIDFdO1xyXG4gICAgICAgICAgICB2YXIgZiA9IGluZGV4IC0gcG9zO1xyXG4gICAgICAgICAgICB2ID0gdjAgKiAoMSAtIGYpICsgdjEgKiBmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKDAsICh2IC8gMjU1KSAqIHRoaXMucHJvcGVydGllcy5hbXBsaXR1ZGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvQmFuZFNpZ25hbC5wcm90b3R5cGUub25HZXRJbnB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1tcImJhbmRcIiwgXCJudW1iZXJcIl1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvQmFuZFNpZ25hbC50aXRsZSA9IFwiU2lnbmFsXCI7XHJcbiAgICBMR0F1ZGlvQmFuZFNpZ25hbC5kZXNjID0gXCJleHRyYWN0IHRoZSBzaWduYWwgb2Ygc29tZSBmcmVxdWVuY3lcIjtcclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYXVkaW8vc2lnbmFsXCIsIExHQXVkaW9CYW5kU2lnbmFsKTtcclxuXHJcbiAgICBmdW5jdGlvbiBMR0F1ZGlvU2NyaXB0KCkge1xyXG4gICAgICAgIGlmICghTEdBdWRpb1NjcmlwdC5kZWZhdWx0X2NvZGUpIHtcclxuICAgICAgICAgICAgdmFyIGNvZGUgPSBMR0F1ZGlvU2NyaXB0LmRlZmF1bHRfZnVuY3Rpb24udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gY29kZS5pbmRleE9mKFwie1wiKSArIDE7XHJcbiAgICAgICAgICAgIHZhciBpbmRleDIgPSBjb2RlLmxhc3RJbmRleE9mKFwifVwiKTtcclxuICAgICAgICAgICAgTEdBdWRpb1NjcmlwdC5kZWZhdWx0X2NvZGUgPSBjb2RlLnN1YnN0cihpbmRleCwgaW5kZXgyIC0gaW5kZXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kZWZhdWx0XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBjb2RlOiBMR0F1ZGlvU2NyaXB0LmRlZmF1bHRfY29kZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vY3JlYXRlIG5vZGVcclxuICAgICAgICB2YXIgY3R4ID0gTEdBdWRpby5nZXRBdWRpb0NvbnRleHQoKTtcclxuICAgICAgICBpZiAoY3R4LmNyZWF0ZVNjcmlwdFByb2Nlc3Nvcikge1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZSA9IGN0eC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoNDA5NiwgMSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vYnVmZmVyIHNpemUsIGlucHV0IGNoYW5uZWxzLCBvdXRwdXQgY2hhbm5lbHNcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU2NyaXB0UHJvY2Vzc29yTm9kZSBkZXByZWNhdGVkXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZSA9IGN0eC5jcmVhdGVHYWluKCk7IC8vYnlwYXNzIGF1ZGlvXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnByb2Nlc3NDb2RlKCk7XHJcbiAgICAgICAgaWYgKCFMR0F1ZGlvU2NyaXB0Ll9ieXBhc3NfZnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgTEdBdWRpb1NjcmlwdC5fYnlwYXNzX2Z1bmN0aW9uID0gdGhpcy5hdWRpb25vZGUub25hdWRpb3Byb2Nlc3M7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3Nsb3RzXHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwiYXVkaW9cIik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJvdXRcIiwgXCJhdWRpb1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBMR0F1ZGlvU2NyaXB0LnByb3RvdHlwZS5vbkFkZGVkID0gZnVuY3Rpb24oZ3JhcGgpIHtcclxuICAgICAgICBpZiAoZ3JhcGguc3RhdHVzID09IExHcmFwaC5TVEFUVVNfUlVOTklORykge1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvbm9kZS5vbmF1ZGlvcHJvY2VzcyA9IHRoaXMuX2NhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NjcmlwdFtcIkBjb2RlXCJdID0geyB3aWRnZXQ6IFwiY29kZVwiLCB0eXBlOiBcImNvZGVcIiB9O1xyXG5cclxuICAgIExHQXVkaW9TY3JpcHQucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5vbmF1ZGlvcHJvY2VzcyA9IHRoaXMuX2NhbGxiYWNrO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU2NyaXB0LnByb3RvdHlwZS5vblN0b3AgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5vbmF1ZGlvcHJvY2VzcyA9IExHQXVkaW9TY3JpcHQuX2J5cGFzc19mdW5jdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NjcmlwdC5wcm90b3R5cGUub25QYXVzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLm9uYXVkaW9wcm9jZXNzID0gTEdBdWRpb1NjcmlwdC5fYnlwYXNzX2Z1bmN0aW9uO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU2NyaXB0LnByb3RvdHlwZS5vblVucGF1c2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZS5vbmF1ZGlvcHJvY2VzcyA9IHRoaXMuX2NhbGxiYWNrO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU2NyaXB0LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvL25vdGhpbmchIGJlY2F1c2Ugd2UgbmVlZCBhbiBvbkV4ZWN1dGUgdG8gcmVjZWl2ZSBvblN0YXJ0Li4uIGZpeCB0aGF0XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9TY3JpcHQucHJvdG90eXBlLm9uUmVtb3ZlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYXVkaW9ub2RlLm9uYXVkaW9wcm9jZXNzID0gTEdBdWRpb1NjcmlwdC5fYnlwYXNzX2Z1bmN0aW9uO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvU2NyaXB0LnByb3RvdHlwZS5wcm9jZXNzQ29kZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBmdW5jID0gbmV3IEZ1bmN0aW9uKFwicHJvcGVydGllc1wiLCB0aGlzLnByb3BlcnRpZXMuY29kZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NjcmlwdCA9IG5ldyBmdW5jKHRoaXMucHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX29sZF9jb2RlID0gdGhpcy5wcm9wZXJ0aWVzLmNvZGU7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrID0gdGhpcy5fc2NyaXB0Lm9uYXVkaW9wcm9jZXNzO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gb25hdWRpb3Byb2Nlc3MgY29kZVwiLCBlcnIpO1xyXG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFjayA9IExHQXVkaW9TY3JpcHQuX2J5cGFzc19mdW5jdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUub25hdWRpb3Byb2Nlc3MgPSB0aGlzLl9jYWxsYmFjaztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExHQXVkaW9TY3JpcHQucHJvdG90eXBlLm9uUHJvcGVydHlDaGFuZ2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcImNvZGVcIikge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuY29kZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NDb2RlKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdyYXBoICYmIHRoaXMuZ3JhcGguc3RhdHVzID09IExHcmFwaC5TVEFUVVNfUlVOTklORykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb25vZGUub25hdWRpb3Byb2Nlc3MgPSB0aGlzLl9jYWxsYmFjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdBdWRpb1NjcmlwdC5kZWZhdWx0X2Z1bmN0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5vbmF1ZGlvcHJvY2VzcyA9IGZ1bmN0aW9uKGF1ZGlvUHJvY2Vzc2luZ0V2ZW50KSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBpbnB1dCBidWZmZXIgaXMgdGhlIHNvbmcgd2UgbG9hZGVkIGVhcmxpZXJcclxuICAgICAgICAgICAgdmFyIGlucHV0QnVmZmVyID0gYXVkaW9Qcm9jZXNzaW5nRXZlbnQuaW5wdXRCdWZmZXI7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgb3V0cHV0IGJ1ZmZlciBjb250YWlucyB0aGUgc2FtcGxlcyB0aGF0IHdpbGwgYmUgbW9kaWZpZWQgYW5kIHBsYXllZFxyXG4gICAgICAgICAgICB2YXIgb3V0cHV0QnVmZmVyID0gYXVkaW9Qcm9jZXNzaW5nRXZlbnQub3V0cHV0QnVmZmVyO1xyXG5cclxuICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHRoZSBvdXRwdXQgY2hhbm5lbHMgKGluIHRoaXMgY2FzZSB0aGVyZSBpcyBvbmx5IG9uZSlcclxuICAgICAgICAgICAgZm9yIChcclxuICAgICAgICAgICAgICAgIHZhciBjaGFubmVsID0gMDtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWwgPCBvdXRwdXRCdWZmZXIubnVtYmVyT2ZDaGFubmVscztcclxuICAgICAgICAgICAgICAgIGNoYW5uZWwrK1xyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnB1dERhdGEgPSBpbnB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsKTtcclxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXREYXRhID0gb3V0cHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKGNoYW5uZWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgNDA5NiBzYW1wbGVzXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzYW1wbGUgPSAwOyBzYW1wbGUgPCBpbnB1dEJ1ZmZlci5sZW5ndGg7IHNhbXBsZSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBvdXRwdXQgZXF1YWwgdG8gdGhlIHNhbWUgYXMgdGhlIGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0RGF0YVtzYW1wbGVdID0gaW5wdXREYXRhW3NhbXBsZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBMR0F1ZGlvLmNyZWF0ZUF1ZGlvTm9kZVdyYXBwZXIoTEdBdWRpb1NjcmlwdCk7XHJcblxyXG4gICAgTEdBdWRpb1NjcmlwdC50aXRsZSA9IFwiU2NyaXB0XCI7XHJcbiAgICBMR0F1ZGlvU2NyaXB0LmRlc2MgPSBcImFwcGx5IHNjcmlwdCB0byBzaWduYWxcIjtcclxuICAgIExpdGVHcmFwaC5yZWdpc3Rlck5vZGVUeXBlKFwiYXVkaW8vc2NyaXB0XCIsIExHQXVkaW9TY3JpcHQpO1xyXG5cclxuICAgIGZ1bmN0aW9uIExHQXVkaW9EZXN0aW5hdGlvbigpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvbm9kZSA9IExHQXVkaW8uZ2V0QXVkaW9Db250ZXh0KCkuZGVzdGluYXRpb247XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcImluXCIsIFwiYXVkaW9cIik7XHJcbiAgICB9XHJcblxyXG4gICAgTEdBdWRpb0Rlc3RpbmF0aW9uLnRpdGxlID0gXCJEZXN0aW5hdGlvblwiO1xyXG4gICAgTEdBdWRpb0Rlc3RpbmF0aW9uLmRlc2MgPSBcIkF1ZGlvIG91dHB1dFwiO1xyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJhdWRpby9kZXN0aW5hdGlvblwiLCBMR0F1ZGlvRGVzdGluYXRpb24pO1xyXG59KSh0aGlzKTtcclxuXG4vL2V2ZW50IHJlbGF0ZWQgbm9kZXNcclxuKGZ1bmN0aW9uKGdsb2JhbCkge1xyXG4gICAgdmFyIExpdGVHcmFwaCA9IGdsb2JhbC5MaXRlR3JhcGg7XHJcblxyXG4gICAgZnVuY3Rpb24gTEdXZWJTb2NrZXQoKSB7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzYwLCAyMF07XHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInNlbmRcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJyZWNlaXZlZFwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCAwKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCAwKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIHVybDogXCJcIixcclxuICAgICAgICAgICAgcm9vbTogXCJsZ3JhcGhcIiwgLy9hbGxvd3MgdG8gZmlsdGVyIG1lc3NhZ2VzLFxyXG4gICAgICAgICAgICBvbmx5X3NlbmRfY2hhbmdlczogdHJ1ZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fd3MgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2xhc3Rfc2VudF9kYXRhID0gW107XHJcbiAgICAgICAgdGhpcy5fbGFzdF9yZWNlaXZlZF9kYXRhID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgTEdXZWJTb2NrZXQudGl0bGUgPSBcIldlYlNvY2tldFwiO1xyXG4gICAgTEdXZWJTb2NrZXQuZGVzYyA9IFwiU2VuZCBkYXRhIHRocm91Z2ggYSB3ZWJzb2NrZXRcIjtcclxuXHJcbiAgICBMR1dlYlNvY2tldC5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09IFwidXJsXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0U29ja2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR1dlYlNvY2tldC5wcm90b3R5cGUub25FeGVjdXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl93cyAmJiB0aGlzLnByb3BlcnRpZXMudXJsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFNvY2tldCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl93cyB8fCB0aGlzLl93cy5yZWFkeVN0YXRlICE9IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByb29tID0gdGhpcy5wcm9wZXJ0aWVzLnJvb207XHJcbiAgICAgICAgdmFyIG9ubHlfY2hhbmdlcyA9IHRoaXMucHJvcGVydGllcy5vbmx5X3NlbmRfY2hhbmdlcztcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0SW5wdXREYXRhKGkpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIganNvbjtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGpzb24gPSBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogMCxcclxuICAgICAgICAgICAgICAgICAgICByb29tOiByb29tLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IGksXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9ubHlfY2hhbmdlcyAmJiB0aGlzLl9sYXN0X3NlbnRfZGF0YVtpXSA9PSBqc29uKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fbGFzdF9zZW50X2RhdGFbaV0gPSBqc29uO1xyXG4gICAgICAgICAgICB0aGlzLl93cy5zZW5kKGpzb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXREYXRhKGksIHRoaXMuX2xhc3RfcmVjZWl2ZWRfZGF0YVtpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5ib3hjb2xvciA9PSBcIiNBRkFcIikge1xyXG4gICAgICAgICAgICB0aGlzLmJveGNvbG9yID0gXCIjNkM2XCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR1dlYlNvY2tldC5wcm90b3R5cGUuY29ubmVjdFNvY2tldCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgdXJsID0gdGhpcy5wcm9wZXJ0aWVzLnVybDtcclxuICAgICAgICBpZiAodXJsLnN1YnN0cigwLCAyKSAhPSBcIndzXCIpIHtcclxuICAgICAgICAgICAgdXJsID0gXCJ3czovL1wiICsgdXJsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl93cyA9IG5ldyBXZWJTb2NrZXQodXJsKTtcclxuICAgICAgICB0aGlzLl93cy5vbm9wZW4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJyZWFkeVwiKTtcclxuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IFwiIzZDNlwiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fd3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB0aGF0LmJveGNvbG9yID0gXCIjQUZBXCI7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShlLmRhdGEpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5yb29tICYmIGRhdGEucm9vbSAhPSB0aGF0LnByb3BlcnRpZXMucm9vbSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZGF0YS5vYmplY3RfY2xhc3MgJiZcclxuICAgICAgICAgICAgICAgICAgICBMaXRlR3JhcGhbZGF0YS5kYXRhLm9iamVjdF9jbGFzc11cclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG5ldyBMaXRlR3JhcGhbZGF0YS5kYXRhLm9iamVjdF9jbGFzc10oZGF0YS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC50cmlnZ2VyU2xvdCgwLCBvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXJTbG90KDAsIGRhdGEuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9sYXN0X3JlY2VpdmVkX2RhdGFbZGF0YS5jaGFubmVsIHx8IDBdID0gZGF0YS5kYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl93cy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvdWxkbnQgY29ubmVjdCB0byB3ZWJzb2NrZXRcIik7XHJcbiAgICAgICAgICAgIHRoYXQuYm94Y29sb3IgPSBcIiNFODhcIjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3dzLm9uY2xvc2UgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29ubmVjdGlvbiBjbG9zZWRcIik7XHJcbiAgICAgICAgICAgIHRoYXQuYm94Y29sb3IgPSBcIiMwMDBcIjtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBMR1dlYlNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3dzIHx8IHRoaXMuX3dzLnJlYWR5U3RhdGUgIT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl93cy5zZW5kKEpTT04uc3RyaW5naWZ5KHsgdHlwZTogMSwgbXNnOiBkYXRhIH0pKTtcclxuICAgIH07XHJcblxyXG4gICAgTEdXZWJTb2NrZXQucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uLCBwYXJhbSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fd3MgfHwgdGhpcy5fd3MucmVhZHlTdGF0ZSAhPSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3dzLnNlbmQoe1xyXG4gICAgICAgICAgICB0eXBlOiAxLFxyXG4gICAgICAgICAgICByb29tOiB0aGlzLnByb3BlcnRpZXMucm9vbSxcclxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXHJcbiAgICAgICAgICAgIGRhdGE6IHBhcmFtXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHV2ViU29ja2V0LnByb3RvdHlwZS5vbkdldElucHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wiaW5cIiwgMF1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBMR1dlYlNvY2tldC5wcm90b3R5cGUub25HZXRPdXRwdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtbXCJvdXRcIiwgMF1dO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlR3JhcGgucmVnaXN0ZXJOb2RlVHlwZShcIm5ldHdvcmsvd2Vic29ja2V0XCIsIExHV2ViU29ja2V0KTtcclxuXHJcbiAgICAvL0l0IGlzIGxpa2UgYSB3ZWJzb2NrZXQgYnV0IHVzaW5nIHRoZSBTaWxseVNlcnZlci5qcyBzZXJ2ZXIgdGhhdCBib3VuY2VzIHBhY2tldHMgYmFjayB0byBhbGwgY2xpZW50cyBjb25uZWN0ZWQ6XHJcbiAgICAvL0ZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vamFnZW5qby9TaWxseVNlcnZlci5qc1xyXG5cclxuICAgIGZ1bmN0aW9uIExHU2lsbHlDbGllbnQoKSB7XHJcbiAgICAgICAgLy90aGlzLnNpemUgPSBbNjAsMjBdO1xyXG4gICAgICAgIHRoaXMucm9vbV93aWRnZXQgPSB0aGlzLmFkZFdpZGdldChcclxuICAgICAgICAgICAgXCJ0ZXh0XCIsXHJcbiAgICAgICAgICAgIFwiUm9vbVwiLFxyXG4gICAgICAgICAgICBcImxncmFwaFwiLFxyXG4gICAgICAgICAgICB0aGlzLnNldFJvb20uYmluZCh0aGlzKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5hZGRXaWRnZXQoXHJcbiAgICAgICAgICAgIFwiYnV0dG9uXCIsXHJcbiAgICAgICAgICAgIFwiUmVjb25uZWN0XCIsXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFNvY2tldC5iaW5kKHRoaXMpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRJbnB1dChcInNlbmRcIiwgTGl0ZUdyYXBoLkFDVElPTik7XHJcbiAgICAgICAgdGhpcy5hZGRPdXRwdXQoXCJyZWNlaXZlZFwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgICAgIHRoaXMuYWRkSW5wdXQoXCJpblwiLCAwKTtcclxuICAgICAgICB0aGlzLmFkZE91dHB1dChcIm91dFwiLCAwKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIHVybDogXCJ0YW1hdHMuY29tOjU1MDAwXCIsXHJcbiAgICAgICAgICAgIHJvb206IFwibGdyYXBoXCIsXHJcbiAgICAgICAgICAgIG9ubHlfc2VuZF9jaGFuZ2VzOiB0cnVlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fc2VydmVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbm5lY3RTb2NrZXQoKTtcclxuICAgICAgICB0aGlzLl9sYXN0X3NlbnRfZGF0YSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2xhc3RfcmVjZWl2ZWRfZGF0YSA9IFtdO1xyXG5cclxuXHRcdGlmKHR5cGVvZihTaWxseUNsaWVudCkgPT0gXCJ1bmRlZmluZWRcIilcclxuXHRcdFx0Y29uc29sZS53YXJuKFwicmVtZW1iZXIgdG8gYWRkIFNpbGx5Q2xpZW50LmpzIHRvIHlvdXIgcHJvamVjdDogaHR0cHM6Ly90YW1hdHMuY29tL3Byb2plY3RzL3NpbGx5c2VydmVyL3NyYy9zaWxseWNsaWVudC5qc1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBMR1NpbGx5Q2xpZW50LnRpdGxlID0gXCJTaWxseUNsaWVudFwiO1xyXG4gICAgTEdTaWxseUNsaWVudC5kZXNjID0gXCJDb25uZWN0cyB0byBTaWxseVNlcnZlciB0byBicm9hZGNhc3QgbWVzc2FnZXNcIjtcclxuXHJcbiAgICBMR1NpbGx5Q2xpZW50LnByb3RvdHlwZS5vblByb3BlcnR5Q2hhbmdlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJyb29tXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5yb29tX3dpZGdldC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbm5lY3RTb2NrZXQoKTtcclxuICAgIH07XHJcblxyXG4gICAgTEdTaWxseUNsaWVudC5wcm90b3R5cGUuc2V0Um9vbSA9IGZ1bmN0aW9uKHJvb21fbmFtZSkge1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcy5yb29tID0gcm9vbV9uYW1lO1xyXG4gICAgICAgIHRoaXMucm9vbV93aWRnZXQudmFsdWUgPSByb29tX25hbWU7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0U29ja2V0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vZm9yY2UgbGFiZWwgbmFtZXNcclxuICAgIExHU2lsbHlDbGllbnQucHJvdG90eXBlLm9uRHJhd0ZvcmVncm91bmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBzbG90ID0gdGhpcy5pbnB1dHNbaV07XHJcbiAgICAgICAgICAgIHNsb3QubGFiZWwgPSBcImluX1wiICsgaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHNsb3QgPSB0aGlzLm91dHB1dHNbaV07XHJcbiAgICAgICAgICAgIHNsb3QubGFiZWwgPSBcIm91dF9cIiArIGk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR1NpbGx5Q2xpZW50LnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3NlcnZlciB8fCAhdGhpcy5fc2VydmVyLmlzX2Nvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgb25seV9zZW5kX2NoYW5nZXMgPSB0aGlzLnByb3BlcnRpZXMub25seV9zZW5kX2NoYW5nZXM7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldElucHV0RGF0YShpKTtcclxuXHRcdFx0dmFyIHByZXZfZGF0YSA9IHRoaXMuX2xhc3Rfc2VudF9kYXRhW2ldO1xyXG4gICAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob25seV9zZW5kX2NoYW5nZXMpXHJcblx0XHRcdFx0e1x0XHJcblx0XHRcdFx0XHR2YXIgaXNfZXF1YWwgPSB0cnVlO1xyXG5cdFx0XHRcdFx0aWYoIGRhdGEgJiYgZGF0YS5sZW5ndGggJiYgcHJldl9kYXRhICYmIHByZXZfZGF0YS5sZW5ndGggPT0gZGF0YS5sZW5ndGggJiYgZGF0YS5jb25zdHJ1Y3RvciAhPT0gU3RyaW5nKVxyXG5cdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZGF0YS5sZW5ndGg7ICsrailcclxuXHRcdFx0XHRcdFx0XHRpZiggcHJldl9kYXRhW2pdICE9IGRhdGFbal0gKVxyXG5cdFx0XHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0XHRcdGlzX2VxdWFsID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIGlmKHRoaXMuX2xhc3Rfc2VudF9kYXRhW2ldICE9IGRhdGEpXHJcblx0XHRcdFx0XHRcdGlzX2VxdWFsID0gZmFsc2U7XHJcblx0XHRcdFx0XHRpZihpc19lcXVhbClcclxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3NlcnZlci5zZW5kTWVzc2FnZSh7IHR5cGU6IDAsIGNoYW5uZWw6IGksIGRhdGE6IGRhdGEgfSk7XHJcblx0XHRcdFx0aWYoIGRhdGEubGVuZ3RoICYmIGRhdGEuY29uc3RydWN0b3IgIT09IFN0cmluZyApXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0aWYoIHRoaXMuX2xhc3Rfc2VudF9kYXRhW2ldIClcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0dGhpcy5fbGFzdF9zZW50X2RhdGFbaV0ubGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkYXRhLmxlbmd0aDsgKytqKVxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2xhc3Rfc2VudF9kYXRhW2ldW2pdID0gZGF0YVtqXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2UgLy9jcmVhdGVcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0aWYoZGF0YS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fbGFzdF9zZW50X2RhdGFbaV0gPSBkYXRhLmNvbmNhdCgpO1xyXG5cdFx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fbGFzdF9zZW50X2RhdGFbaV0gPSBuZXcgZGF0YS5jb25zdHJ1Y3RvciggZGF0YSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlXHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xhc3Rfc2VudF9kYXRhW2ldID0gZGF0YTsgLy9zaG91bGQgYmUgY2xvbmVkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3V0cHV0RGF0YShpLCB0aGlzLl9sYXN0X3JlY2VpdmVkX2RhdGFbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYm94Y29sb3IgPT0gXCIjQUZBXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5ib3hjb2xvciA9IFwiIzZDNlwiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTEdTaWxseUNsaWVudC5wcm90b3R5cGUuY29ubmVjdFNvY2tldCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBpZiAodHlwZW9mIFNpbGx5Q2xpZW50ID09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcclxuICAgICAgICAgICAgICAgICAgICBcIlNpbGx5Q2xpZW50IG5vZGUgY2Fubm90IGJlIHVzZWQsIHlvdSBtdXN0IGluY2x1ZGUgU2lsbHlTZXJ2ZXIuanNcIlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9lcnJvciA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3NlcnZlciA9IG5ldyBTaWxseUNsaWVudCgpO1xyXG4gICAgICAgIHRoaXMuX3NlcnZlci5vbl9yZWFkeSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlYWR5XCIpO1xyXG4gICAgICAgICAgICB0aGF0LmJveGNvbG9yID0gXCIjNkM2XCI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9zZXJ2ZXIub25fbWVzc2FnZSA9IGZ1bmN0aW9uKGlkLCBtc2cpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UobXNnKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgLy9FVkVOVCBzbG90XHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5kYXRhLm9iamVjdF9jbGFzcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIExpdGVHcmFwaFtkYXRhLmRhdGEub2JqZWN0X2NsYXNzXVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gbmV3IExpdGVHcmFwaFtkYXRhLmRhdGEub2JqZWN0X2NsYXNzXShkYXRhLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXJTbG90KDAsIG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudHJpZ2dlclNsb3QoMCwgZGF0YS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSAvL2ZvciBGTE9XIHNsb3RzXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fbGFzdF9yZWNlaXZlZF9kYXRhW2RhdGEuY2hhbm5lbCB8fCAwXSA9IGRhdGEuZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGF0LmJveGNvbG9yID0gXCIjQUZBXCI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9zZXJ2ZXIub25fZXJyb3IgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY291bGRudCBjb25uZWN0IHRvIHdlYnNvY2tldFwiKTtcclxuICAgICAgICAgICAgdGhhdC5ib3hjb2xvciA9IFwiI0U4OFwiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fc2VydmVyLm9uX2Nsb3NlID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbm5lY3Rpb24gY2xvc2VkXCIpO1xyXG4gICAgICAgICAgICB0aGF0LmJveGNvbG9yID0gXCIjMDAwXCI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy51cmwgJiYgdGhpcy5wcm9wZXJ0aWVzLnJvb20pIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NlcnZlci5jb25uZWN0KHRoaXMucHJvcGVydGllcy51cmwsIHRoaXMucHJvcGVydGllcy5yb29tKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiU2lsbHlTZXJ2ZXIgZXJyb3I6IFwiICsgZXJyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NlcnZlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZmluYWxfdXJsID0gdGhpcy5wcm9wZXJ0aWVzLnVybCArIFwiL1wiICsgdGhpcy5wcm9wZXJ0aWVzLnJvb207XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMR1NpbGx5Q2xpZW50LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc2VydmVyIHx8ICF0aGlzLl9zZXJ2ZXIuaXNfY29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2VydmVyLnNlbmRNZXNzYWdlKHsgdHlwZTogMSwgZGF0YTogZGF0YSB9KTtcclxuICAgIH07XHJcblxyXG4gICAgTEdTaWxseUNsaWVudC5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHBhcmFtKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zZXJ2ZXIgfHwgIXRoaXMuX3NlcnZlci5pc19jb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zZXJ2ZXIuc2VuZE1lc3NhZ2UoeyB0eXBlOiAxLCBhY3Rpb246IGFjdGlvbiwgZGF0YTogcGFyYW0gfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExHU2lsbHlDbGllbnQucHJvdG90eXBlLm9uR2V0SW5wdXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtbXCJpblwiLCAwXV07XHJcbiAgICB9O1xyXG5cclxuICAgIExHU2lsbHlDbGllbnQucHJvdG90eXBlLm9uR2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbW1wib3V0XCIsIDBdXTtcclxuICAgIH07XHJcblxyXG4gICAgTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJuZXR3b3JrL3NpbGx5Y2xpZW50XCIsIExHU2lsbHlDbGllbnQpO1xyXG5cclxuLy9IVFRQIFJlcXVlc3RcclxuZnVuY3Rpb24gSFRUUFJlcXVlc3ROb2RlKCkge1xyXG5cdHZhciB0aGF0ID0gdGhpcztcclxuXHR0aGlzLmFkZElucHV0KFwicmVxdWVzdFwiLCBMaXRlR3JhcGguQUNUSU9OKTtcclxuXHR0aGlzLmFkZElucHV0KFwidXJsXCIsIFwic3RyaW5nXCIpO1xyXG5cdHRoaXMuYWRkUHJvcGVydHkoXCJ1cmxcIiwgXCJcIik7XHJcblx0dGhpcy5hZGRPdXRwdXQoXCJyZWFkeVwiLCBMaXRlR3JhcGguRVZFTlQpO1xyXG4gICAgdGhpcy5hZGRPdXRwdXQoXCJkYXRhXCIsIFwic3RyaW5nXCIpO1xyXG5cdHRoaXMuYWRkV2lkZ2V0KFwiYnV0dG9uXCIsIFwiRmV0Y2hcIiwgbnVsbCwgdGhpcy5mZXRjaC5iaW5kKHRoaXMpKTtcclxuXHR0aGlzLl9kYXRhID0gbnVsbDtcclxuXHR0aGlzLl9mZXRjaGluZyA9IG51bGw7XHJcbn1cclxuXHJcbkhUVFBSZXF1ZXN0Tm9kZS50aXRsZSA9IFwiSFRUUCBSZXF1ZXN0XCI7XHJcbkhUVFBSZXF1ZXN0Tm9kZS5kZXNjID0gXCJGZXRjaCBkYXRhIHRocm91Z2ggSFRUUFwiO1xyXG5cclxuSFRUUFJlcXVlc3ROb2RlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKClcclxue1xyXG5cdHZhciB1cmwgPSB0aGlzLnByb3BlcnRpZXMudXJsO1xyXG5cdGlmKCF1cmwpXHJcblx0XHRyZXR1cm47XHJcblxyXG5cdHRoaXMuYm94Y29sb3IgPSBcIiNGRjBcIjtcclxuXHR2YXIgdGhhdCA9IHRoaXM7XHJcblx0dGhpcy5fZmV0Y2hpbmcgPSBmZXRjaCh1cmwpXHJcblx0LnRoZW4ocmVzcD0+e1xyXG5cdFx0aWYoIXJlc3Aub2spXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuYm94Y29sb3IgPSBcIiNGMDBcIjtcclxuXHRcdFx0dGhhdC50cmlnZ2VyKFwiZXJyb3JcIik7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuYm94Y29sb3IgPSBcIiMwRjBcIjtcclxuXHRcdFx0cmV0dXJuIHJlc3AudGV4dCgpO1xyXG5cdFx0fVxyXG5cdH0pXHJcblx0LnRoZW4oZGF0YT0+e1xyXG5cdFx0dGhhdC5fZGF0YSA9IGRhdGE7XHJcblx0XHR0aGF0Ll9mZXRjaGluZyA9IG51bGw7XHJcblx0XHR0aGF0LnRyaWdnZXIoXCJyZWFkeVwiKTtcclxuXHR9KTtcclxufVxyXG5cclxuSFRUUFJlcXVlc3ROb2RlLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGV2dClcclxue1xyXG5cdGlmKGV2dCA9PSBcInJlcXVlc3RcIilcclxuXHRcdHRoaXMuZmV0Y2goKTtcclxufVxyXG5cclxuSFRUUFJlcXVlc3ROb2RlLnByb3RvdHlwZS5vbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLnNldE91dHB1dERhdGEoMSwgdGhpcy5fZGF0YSk7XHJcbn07XHJcblxyXG5IVFRQUmVxdWVzdE5vZGUucHJvdG90eXBlLm9uR2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBbW1wiZXJyb3JcIixMaXRlR3JhcGguRVZFTlRdXTtcclxufVxyXG5cclxuTGl0ZUdyYXBoLnJlZ2lzdGVyTm9kZVR5cGUoXCJuZXR3b3JrL2h0dHByZXF1ZXN0XCIsIEhUVFBSZXF1ZXN0Tm9kZSk7XHJcblxyXG5cclxuXHRcclxufSkodGhpcyk7XHJcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8463\n')}},__webpack_module_cache__={};function __webpack_require__(t){var I=__webpack_module_cache__[t];if(void 0!==I)return I.exports;var g=__webpack_module_cache__[t]={exports:{}};return __webpack_modules__[t].call(g.exports,g,g.exports,__webpack_require__),g.exports}__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),__webpack_require__(9653);var __webpack_exports__=__webpack_require__(2980)})();